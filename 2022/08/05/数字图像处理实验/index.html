<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数字图像处理实验 | Gruge's Blog</title><meta name="keywords" content="数字图像处理基础实验"><meta name="author" content="Gruge"><meta name="copyright" content="Gruge"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数字图像处理的基础将彩色图转换为灰度图代码： 1234RGB = imread(&amp;#x27;D:\reports\test.jpg&amp;#x27;)subplot(121),imshow(RGB)gray = rgb2gray(RGB)subplot(122),imshow(gray)  转换的结果是：  将灰度图转为为索引图代码： 123456RGB = imread(&amp;#x27;D:\report">
<meta property="og:type" content="article">
<meta property="og:title" content="数字图像处理实验">
<meta property="og:url" content="http://example.com/2022/08/05/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="Gruge's Blog">
<meta property="og:description" content="数字图像处理的基础将彩色图转换为灰度图代码： 1234RGB = imread(&amp;#x27;D:\reports\test.jpg&amp;#x27;)subplot(121),imshow(RGB)gray = rgb2gray(RGB)subplot(122),imshow(gray)  转换的结果是：  将灰度图转为为索引图代码： 123456RGB = imread(&amp;#x27;D:\report">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg">
<meta property="article:published_time" content="2022-08-05T07:52:11.000Z">
<meta property="article:modified_time" content="2022-08-05T08:10:10.785Z">
<meta property="article:author" content="Gruge">
<meta property="article:tag" content="数字图像处理基础实验">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/05/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数字图像处理实验',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-05 16:10:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/463b631c6a0f63ec.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Gruge's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数字图像处理实验</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-05T07:52:11.000Z" title="发表于 2022-08-05 15:52:11">2022-08-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-05T08:10:10.785Z" title="更新于 2022-08-05 16:10:10">2022-08-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/">数字图像处理基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数字图像处理实验"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg');"></div><article class="post-content" id="article-container"><h3 id="数字图像处理的基础"><a href="#数字图像处理的基础" class="headerlink" title="数字图像处理的基础"></a>数字图像处理的基础</h3><h4 id="将彩色图转换为灰度图"><a href="#将彩色图转换为灰度图" class="headerlink" title="将彩色图转换为灰度图"></a>将彩色图转换为灰度图</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RGB = imread('D:\reports\test.jpg')</span><br><span class="line">subplot(121),imshow(RGB)</span><br><span class="line">gray = rgb2gray(RGB)</span><br><span class="line">subplot(122),imshow(gray)</span><br></pre></td></tr></tbody></table></figure>

<p>转换的结果是：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731101025493.png" alt="image-20220731101025493"></p>
<h4 id="将灰度图转为为索引图"><a href="#将灰度图转为为索引图" class="headerlink" title="将灰度图转为为索引图"></a>将灰度图转为为索引图</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RGB = imread('D:\reports\test.jpg')</span><br><span class="line">subplot(221),imshow(RGB)</span><br><span class="line">gray = rgb2gray(RGB)</span><br><span class="line">subplot(222),imshow(gray)</span><br><span class="line">[X,map] = gray2ind(gray,8)</span><br><span class="line">subplot(223),imshow(X,map)</span><br></pre></td></tr></tbody></table></figure>

<p>结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731101632758.png" alt="image-20220731101632758"></p>
<p>结论：变为索引值之后图像变得非常的不自然了，图中的显色有分块的现象，特别是在水中的那部分，这是为什么呢？将函数中索引值8增大，这个值越大发现图像之中的颜色表示就更加的自然（最后那幅图的索引值是64的）</p>
<p>索引值：图像颜色映射的个数，也表示图像的灰度级数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731102131472.png" alt="image-20220731102131472"></p>
<h4 id="将索引图转化为真彩色的图"><a href="#将索引图转化为真彩色的图" class="headerlink" title="将索引图转化为真彩色的图"></a>将索引图转化为真彩色的图</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RGB = imread('D:\reports\test.jpg')</span><br><span class="line">subplot(221),imshow(RGB)</span><br><span class="line">gray = rgb2gray(RGB)</span><br><span class="line">subplot(222),imshow(gray)</span><br><span class="line">[X,map] = gray2ind(gray,64)</span><br><span class="line">subplot(223),imshow(X,map)，</span><br><span class="line">color = ind2rgb(X,map)</span><br><span class="line">subplot(224),imshow(color)</span><br></pre></td></tr></tbody></table></figure>

<p>这样子得到的rgb和原来的二值图是一样的，也不知道为什么，并且按照网上的方式读取tif文件，一直不能够读取成功，使用bmp格式的图像得到的结果仍然是一样的，所以二值图转换的原理是什么需要考究一下</p>
<h4 id="将灰度图像转化为二值化图"><a href="#将灰度图像转化为二值化图" class="headerlink" title="将灰度图像转化为二值化图"></a>将灰度图像转化为二值化图</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">color = imread('D:\reports\test.jpg')</span><br><span class="line">subplot(221),imshow(color)</span><br><span class="line">gray = rgb2gray(color)</span><br><span class="line">subplot(222),imshow(gray)</span><br><span class="line">BW1 = im2bw(gray,0.3)</span><br><span class="line">subplot(223),imshow(BW1)</span><br><span class="line">BW2 = im2bw(gray,0.7)</span><br><span class="line">subplot(224),imshow(BW2)</span><br></pre></td></tr></tbody></table></figure>

<p>运行的结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731105415590.png" alt="image-20220731105415590"></p>
<p>思考：灰度转二值图的函数是im2bw，后面的阈值的意思是，判断哪些该转换成1，哪些该转换成0，阈值设置得越小，得到的二值图像的白色面积越多。也就是进行阈值处理。</p>
<h3 id="图像的几何变换"><a href="#图像的几何变换" class="headerlink" title="图像的几何变换"></a>图像的几何变换</h3><h4 id="图像的平移"><a href="#图像的平移" class="headerlink" title="图像的平移"></a>图像的平移</h4><p>原理说明：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731145937610.png" alt="image-20220731145937610"></p>
<p>代码：</p>
<p>mymove.m(脚本文件，在这里面定义了一个用于移动的函数，在同一文件夹目录下可以直接调用该函数)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function OUT = mymove(Image,move_X,move_Y)</span><br><span class="line">J = double(Image); % 将图像中的数据转换成双精度的形式</span><br><span class="line">HW=size(J);% 获取原图像的大小</span><br><span class="line">OUT = zeros(HW); % 新建新图像的矩阵</span><br><span class="line">OUT(1:HW(1),1:HW(2)) = inf; % inf在matlab中表现的是无限大的形式，即这里将图像的内容初始化为全白的背景</span><br><span class="line">if((move_X&gt;=0)&amp;&amp;(move_Y&gt;=0))</span><br><span class="line">    OUT(move_X+1:HW(1),move_Y+1:HW(2)) = J(1:HW(1)-move_X,1:HW(2)-move_Y);</span><br><span class="line">elseif((move_X&gt;0)&amp;&amp;(move_Y&lt;0))</span><br><span class="line">    OUT(move_X+1:HW(1),1:HW(2)+move_Y) = J(1:HW(1)-move_X,1-move_Y:HW(2));</span><br><span class="line">elseif((move_X&lt;0)&amp;&amp;(move_Y&gt;0))</span><br><span class="line">    OUT(1:HW(1)+move_X,1+move_Y:HW(2)) = J(1-move_X:HW(1),1:HW(2)-move_Y);</span><br><span class="line">elseif((move_X&lt;0)&amp;&amp;(move_Y&lt;0))</span><br><span class="line">    OUT(1:HW(1)+move_X,1:HW(2)+move_Y) = J(1-move_X:HW(1),1-move_Y:HW(2));</span><br><span class="line">end % 判断性语句结束的标志</span><br><span class="line">OUT = uint8(OUT);</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>主程序代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = mymove(image,60,100);</span><br><span class="line">subplot(232),imshow(image_1);</span><br><span class="line">image_2 = mymove(image,-60,100);</span><br><span class="line">subplot(234),imshow(image_2);</span><br><span class="line">image_3 = mymove(image,60,-100);</span><br><span class="line">subplot(235),imshow(image_3);</span><br><span class="line">image_4 = mymove(image,-60,-100);</span><br><span class="line">subplot(236),imshow(image_4);</span><br></pre></td></tr></tbody></table></figure>



<p>代码运行的结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731145831362.png" alt="image-20220731145831362"></p>
<h4 id="图像的缩放"><a href="#图像的缩放" class="headerlink" title="图像的缩放"></a>图像的缩放</h4><p>原理:</p>
<p>使用的双线性插值算法，遍历变换之后的每个像素点，并且定位和该像素点相关的四个像素点，利用这四个像素点的像素根据公式推导出该像素点的像素。计算的公式如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731162031267.png" alt="image-20220731162031267"></p>
<p>代码：</p>
<p>脚本函数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function OUT = changeSize(Image,zoom_X,zoom_Y)</span><br><span class="line">J = double(Image); % 将图像中的数据转换成双精度的形式</span><br><span class="line">HW = size(J);% 获取原图像的大小 返回的第一个参数是行数 第二个参数是列数</span><br><span class="line">OUT = zeros(HW); % 新建新图像的矩阵</span><br><span class="line">OUT(1:HW(1),1:HW(2)) = inf; % inf在matlab中表现的是无限大的形式，即这里将图像的内容初始化为全白的背景</span><br><span class="line">changeHW = [floor(HW(1)*zoom_Y),floor(HW(2)*zoom_X)];%放大缩小后的图像的大小 </span><br><span class="line">%便利放大缩小之后的图像的每一个像素点</span><br><span class="line">for i = 1:changeHW(1)</span><br><span class="line">    for j = 1:changeHW(2)</span><br><span class="line">        % 变化之后的图像中的像素点定位到原图像中的对应的位置</span><br><span class="line">        X = i/zoom_Y;</span><br><span class="line">        Y = j/zoom_X;</span><br><span class="line">        % 获得数值的小数部分</span><br><span class="line">        u = X-floor(X);</span><br><span class="line">        v = Y-floor(Y);</span><br><span class="line">        if X&lt; 1</span><br><span class="line">            X =1;</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        if Y&lt; 1</span><br><span class="line">            Y = 1;</span><br><span class="line">        end</span><br><span class="line">        OUT(i,j) = J(floor(X),floor(Y))*u*v + J(ceil(X),floor(Y))*u*(1-v) + J(floor(X),ceil(Y))*(1-u)*v + J(ceil(X),ceil(Y))*(1-u)*(1-v);</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">OUT = uint8(OUT(1:HW(1),1:HW(2)));</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>



<p>主函数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = changeSize(image,0.5,0.5);</span><br><span class="line">subplot(232),imshow(image_1),axis on;</span><br><span class="line">image_2 = changeSize(image,1.5,1.5);</span><br><span class="line">subplot(233),imshow(image_2),axis on;</span><br><span class="line">image_3 = changeSize(image,0.5,0.8);</span><br><span class="line">subplot(234),imshow(image_3),axis on;</span><br><span class="line">image_4 = changeSize(image,1.0,1.5);</span><br><span class="line">subplot(235),imshow(image_4),axis on;</span><br></pre></td></tr></tbody></table></figure>

<p>代码运行的结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731161451618.png" alt="image-20220731161451618"></p>
<h4 id="图像旋转"><a href="#图像旋转" class="headerlink" title="图像旋转"></a>图像旋转</h4><p>新图像的高和宽的公式：</p>
<p>**nHW(1)=ceil(HW(1)*abs(cos(abs(alpha)))+HW(2)*abs(sin(abs(alpha)))); nHW(2)=ceil(HW(1)<em>abs(sin(abs(alpha)))+HW(2)<em>abs(cos(abs(alpha))));</em></em></p>
<p>换算到逆时针旋转之后的坐标公式：<br><em><strong>x1=x0cos(β)-y0sin(β)<br>y1=x0sin(β)+y0cos(β)</strong></em></p>
<p>图像：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731163223386.png" alt="image-20220731163223386"></p>
<p>则由新图像中的坐标换算到原图像中的坐标公式：<br><em><strong>x=icos(β)+jsin(β)<br>y=-isin(β)+jcos(β)</strong></em></p>
<p>变换之后的图像中的每个坐标不只是有角度上的转变，还有一定的平移，因为要确保图像在中央</p>
<p>旋转函数代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function OUT = myrotate(image,alpha) % alpha是旋转的角度</span><br><span class="line">J = double(image);% 将图像中的值转换成双精度形式</span><br><span class="line">HW = size(J);% 获得图像的大小 size</span><br><span class="line">alpha = mod(alpha,360);% 将角度转变到0~360</span><br><span class="line">alpha = (alpha*pi)/180;% 将角度转变成弧度制</span><br><span class="line">nHW(1) = ceil(HW(1)*abs(cos(abs(alpha)))+HW(2)*abs(sin(abs(alpha))));% 旋转之后的图像的大小（长和宽都要重新定义）</span><br><span class="line">nHW(2) = ceil(HW(1)*abs(sin(abs(alpha)))+HW(2)*abs(cos(abs(alpha))));</span><br><span class="line">OUT = zeros(nHW);% 利用新的长和宽定义图像的矩阵</span><br><span class="line">OUT(1:nHW(1),1:nHW(2)) = inf;% 对这个矩阵进行初始化（inf 初始化成白色的）</span><br><span class="line">u0 = HW(2)*abs(sin(alpha));u2 = HW(1)*abs(cos(alpha));% 竖直方向的平移量</span><br><span class="line">u1 = HW(1)*abs(sin(alpha));u3 = HW(2)*abs(cos(alpha)); % 水平方向的平移量</span><br><span class="line">T = [cos(alpha),sin(alpha);-sin(alpha),cos(alpha)];% 对坐标进行换算的矩阵</span><br><span class="line">% 遍历这个新的图像</span><br><span class="line">for i = 1:nHW(1)</span><br><span class="line">    for j = 1:nHW(2)</span><br><span class="line">        if(alpha&gt;=0 &amp;&amp; alpha&lt;pi/2)</span><br><span class="line">            XY = T * ([i;j]-[u0;0]);% 此时整个图像需要向上移动 </span><br><span class="line">        elseif(alpha&gt;=pi/2 &amp;&amp; alpha&lt;pi)</span><br><span class="line">            XY = T *([i;j]-[u0+u2;u3]);</span><br><span class="line">        elseif(alpha&gt;=pi &amp;&amp; alpha&lt;3*pi/2)</span><br><span class="line">            XY = T *([i;j]-[u2;u1+u3]);</span><br><span class="line">        elseif(alpha&gt;=3*pi/2 &amp;&amp; alpha&lt;2*pi)</span><br><span class="line">            XY = T * ([i;j]-[0;u1]);</span><br><span class="line">        end</span><br><span class="line">        X = XY(1);</span><br><span class="line">        Y = XY(2);</span><br><span class="line">        if X&gt;=1 &amp;&amp; X&lt;=HW(1) &amp;&amp; Y&gt;=1 &amp;&amp; Y&lt;=HW(2)</span><br><span class="line">            u = X - floor(X);</span><br><span class="line">            v = Y - floor(Y);</span><br><span class="line">         OUT(i,j) = J(floor(X),floor(Y))*u*v + J(ceil(X),floor(Y))*u*(1-v) + J(floor(X),ceil(Y))*(1-u)*v + J(ceil(X),ceil(Y))*(1-u)*(1-v);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    end</span><br><span class="line">OUT = uint8(OUT(1:nHW(1),1:nHW(2)));</span><br><span class="line">% 根据旋转的角度平移坐标值 并且 乘以换算的矩阵 得到在原图像中的坐标点</span><br><span class="line">% 得到小数的部分</span><br><span class="line">% 使用双线插入法获得对应的像素值</span><br><span class="line">% 将OUT的值转变成uint8的形式</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>主函数代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image1 = myrotate(image,30);</span><br><span class="line">subplot(232),imshow(image1),axis on;</span><br><span class="line">image1 = myrotate(image,120);</span><br><span class="line">subplot(233),imshow(image1),axis on;</span><br><span class="line">image1 = myrotate(image,210);</span><br><span class="line">subplot(234),imshow(image1),axis on;</span><br><span class="line">image1 = myrotate(image,310);</span><br><span class="line">subplot(235),imshow(image1),axis on;</span><br></pre></td></tr></tbody></table></figure>

<p>运行的效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731175016882.png" alt="image-20220731175016882"></p>
<h4 id="图像镜像"><a href="#图像镜像" class="headerlink" title="图像镜像"></a>图像镜像</h4><p>水平镜像的公式：（水平镜像操作是以原图像的垂直中轴线为中心，将图像分为左右两部分进行对称变换）<br><em><strong>x1=x0<br>y1=width+1-y0</strong></em></p>
<p>垂直镜像的公式：（垂直镜像操作是以原图像的水平中轴线为中心，将图像分为上下两部分进行对称变换）</p>
<p><em><strong>x1=height+1-x0<br>y1=y0</strong></em></p>
<p>width =》 第二个得到的数据</p>
<p>height =》第一个得到的数据</p>
<p>镜像函数的代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function OUT = mymirror(Image,choice)</span><br><span class="line">    J= double(Image);% 将图像的数据进行双精度</span><br><span class="line">    HW = size(J);% 获得图像的大小 size</span><br><span class="line">    OUT = zeros(HW(1),HW(2));% 利用图像的大小创建对应的数组</span><br><span class="line">    OUT(1:HW(1),1:HW(2)) = inf;% 初始化矩阵 inf</span><br><span class="line">    % 遍历矩阵</span><br><span class="line">    for i = 1:HW(1)</span><br><span class="line">        for j = 1:HW(2)</span><br><span class="line">            if strcmp(choice,'level') % 水平镜像</span><br><span class="line">                OUT(i,j) = J(i,HW(2)+1-j);</span><br><span class="line">            elseif strcmp(choice,'vertical') % 垂直镜像</span><br><span class="line">                OUT(i,j) = J(HW(1)+1-i,j);</span><br><span class="line">            end </span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    % 针对不同的选择进行设置</span><br><span class="line">    % 对相应位置图像的像素进行设置</span><br><span class="line">    OUT = uint8(OUT);</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>主函数的代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = mymirror(image,'level')</span><br><span class="line">subplot(232),imshow(image_1),axis on,title('水平镜像')</span><br><span class="line">image_2 = mymirror(image,'vertical')</span><br><span class="line">subplot(233),imshow(image_2),axis on,title('垂直镜像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731235124610.png" alt="image-20220731235124610"></p>
<h4 id="图像的转置"><a href="#图像的转置" class="headerlink" title="图像的转置"></a>图像的转置</h4><p>转置就是像素点的x坐标和y坐标进行交换，注意这样使得它的长和宽的大小也进行了交换</p>
<p>转置函数代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function OUT = myTranspose(Image)</span><br><span class="line">    J= double(Image);% 将图像的数据进行双精度</span><br><span class="line">    HW = size(J);% 获得图像的大小 size</span><br><span class="line">    OUT = zeros(HW(2),HW(1));% 因为是转置所以它的行宽的大小进行了交换</span><br><span class="line">    OUT(1:HW(2),1:HW(1)) = inf;% 初始化矩阵 inf</span><br><span class="line">    % 遍历矩阵</span><br><span class="line">    for i = 1:HW(2)</span><br><span class="line">        for j = 1:HW(1)</span><br><span class="line">            OUT(i,j) = J(j,i); % 转置像素赋值的公式</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    OUT = uint8(OUT);</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>主函数代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = myTranspose(image);</span><br><span class="line">subplot(232),imshow(image_1),axis on,title('转置的图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731235832423.png" alt="image-20220731235832423"></p>
<h4 id="图像的剪切"><a href="#图像的剪切" class="headerlink" title="图像的剪切"></a>图像的剪切</h4><p>剪切函数代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function OUT = myCut(Image,strat_X,strat_Y)</span><br><span class="line">    J= double(Image);% 将图像的数据进行双精度</span><br><span class="line">    HW = size(J);</span><br><span class="line">    OUT = J(strat_X:HW(1),strat_Y:HW(2));% 因为是转置所以它的行宽的大小进行了交换</span><br><span class="line">    OUT = uint8(OUT);</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>主函数代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = myCut(image,50,70);</span><br><span class="line">subplot(232),imshow(image_1),axis on,title('剪切的图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801000929925.png" alt="image-20220801000929925"></p>
<h3 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h3><h4 id="函数映射"><a href="#函数映射" class="headerlink" title="函数映射"></a><strong>函数映射</strong></h4><p>使用<strong>imadjust</strong>这个灰度值映射函数</p>
<blockquote>
<p>语法：<em>g=imadjust(f,[low-in,hign-in],[low-out,high-out],gamma);</em></p>
<p>将输入图像<strong>指定灰度范围</strong>映射到想要得到的<strong>输出图像的灰度范围</strong></p>
<p><strong>gamma</strong>为映射函数曲线的特征参数，gamma小于1，则映射被<strong>加权至高的输出值</strong>，大于1，则被<strong>加权至较低的输出值</strong>，等于1为<strong>线性映射</strong>。gamma默认为1。</p>
</blockquote>
<p>运行代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = imadjust(image,[0,1],[1,0]);</span><br><span class="line">subplot(232),imshow(image_1)</span><br><span class="line">image_2 = imadjust(image,[0.3,0.8],[0,1]);</span><br><span class="line">subplot(233),imshow(image_2)</span><br><span class="line">image_3 = imadjust(image,[0.3,0.8],[0,1],0.5);</span><br><span class="line">subplot(234),imshow(image_3)</span><br><span class="line">image_4 = imadjust(image,[0.3,0.8],[0,1],1.5);</span><br><span class="line">subplot(235),imshow(image_4)</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801002104962.png" alt="image-20220801002104962"></p>
<p>分析：第二张图是将[0,1]的像素值投影到[1,0]的像素值区域，这样得到的图片的效果就是颜色取反，越黑的像素点转变之后就越白。第三张图使得图像黑色区域更黑，白色区域更白，容易使得图像整体的感觉变得更暗，所以有第四张图，将grammer设置为0.5（数值小于1了），能够提高图像的亮度，第五张图，将grammer设置为1.5，降低了图像的亮度。</p>
<h4 id="直方图处理"><a href="#直方图处理" class="headerlink" title="直方图处理"></a>直方图处理</h4><p>绘制图像直方图</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">subplot(232),imshow(image)</span><br><span class="line">imhist(image,16)</span><br><span class="line">subplot(233),imshow(image)</span><br><span class="line">plot(imhist(image))</span><br></pre></td></tr></tbody></table></figure>

<p>代码的运行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801004113238.png" alt="image-20220801004113238"></p>
<p>均衡化调用的函数hiseq()</p>
<p>运行的代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">subplot(232),imshow(image)</span><br><span class="line">imhist(image,16)</span><br><span class="line">subplot(233),imshow(image)</span><br><span class="line">plot(imhist(image))</span><br><span class="line">g = histeq(image,256)</span><br><span class="line">subplot(234),imshow(g)</span><br><span class="line">subplot(235),imshow(g)</span><br><span class="line">imhist(g,16)</span><br><span class="line">subplot(236),imshow(g)</span><br><span class="line">plot(imhist(g))</span><br></pre></td></tr></tbody></table></figure>

<p>效果图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801004646948.png" alt="image-20220801004646948"></p>
<p>分析：通过图我们可以看到均衡化之后的直方图中每部分像素值（每个分类部分）中的点的数量近似相同，图像显示也有了明显的差异</p>
<p>使用直方图图匹配</p>
<p>参考的文章：<a target="_blank" rel="noopener" href="https://www.programminghunter.com/article/37032194016/">https://www.programminghunter.com/article/37032194016/</a></p>
<p>自己写的代码：(代码里面找最近的点的那个地方,使用了index()函数自己没有看懂)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">% 双峰高斯函数</span><br><span class="line">r = 127;</span><br><span class="line">x = -r:r+1;</span><br><span class="line">sigma = 20;</span><br><span class="line">y1=exp(-((x-80).^2)/(2*sigma^2));</span><br><span class="line">y2=exp(-((x+80).^2)/(2*sigma^2));</span><br><span class="line">y=y1+y2; </span><br><span class="line">y = y /sum(y);% 归一化 概率</span><br><span class="line">subplot(232),imshow(y)</span><br><span class="line">plot(y)</span><br><span class="line">% 该函数的累计直方图</span><br><span class="line">G = [];</span><br><span class="line">for i=1:256</span><br><span class="line">    G = [G sum(y(1:i))];</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subplot(233),imshow(image)</span><br><span class="line">imhist(image)</span><br><span class="line">% 获得原图像的累计直方图</span><br><span class="line">hist = imhist(image);% 获得原图像的直方图</span><br><span class="line">imageP = hist/(HW(1)*HW(2));% 每一中像素的概率</span><br><span class="line">% 对概率再累计求和</span><br><span class="line">s=[];</span><br><span class="line">for i=1:256</span><br><span class="line">    s=[s sum(imageP(1:i))];</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 找到两个概率累计图中最近的点</span><br><span class="line">for i = 1:256</span><br><span class="line">    tem{i} = G-s(i);</span><br><span class="line">    tem{i} = abs(tem{i}); % 这里看的是距离，所以取绝对值进行比较就可以了</span><br><span class="line">    [a index(i)] = min(tem{i}); % 获得距离最小的点</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">newimage=zeros(HW(1),HW(2));</span><br><span class="line">for i = 1:HW(1)</span><br><span class="line">    for j = 1:HW(2)</span><br><span class="line">        newimage(i,j) = index(image(i,j)+1)-1;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">newimage = uint8(newimage);</span><br><span class="line">subplot(234),imshow(newimage)</span><br><span class="line">subplot(234),imshow(newimage)</span><br><span class="line">imhist(newimage)</span><br></pre></td></tr></tbody></table></figure>

<p>运行的结果是：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801104042622.png" alt="image-20220801104042622"></p>
<p>分析：看这个曲线就能知道匹配了上面的图像了，这里面要使用累积概率进行计算才可以</p>
<h3 id="图像的平滑处理"><a href="#图像的平滑处理" class="headerlink" title="图像的平滑处理"></a>图像的平滑处理</h3><h4 id="采用均值和高斯滤波器进行平滑处理"><a href="#采用均值和高斯滤波器进行平滑处理" class="headerlink" title="采用均值和高斯滤波器进行平滑处理"></a>采用均值和高斯滤波器进行平滑处理</h4><p>用来生成滤波器的函数</p>
<p>h = fspecial(type)<br>h = fspecial(type，para)</p>
<p>type参数来指定滤波器的种类，para来对具体的滤波器种类添加额外的参数信息</p>
<p><strong>高斯滤波器</strong></p>
<p>H = fspecial(‘gaussian’,hsize,sigma) ：type = ‘gaussian’时就是高斯滤波器了，size指定滤波器的大小,默认值是3×3，sigma指定滤波器的标准差，默认值是0.5（决定了高斯模糊核的模糊程度），使用sigma的值很大的时候，然后运用此模糊核对图像处理，会使图像更加模糊。</p>
<p>例： h1 = fspecial(‘gaussian’,5,1)</p>
<p><strong>均值滤波器</strong></p>
<p>H =fspecial(‘average’,hsize) ：hsize指定滤波器的尺寸</p>
<p>例：h1 = fspecial(‘average’,5) %5x5的核</p>
<p><strong>圆形均值滤波器</strong></p>
<p>H = fspecialL(‘disk’,RADIUS)，radius代表区域半径。</p>
<p>例：h1 = fspecial(‘disk’,3)</p>
<p><strong>拉普拉斯滤波器</strong></p>
<p>H = fspecial（’laplacian’,ALPHA)：alpha用于控制算子形状，取值范围为【0，1】，默认值为0.2，尺寸一定是3×3</p>
<p>例：h1 =fspecial(‘laplacian’)</p>
<p><strong>拉普拉斯高斯滤波器</strong></p>
<p>H = fspecial(‘log’,hsize,sigma) :hsize表示模板尺寸，默认值为3x3,sigma为滤波器的标准差</p>
<p>例：h1 =fspecial(‘log’,3,0.2)</p>
<p><strong>prewitt</strong></p>
<p>H = fspecial(‘prewitt’) ：用于边缘增强，这个函数是没有参数的，默认的大小就是3x3，</p>
<p><strong>sobel</strong></p>
<p>H = fspecial(‘sobel’)：这个函数是无参数的，用于边缘的提取。</p>
<p>例：h1 = fspecial(‘sobel’)</p>
<p>高斯和均值滤波器的代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title('原图')</span><br><span class="line">average3image = filter2(fspecial('average',3),image)/255;% 采用均值滤波器进行平滑处理 3x3</span><br><span class="line">subplot(232),imshow(average3image),title('3x3的均值滤波器')</span><br><span class="line">average5image = filter2(fspecial('average',5),image)/255;% 5x5</span><br><span class="line">subplot(233),imshow(average5image),title('5x5的均值滤波器')</span><br><span class="line">average7image = filter2(fspecial('average',7),image)/255;% 7X7</span><br><span class="line">subplot(234),imshow(average7image),title('7x7的均值滤波器')</span><br><span class="line">gaussianImage1 = filter2(fspecial('gaussian'),image)/255;</span><br><span class="line">subplot(235),imshow(gaussianImage1),title('0.5的高斯滤波器')</span><br><span class="line">gaussianImage2 = filter2(fspecial('gaussian',5,10),image)/255;</span><br><span class="line">subplot(236),imshow(gaussianImage2),title('10的高斯滤波器');</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801110943637.png" alt="image-20220801110943637"></p>
<p>分析：可以看到越大的模板，处理之后的图像就会越模糊，sigma越大就会使得页面更加的模糊</p>
<p>边缘增强的两个滤波器prewitt和sobel：</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title('原图')</span><br><span class="line">prewittImage = filter2(fspecial('prewitt'),image)/255</span><br><span class="line">subplot(232),imshow(prewittImage),title('prewitt边缘增强')</span><br><span class="line">sobelImage = filter2(fspecial('sobel'),image)/255</span><br><span class="line">subplot(233),imshow(sobelImage),title('sobel边缘增强')</span><br></pre></td></tr></tbody></table></figure>



<p>锐化处理的公式（把边缘部分进行突出）</p>
<ul>
<li>原图*2-平滑图像</li>
<li>原图+边缘处理图像</li>
</ul>
<p>锐化处理代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title('原图')</span><br><span class="line">average5image = filter2(fspecial('average',5),image)/255;% 5x5</span><br><span class="line">subplot(234),imshow(average5image),title('5x5的均值滤波器')</span><br><span class="line">prewittImage = filter2(fspecial('prewitt'),image)/255;</span><br><span class="line">subplot(232),imshow(prewittImage),title('prewitt边缘增强')</span><br><span class="line">sobelImage = filter2(fspecial('sobel'),image)/255;</span><br><span class="line">subplot(233),imshow(sobelImage),title('sobel边缘增强')</span><br><span class="line">subImage1 = image*2-uint8(average5image);</span><br><span class="line">subplot(235),imshow(subImage1),title('原图*2-平滑图像锐化')</span><br><span class="line">subImage2 = image+uint8(prewittImage);</span><br><span class="line">subplot(236),imshow(subImage2),title('原图+边缘处理图像锐化')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801112456585.png" alt="image-20220801112456585"></p>
<p>分析：因为我用的是模糊程度偏大的图像，所以使得使用第一种方法锐化之后的结果，图像的整体的亮度会偏大，第二种方式锐化之后的，仔细看能够感觉细节上面增强了，但是直观上来看，我认为是不明显的。</p>
<h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><p>边缘的两个性质：</p>
<ul>
<li>强度的一阶导数的模大于某个阈值的位置（在边缘处像素几句变化）</li>
<li>强度的二阶导数有过零点的位置</li>
</ul>
<p>使用edge()函数检测 <a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/images/ref/edge.html">edge()函数的各种用法</a></p>
<p>sobel和canny边缘检测的对比</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title('原图')</span><br><span class="line">BW1 = edge(image,'sobel');</span><br><span class="line">subplot(232),imshow(BW1),title('sobel边缘检测')</span><br><span class="line">BW2 = edge(image,'canny');</span><br><span class="line">subplot(233),imshow(BW2),title('canny边缘检测')</span><br><span class="line">figure</span><br><span class="line">imshowpair(BW1,BW2,'montage')</span><br><span class="line">title('sobel边缘检测                canny边缘检测 ')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801114928541.png" alt="image-20220801114928541"></p>
<p>分析：canny边缘的提取能力高于其它的</p>
<p>边缘检测的方法：<br>robert：边缘<strong>定位精度较高</strong>，对于陡峭边缘且噪声低的图像效果较好，但没有进行平滑处理，没有抑制噪声的能力</p>
<p>sobel prewitt：进行了平滑处理，对噪声具有一定<strong>抑制能力</strong>，但容易出现多像素宽度</p>
<p>laplacian：对噪声较为敏感，使噪声能力成分得到加强，容易丢失部分边缘方向信息，造成一些不连续的检测边缘，同时抗噪声能力较差。</p>
<p>log：抗噪声能力较强，但会造成一些尖锐的边缘无法检测到。</p>
<p>canny：最优化思想的边缘检测算子，同时采用高斯函数对图像进行平滑处理，但会造成将高频边缘平滑掉，造成边缘丢失，采用双阈值算法检测和连接边缘。</p>
<p>上面几种边缘检测方法的对比：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801120104487.png" alt="image-20220801120104487"></p>
<p>分析：对比上面的几个图，我们能够看到canny的边缘检测的效果是最好的。</p>
<h3 id="图像的分割"><a href="#图像的分割" class="headerlink" title="图像的分割"></a>图像的分割</h3><p>这里采用的方法都是阈值分割，上面用于边缘检测也是可以用于图像分割的</p>
<h4 id="全局分割"><a href="#全局分割" class="headerlink" title="全局分割"></a>全局分割</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title('原图')</span><br><span class="line">subplot(232),imshow(image),title('原图直方图')</span><br><span class="line">imhist(image,200)</span><br><span class="line">% 采用全局阈值分割</span><br><span class="line">grobeCutImage1 = image&gt;100;</span><br><span class="line">subplot(234),imshow(grobeCutImage1),title('分割图像一')</span><br><span class="line">grobeCutImage2 = image&gt;180;</span><br><span class="line">subplot(235),imshow(grobeCutImage2),title('分割图像二')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801151058135.png" alt="image-20220801151058135"></p>
<h4 id="Otsu阈值分割"><a href="#Otsu阈值分割" class="headerlink" title="Otsu阈值分割"></a>Otsu阈值分割</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title('原图')</span><br><span class="line">subplot(232),imshow(image),title('原图直方图')</span><br><span class="line">imhist(image,200)</span><br><span class="line">% 采用Otsu阈值分割</span><br><span class="line">doubleImage = im2double(image);</span><br><span class="line">T = graythresh(doubleImage) ;</span><br><span class="line">J = im2bw(doubleImage,T);</span><br><span class="line">subplot(234),imshow(J),title('Otsu阈值处理')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801151842037.png" alt="image-20220801151842037"></p>
<h4 id="迭代式阈值分割法"><a href="#迭代式阈值分割法" class="headerlink" title="迭代式阈值分割法"></a>迭代式阈值分割法</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title('原图')</span><br><span class="line">subplot(232),imshow(image),title('原图直方图')</span><br><span class="line">imhist(image,200)</span><br><span class="line">% 采用迭代式阈值分割法</span><br><span class="line">doubleImage = im2double(image);</span><br><span class="line">thred = 0.01 ;% 精度</span><br><span class="line">T1 = (min(doubleImage)+max(doubleImage));% 得到第一个分界点 最大值和最小值取二分之一的位置（T1）</span><br><span class="line">sumRight = find(doubleImage&lt;T1);% 找出小于这个分界点的值</span><br><span class="line">sumLeft = find(doubleImage&gt;=T1);% 找出大于这个分界点的值</span><br><span class="line">T2 = (mean(doubleImage(sumRight))+mean(doubleImage(sumLeft)))/2;% 分别求这两边数字的平均值</span><br><span class="line">% 对这两边的平均值求和再*1/2</span><br><span class="line">while abs(T1-T2)&lt;=thred</span><br><span class="line">    T1 = T2;</span><br><span class="line">    sumRight = find(doubleImage&lt;T1);</span><br><span class="line">    sumLeft = find(doubleImage&gt;=T1);</span><br><span class="line">    T2 = (mean(doubleImage(sumRight))+mean(doubleImage(sumLeft)))/2;</span><br><span class="line">end    % whiel循环，T1和T2之间的差在0.01之上时不断进行迭代</span><br><span class="line">% T1 =T2 再继续用相同的方法求得T2（这样保证左右两边的像素总值近似相等时结束）</span><br><span class="line">% 使用im2bw()进行阈值的划分</span><br><span class="line">result = im2bw(doubleImage,T2);</span><br><span class="line">subplot(232),imshow(result),title('迭代式阈值分割')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801154509823.png" alt="image-20220801154509823"></p>
<p>分析：这里的这个阈值点的确定的要求，要使得这个阈值以下的所有点像素相加的结果等于这个阈值以上的所有点像素相加的结果，但我觉得分割效果并不是很优秀</p>
<h4 id="区域分割的分水岭分割"><a href="#区域分割的分水岭分割" class="headerlink" title="区域分割的分水岭分割"></a>区域分割的分水岭分割</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread('D:\reports\test.jpg');</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title('原图')</span><br><span class="line">subplot(232),imshow(image),title('原图直方图')</span><br><span class="line">imhist(image,200)</span><br><span class="line">% 采用分水岭分割</span><br><span class="line">newimage = watershed(image,1); % 这个地方能输入的参数值是 1, 4, 6, 8, 18, or 26 默认是8 指的是连通区的个数</span><br><span class="line">subplot(234),imshow(newimage),title('分水岭分割')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801155205365.png" alt="image-20220801155205365"></p>
<p>感觉不到任何的效果，不知道这种分割方法的效果和意义所在</p>
<h3 id="图像的形态学处理"><a href="#图像的形态学处理" class="headerlink" title="图像的形态学处理"></a>图像的形态学处理</h3><h3 id="图像腐蚀"><a href="#图像腐蚀" class="headerlink" title="图像腐蚀"></a>图像腐蚀</h3><p>运行的代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">bw = zeros(9,9);</span><br><span class="line">bw(2:6,3:7) = 1;% 给2到6排和3到7列的数据赋值为1</span><br><span class="line">se = strel('square',5);% 创立5*5的结构体</span><br><span class="line">se2 = strel('square',1);% 创立1*1的结构体</span><br><span class="line">se3 = strel('square',3);% 创立3*3的结构体</span><br><span class="line">bw2 = imerode(bw,se);% 用se模板对bw进行腐蚀的操作</span><br><span class="line">bw3 = imerode(bw,se2);% 用se模板对bw进行腐蚀的操作</span><br><span class="line">bw4 = imerode(bw,se3);% 用se模板对bw进行腐蚀的操作</span><br><span class="line">subplot(221); imshow(bw);title('输入的图像')</span><br><span class="line">subplot(222); imshow(bw3);title('1*1 腐蚀后的图像')</span><br><span class="line">subplot(223); imshow(bw4);title('3*3 腐蚀后的图像')</span><br><span class="line">subplot(224); imshow(bw2);title('5*5 腐蚀后的图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804110512155.png" alt="image-20220804110512155"></p>
<p>3*3的腐蚀模板：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804110649716.png" alt="image-20220804110649716"></p>
<p>原图像的模板：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804110723961.png" alt="image-20220804110723961"></p>
<p>3*3腐蚀之后的结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804110756214.png" alt="image-20220804110756214"></p>
<h4 id="图像膨胀"><a href="#图像膨胀" class="headerlink" title="图像膨胀"></a>图像膨胀</h4><p>运行的代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">bw = zeros(9,9);</span><br><span class="line">bw(4:5,4:6) = 1;% 给4到5排和4到6列的数据赋值为1</span><br><span class="line">se = strel('square',5);% 创立5*5的结构体</span><br><span class="line">se2 = strel('square',1);% 创立1*1的结构体</span><br><span class="line">se3 = strel('square',3);% 创立3*3的结构体</span><br><span class="line">bw2 = imdilate(bw,se);% 用se模板对bw进行膨胀的操作</span><br><span class="line">bw3 = imdilate(bw,se2);% 用se模板对bw进行膨胀的操作</span><br><span class="line">bw4 = imdilate(bw,se3);% 用se模板对bw进行膨胀的操作</span><br><span class="line">subplot(221); imshow(bw);title('输入的图像')</span><br><span class="line">subplot(222); imshow(bw3);title('1*1 膨胀后的图像')</span><br><span class="line">subplot(223); imshow(bw4);title('3*3 膨胀后的图像')</span><br><span class="line">subplot(224); imshow(bw2);title('5*5 膨胀后的图像')</span><br></pre></td></tr></tbody></table></figure>

<p>图像运行结果的截图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804111645824.png" alt="image-20220804111645824"></p>
<p><strong>线性膨胀图像</strong></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread('D:\reports\label.jpg');</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title('原图像')</span><br><span class="line">se = strel('line',11,90);% 制定一个线性的结构，长度是11，角度是90度</span><br><span class="line">bw1 = imdilate(image,se);</span><br><span class="line">subplot(232);imshow(bw1);title('垂直线性膨胀图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804112706637.png" alt="image-20220804112706637"></p>
<p>用于膨胀的模板</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804112819360.png" alt="image-20220804112819360"></p>
<p><strong>球形膨胀</strong></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread('D:\reports\label.jpg');</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title('原图像')</span><br><span class="line">se = strel('ball',5,5);% 制定一个球形膨胀的结构</span><br><span class="line">bw1 = imdilate(image,se);</span><br><span class="line">subplot(232);imshow(bw1);title('球形膨胀图像')</span><br></pre></td></tr></tbody></table></figure>



<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804113013278.png" alt="image-20220804113013278"></p>
<p>球形模板图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804113314104.png" alt="image-20220804113314104"></p>
<h4 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h4><p>腐蚀运算，然后再做膨胀运算</p>
<p>运算代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread('D:\reports\label.jpg');</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title('原图像')</span><br><span class="line">se = strel('disk',3);% 制定一个棋盘膨胀的结构</span><br><span class="line">bw1 = imopen(image,se); % 进行开运算</span><br><span class="line">subplot(232);imshow(bw1);title('开运算图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804113806790.png" alt="image-20220804113806790"></p>
<p>分析：</p>
<p>我们能够看到的是右边的图相比于左边的图已经不连贯而变得模糊了，是因为开运算的第一次腐蚀，就会将很多细节的地方去除掉。</p>
<h4 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h4><p>先做膨胀运算，然后再做腐蚀运算</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread('D:\reports\label.jpg');</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title('原图像')</span><br><span class="line">se = strel('disk',3);% 制定一个棋盘膨胀的结构</span><br><span class="line">bw1 = imclose(image,se); % 进行闭运算</span><br><span class="line">subplot(232);imshow(bw1);title('闭运算图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804114257142.png" alt="image-20220804114257142"></p>
<h4 id="形态学的高帽滤波"><a href="#形态学的高帽滤波" class="headerlink" title="形态学的高帽滤波"></a>形态学的高帽滤波</h4><p>高帽滤波定义</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804114443334.png" alt="image-20220804114443334"></p>
<p><strong>A</strong>输入的图像，<strong>B</strong>为采用的结构元素，即从图像中减去形态学开操作后的图像，通过<strong>高帽滤波可以增强图像的对比度</strong>。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread('D:\reports\label.jpg');</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title('原图像')</span><br><span class="line">se = strel('disk',3);% 制定一个棋盘膨胀的结构</span><br><span class="line">bw1 = imtophat(image,se); % 高帽滤波</span><br><span class="line">adjustBw1 = imadjust(bw1);% 进行图像增强的操作 </span><br><span class="line">subplot(232);imshow(bw1);title('高帽滤波后的图像')</span><br><span class="line">subplot(233);imshow(adjustBw1);title('图像增强后图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804115244654.png" alt="image-20220804115244654"></p>
<p>分析：因为高帽滤波的减法运算，所以图像的背景色就是0了</p>
<h4 id="低帽滤波"><a href="#低帽滤波" class="headerlink" title="低帽滤波"></a>低帽滤波</h4><p>定义：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804115641941.png" alt="image-20220804115641941"></p>
<p><strong>A</strong>输入的图像，<strong>B</strong>为采用的结构元素，即从图像中减去形态学闭操作后的图像。通过<strong>低帽滤波可以获取图像的边缘</strong></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread('D:\reports\label.jpg');</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title('原图像')</span><br><span class="line">se = strel('disk',3);% 制定一个棋盘膨胀的结构</span><br><span class="line">bw1 = imtophat(image,se); % 高帽滤波</span><br><span class="line">bw2 = imbothat(image,se); % 低帽滤波</span><br><span class="line">dealBw2 = imsubtract(imadd(image,bw1),bw2);% 进行图像处理的操作 </span><br><span class="line">subplot(232);imshow(bw1);title('高帽滤波后的图像')</span><br><span class="line">subplot(233);imshow(bw2);title('低帽滤波后的图像')</span><br><span class="line">subplot(234);imshow(dealBw2);title('处理后的图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804120236113.png" alt="image-20220804120236113"></p>
<p>imsubtract(imadd(image,bw1),bw2)：其中bw1进行的是高帽滤波，bw2进行的是低帽滤波，这样处理的结果使得图像的对比度增强</p>
<h4 id="填充操作"><a href="#填充操作" class="headerlink" title="填充操作"></a>填充操作</h4><p>对灰度图像进行填充</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread('D:\reports\label.jpg');</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">% bw = im2bw(image);</span><br><span class="line">fillBw = imfill(image,'holes');</span><br><span class="line">subplot(121),imshow(image),title('二值化图像')</span><br><span class="line">subplot(122),imshow(fillBw),title('填充操作之后的图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804142511067.png" alt="image-20220804142511067"></p>
<p>分析：右边的图相比于左边哦我们能看到a和e这种中间有镂空的空洞部分都被进行了填充</p>
<h4 id="灰度图像中设定阈值的局部极大值"><a href="#灰度图像中设定阈值的局部极大值" class="headerlink" title="灰度图像中设定阈值的局部极大值"></a>灰度图像中设定阈值的局部极大值</h4><p>[输入像素值-周围值(10)]&gt;X(设定阈值)时,这个像素点就会被特别标记</p>
<p>通过imhmax()对极大值进行抑制</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread('D:\reports\label.jpg');</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">R = imextendedmax(image,100); % 带阈值的局部区域最大</span><br><span class="line">R2 = imextendedmax(image,150);</span><br><span class="line">subplot(131),imshow(image),title('原图像')</span><br><span class="line">subplot(132),imshow(R),title('设定阈值(100)');</span><br><span class="line">subplot(133),imshow(R2),title('设定阈值(150)');</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804143530355.png" alt="image-20220804143530355"></p>
<h4 id="灰度图像边缘测定"><a href="#灰度图像边缘测定" class="headerlink" title="灰度图像边缘测定"></a>灰度图像边缘测定</h4><p>使用膨胀腐蚀</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread('D:\reports\label.jpg');</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">se = strel('disk',3);% 创模板</span><br><span class="line">erodeImage = imerode(image,se);% 腐蚀操作</span><br><span class="line">dilateImage = imdilate(image,se);% 膨胀操作</span><br><span class="line">dealImage1 = dilateImage - erodeImage;</span><br><span class="line">dealImage2 = image - erodeImage;</span><br><span class="line">subplot(221),imshow(image),title('原图像')</span><br><span class="line">subplot(222),imshow(dealImage1),title('膨胀-腐蚀')</span><br><span class="line">subplot(223),imshow(dealImage2),title('原图-腐蚀')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804144738253.png" alt="image-20220804144738253"></p>
<h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><h4 id="图像的频谱图展示"><a href="#图像的频谱图展示" class="headerlink" title="图像的频谱图展示"></a>图像的频谱图展示</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread('D:\reports\label.jpg');</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">F = fft2(im2double(image)); % FFT傅里叶变换</span><br><span class="line">F = fftshift(F); % FFT频谱平移</span><br><span class="line">F = real(F); </span><br><span class="line">T = log(F+1); %频谱对数变换</span><br><span class="line">subplot(231),imshow(image),title('原图像')</span><br><span class="line">subplot(234),imshow(T,[]),title('原图像的频率图')</span><br><span class="line">noisyImage = imnoise(image ,'salt &amp; pepper',0.04); % 向图像之中添加椒盐噪声</span><br><span class="line">noisyF = fft2(im2double(noisyImage));</span><br><span class="line">noisyF = fftshift(noisyF);</span><br><span class="line">noisyF = real(noisyF);</span><br><span class="line">noisyT = log(noisyF+1); % 频谱对数变换</span><br><span class="line">subplot(232),imshow(noisyImage),title('椒盐噪声')</span><br><span class="line">subplot(235),imshow(noisyT,[]),title('椒盐噪声的频率图')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804153219688.png" alt="image-20220804153219688"></p>
<h4 id="高斯低通-高通-频域滤波"><a href="#高斯低通-高通-频域滤波" class="headerlink" title="高斯低通(高通)频域滤波"></a>高斯低通(高通)频域滤波</h4><p>低通滤波：对频谱图做高斯低通滤波，使低频通过而使高频衰减，滤波之后的图像会变得模糊，比原始图像减少尖锐的细节部分而突出平滑过渡部分，</p>
<p>高通滤波：使高频通过而使低频衰减，结果发现滤波后的图像变锐化，比原始图像减少平滑过渡而突出边缘等细节部分。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">image = imread('D:\reports\blackAndWhite.jpg')</span><br><span class="line">I = rgb2gray(image)</span><br><span class="line">P = double(I);</span><br><span class="line">M = im2double(I); % 转化为归一化二维矩阵</span><br><span class="line">Q = fft2(P); % 转化为二维矩阵</span><br><span class="line">N = fft2(M); </span><br><span class="line">move1 = fftshift(N); % 转换到频谱的中心</span><br><span class="line">move2 = fftshift(Q);</span><br><span class="line">subplot(231),imshow(I),title('原图像')</span><br><span class="line">HW = size(move2);</span><br><span class="line">d0 = 50 ;% 截至频率，数值越小越平滑</span><br><span class="line">row1 = fix(HW(1)/2)</span><br><span class="line">col1 = fix(HW(2)/2)</span><br><span class="line">for i = 1:HW(1)</span><br><span class="line">    for j = 1:HW(2)</span><br><span class="line">        d = sqrt((i-row1)^2+(j-col1)^2);</span><br><span class="line">        hl(i,j) = exp(-d^2 /(2*d0^2));% 高斯低通滤波器</span><br><span class="line">        hh(i,j) = 1-hl(i,j); % 高斯高通滤波器</span><br><span class="line">        gl(i,j) = hl(i,j) * move2(i,j); % 高斯低通滤波</span><br><span class="line">        gh(i,j) = hh(i,j) * move2(i,j); % 高斯高通滤波</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">% 对图像进行傅里叶的反变换</span><br><span class="line">gl = ifftshift(gl);</span><br><span class="line">g1 = ifft2(gl); </span><br><span class="line">k1 = uint8(real(gl));</span><br><span class="line">gh = ifftshift(ifft(gh));</span><br><span class="line">k2 = uint8(real(gh));</span><br><span class="line">subplot(232),imshow(k1),title('原图像低通滤波')</span><br><span class="line">subplot(233),imshow(k2),title('原图像高通滤波')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804165900350.png" alt="image-20220804165900350"></p>
<p>总结：不知道为什么达不到平滑图像的效果，对比网上的代码，感觉也没有错</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wulafly/article/details/53225255">参考文章</a></p>
<p><a target="_blank" rel="noopener" href="http://www.dwenzhao.cn/profession/language/matlabimgtrans.html">频率域波的运用处理</a></p>
<h3 id="图像的合成处理"><a href="#图像的合成处理" class="headerlink" title="图像的合成处理"></a>图像的合成处理</h3><p>对图像数据进行加减异或运算从而对图像进行处理，这里就简单的展示了一下加运算</p>
<h4 id="加运算"><a href="#加运算" class="headerlink" title="加运算"></a>加运算</h4><p>数据信息：<em>uint8</em> 类型的数据容易溢出，饱和截取操作；或者预先转化为<em>uint16</em>数据类型。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">image = imread('D:\reports\blackAndWhite.jpg');</span><br><span class="line">image = rgb2gray(image);</span><br><span class="line">image2 = imread('D:\reports\test.jpg');</span><br><span class="line">image2 = rgb2gray(image2);</span><br><span class="line">newImage = imadd(image,image2,'uint8');</span><br><span class="line">newImage2 = imadd(image,image2,'uint16');</span><br><span class="line">subplot(231),imshow(image),title('图像1')</span><br><span class="line">subplot(232),imshow(image2),title('图像2')</span><br><span class="line">subplot(234),imshow(newImage,[]),title('相加(饱和截取)')</span><br><span class="line">subplot(235),imshow(newImage2,[]),title('uint16数据类型')</span><br></pre></td></tr></tbody></table></figure>

<p>效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804172555954.png" alt="image-20220804172555954"></p>
<h3 id="彩色图像的处理"><a href="#彩色图像的处理" class="headerlink" title="彩色图像的处理"></a>彩色图像的处理</h3><p>cat运算符可以堆叠出RGB图像</p>
<p>rgb2ind()函数生成8色的抖动和非抖动图像</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">image = imread('D:\reports\test.jpg');</span><br><span class="line">image2 = imread('D:\reports\test.jpg');</span><br><span class="line">[f1,map] = rgb2ind(image,8,'nodither');% 将rgb图像转化为索引图像，且索引图像是8种颜色(不抖动)</span><br><span class="line">subplot(121),imshow(f1,map),title('rgb2ind无抖动图像');</span><br><span class="line">[f2,map2] = rgb2ind(image,8,'dither');</span><br><span class="line">subplot(122),imshow(f2,map2),title('rgb2ind抖动图像');</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804234124105.png" alt="image-20220804234124105"></p>
<p>‘replicate’:图像大小通过复制外边界的值来扩展</p>
<p>平滑rgb图像</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">image = imread('D:\reports\test.jpg');</span><br><span class="line">image2 = imread('D:\reports\test.jpg');</span><br><span class="line">mode = fspecial('motion',50,40); % 创建一个滤波</span><br><span class="line">filteredImage = imfilter(image,mode);</span><br><span class="line">subplot(121),imshow(image),title('原图像')</span><br><span class="line">subplot(122),imshow(filteredImage),title('平滑图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804235002633.png" alt="image-20220804235002633"></p>
<p>锐化rgb图像</p>
<p>这里是用原图像减去拉普拉斯算子处理之后的图像得到锐化图像</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image = imread('D:\reports\test.jpg');</span><br><span class="line">mode = [1 1 1 1 1;1 1 1 1 1;1 1 -24 1 1;1 1 1 1 1;1 1 1 1 1];% 拉普拉斯算子</span><br><span class="line">filteredImage = image - imfilter(image,mode,'replicate');</span><br><span class="line">subplot(121),imshow(image),title('原图像')</span><br><span class="line">subplot(122),imshow(filteredImage),title('锐化图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804235923711.png" alt="image-20220804235923711"></p>
<p>将图像转化为hsi（色调，饱和度，亮度），再对其中一个分量进行处理得到的图像</p>
<p>rgb2hsi()函数代码（同目录之下创建rgb2hsi文件）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function hsi = rgb2hsi(rgb)</span><br><span class="line">%hsi = rgb2hsi( rgb )将rgb转化为hsi</span><br><span class="line">%输出hsi是double型的</span><br><span class="line"> </span><br><span class="line">% rgb =imread(rgb);%没有这句会报错</span><br><span class="line">%提取图像RGB分量</span><br><span class="line">rgb = im2double(rgb);</span><br><span class="line">r = rgb(:,:,1);</span><br><span class="line">g = rgb(:,:,2);</span><br><span class="line">b = rgb(:,:,3);</span><br><span class="line"> </span><br><span class="line">%执行转化</span><br><span class="line">num = 0.5*((r-g)+(r-b));</span><br><span class="line">den = sqrt((r-g).^2 +(r-b).*(g-b));</span><br><span class="line">theta = acos(num./(den + eps)); %eps极小值标示，防止除以0出错</span><br><span class="line"> </span><br><span class="line">H = theta;</span><br><span class="line">H( b&gt;g ) = 2*pi - H( b&gt;g );</span><br><span class="line">H = H/(2*pi);</span><br><span class="line"> </span><br><span class="line">num = min(min(r,g),b);</span><br><span class="line">den = r + g + b;</span><br><span class="line">den(den == 0) = eps;%eps极小值标示，防止除以0出错</span><br><span class="line">S = 1 - 3.* num./den;</span><br><span class="line">H( S==0 ) = 0;</span><br><span class="line">I = ( r + g + b )/3;</span><br><span class="line"> </span><br><span class="line">%组合hsi图像，H、S、I是矩阵</span><br><span class="line">hsi = cat(3,H,S,I);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>hsi2rgb()函数脚本：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">%hsi2rgb源程序</span><br><span class="line">function rgb=hsi2rgb(hsi)</span><br><span class="line">%rgb=hsi2rgb(hsi)把一幅HSI图像转换为RGB图像</span><br><span class="line">%其中HSI是double型</span><br><span class="line">%hsi(:,:,1)是色度分量，它的范围是除以2*pi后在[0,1]内</span><br><span class="line">%hsi(:,:,2)是饱和度分量，它的范围是在[0,1]内</span><br><span class="line">%hsi(:,:,3)是亮度分量，它的范围是在[0,1]内</span><br><span class="line"></span><br><span class="line">%输出图像的分量是</span><br><span class="line">%rgb(:,:,1)为红</span><br><span class="line">%rgb(:,:,2)为绿</span><br><span class="line">%rgb(:,:,3)为蓝</span><br><span class="line"></span><br><span class="line">%提取HSI的各个分量</span><br><span class="line">hsi=im2double(hsi);%把hsi转化为双精度浮点类型</span><br><span class="line">H=hsi(:,:,1)*2*pi;</span><br><span class="line">S=hsi(:,:,2);</span><br><span class="line">I=hsi(:,:,3);</span><br><span class="line"></span><br><span class="line">%执行变换方程</span><br><span class="line">R=zeros(size(hsi,1),size(hsi,2));</span><br><span class="line">G=zeros(size(hsi,1),size(hsi,2));</span><br><span class="line">B=zeros(size(hsi,1),size(hsi,2));</span><br><span class="line"></span><br><span class="line">%RG区(0&lt;=H&lt;2*pi/3)</span><br><span class="line">idx=find((0&lt;=H) &amp; (H&lt;2*pi/3));%寻找0&lt;=H&lt;2*pi/3</span><br><span class="line">B(idx)=I(idx).*(1-S(idx));</span><br><span class="line">R(idx)=I(idx).*(1+S(idx).*cos(H(idx))./cos(pi/3-H(idx)));</span><br><span class="line">G(idx)=3*I(idx)-(R(idx)+B(idx));</span><br><span class="line"></span><br><span class="line">%BG区(2*pi/3&lt;=H&lt;4*pi/3)</span><br><span class="line">idx=find((2*pi/3&lt;=H) &amp; (H&lt;4*pi/3));%寻找2*pi/3&lt;=H&lt;4*pi/3</span><br><span class="line">R(idx)=I(idx).*(1-S(idx));</span><br><span class="line">G(idx)=I(idx).*(1+S(idx).*cos(H(idx)-2*pi/3)./cos(pi-H(idx)));</span><br><span class="line">B(idx)=3*I(idx)-(R(idx)+G(idx));</span><br><span class="line"></span><br><span class="line">%BR区(4*pi/3&lt;=H&lt;=2*pi)</span><br><span class="line">idx=find((4*pi/3&lt;=H) &amp; (H&lt;=2*pi));%寻找4*pi/3&lt;=H&lt;=2*pi</span><br><span class="line">G(idx)=I(idx).*(1-S(idx));</span><br><span class="line">B(idx)=I(idx).*(1+S(idx).*cos(H(idx)-4*pi/3)./cos(5*pi/3-H(idx)));</span><br><span class="line">R(idx)=3*I(idx)-(G(idx)+B(idx));</span><br><span class="line"></span><br><span class="line">%将3个分量联合成为一个RGB图像</span><br><span class="line">rgb=cat(3,R,G,B);</span><br><span class="line">rgb=max(min(rgb,1),0);</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>主函数（这里是对亮度分量进行平滑处理的结果）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">image = imread('D:\reports\test.jpg');</span><br><span class="line">hsiImage = rgb2hsi(image)% 将原图像转化为hsi图像</span><br><span class="line">% 分别得到hsi的三个分量</span><br><span class="line">h = hsiImage(:,:,1);</span><br><span class="line">s = hsiImage(:,:,2);</span><br><span class="line">i = hsiImage(:,:,3);</span><br><span class="line">mode = ones(25)./(25*25);</span><br><span class="line">filterI = imfilter(i,mode,'replicate');% 对其中的i分量，亮度分量使用filter进行平滑处理</span><br><span class="line">hsiImage = cat(3,h,s,filterI);% 将这三个方向的值组合在一起</span><br><span class="line">image2 = hsi2rgb(hsiImage)% 将hsi图像转化成rgb图像</span><br><span class="line">subplot(121),imshow(image),title('原图像')</span><br><span class="line">subplot(122),imshow(image2),title('亮度分量平滑图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805002223940.png" alt="image-20220805002223940"></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7001840048278601758">参考文章</a></p>
<h3 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h3><p>小波变换有着窗口自适应的特点，即高频信号分辨率高（但是频率分辨率差），低频信号频率分辨率高（但是时间分辨率差）</p>
<p>wavemngr(‘read’,1):进行小波的查看</p>
<p>waveinfo():查看小波的相关信息</p>
<p>小波在时间上的移动,逐一比较不同位置的窗口信号,小波系数，<strong>小波系数越大</strong>，则证明小波与该段信号的<strong>拟合程度越好</strong>,</p>
<p>小波的信息查询：waveinfo函数，例如waveinfo(‘wname’)</p>
<p>wname代表的小波有：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">'haar' : Haar wavelet.</span><br><span class="line">'db' : Daubechies wavelets.</span><br><span class="line">'sym' : Symlets.</span><br><span class="line">'coif' : Coiflets.</span><br><span class="line">'bior' : Biorthogonal wavelets.</span><br><span class="line">'rbio' : Reverse biorthogonal wavelets.</span><br><span class="line">'meyr' : Meyer wavelet.</span><br><span class="line">'dmey' : Discrete Meyer wavelet.</span><br><span class="line">'gaus' : Gaussian wavelets.</span><br><span class="line">'mexh' : Mexican hat wavelet.</span><br><span class="line">'morl' : Morlet wavelet.</span><br><span class="line">'cgau' : Complex Gaussian wavelets.</span><br><span class="line">'cmor' : Complex Morlet wavelets.</span><br><span class="line">'shan' : Complex Shannon wavelets.</span><br><span class="line">'fbsp' : Complex Frequency B-spline wavelets.</span><br><span class="line">'fk' : Fejer-Korovkin orthogonal wavelets</span><br></pre></td></tr></tbody></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805103058654.png" alt="image-20220805103058654"></p>
<p><strong>wfilters函数</strong></p>
<blockquote>
<p>[LO<em>D,HI</em>D,LO<em>R,HI</em>R] = wfilters(‘wname’):计算正交小波或双正交小波（wname）有关联的四个滤波器</p>
<p>LO_D，分解低通滤波器;HI_D，分解高通滤波器;LO_R，重构低通滤波器;HI_R，重构高通滤波器</p>
</blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">[LOD,HID,LOR,HIR] = wfilters('db45');% 得到该小波关联的四个滤波器</span><br><span class="line">% 将这四个滤波器显示出来</span><br><span class="line">subplot(221),stem(LOD),xlim([0,100]),title('分解低通滤波器')</span><br><span class="line">xlabel('x'),ylabel('y')</span><br><span class="line">subplot(222),stem(HID),xlim([0,100]),title('分解高通滤波器')</span><br><span class="line">xlabel('x'),ylabel('y')</span><br><span class="line">subplot(223),stem(LOR),xlim([0,100]),title('重构低通滤波器')</span><br><span class="line">xlabel('x'),ylabel('y')</span><br><span class="line">subplot(224),stem(HIR),xlim([0,100]),title('重构低通滤波器')</span><br><span class="line">xlabel('x'),ylabel('y')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805105124689.png" alt="image-20220805105124689"></p>
<h4 id="二维离散小波变换图像单层小波分解"><a href="#二维离散小波变换图像单层小波分解" class="headerlink" title="二维离散小波变换图像单层小波分解"></a>二维离散小波变换图像单层小波分解</h4><p>使用dwt2()函数</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">image = imread('D:\reports\test.jpg');% 获取照片</span><br><span class="line">T = rgb2gray(image);% 将照片转化成灰度模式</span><br><span class="line">[sm1,deHo,deVe,deDi] = dwt2(T,'bior3.7');% 将灰度照片单层分解成四个层面</span><br><span class="line">% 将四个层面的图像分别输出</span><br><span class="line">figure</span><br><span class="line">subplot(141),imshow(uint8(sm1),title('近似分量')% 近似分量</span><br><span class="line">subplot(142),imshow(deHo),title('细节水平分量')% 细节水平分量</span><br><span class="line">subplot(143),imshow(deVe),title('细节垂直分量')% 细节垂直分量</span><br><span class="line">subplot(144),imshow(deDi),title('细节对角分量')% 细节对角分量'</span><br><span class="line">figure</span><br><span class="line">subplot(121),imshow(image),title('原图')% 原图</span><br><span class="line">subplot(122),imshow([sm1,deHo;deVe,deDi]),title('小波变换分量组合')% 小波变换分量组合图像</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805131621875.png" alt="image-20220805131621875"></p>
<h4 id="小波实现图像的重构"><a href="#小波实现图像的重构" class="headerlink" title="小波实现图像的重构"></a>小波实现图像的重构</h4><p>idwt2()函数</p>
<p>这里使用db1小波函数对图像进行分解，然后再用db4的小波函数对图像进行重构，做差之后就能直观的看到前后图像的差别</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">image = imread('D:\reports\test.jpg');% 获取照片</span><br><span class="line">T = rgb2gray(image);% 将照片转化成灰度模式</span><br><span class="line">[sm1,deHo,deVe,deDi] = dwt2(T,'db1');% 将灰度照片单层分解成四个层面</span><br><span class="line">imageS = size(T);%获得原图像的尺度</span><br><span class="line">T0 = idwt2(sm1,deHo,deVe,deDi,'db4',imageS);% 利用小波分解的第一层系数去重构</span><br><span class="line">T1 = double(T)-T0;</span><br><span class="line">figure</span><br><span class="line">subplot(131),imshow(uint8(T)),title('原图像')</span><br><span class="line">subplot(132),imshow(uint8(T0)),title('重构图像')</span><br><span class="line">subplot(133),imshow(uint8(T1)),title('差异图像')</span><br></pre></td></tr></tbody></table></figure>

<p>效果图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805132501969.png" alt="image-20220805132501969"></p>
<h4 id="多层小波重构"><a href="#多层小波重构" class="headerlink" title="多层小波重构"></a>多层小波重构</h4><p>使用函数upcoef2()完成重构</p>
<p>appcoef2()：获取小波分解的近似系数</p>
<p>[<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&amp;s_tid=srchtitle_detcoef2_1#mw_09cf57bc-3330-4b93-a910-445cde51c817"><code>h</code></a>,<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&amp;s_tid=srchtitle_detcoef2_1#mw_e81701d6-fe13-4c82-8ca5-291a4f343e89"><code>v</code></a>,<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&amp;s_tid=srchtitle_detcoef2_1#mw_3804afb4-f6e9-4671-9dda-14dae7e60694"><code>d</code></a>] = detcoef2(‘all’,<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&amp;s_tid=srchtitle_detcoef2_1#mw_0f3a673f-2992-4843-ae0f-b9e10ec8712d"><code>c</code></a>,<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&amp;s_tid=srchtitle_detcoef2_1#mw_63157831-b6ac-4121-95b6-d9fd171a3585"><code>s</code></a>,<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&amp;s_tid=srchtitle_detcoef2_1#mw_91710198-9837-410b-bfdc-c2728c302aef"><code>n</code></a>):返回级别n处的水平h、垂直v和对角线d细节系数。’all‘这个参数也可以相应的修改而获得三个方向对应的细节系数</p>
<p>二层的分解需要将用小波函数分解出两层，然后再对每一层再进行小波变换的分解，重构的时候分方向重构。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">image = imread('D:\reports\test.jpg');% 获取照片</span><br><span class="line">T = rgb2gray(image);% 将照片转化成灰度模式</span><br><span class="line">[c,s] = wavedec2(T,2,'db4'); % 对图像进行小波的二层分解 wavedec2 小波函数使用db4</span><br><span class="line">siz = s(size(s,1),:);% 获得第二层小波分解的系数矩阵</span><br><span class="line">ca1 = appcoef2(c,s,'db4',2); % 小波分解的近似系数 appcoef()</span><br><span class="line">a1 = upcoef2('a',ca1,'db4',2,siz); % upcoef2()函数进行重构</span><br><span class="line"></span><br><span class="line">chd1 = detcoef2('h',c,s,2); % 小波分解的细节系数水平分量detcoef2()'h</span><br><span class="line">hd1 = upcoef2('h',chd1,'db4',2,siz);</span><br><span class="line"></span><br><span class="line">cvd1 = detcoef2('v',c,s,2); % 细节系数垂直分量'v'</span><br><span class="line">vd1 = upcoef2('v',cvd1,'db4',2,siz);</span><br><span class="line"></span><br><span class="line">cdd1 = detcoef2('d',c,s,2); % 细节系数对角分量'd'</span><br><span class="line">dd1 = upcoef2('d',cdd1,'db4',2,siz);</span><br><span class="line"></span><br><span class="line">result1 = a1+hd1+vd1+dd1;  % 将四个重构的分量相加得到图像的重构结果</span><br><span class="line">figure</span><br><span class="line">subplot(221),imshow(uint8(a1)),title('小波分解的近似系数')</span><br><span class="line">subplot(222),imshow(hd1),title('小波分解的近似系数水平分量')</span><br><span class="line">subplot(223),imshow(vd1),title('小波分解的细节系数垂直分量')</span><br><span class="line">subplot(224),imshow(dd1),title('小波分解的细节系数对角分量')</span><br><span class="line">figure</span><br><span class="line">subplot(121),imshow(uint8(T)),title('原图像')</span><br><span class="line">subplot(122),imshow(uint8(result1)),title('二层分解重构图像')</span><br></pre></td></tr></tbody></table></figure>



<p>效果图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805141517643.png" alt="image-20220805141517643"></p>
<h4 id="小波去噪去噪"><a href="#小波去噪去噪" class="headerlink" title="小波去噪去噪"></a>小波去噪去噪</h4><p>wrcoef2():使用wname指定的小波返回基于图像的小波分解结构[c,s]的type重构系数矩阵</p>
<p>例:<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/wrcoef2.html?searchHighlight=wrcoef2&amp;s_tid=srchtitle_wrcoef2_1#mw_9150039f-ca62-418b-8ca4-60dd701e1d07"><code>x</code></a> = wrcoef2(<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/wrcoef2.html?searchHighlight=wrcoef2&amp;s_tid=srchtitle_wrcoef2_1#mw_e8ef2513-e0bd-4cb0-8627-0cd7725f54bc"><code>type</code></a>,<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/wrcoef2.html?searchHighlight=wrcoef2&amp;s_tid=srchtitle_wrcoef2_1#mw_177fae65-edf4-44c3-aecd-9b55acdb796c"><code>c</code></a>,<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/wrcoef2.html?searchHighlight=wrcoef2&amp;s_tid=srchtitle_wrcoef2_1#mw_34affb98-fb55-4113-8dd1-8faf2f83de0a"><code>s</code></a>,<a target="_blank" rel="noopener" href="https://ww2.mathworks.cn/help/wavelet/ref/wrcoef2.html?searchHighlight=wrcoef2&amp;s_tid=srchtitle_wrcoef2_1#mw_6d9d77b8-5a90-459f-9f09-0edd798f673a"><code>wname</code></a>) ;a2 = wrcoef2(“a”,c,s,”sym5”,2);</p>
<p>NC = wthcoef2(‘type’,C,S,N,T,SORH) ：向量N和T中定义阈值，再从小波分解结构[C,S]中获得的水平、垂直或对角系数</p>
<p><a target="_blank" rel="noopener" href="https://chowdera.com/2022/03/202203110547374632.html">参考文章</a></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">image = imread('D:\reports\test.jpg');% 获取照片</span><br><span class="line">T = rgb2gray(image);% 将照片转化成灰度模式</span><br><span class="line">T = imnoise(T,'speckle',0.1);</span><br><span class="line">subplot(131),imshow(uint8(T)),title('加噪图像')</span><br><span class="line">% init=2055615866;</span><br><span class="line">% randn('seed',init);</span><br><span class="line">% T = double(T) + 2*randn(size(T));</span><br><span class="line">[c,s] = wavedec2(T,2,'sym4'); % 对图像进行小波的二层分解 wavedec2 小波函数使用db4</span><br><span class="line">result1 = wrcoef2('a',c,s,'sym4',2);% 重构第二层的近似系数，小波分解去噪的操作</span><br><span class="line">subplot(132),imshow(result1),title('小波分解去噪')</span><br><span class="line">n = [1,2];% 设置阈值N 尺度向量</span><br><span class="line">r = [10.28, 24.08];% 设置阈值T 阈值向量</span><br><span class="line">dealData0 = wthcoef2('t',c,s,n,r,'s');% 对高频小波进行阈值处理 wthcoef2</span><br><span class="line">dealData1 = wthcoef2('t',dealData0,s,n,r,'s');% 对高频小波进行第二次阈值处理</span><br><span class="line">result2 = waverec2(dealData1,s,'sym4');% 对阈值处理之后的小波进行重构 waverec2（）</span><br><span class="line">subplot(133),imshow(result1),title('小波阈值去噪')</span><br></pre></td></tr></tbody></table></figure>

<p>实验结果：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805154151408.png" alt="image-20220805154151408"></p>
<p>总结：能够看到噪声明显减弱了，但是图像也更模糊了，去噪的过程就是过滤高频小波，高频小波之中表现的是细节</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Gruge</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/05/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/">http://example.com/2022/08/05/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Gruge's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/">数字图像处理基础实验</a></div><div class="post_share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/05/04/DASCTF2022-FATE/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DASCTF2022-FATE</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/463b631c6a0f63ec.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Gruge</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">数字图像处理的基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%BD%A9%E8%89%B2%E5%9B%BE%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%81%B0%E5%BA%A6%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">将彩色图转换为灰度图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%81%B0%E5%BA%A6%E5%9B%BE%E8%BD%AC%E4%B8%BA%E4%B8%BA%E7%B4%A2%E5%BC%95%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text">将灰度图转为为索引图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%B4%A2%E5%BC%95%E5%9B%BE%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%9C%9F%E5%BD%A9%E8%89%B2%E7%9A%84%E5%9B%BE"><span class="toc-number">1.3.</span> <span class="toc-text">将索引图转化为真彩色的图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%80%BC%E5%8C%96%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">将灰度图像转化为二值化图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">图像的几何变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E5%B9%B3%E7%A7%BB"><span class="toc-number">2.1.</span> <span class="toc-text">图像的平移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BC%A9%E6%94%BE"><span class="toc-number">2.2.</span> <span class="toc-text">图像的缩放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%97%8B%E8%BD%AC"><span class="toc-number">2.3.</span> <span class="toc-text">图像旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E9%95%9C%E5%83%8F"><span class="toc-number">2.4.</span> <span class="toc-text">图像镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E8%BD%AC%E7%BD%AE"><span class="toc-number">2.5.</span> <span class="toc-text">图像的转置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E5%89%AA%E5%88%87"><span class="toc-number">2.6.</span> <span class="toc-text">图像的剪切</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">灰度变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%98%A0%E5%B0%84"><span class="toc-number">3.1.</span> <span class="toc-text">函数映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%A4%84%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">直方图处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E5%B9%B3%E6%BB%91%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">图像的平滑处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%9D%87%E5%80%BC%E5%92%8C%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%B9%B3%E6%BB%91%E5%A4%84%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">采用均值和高斯滤波器进行平滑处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">5.</span> <span class="toc-text">边缘检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%86%E5%89%B2"><span class="toc-number">6.</span> <span class="toc-text">图像的分割</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%88%86%E5%89%B2"><span class="toc-number">6.1.</span> <span class="toc-text">全局分割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Otsu%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2"><span class="toc-number">6.2.</span> <span class="toc-text">Otsu阈值分割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%BC%8F%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">迭代式阈值分割法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E5%88%86%E5%89%B2%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD%E5%88%86%E5%89%B2"><span class="toc-number">6.4.</span> <span class="toc-text">区域分割的分水岭分割</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">图像的形态学处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E8%85%90%E8%9A%80"><span class="toc-number">8.</span> <span class="toc-text">图像腐蚀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E8%86%A8%E8%83%80"><span class="toc-number">8.1.</span> <span class="toc-text">图像膨胀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E8%BF%90%E7%AE%97"><span class="toc-number">8.2.</span> <span class="toc-text">开运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E8%BF%90%E7%AE%97"><span class="toc-number">8.3.</span> <span class="toc-text">闭运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E7%9A%84%E9%AB%98%E5%B8%BD%E6%BB%A4%E6%B3%A2"><span class="toc-number">8.4.</span> <span class="toc-text">形态学的高帽滤波</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8E%E5%B8%BD%E6%BB%A4%E6%B3%A2"><span class="toc-number">8.5.</span> <span class="toc-text">低帽滤波</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%93%8D%E4%BD%9C"><span class="toc-number">8.6.</span> <span class="toc-text">填充操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F%E4%B8%AD%E8%AE%BE%E5%AE%9A%E9%98%88%E5%80%BC%E7%9A%84%E5%B1%80%E9%83%A8%E6%9E%81%E5%A4%A7%E5%80%BC"><span class="toc-number">8.7.</span> <span class="toc-text">灰度图像中设定阈值的局部极大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%B5%8B%E5%AE%9A"><span class="toc-number">8.8.</span> <span class="toc-text">灰度图像边缘测定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-number">9.</span> <span class="toc-text">傅里叶变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E9%A2%91%E8%B0%B1%E5%9B%BE%E5%B1%95%E7%A4%BA"><span class="toc-number">9.1.</span> <span class="toc-text">图像的频谱图展示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E4%BD%8E%E9%80%9A-%E9%AB%98%E9%80%9A-%E9%A2%91%E5%9F%9F%E6%BB%A4%E6%B3%A2"><span class="toc-number">9.2.</span> <span class="toc-text">高斯低通(高通)频域滤波</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E5%90%88%E6%88%90%E5%A4%84%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">图像的合成处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BF%90%E7%AE%97"><span class="toc-number">10.1.</span> <span class="toc-text">加运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">彩色图像的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">12.</span> <span class="toc-text">小波变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2%E5%9B%BE%E5%83%8F%E5%8D%95%E5%B1%82%E5%B0%8F%E6%B3%A2%E5%88%86%E8%A7%A3"><span class="toc-number">12.1.</span> <span class="toc-text">二维离散小波变换图像单层小波分解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%B3%A2%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E7%9A%84%E9%87%8D%E6%9E%84"><span class="toc-number">12.2.</span> <span class="toc-text">小波实现图像的重构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E5%B0%8F%E6%B3%A2%E9%87%8D%E6%9E%84"><span class="toc-number">12.3.</span> <span class="toc-text">多层小波重构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%B3%A2%E5%8E%BB%E5%99%AA%E5%8E%BB%E5%99%AA"><span class="toc-number">12.4.</span> <span class="toc-text">小波去噪去噪</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/05/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/" title="数字图像处理实验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数字图像处理实验"></a><div class="content"><a class="title" href="/2022/08/05/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/" title="数字图像处理实验">数字图像处理实验</a><time datetime="2022-08-05T07:52:11.000Z" title="发表于 2022-08-05 15:52:11">2022-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/04/DASCTF2022-FATE/" title="DASCTF2022-FATE"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DASCTF2022-FATE"></a><div class="content"><a class="title" href="/2022/05/04/DASCTF2022-FATE/" title="DASCTF2022-FATE">DASCTF2022-FATE</a><time datetime="2022-05-04T09:44:12.000Z" title="发表于 2022-05-04 17:44:12">2022-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/25/starCTF2022-Simple-NaCl/" title="starCTF2022_Simple+NaCl"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="starCTF2022_Simple+NaCl"></a><div class="content"><a class="title" href="/2022/04/25/starCTF2022-Simple-NaCl/" title="starCTF2022_Simple+NaCl">starCTF2022_Simple+NaCl</a><time datetime="2022-04-25T12:10:56.000Z" title="发表于 2022-04-25 20:10:56">2022-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/21/DASCTF-Login/" title="DASCTF_Login"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DASCTF_Login"></a><div class="content"><a class="title" href="/2022/04/21/DASCTF-Login/" title="DASCTF_Login">DASCTF_Login</a><time datetime="2022-04-21T06:04:38.000Z" title="发表于 2022-04-21 14:04:38">2022-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/15/HFCTF2022-theShellcode/" title="HFCTF2022_theShellcode"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/ca6f47126f533a59.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HFCTF2022_theShellcode"></a><div class="content"><a class="title" href="/2022/04/15/HFCTF2022-theShellcode/" title="HFCTF2022_theShellcode">HFCTF2022_theShellcode</a><time datetime="2022-04-15T14:35:25.000Z" title="发表于 2022-04-15 22:35:25">2022-04-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2022 By Gruge</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '1aa3bac2fd8cfac9d7c3',
      clientSecret: '7640d6d45e9030f665c75a640991b67e8367e67d',
      repo: 'G2uge.github.io',
      owner: 'G2uge',
      admin: ['G2uge'],
      id: '1301c82e77bea634de72875720759594',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>