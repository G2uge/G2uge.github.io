<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022DASCTF_X_SU_StarGate</title>
    <url>/2022/04/05/2022DASCTF-X-SU-StarGate/</url>
    <content><![CDATA[<h2 id="StarGate"><a href="#StarGate" class="headerlink" title="StarGate"></a>StarGate</h2><p>这道题因为自己各种基础知识不牢固的原因写了很久，细节上的知识需要自己不断地积累，也觉得自己写代码太烂了！！！太菜了！！！</p>
<p>使用nc连接靶机，返回得到文件的base64加密内容</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331195957518.png" alt="image-20220331195957518"></p>
<p>提取出这个base64加密的内容，放入<a href="https://www.strerr.com/cn/base64_decode_file.html">在线网站</a>之中bse64解密，得到的是一个elf文件</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331195917666.png" alt="image-20220331195917666"></p>
<p>将这个elf文件放入ida之中，通过字符串定位到关键的代码位置</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331200301470.png" alt="image-20220331200301470"></p>
<h3 id="分析流程（欧拉路径问题）"><a href="#分析流程（欧拉路径问题）" class="headerlink" title="分析流程（欧拉路径问题）"></a>分析流程（欧拉路径问题）</h3><p>题目之中给了提示 “寻找欧拉路径”</p>
<blockquote>
<p>对于一个给定的图，怎样判断是否存在着一个恰好<strong>包含了所有的边</strong>，并且<strong>没有重复的路径</strong>？这就是<strong>一笔画问题</strong>。用图论的术语来说，就是判断这个图是否是一个能够<strong>遍历完所有的边而没有重复</strong>。这样的图现称为<strong>欧拉图</strong>。这时遍历的路径称作<strong>欧拉路径</strong>（一个环或者一条链），如果路径闭合（一个圈），则称为<strong>欧拉回路</strong></p>
</blockquote>
<p>通过catflag这个字符串定位到一个相关联的函数</p>
<p>if语句之中的判断条件是判断走过了所有的路径，每个变量参数代表的是某路径是否走过的标志位</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331201621712.png" alt="image-20220331201621712"></p>
<p>查看字符串表，图中红色方框中的字符串就能够定位到一个函数之中，每个函数之中的逻辑都一样</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331202132905.png" alt="image-20220331202132905"></p>
<p>字符串定位到的函数：每次输入一个字符串，相当于到达某一个对应的函数，跳转就是一条边，每条边的表示方法是dword_41D1C这样的形式 </p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331202356711.png" alt="image-20220331202356711"></p>
<p>走过所有的边，最后catflag的函数：</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331202805308.png" alt="image-20220331202805308"></p>
<p>所以这个就是一个一笔画问题</p>
<p>因为这是一个图的问题，从代码之中提取出边对应的字符串的表示方法和它对应调用的函数，对应的函数之中又有和这条边相连的能够走的路径，我们要dump出所有的边，并且给按照代码将这些边连接起来生成一个图，再将这个图作为参数传入欧拉路径的算法之中，得到走的路径，按照这个路径再向这个靶机之中传入得到的路径</p>
<p>re模块的常量(属性)</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220401205707835.png" alt="image-20220401205707835"></p>
<h3 id="连接服务器得到elf文件"><a href="#连接服务器得到elf文件" class="headerlink" title="连接服务器得到elf文件"></a>连接服务器得到elf文件</h3><p>用pwn连接服务器，将服务器返回的进行base64加密的elf文件进行解密，并且保存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获得连接服务器得到的脚本</span><br><span class="line">from pwn import *</span><br><span class="line">import base64</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = remote(&quot;node4.buuoj.cn&quot;,25305)</span><br><span class="line">io.recvuntil(&#x27;Gate&#x27;)</span><br><span class="line">code = io.recvuntil(&#x27;==end==&#x27;)</span><br><span class="line">with open(&quot;code&quot;,&quot;wb&quot;) as f:</span><br><span class="line">    f.write(base64.b64decode(code[:-8]))</span><br></pre></td></tr></table></figure>

<h3 id="ida反编译得到c语言文件"><a href="#ida反编译得到c语言文件" class="headerlink" title="ida反编译得到c语言文件"></a>ida反编译得到c语言文件</h3><p>将elf文件放入ida64之中（使用ida64的7.5版本），然后使用File-&gt;Produce File-&gt;Creat C File将反编译的c语言代码dump下来</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220405221614550.png" alt="image-20220405221614550"> </p>
<h3 id="图的生成"><a href="#图的生成" class="headerlink" title="图的生成"></a>图的生成</h3><p>正则搜索code.c文件之中的代码，得到相对应的图（点和点的对应关系）,并将其写入graph.txt文件之中</p>
<p>生成图的方法：</p>
<ul>
<li><p>使用正则表达式搜索到所有具有如下if语句的函数，每个这样的函数将是数组之中的一个元素</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220405223108571.png" alt="image-20220405223108571"></p>
</li>
<li><p>将所有这些函数名集合成一个数组，这个数组就是所有的点</p>
</li>
<li><p>这些函数名跳转到另外一个函数就作为一个边（每个函数名也就是每个点都会有一个对应的字符串），遍历每个函数就能够得到所有的这些边，需要注意的是因为是无向图，同一条边会被表示两次</p>
</li>
<li><p>将数组之中这些函数的索引作为每个点的表示（因为c语言脚本之宗数组的起点是1，所以所有的索引需要加一之后写入）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;code.c&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:   <span class="comment"># 因为后面要用正则匹配的是字符串文本，所以读取的方式不能使用rb，要使用r</span></span><br><span class="line">    codes = f.read()</span><br><span class="line"><span class="comment"># 下面的两个数组字符串和调用的函数关系都是对应的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得字符串（边）</span></span><br><span class="line">passwords = re.findall(<span class="string">&#x27;if \( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 \)&#x27;</span>,codes)   <span class="comment"># 按照顺序提取出来的passwords if ( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 )    !strcmp\(&quot;(.*?)&quot;, s2\)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(passwords))</span><br><span class="line"><span class="comment"># 当前函数（点）经过该字符串（边）到达的函数</span></span><br><span class="line">funcnames_pass = re.findall(<span class="string">&quot;(sub_[0123456789ABCDEF]&#123;6&#125;\(\));\n    exit\(0\);&quot;</span>,codes)   <span class="comment"># 和上面的password具有对应关系的函数名</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(funcnames_pass))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取出所有的选择的函数的所有内容</span></span><br><span class="line">functions = re.findall(<span class="string">&quot;__int64 sub_[0123456789ABCDEF]&#123;6&#125;\(\)\n&#123;\n  char s2\[40\];.*?Wrong password&quot;</span>,codes,re.DOTALL)  <span class="comment"># .*?Wrong password</span></span><br><span class="line"><span class="comment"># 从所有的函数之中提取出来该函数（点）能够到达的函数（点） 用funcnames的index表示每个点</span></span><br><span class="line">funcnames = []</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> functions:</span><br><span class="line">    funcname = re.findall(<span class="string">&quot;__int64 (sub_[0123456789ABCDEF]&#123;6&#125;\(\))&quot;</span>,obj)[<span class="number">0</span>]</span><br><span class="line">    funcnames.append(funcname)</span><br><span class="line"><span class="built_in">print</span>(funcnames)</span><br><span class="line"><span class="comment"># 字典 保存每个函数之中子函数和字符串相应的对应关系的数据</span></span><br><span class="line">dic_child_func = &#123;&#125;</span><br><span class="line">dic_child_str = &#123;&#125;</span><br><span class="line"><span class="comment"># 使用二维数组表示这个图</span></span><br><span class="line">graph = []</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> functions:</span><br><span class="line">    funcname = re.findall(<span class="string">&quot;__int64 (sub_[0123456789ABCDEF]&#123;6&#125;\(\))&quot;</span>,obj)[<span class="number">0</span>]</span><br><span class="line">    child_funcnames = re.findall(<span class="string">&quot;(sub_[0123456789ABCDEF]&#123;6&#125;\(\));\n    exit\(0\);&quot;</span>,obj)</span><br><span class="line">    child_str = re.findall(<span class="string">&#x27;if \( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 \)&#x27;</span>,obj)</span><br><span class="line">    <span class="comment"># print(child_str)</span></span><br><span class="line">    <span class="comment"># print(child_funcnames)</span></span><br><span class="line">    dic_child_func[funcname] = child_funcnames</span><br><span class="line">    dic_child_str[funcname] = child_str</span><br><span class="line">    <span class="keyword">for</span> obj0 <span class="keyword">in</span> child_funcnames:</span><br><span class="line">        tem = []</span><br><span class="line">        tem.append(funcnames.index(funcname)) <span class="comment"># 获得当前函数的索引</span></span><br><span class="line">        tem.append(funcnames.index(obj0))  <span class="comment"># 获取当前函数能够到达的下一个点的索引</span></span><br><span class="line">        graph.append(tem)</span><br><span class="line"><span class="built_in">print</span>(graph)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(graph))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;graph.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 总边数的两倍 总的节点的个数</span></span><br><span class="line">    f.write(<span class="built_in">str</span>(<span class="built_in">len</span>(graph))+<span class="string">&quot;  &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(funcnames)))</span><br><span class="line">    f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">        f.write(<span class="built_in">str</span>(graph[i][<span class="number">0</span>]+<span class="number">1</span>)+<span class="string">&quot;  &quot;</span>+<span class="built_in">str</span>(graph[i][<span class="number">1</span>]+<span class="number">1</span>))</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="欧拉路径算法（fleury算法）"><a href="#欧拉路径算法（fleury算法）" class="headerlink" title="欧拉路径算法（fleury算法）"></a>欧拉路径算法（fleury算法）</h3><p>用c语言读取graph.txt之中点的对应关系，初始化图，得到对应的数组，然后找出欧拉路径，将欧拉路径写入到map.txt文件之中</p>
<p>注意，因为刻画出来的无向图之中，一条边被表示了两次，所以在初始化数组的时候，需要判断一下该条边是否被赋值过，如果已经被赋值了，就不用再次赋值了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> n, m, flag, top, sum, du[N], ans[<span class="number">5005</span>], <span class="built_in">map</span>[N][N];</span><br><span class="line">FILE* fpwrite;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    ans[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[x][i]--;</span><br><span class="line">            <span class="built_in">map</span>[i][x]--;</span><br><span class="line">            dfs(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fleury</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    top = <span class="number">1</span>;</span><br><span class="line">    ans[top] = x;</span><br><span class="line">    <span class="keyword">while</span>(top &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//判断是否可扩展</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[ans[top]][i] &gt;= <span class="number">1</span>)<span class="comment">//若存在一条从ans[top]出发的边  那么就是可扩展</span></span><br><span class="line">            &#123;k = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)<span class="comment">//该点x没有其他的边可以先走了（即不可扩展）， 那么就输出它</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            printf(&quot;%d &quot;, ans[top]);</span></span><br><span class="line">        <span class="built_in">fprintf</span>(fpwrite,<span class="string">&quot;%d&quot;</span>,ans[top]);</span><br><span class="line">        <span class="built_in">fprintf</span>(fpwrite,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">1</span>)<span class="comment">//如可扩展， 则dfs可扩展的哪条路线</span></span><br><span class="line">        &#123;</span><br><span class="line">            top--;<span class="comment">//这需要注意</span></span><br><span class="line">            dfs(ans[top+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* fpread;</span><br><span class="line">    fpread = fopen(<span class="string">&quot;D:\\re\\buuctf\\practice\\1\\graph.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);  <span class="comment">//D:\\re\\buuctf\\practice\\1\\graph</span></span><br><span class="line">    fpwrite = fopen(<span class="string">&quot;D:\\re\\buuctf\\practice\\1\\map.txt&quot;</span>,<span class="string">&quot;w&quot;</span>); <span class="comment">//向其中写入路径的文本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fpread == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file is error!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(fpread,<span class="string">&quot;%d&quot;</span>,&amp;m);  <span class="comment">//得到边的条数两倍</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fpread,<span class="string">&quot;%d&quot;</span>,&amp;n);  <span class="comment">// 得到总的节点个数</span></span><br><span class="line">    <span class="built_in">memset</span>(du, <span class="number">0</span>, <span class="keyword">sizeof</span>(du));</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            <span class="built_in">fscanf</span>(fpread,<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">map</span>[x][y]++; <span class="comment">//记录边， 因为是无向图所以加两条边， 两个点之间可能有多条边</span></span><br><span class="line">            <span class="built_in">map</span>[y][x]++;</span><br><span class="line">            du[x]++;</span><br><span class="line">            du[y]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">1</span>; <span class="comment">// flag标记开始点。 如果所有点度数全为偶数那就从1开始搜</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(du[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                flag = i;<span class="comment">// 若有奇数边， 从奇数边开始搜</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span> || sum == <span class="number">2</span>)</span><br><span class="line">            fleury(flag);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Success！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="用于交互的字符串数组"><a href="#用于交互的字符串数组" class="headerlink" title="用于交互的字符串数组"></a>用于交互的字符串数组</h3><ul>
<li><p>得到的索引需要减一</p>
</li>
<li><p>用python读取整个欧拉路径，得到走这个欧拉路径需要的输入的字符串，再和服务器进行相应的交互，注意的是，得到的欧拉路径可能顺序可能需要颠倒一下（可以根据最后需要到达的函数所需要的字符串来判断是否需要颠倒）</p>
</li>
</ul>
<p>（图中表示的那个函数是输出cat flag的函数，图中标注的字符串是我们需要到达的字符串）</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220405222345489.png" alt="image-20220405222345489"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">theMap = []  <span class="comment"># 用数字表示的路径</span></span><br><span class="line">theStrmap = []  <span class="comment"># 用字符串表示的路径</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;map.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        theMap.append(<span class="built_in">int</span>(line.strip(<span class="string">&#x27;\n&#x27;</span>))-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(theMap))</span><br><span class="line">theFistFunc = funcnames[theMap[<span class="number">0</span>]]  <span class="comment"># 获得第一个函数的名称</span></span><br><span class="line">theFistFuncStr = passwords[funcnames_pass.index(theFistFunc)] <span class="comment"># 用第一个函数的名称找到函数数组里面的index 然后找到对应的str</span></span><br><span class="line">theStrmap.append(theFistFuncStr)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theMap)-<span class="number">1</span>):</span><br><span class="line">    theFucName = funcnames[theMap[i]]</span><br><span class="line">    theNextFuncName = funcnames[theMap[i+<span class="number">1</span>]]</span><br><span class="line">    theIndex = dic_child_func[theFucName].index(theNextFuncName)</span><br><span class="line">    theStrmap.append(dic_child_str[theFucName][theIndex])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(theStrmap))</span><br><span class="line"><span class="comment"># 查看第一步所到达的函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一步所到达的函数的字符串：&quot;</span>+theFistFuncStr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;到达最后一步函数输入的字符串：&quot;</span>+theStrmap[<span class="built_in">len</span>(theStrmap)-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 代码之中搜查到的最后的一个字符串</span></span><br><span class="line">theCodeFinalStr = re.findall(<span class="string">&quot;  v2 = __readfsqword\(0x28u\);\n  if \( !dword_[0123456789ABCDEF]&#123;6&#125;\n.*?printf\(\&quot;Now you in universe ([a-zA-Z]&#123;1,&#125;)&quot;</span>,codes,re.DOTALL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;是否需要颠倒一下顺序:1.是 2.否&quot;)</span></span><br><span class="line"><span class="comment"># choose = 2</span></span><br><span class="line"><span class="comment"># choose=int(input(&quot;请输入你的选择:&quot;))</span></span><br><span class="line"><span class="comment"># if choose == 1:</span></span><br><span class="line"><span class="comment">#     theStrmap.reverse()</span></span><br><span class="line"><span class="comment"># 如果最后到达的字符串出现在第一步，说明顺序反了，需要颠倒一下</span></span><br><span class="line"><span class="keyword">if</span> theFistFuncStr == theCodeFinalStr:</span><br><span class="line">    theStrmap.reverse()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theStrmap)):</span><br><span class="line">    io.sendline(theStrmap[i])</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># 使用pwn进行服务器的交互</span></span><br></pre></td></tr></table></figure>

<h3 id="脚本汇总"><a href="#脚本汇总" class="headerlink" title="脚本汇总"></a>脚本汇总</h3><p>python的脚本代码(汇总)：需要按照需求在相应的位置停顿</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获得连接服务器得到的脚本</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25305</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Gate&#x27;</span>)</span><br><span class="line">code = io.recvuntil(<span class="string">&#x27;==end==&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;code&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(base64.b64decode(code[:-<span class="number">8</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;请先dump出code.c 之后想要继续请按回车&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;code.c&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:   <span class="comment"># 因为后面要用正则匹配的是字符串文本，所以读取的方式不能使用rb，要使用r</span></span><br><span class="line">    codes = f.read()</span><br><span class="line"><span class="comment"># 下面的两个数组字符串和调用的函数关系都是对应的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得字符串（边）</span></span><br><span class="line">passwords = re.findall(<span class="string">&#x27;if \( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 \)&#x27;</span>,codes)   <span class="comment"># 按照顺序提取出来的passwords if ( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 )    !strcmp\(&quot;(.*?)&quot;, s2\)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(passwords))</span><br><span class="line"><span class="comment"># 当前函数（点）经过该字符串（边）到达的函数</span></span><br><span class="line">funcnames_pass = re.findall(<span class="string">&quot;(sub_[0123456789ABCDEF]&#123;6&#125;\(\));\n    exit\(0\);&quot;</span>,codes)   <span class="comment"># 和上面的password具有对应关系的函数名</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(funcnames_pass))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取出所有的选择的函数的所有内容</span></span><br><span class="line">functions = re.findall(<span class="string">&quot;__int64 sub_[0123456789ABCDEF]&#123;6&#125;\(\)\n&#123;\n  char s2\[40\];.*?Wrong password&quot;</span>,codes,re.DOTALL)  <span class="comment"># .*?Wrong password</span></span><br><span class="line"><span class="comment"># 从所有的函数之中提取出来该函数（点）能够到达的函数（点） 用funcnames的index表示每个点</span></span><br><span class="line">funcnames = []</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> functions:</span><br><span class="line">    funcname = re.findall(<span class="string">&quot;__int64 (sub_[0123456789ABCDEF]&#123;6&#125;\(\))&quot;</span>,obj)[<span class="number">0</span>]</span><br><span class="line">    funcnames.append(funcname)</span><br><span class="line"><span class="built_in">print</span>(funcnames)</span><br><span class="line"><span class="comment"># 字典 保存每个函数之中子函数和字符串相应的对应关系的数据</span></span><br><span class="line">dic_child_func = &#123;&#125;</span><br><span class="line">dic_child_str = &#123;&#125;</span><br><span class="line"><span class="comment"># 使用二维数组表示这个图</span></span><br><span class="line">graph = []</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> functions:</span><br><span class="line">    funcname = re.findall(<span class="string">&quot;__int64 (sub_[0123456789ABCDEF]&#123;6&#125;\(\))&quot;</span>,obj)[<span class="number">0</span>]</span><br><span class="line">    child_funcnames = re.findall(<span class="string">&quot;(sub_[0123456789ABCDEF]&#123;6&#125;\(\));\n    exit\(0\);&quot;</span>,obj)</span><br><span class="line">    child_str = re.findall(<span class="string">&#x27;if \( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 \)&#x27;</span>,obj)</span><br><span class="line">    <span class="comment"># print(child_str)</span></span><br><span class="line">    <span class="comment"># print(child_funcnames)</span></span><br><span class="line">    dic_child_func[funcname] = child_funcnames</span><br><span class="line">    dic_child_str[funcname] = child_str</span><br><span class="line">    <span class="keyword">for</span> obj0 <span class="keyword">in</span> child_funcnames:</span><br><span class="line">        tem = []</span><br><span class="line">        tem.append(funcnames.index(funcname)) <span class="comment"># 获得当前函数的索引</span></span><br><span class="line">        tem.append(funcnames.index(obj0))  <span class="comment"># 获取当前函数能够到达的下一个点的索引</span></span><br><span class="line">        graph.append(tem)</span><br><span class="line"><span class="built_in">print</span>(graph)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(graph))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;graph.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 总边数的两倍 总的节点的个数</span></span><br><span class="line">    f.write(<span class="built_in">str</span>(<span class="built_in">len</span>(graph))+<span class="string">&quot;  &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(funcnames)))</span><br><span class="line">    f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">        f.write(<span class="built_in">str</span>(graph[i][<span class="number">0</span>]+<span class="number">1</span>)+<span class="string">&quot;  &quot;</span>+<span class="built_in">str</span>(graph[i][<span class="number">1</span>]+<span class="number">1</span>))</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个地方等待输入，等c语言脚本运行完之后再接着运行</span></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;请先执行c语言代码，之后继续请按回车&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">theMap = []  <span class="comment"># 用数字表示的路径</span></span><br><span class="line">theStrmap = []  <span class="comment"># 用字符串表示的路径</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;map.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        theMap.append(<span class="built_in">int</span>(line.strip(<span class="string">&#x27;\n&#x27;</span>))-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(theMap))</span><br><span class="line">theFistFunc = funcnames[theMap[<span class="number">0</span>]]  <span class="comment"># 获得第一个函数的名称</span></span><br><span class="line">theFistFuncStr = passwords[funcnames_pass.index(theFistFunc)] <span class="comment"># 用第一个函数的名称找到函数数组里面的index 然后找到对应的str</span></span><br><span class="line">theStrmap.append(theFistFuncStr)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theMap)-<span class="number">1</span>):</span><br><span class="line">    theFucName = funcnames[theMap[i]]</span><br><span class="line">    theNextFuncName = funcnames[theMap[i+<span class="number">1</span>]]</span><br><span class="line">    theIndex = dic_child_func[theFucName].index(theNextFuncName)</span><br><span class="line">    theStrmap.append(dic_child_str[theFucName][theIndex])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(theStrmap))</span><br><span class="line"><span class="comment"># 查看第一步所到达的函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一步所到达的函数的字符串：&quot;</span>+theFistFuncStr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;到达最后一步函数输入的字符串：&quot;</span>+theStrmap[<span class="built_in">len</span>(theStrmap)-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 代码之中搜查到的最后的一个字符串</span></span><br><span class="line">theCodeFinalStr = re.findall(<span class="string">&quot;  v2 = __readfsqword\(0x28u\);\n  if \( !dword_[0123456789ABCDEF]&#123;6&#125;\n.*?printf\(\&quot;Now you in universe ([a-zA-Z]&#123;1,&#125;)&quot;</span>,codes,re.DOTALL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;是否需要颠倒一下顺序:1.是 2.否&quot;)</span></span><br><span class="line"><span class="comment"># choose = 2</span></span><br><span class="line"><span class="comment"># choose=int(input(&quot;请输入你的选择:&quot;))</span></span><br><span class="line"><span class="comment"># if choose == 1:</span></span><br><span class="line"><span class="comment">#     theStrmap.reverse()</span></span><br><span class="line"><span class="comment"># 如果最后到达的字符串出现在第一步，说明顺序反了，需要颠倒一下</span></span><br><span class="line"><span class="keyword">if</span> theFistFuncStr == theCodeFinalStr:</span><br><span class="line">    theStrmap.reverse()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theStrmap)):</span><br><span class="line">    io.sendline(theStrmap[i])</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># 使用pwn进行服务器的交互</span></span><br><span class="line">flag&#123;76efc0a7-eba1-4b83-a6d7-dce9cf17f4bd&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220405222805883.png" alt="image-20220405222805883"></p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>复现</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF的Dig the way - 栈溢出</title>
    <url>/2022/02/27/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h2 id="BUUCTF的Dig-the-way-栈溢出"><a href="#BUUCTF的Dig-the-way-栈溢出" class="headerlink" title="BUUCTF的Dig the way - 栈溢出"></a>BUUCTF的Dig the way - 栈溢出</h2><p>这是一道栈溢出的题目</p>
<p>进入到主函数里面</p>
<p>首先就是读取data之中数据的代码</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227123156345.png" alt="image-20220227123156345"></p>
<p>通过代码我们可以知道这个地方并没有对数据的写入长度进行限制</p>
<h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><p>fseek()函数可以移动文件的读写指针到指定的位置，即移动当前文件的位置指针，其原型为：<br>  int fseek(FILE * stream, long offset, int fromwhere);</p>
<p>【参数】stream为文件指针，offset为偏移量，fromwhere为指针的起始位置。</p>
<p>参数 offset 为根据参数 fromwhere 来移动读写位置的位移数。参数 fromwhere 为下列其中一种：</p>
<ul>
<li>SEEK_SET：从距文件开头 offset 位移量为新的读写位置；</li>
<li>SEEK_CUR：以目前的读写位置往后增加 offset 个位移量；</li>
<li>SEEK_END：将读写位置指向文件尾后再增加 offset 个位移量。</li>
</ul>
<p>例子：</p>
<ul>
<li>将读写位置移动到文件开头：fseek(fp, 0, SEEK_SET);</li>
<li>将读写位置移动到文件尾时：fseek(fp, 0, SEEK_END);</li>
<li>将读写位置动到离文件开头100字节处：fseek(fp,100L, SEEK_SET);</li>
<li>将读写指针移动到离文件当前位置100字节处：fseek(fp,100L, SEEK_CUR);</li>
<li>将读写指针退回到离文件结尾100字节处：fseek(fp, -100L, SEEK_END);</li>
</ul>
<h4 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h4><p>用 法: <code>long ftell(FILE *fp);</code><br>描 述: 返回当前文件指针位置。这个位置是当前文件指针相对于文件开头的位移量。<br>返回值:返回文件指针的位置，若出错则返回-1L。<br>参数：文件指针。</p>
<h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><p>用 法: size_t fread( void *buffer, size_t size, size_t count, FILE *stream ) ;<br>描 述: fread()用来从文件流中读取数据。参数stream为已打开的文件指针，参数buffer指向欲存放读取进来的数据空间，读取的字节数以参数size * count来决定。<br>返回值: 返回实际读取到的count数目，如果此值比参数count来得小，则代表可能读到了文件尾了或者有错误发生(前者几率大)，这时必须用feof()或ferror()来决定发生什么情况。<br>参数：</p>
<p>buffer ：读取的数据存放的内存的指针（可以是数组，也可以是新开辟的空间，buffer就是一个索引）；<br>size ： 每次读取的字节数 ；<br>count ：读取次数 ；<br>strean：要读取的文件的指针；</p>
<h4 id="三个函数的解析"><a href="#三个函数的解析" class="headerlink" title="三个函数的解析"></a>三个函数的解析</h4><h5 id="func0"><a href="#func0" class="headerlink" title="func0"></a>func0</h5><p>交换栈中的两个数据</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113310818.png" alt="image-20220227113300364"></p>
<h5 id="func1"><a href="#func1" class="headerlink" title="func1"></a>func1</h5><p>这个函数的返回值小于等于2</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113437073.png" alt="image-20220227113437073"></p>
<h5 id="func2"><a href="#func2" class="headerlink" title="func2"></a>func2</h5><p>这个函数的返回值大于等于2</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113508616.png" alt="image-20220227113508616"></p>
<p>现在我们需要使v11等于0 ，程序之中给v11赋值的是func2函数，但是该函数的返回值一定是大于等于2的，显示不可能实现v11= 0</p>
<p>但是在上面的三个函数之中我们可以看到func1的返回值能够等于0 ，所以需要使用func0这个函数调换栈中func1和func2这两个函数的位置</p>
<h4 id="交换func1函数和func0函数位置"><a href="#交换func1函数和func0函数位置" class="headerlink" title="交换func1函数和func0函数位置"></a>交换func1函数和func0函数位置</h4><p>运行func0函数时，传入的参数v12和v13是初始值，我们只需将表示func1地址的v15 和 表示func2地址的v16交换</p>
<p>v15的地址是 v8+4*7    v16的地址是v8+4*8 所以需要将v12 和 v13的值设为7 和 8 ；</p>
<p>按道理来说7和8的顺序没有关系，但是实际操作发现7和8的赋值顺序不一样，得到的flag是不一样的，只有把v12 = 7和 v13 = 8才可以得到正确的flag</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227122635003.png" alt="image-20220227122635003"></p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227122638492.png" alt="image-20220227122638492"></p>
<h4 id="使得func1的返回值为0"><a href="#使得func1的返回值为0" class="headerlink" title="使得func1的返回值为0"></a>使得func1的返回值为0</h4><p>运行func2时 v12=2  v13=3 ，所以函数之中进行运算的两个数字是v10和v11，v10的值是2 ，若想要这个函数的返回值是0，需要将v10置为-1 即0xffffffff</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227123021830.png" alt="image-20220227123021830"></p>
<h4 id="data文件的构造"><a href="#data文件的构造" class="headerlink" title="data文件的构造"></a>data文件的构造</h4><p>data数据传入的首地址是v7，因为没有设置传入数据的长度，所以可以传入无限制大小的数据，多出来的部分会对后面的数据进行覆盖，v7的长度是20 ，v10的位置是 20+2*4 = 28  v11的位置是 20+3*4=32  v12的位置是 20+4*4=36 v13的位置是 20+5*4=40 总的数据长度是44</p>
<p>用010构造数据，并且保存为data，和exe文件放到同一目录之下，运行程序</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227130028183.png" alt="image-20220227130028183"></p>
<p>运行的结果：</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227130059588.png" alt="image-20220227130059588"></p>
<p>所以得到的flag是</p>
<p>flag{8cda1bdb68a72a392a3968a71bdb8cda}</p>
<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。</p>
<p>实现栈溢出，要满足两个条件。第一，程序要有向栈内写入数据的行为；第二，程序并不限制写入数据的长度。如果想用栈溢出来执行攻击指令，就要在溢出数据内包含攻击指令的内容或地址，并且要将程序控制权交给该指令。攻击指令可以是自定义的指令片段，也可以利用系统内已有的函数及指令。</p>
</blockquote>
<h3 id="函数状态主要涉及三个寄存器-–-esp，ebp，eip"><a href="#函数状态主要涉及三个寄存器-–-esp，ebp，eip" class="headerlink" title="函数状态主要涉及三个寄存器 – esp，ebp，eip"></a>函数状态主要涉及三个寄存器 – esp，ebp，eip</h3><ul>
<li><p><code>esp</code>用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化</p>
</li>
<li><p><code>ebp</code>用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p>
</li>
<li><p><code>eip</code> 用来存储即将执行的程序指令的地址，cpu依照 eip的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p>
<p>使用这三个寄存器实现 将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。</p>
</li>
</ul>
<h3 id="栈溢出攻击"><a href="#栈溢出攻击" class="headerlink" title="栈溢出攻击"></a>栈溢出攻击</h3><blockquote>
<p>当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是<br>eip。所以我们的目标就是让 eip 载入攻击指令的地址。 首先，在退栈过程中，返回地址会被传给<br>eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。</p>
</blockquote>
<p>四种方法归类：</p>
<p>1.修改返回地址，让其指向溢出数据中的一段指令（shellcode） </p>
<p>2.修改返回地址，让其指向内存中已有的某个函数（return2libc）</p>
<p> 3.修改返回地址，让其指向内存中已有的一段指令（ROP） </p>
<p>4.修改某个被调用函数的地址，让其指向另一个函数（hijack GOT）</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227134449755.png" alt="image-20220227134449755"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>32位x86架构下的通用寄存器包括一般寄存器（eax、ebx、ecx、edx），索引寄存器（esi、edi），以及堆栈指针寄存器（esp、ebp）</p>
<ul>
<li><p>eax被称为累加寄存器（Accumulator），用以进行算数运算和返回函数结果等。</p>
</li>
<li><p>ebx被称为基址寄存器（Base），在内存寻址时（比如数组运算）用以存放基地址。</p>
</li>
<li><p>ecx被称为记数寄存器（Counter），用以在循环过程中记数。</p>
</li>
<li><p>edx 被称为数据寄存器（Data），常配合 eax 一起存放运算结果等数据。</p>
</li>
<li><p>esi 指向要处理的数据地址（Source Index）</p>
</li>
<li><p>edi指向存放处理结果的数据地址（Destination Index）</p>
</li>
</ul>
<p>参考文章： <a href="https://blog.csdn.net/weixin_43092232/article/details/96902468">https://blog.csdn.net/weixin_43092232/article/details/96902468</a></p>
]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>AntCTF &amp; Dˆ3CTF 2022（d3arm+d3w0w）</title>
    <url>/2022/03/10/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/</url>
    <content><![CDATA[<h1 id="AntCTF-amp-Dˆ3CTF-2022（d3arm-d3w0w）"><a href="#AntCTF-amp-Dˆ3CTF-2022（d3arm-d3w0w）" class="headerlink" title="AntCTF &amp; Dˆ3CTF 2022（d3arm+d3w0w）"></a>AntCTF &amp; Dˆ3CTF 2022（d3arm+d3w0w）</h1><h2 id="d3arm"><a href="#d3arm" class="headerlink" title="d3arm"></a>d3arm</h2><p>得到了一个bin的文件，如果想要得到代码需要将这个bin文件转化成hex文件，使用bintohex这个软件，得到hex文件，然后将这个hex文件载入到ida之中，将hex文件载入ida的时候需要设置一些参数，这个过程可以参考<a href="https://blog.csdn.net/daidi1989/article/details/86304843">这篇文章</a></p>
<p>将这个hex文件载入ida之中之后，查看字符串，根据图中标记的字符串跟进到关键代码的位置</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308212419039.png" alt="image-20220308212419039"></p>
<h3 id="关键主代码"><a href="#关键主代码" class="headerlink" title="关键主代码"></a>关键主代码</h3><p>图中标记的地方就是可能是flag的地方</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308212548857.png" alt="image-20220308212548857"></p>
<h3 id="引用了flag的函数"><a href="#引用了flag的函数" class="headerlink" title="引用了flag的函数"></a>引用了flag的函数</h3><p>在这个函数里面不能够得到什么数值的有效信息，所以查看引用该函数的其它函数，但是这里通过交叉函数我并不能找到有效的函数，翻看这个函数上下的函数，找到一个<strong>引用了point和flag地址的一个函数，将point作为下标，给flag进行赋值的操作</strong></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308214809866.png" alt="image-20220308214809866"></p>
<p>通过<strong>地址0x800DB64</strong>，在汇编代码的界面之宗，点击G 输入跳转到0x000DB64这个地址，就可以找到这个数组了</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308215223252.png" alt="image-20220308215223252"></p>
<p>这个数组是（上图之中只是部分的数据，一共要取42个数字）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x20,0x6d,0x50,0x30,0x38,0x48,0x20,0x6d,0x5,0x26,0x6d,0x56,0x72,0x6d,0x51,0x22,0x6c,0x4,0x70,0x38,0x0,0x26,0x6a,0x57,0x27,0x6a,0x57,0x74,0x6b,0xa,0x27,0x38,0x1,0x75,0x6a,0x5,0x27,0x68,0x3,0x26,0x3a,0x4e]</span><br></pre></td></tr></table></figure>

<h3 id="异或的对象MEMORY-0x20002314"><a href="#异或的对象MEMORY-0x20002314" class="headerlink" title="异或的对象MEMORY[0x20002314]"></a>异或的对象MEMORY[0x20002314]</h3><p>但是现在还不知道这个数组异或的对象MEMORY[0x20002314]的内容</p>
<p>找到和这个地址的数相关的函数，这个函数有对这个地址赋值的操作，其中的MEMORY[0x20002314] = 0x335E44u &gt;&gt; (8 * v1 &amp; 0xF8)这个式子中的v1来自于 MEMORY[0x2000326C] % 3，MEMORY[0x2000326C]和上一个函数相得知是数组的下标，异或的对象有3种0x44、0x5E、0x33,根据MEMORY[0x2000326C] % 3的结果作为下标来决定异或的对象</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308220048764.png" alt="image-20220308220048764"></p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [0x20,0x6d,0x50,0x30,0x38,0x48,0x20,0x6d,0x5,0x26,0x6d,0x56,0x72,0x6d,0x51,0x22,0x6c,0x4,0x70,0x38,0x0,0x26,0x6a,0x57,0x27,0x6a,0x57,0x74,0x6b,0xa,0x27,0x38,0x1,0x75,0x6a,0x5,0x27,0x68,0x3,0x26,0x3a,0x4e]</span><br><span class="line">key = 0x335E44</span><br><span class="line">for i in range(len(obj)):</span><br><span class="line">  temkey = (key&gt;&gt;((i%3)*8)) &amp; 0xff</span><br><span class="line">  print(chr(temkey^obj[i]),end=&#x27;&#x27;)</span><br><span class="line">d3ctf&#123;d36b3e63bf274f3b4dc4d059cf2146c60bd&#125;</span><br></pre></td></tr></table></figure>

<p>d3ctf{d36b3e63bf274f3b4dc4d059cf2146c60bd}</p>
<h2 id="d3w0w"><a href="#d3w0w" class="headerlink" title="d3w0w"></a>d3w0w</h2><p>使用32位的ida打开这个程序，通过程序之中的字符串定位到关键的代码</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309090157805.png" alt="image-20220309090157805"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309090254186.png" alt="image-20220309090254186"></p>
<p>分析代码显然我们需要使得这两个函数都能够返回0，这里我们得到的v3的结果就是0</p>
<h3 id="第一个函数-sub-401000-amp-v1-amp-unk-4262F8"><a href="#第一个函数-sub-401000-amp-v1-amp-unk-4262F8" class="headerlink" title="第一个函数 sub_401000(&amp;v1, &amp;unk_4262F8)"></a>第一个函数 sub_401000(&amp;v1, &amp;unk_4262F8)</h3><p>第一个函数 sub_401000(&amp;v1, &amp;unk_4262F8) 其中的v1代表我们输入的flag的值，这个flag里面有四种char 1，2，3，4，利用这个flag的字符串用走迷宫的形式给这个数组赋值</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309091251377.png" alt="image-20220309091251377"></p>
<h3 id="32位程序调用64位函数："><a href="#32位程序调用64位函数：" class="headerlink" title="32位程序调用64位函数："></a><a href="https://www.anquanke.com/post/id/171111">32位程序调用64位函数</a>：</h3><p>rewolf-wow64ext的目的就是让运行在Wow64环境中的x86应用程序可以直接调用x64下ntdll.dll中的Native API。</p>
<p> 进程的32位模式改为64位模式的具体代码：</p>
<p>主要方法是 借助retf将<strong>CS寄存器的值</strong>设置为<strong>0x33</strong>。</p>
<p>为什么要将CS寄存器的值设置为0x33？因为我们所需CPU的解码模式需要是<strong>64位模式</strong>，而当前模式是<strong>32位</strong>。64位CPU是通过GDT表中CS段所对应的表项中<strong>L标志位</strong>来确定当前<strong>解码模式</strong>的。</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309092835616.png" alt="image-20220309092835616"></p>
<p>在x64系统下的进程是有32位和64位两种工作模式，这两种工作模式的区别在于CS寄存器。<strong>32位模式</strong>时，<strong>CS = 0x23</strong>；<strong>64位模式</strong>时，<strong>CS = 0x33</strong>。</p>
<p>切换这两种工作模式的方法：</p>
<p>一般会通过retf指令，retf指令和 <strong>pop</strong> ip+<strong>pop</strong> cs 作用相同。如果此时栈中有0x33，则会将0x33弹出到CS寄存器中，实现32位程序切换到64位代码的过程</p>
<p>我们直接打开这个函数，不能够反编译，然后现在查看汇编代码，在程序的开头就调用了一个函数</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309092438231.png" alt="image-20220309092438231"></p>
<p>跟进到这个函数之中去，发现了和32需要调用64位函数的时候的中间代码相同的一段代码，这样我们就能知道这个地方的函数是64位的</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309092509334.png" alt="image-20220309092509334"></p>
<h3 id="第二个函数-sub-401220-amp-unk-4262F8"><a href="#第二个函数-sub-401220-amp-unk-4262F8" class="headerlink" title="第二个函数 sub_401220(&amp;unk_4262F8)"></a>第二个函数 sub_401220(&amp;unk_4262F8)</h3><p> 这个函数的参数就是在上一个函数赋值的数组，这个函数里面就是对这个赋值得到的数组进行一系列的限制，但是这个地方是一个32位的程序之中调用64位的函数，所以我们需要将这个函数dump出来，然后导入到ida64之中去反编译这个函数，但是这里的代码之中即有32位的代码又有64位的代码，这样做是不能通过这样的方法反编译出来的。</p>
<p>但是使用ida7.5反编译这个程序就能够得到这个函数的代码，但是这个代码之中会混杂着一些asm的汇编代码，需要我们仔细地分析这个代码。</p>
<p>这里面参杂着一些64位的汇编代码，它的代码意义在图中有标明进行注释</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310212725752.png" alt="image-20220310212725752"></p>
<h4 id="对迷宫的第一排-第一列-第六排-第六列的限制"><a href="#对迷宫的第一排-第一列-第六排-第六列的限制" class="headerlink" title="对迷宫的第一排 第一列 第六排 第六列的限制"></a>对迷宫的第一排 第一列 第六排 第六列的限制</h4><p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310212935273.png" alt="image-20220310212935273"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310212948727.png" alt="image-20220310212948727"></p>
<h4 id="第一种特殊点的限制"><a href="#第一种特殊点的限制" class="headerlink" title="第一种特殊点的限制"></a>第一种特殊点的限制</h4><p>限制1 ：不能同时含有 8 和 2 并且也不能同时含有4和1 所以有12、9、6、3这四种组合方式</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310213056630.png" alt="image-20220310213056630"></p>
<p>限制2 ：需要赋值两次</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215425865.png" alt="image-20220310215425865"></p>
<p>限制三  ：</p>
<p>如果当前的格子之中是8 则它的上一行的对应的格子就不能是8 </p>
<p>如果当前的格子之中是2 则它的下一行的对应的格子就不能是2</p>
<p>如果当前的格子之中是4 则它的上一格的对应的格子就不能是4</p>
<p>如果当前的格子之中是1 则它的上一行的对应的格子就不能是1</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215559291.png" alt="image-20220310215559291"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215603014.png" alt="image-20220310215603014"></p>
<h4 id="第二种特殊点的限制"><a href="#第二种特殊点的限制" class="headerlink" title="第二种特殊点的限制"></a>第二种特殊点的限制</h4><p>限制一 ：这十个坐标含有2和8的组合 或者 含有1和4的组合</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215808216.png" alt="image-20220310215808216"></p>
<p>限制二 ：</p>
<p>当<strong>本格是10</strong>时，上下两行之中一定要含有1或4</p>
<p>当<strong>本格是5</strong>时，左右两格之中一定要含有8或2</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220010868.png" alt="image-20220310220010868"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220052452.png" alt="image-20220310220052452"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220106999.png" alt="image-20220310220106999"></p>
<h4 id="对走的方向以及迷宫终点设置的代码"><a href="#对走的方向以及迷宫终点设置的代码" class="headerlink" title="对走的方向以及迷宫终点设置的代码"></a>对走的方向以及迷宫终点设置的代码</h4><p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220252666.png" alt="image-20220310220252666"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220335420.png" alt="image-20220310220335420"></p>
<h4 id="整理之后地代码"><a href="#整理之后地代码" class="headerlink" title="整理之后地代码"></a>整理之后地代码</h4><p>别人的wp之中找到对这部分代码的整理之后的结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">spoint1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  spoint1[<span class="number">1</span>] = <span class="number">14</span>;</span><br><span class="line">  spoint1[<span class="number">2</span>] = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//总体限制，不能撞墙，不能重复使用格子</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( table[<span class="number">6</span> * i + j] &gt; <span class="number">0xF</span>u )            <span class="comment">// 每一个格子都不能大于16</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      v14 = table[<span class="number">6</span> * i + j] % <span class="number">0x10</span>u / <span class="number">8</span>;</span><br><span class="line">      v22 = j;</span><br><span class="line">      v15 = table[<span class="number">6</span> * i + j] % <span class="number">8u</span> / <span class="number">4</span> + v14;</span><br><span class="line">      v23 = j;</span><br><span class="line">      v16 = table[<span class="number">6</span> * i + j] % <span class="number">4u</span> / <span class="number">2</span> + v15;</span><br><span class="line">      v24 = j;</span><br><span class="line">      <span class="keyword">if</span> ( table[<span class="number">6</span> * i + j] % <span class="number">2u</span> + v16 &gt; <span class="number">2</span> )    <span class="comment">// 计算二进制1的个数,也就是说每个格子不能被设置两次以上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( !j &amp;&amp; table[<span class="number">6</span> * i] % <span class="number">8u</span> / <span class="number">4</span> )        <span class="comment">// 6*6数组的第一列不能=4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( j == <span class="number">5</span> &amp;&amp; table[<span class="number">6</span> * i + <span class="number">5</span>] % <span class="number">2u</span> )    <span class="comment">// 最后一列不能=1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( !i &amp;&amp; table[j] % <span class="number">0x10</span>u / <span class="number">8</span> )         <span class="comment">// 第一行每一个都不能=8</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( i == <span class="number">5</span> &amp;&amp; table[j + <span class="number">30</span>] % <span class="number">4u</span> / <span class="number">2</span> )   <span class="comment">// 最后一行每一个都不能=2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第一种特殊点限制条件，这种特殊点周围不能连着出现两种操作，碰到必须拐弯</span></span><br><span class="line">  <span class="keyword">for</span> ( k = <span class="number">0</span>; (<span class="type">unsigned</span> __int64)k &lt; <span class="number">3</span>; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    row1 = spoint1[k] / <span class="number">10</span>;                     <span class="comment">// 0 1 2</span></span><br><span class="line">    col1 = spoint1[k] % <span class="number">10</span>;                     <span class="comment">// 0 4 0</span></span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">0x10</span>u / <span class="number">8</span> &amp;&amp; table[<span class="number">6</span> * row1 + col1] % <span class="number">4u</span> / <span class="number">2</span> )<span class="comment">// != 8 != 2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">8u</span> / <span class="number">4</span> &amp;&amp; table[<span class="number">6</span> * row1 + col1] % <span class="number">2u</span> )<span class="comment">// != 4 != 1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    v17 = table[<span class="number">6</span> * row1 + col1] % <span class="number">0x10</span>u / <span class="number">8</span>;</span><br><span class="line">    v25 = col1;</span><br><span class="line">    v18 = table[<span class="number">6</span> * row1 + col1] % <span class="number">4u</span> / <span class="number">2</span> + v17;</span><br><span class="line">    v26 = col1;</span><br><span class="line">    v19 = table[<span class="number">6</span> * row1 + col1] % <span class="number">2u</span> + v18;</span><br><span class="line">    v27 = col1;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">8u</span> / <span class="number">4</span> + v19 != <span class="number">2</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">0x10</span>u / <span class="number">8</span> )   <span class="comment">// 当前格子为8则判断上一行不能为8</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row1 - <span class="number">6</span> + col1] % <span class="number">0x10</span>u / <span class="number">8</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">4u</span> / <span class="number">2</span> ) <span class="comment">// 当前格子为2则判断下一行不能为2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row1 + <span class="number">6</span> + col1] % <span class="number">4u</span> / <span class="number">2</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">8u</span> / <span class="number">4</span> ) <span class="comment">// 当前格子为4则判断上一格不能为4</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row1 - <span class="number">1</span> + col1] % <span class="number">8u</span> / <span class="number">4</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">2u</span> &amp;&amp; !(table[<span class="number">6</span> * row1 + <span class="number">1</span> + col1] % <span class="number">2u</span>) )<span class="comment">// 当前格子为1则判断下一格不能为1</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第二种特殊点限制条件，必须直线进入，连续3格可连成直线，并且是拐弯进入前一格，或者进入后一格后拐弯</span></span><br><span class="line">  spoint2[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">  spoint2[<span class="number">1</span>] = <span class="number">13</span>;</span><br><span class="line">  spoint2[<span class="number">2</span>] = <span class="number">15</span>;</span><br><span class="line">  spoint2[<span class="number">3</span>] = <span class="number">21</span>;</span><br><span class="line">  spoint2[<span class="number">4</span>] = <span class="number">24</span>;</span><br><span class="line">  spoint2[<span class="number">5</span>] = <span class="number">31</span>;</span><br><span class="line">  spoint2[<span class="number">6</span>] = <span class="number">32</span>;</span><br><span class="line">  spoint2[<span class="number">7</span>] = <span class="number">41</span>;</span><br><span class="line">  spoint2[<span class="number">8</span>] = <span class="number">45</span>;</span><br><span class="line">  spoint2[<span class="number">9</span>] = <span class="number">53</span>;</span><br><span class="line">  <span class="keyword">for</span> ( l = <span class="number">0</span>; (<span class="type">unsigned</span> __int64)l &lt; <span class="number">0xA</span>; ++l )</span><br><span class="line">  &#123;</span><br><span class="line">    row2 = spoint2[l] / <span class="number">10</span>;</span><br><span class="line">    col2 = spoint2[l] % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (!(table[<span class="number">6</span> * row2 + col2] % <span class="number">0x10</span>u / <span class="number">8</span>) || !(table[<span class="number">6</span> * row2 + col2] % <span class="number">4u</span> / <span class="number">2</span>))<span class="comment">// 只有 28 或者14的组合</span></span><br><span class="line">      &amp;&amp; (!(table[<span class="number">6</span> * row2 + col2] % <span class="number">8u</span> / <span class="number">4</span>) || !(table[<span class="number">6</span> * row2 + col2] % <span class="number">2u</span>)) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row2 + col2] % <span class="number">0x10</span>u / <span class="number">8</span>     <span class="comment">// 28组合</span></span><br><span class="line">                                                <span class="comment">// 上一行 =4 =1或者</span></span><br><span class="line">                                                <span class="comment">// 下一行 =4 =1</span></span><br><span class="line">      &amp;&amp; table[<span class="number">6</span> * row2 + col2] % <span class="number">4u</span> / <span class="number">2</span></span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">6</span> + col2] % <span class="number">8u</span> / <span class="number">4</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">6</span> + col2] % <span class="number">2u</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">6</span> + col2] % <span class="number">8u</span> / <span class="number">4</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">6</span> + col2] % <span class="number">2u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row2 + col2] % <span class="number">8u</span> / <span class="number">4</span>        <span class="comment">// 14组合</span></span><br><span class="line">                                                <span class="comment">// 上一格 =2 =8或者</span></span><br><span class="line">                                                <span class="comment">// 下一格 =2 =8</span></span><br><span class="line">      &amp;&amp; table[<span class="number">6</span> * row2 + col2] % <span class="number">2u</span></span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">1</span> + col2] % <span class="number">0x10</span>u / <span class="number">8</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">1</span> + col2] % <span class="number">4u</span> / <span class="number">2</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">1</span> + col2] % <span class="number">0x10</span>u / <span class="number">8</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">1</span> + col2] % <span class="number">4u</span> / <span class="number">2</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//校验,使用数组的值移动点，最后能回到(0,0)点就是flag了</span></span><br><span class="line">    oldrow = <span class="number">0</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  row3 = <span class="number">0</span>;</span><br><span class="line">  col3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *table % <span class="number">0x10</span>u / <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    row3 = <span class="number">-1</span>;                                  <span class="comment">// 前一行</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">LABEL_79:</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">0x10</span>u / <span class="number">8</span>) || row3 - <span class="number">1</span> == oldrow &amp;&amp; col3 == v11 )<span class="comment">// 8则转到上一行</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">4u</span> / <span class="number">2</span>) || row3 + <span class="number">1</span> == oldrow &amp;&amp; col3 == v11 )<span class="comment">// 2</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">8u</span> / <span class="number">4</span>) || row3 == oldrow &amp;&amp; col3 - <span class="number">1</span> == v11 )<span class="comment">// 4</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">2u</span>) || row3 == oldrow &amp;&amp; col3 + <span class="number">1</span> == v11 )<span class="comment">// 1</span></span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">            oldrow = row3;</span><br><span class="line">            v11 = col3++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            oldrow = row3;</span><br><span class="line">            v11 = col3--;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          oldrow = row3;</span><br><span class="line">          v11 = col3;</span><br><span class="line">          ++row3;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        oldrow = row3;</span><br><span class="line">        v11 = col3;</span><br><span class="line">        --row3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( row3 || col3 );</span><br><span class="line">    result = <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *table % <span class="number">4u</span> / <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      row3 = <span class="number">1</span>;                                 <span class="comment">// 后一行</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_79;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *table % <span class="number">8u</span> / <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      col3 = <span class="number">-1</span>;                                <span class="comment">// 前一格</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_79;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *table % <span class="number">2u</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      col3 = <span class="number">1</span>;                                 <span class="comment">// 后一格</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_79;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">1</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h4 id="总结第二个函数中对迷宫的限制"><a href="#总结第二个函数中对迷宫的限制" class="headerlink" title="总结第二个函数中对迷宫的限制"></a>总结第二个函数中对迷宫的限制</h4><ol>
<li><p>通过<strong>第一个函数</strong>我们可以知道每当一个格子被设置值（方向）的时候，它所到达的下一个格子也会被设置一个值（方向），下一个格子的值（方向）是和当前格子相反的方向，也就是下一个格子含有指向当前格子的方向，所以迷宫走的路径是<strong>双向设置的</strong>（每一步都是双向的），既能够正着走，也能够反着走，在特殊点的性质设置的时候也会利用到这个迷宫设置的这个特点。</p>
</li>
<li><p>这个迷宫中的数据都要被设置两次</p>
</li>
<li><p>迷宫的第一列不能是4</p>
</li>
</ol>
<p>​       迷宫的第六列不能是1</p>
<p>​       迷宫的第一排不能是8</p>
<p>​       迷宫的第六排不能是2</p>
<ol start="4">
<li>对坐标为（0,0）（1,4）（2,0）的限制（坐标的第一个是行第二个是列）</li>
</ol>
<ul>
<li>这个单元格中不能同时含有 8 和 2 并且也不能同时含有4和1</li>
<li>需要被赋值两次（采用和开头相同的检验是否被赋值了两次以上的检验方法）</li>
<li>如果当前的格子之中是8 则它的上一行的对应的格子就不能是8</li>
<li>如果当前的格子之中是2 则它的下一行的对应的格子就不能是2</li>
<li>如果当前的格子之中是4 则它的上一格的对应的格子就不能是4</li>
<li>如果当前的格子之中是1 则它的上一行的对应的格子就不能是1</li>
<li>这种特殊点周围不能连着出现两种操作，<strong>碰到必须拐弯</strong>。<ul>
<li>它自身就必须含有<strong>水平和竖直</strong>方向的移动<strong>各一种</strong></li>
<li>这种特殊节点需要<strong>连接两个格子</strong>（通过自己有的两个方向能够到达这两个格子），所以这两个格子需要分别存在于它的<strong>水平和竖直方向</strong>上，那么在这个节点必定要<strong>转弯</strong></li>
</ul>
</li>
</ul>
<ol start="5">
<li>对坐标(0,4) (1,3) (1,5) (2,1) (2,4) (3,1) (3,2) (4,1) (4,5) (5,3)的限制</li>
</ol>
<ul>
<li>这十个坐标含有2和8的组合 或者 含有1和4的组合（因为在程序的最开始就标注了每个格子被设置的次数不能超过2次，所以这10个坐标的设置只能是这两种组合种的一种，也就是这10个格子的数值只能是10或者5）</li>
<li>当<strong>本格是10</strong>时，上下两行之中一定要含有1或4（在本格之中即能向上走也能向下走）</li>
<li>当<strong>本格是5</strong>时，左右两格之中一定要含有8或2（在本格之中既能向左走也能向右走）</li>
<li>第二种特殊点限制条件，必须直线进入，<strong>连续3格可连成直线</strong>，并且是<strong>拐弯进入前一格</strong>，或者进入<strong>后一格后拐弯</strong>。<ul>
<li>这种特殊点需要能够到达它的<strong>前后两个节点</strong>（连接两个格子），但是它自己本身这个格子之中方向的定义只有<strong>一种类型</strong>（竖直方向的 或者 水平方向的）。所以它的前后两个格子和它自身必须在<strong>同一条直线</strong>上，那么这样就使得进入这个格子的方向，就是这个格子所具有的方向（水平还是竖直）。</li>
<li>因为第二三个条件的限制使得，它连接的两个格子之中会有转弯的方向，如果是它的前一个格子含有转弯的方向，说明是<strong>拐弯进入前一格</strong>的。如果它的后一个格子含有转弯的方向，说明<strong>进入后一格后拐弯</strong>。</li>
</ul>
</li>
</ul>
<ol start="6">
<li>走迷宫的规则和操作：</li>
</ol>
<ul>
<li>8是向上走 2是向下走 4是向左走 1是向右走（判断的顺序是8 2 4 1）</li>
<li>不能再回到上一格的位置</li>
<li>走到终点的位置是 （0，0）</li>
</ul>
<h3 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h3><p>使用#标注第一种类型的特殊点 使用$来标注第二种特殊类型的点 从上一个函数我们可以知道第一个位置固定是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0  1  2  3  4  5 </span><br><span class="line">0 #3 05 05 05 $5 06  </span><br><span class="line">1 0A 0  03 $5 #4 $A</span><br><span class="line">2 #9 $5 0C 0  $A 0A</span><br><span class="line">3 03 $5 $5 06 0A 0A</span><br><span class="line">4 09 $5 06 09 0C $A</span><br><span class="line">5 0  0  09 $5 05 0C</span><br><span class="line"></span><br><span class="line">[3, 5, 5, 5, 5, 6] </span><br><span class="line">[A, 0, 3, 5, 6, A] </span><br><span class="line">[9, 5, C, 0, A, A] </span><br><span class="line">[3, 5, 5, 6, A, A] </span><br><span class="line">[9, 5, 6, 9, C, A] </span><br><span class="line">[0, 0, 9, 5, 5, C]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">idx</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">#↓</td>
<td align="left">←</td>
<td align="left">←</td>
<td align="left">←</td>
<td align="left">*←</td>
<td align="left">←</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">↓</td>
<td align="left">0</td>
<td align="left">→</td>
<td align="left">*→</td>
<td align="left">#↓</td>
<td align="left">*↑</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">#→</td>
<td align="left">*→</td>
<td align="left">↑</td>
<td align="left">0</td>
<td align="left">*↓</td>
<td align="left">↑</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">↓</td>
<td align="left">*←</td>
<td align="left">*←</td>
<td align="left">←</td>
<td align="left">↓</td>
<td align="left">↑</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">→</td>
<td align="left">*→</td>
<td align="left">↓</td>
<td align="left">↑</td>
<td align="left">←</td>
<td align="left">*↑</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">→</td>
<td align="left">*→</td>
<td align="left">→</td>
<td align="left">↑</td>
</tr>
</tbody></table>
<p>上面这个是走迷宫的过程，得到的按着这个方向正着走到最后之后再按着同样的路线反着走一次就能够得到这个目标的6*6的map了</p>
<p>按照第一个函数的赋值的方式就能够得到这个过程是 d3ctf{22441442223133324424441111133333}</p>
<p>所以最后得到的flag是 d3ctf{22441442223133324424441111133333}</p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>迷宫</tag>
        <tag>binToHex</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF_Login</title>
    <url>/2022/04/21/DASCTF-Login/</url>
    <content><![CDATA[<h2 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h2><p>这道题里面给了两个文件，一个作为了客户端，一个作为服务器，两个程序之间相互传输数据，对登录的token、password以及verify这三个数进行了验证。</p>
<p>验证的主逻辑是在check程序之中，这里有三中加密（RSA、Hill、AES），这次的AES进行了魔改，解密的脚本不得不自己来码代码！！</p>
<h3 id="两个程序的交互"><a href="#两个程序的交互" class="headerlink" title="两个程序的交互"></a>两个程序的交互</h3><p>提供了两个文件，一个文佳时客户端界面，一个时服务器界面，要实现两个页面的交互</p>
<p>打开的是两个程序，一个程序作为的是客户端（login），一个作为的是服务器（check）</p>
<p>在这两个程序之中找到start函数，然后打开第一个参数，就是main函数</p>
<p><img src="/images/DASCTF-Login/image-20220418182800620.png" alt="image-20220418182800620"></p>
<p>login程序：</p>
<ul>
<li>和服务器进行一系列的交互</li>
<li>一个while循环向服务器发送和接受消息</li>
<li>其中的if语句会根据接受到的参数，来做出特定的反应</li>
</ul>
<p>连接服务器：</p>
<p><img src="/images/DASCTF-Login/image-20220418185651992.png" alt="image-20220418185651992"></p>
<p>客户端和服务器间的交互：</p>
<p><img src="/images/DASCTF-Login/image-20220418190656569.png" alt="image-20220418190656569"></p>
<p>if语句发送数据：</p>
<p><img src="/images/DASCTF-Login/image-20220418184030804.png" alt="image-20220418184030804"><img src="/images/DASCTF-Login/image-20220418184014037.png" alt="image-20220418184014037"></p>
<p>客户端：</p>
<p>连接客户端：</p>
<p><img src="/images/DASCTF-Login/image-20220418185943841.png" alt="image-20220418185943841"></p>
<p>进入main函数之中，和客户端进行交互，验证三个数据</p>
<p><img src="/images/DASCTF-Login/image-20220418232408361.png" alt="image-20220418232408361"></p>
<h3 id="rsa解密"><a href="#rsa解密" class="headerlink" title="rsa解密"></a>rsa解密</h3><p>大素数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13123058934861171416713230498081453101147538789122070079961388806126697916963123413431108069961369055630747412550900239402710827847917960870358653962948282381351741121884528399369764530446509936240262290248305226552117100584726616255292963971141510518678552679033220315246377746270515853987903184512948801397452104554589803725619076066339968999308910127885089547678968793196148780382182445270838659078189316664538631875879022325427220682805580410213245364855569367702919157881367085677283124732874621569379901272662162025780608669577546548333274766058755786449491277002349918598971841605936268030140638579388226573929</span><br></pre></td></tr></table></figure>

<p>分解的质数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = 98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033</span><br><span class="line">q = 133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513</span><br><span class="line">e = 0x10001</span><br></pre></td></tr></table></figure>

<p>密文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c = 0x2e7469206873696c6f70206577206e6f697461737265766e6f63207962202c646e696d2065687420686369726e6520657720676e6964616572207942</span><br></pre></td></tr></table></figure>

<p>解密脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Decrypt</span>(<span class="params">c,e,p,q</span>):</span><br><span class="line">    L = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    d = gmpy2.invert(e,L)</span><br><span class="line">    n = p * q</span><br><span class="line">    m = gmpy2.powmod(c, d, n)</span><br><span class="line">    flag = <span class="built_in">str</span>(m)</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">p = <span class="number">98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033</span></span><br><span class="line">q = <span class="number">133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="number">0x2e7469206873696c6f70206577206e6f697461737265766e6f63207962202c646e696d2065687420686369726e6520657720676e6964616572207942</span></span><br><span class="line">Decrypt(c,e,p,q)</span><br></pre></td></tr></table></figure>

<p>明文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">token = 11963777321199993924175387978397443935563034091716786597947508874393819454915798980986262132792605021295930274531653741552766395859285325677395421549163602968276475448835066393456449574469736327622969755801884982386140722904578598391534204834007447860153096480268812700725451958035204357033892179559153729604237187552716580637492579876006993181920209114166153317182827927606249871955662032809256743464460825303610341043145126848787575238499023185150429072724679210155061579052743238859739734301162335989939278904459012917375108407803445722785027315562371588439877746983153339473213449448259686486917983129418859935686</span><br></pre></td></tr></table></figure>

<h3 id="hill解密"><a href="#hill解密" class="headerlink" title="hill解密"></a>hill解密</h3><p>密钥矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xA34C0F7A2E25DB71,0x7AA91B6E29AA226A,0x56AA0EF0802F278A,0x9AF6F2A9005859F7,0xC9481C4E</span><br><span class="line">形成6*6的矩阵 (GF(257))</span><br><span class="line">0x71,0xdb,0x25,0x2e,0x7a,0x0f</span><br><span class="line">0x4c,0xa3,0x6a,0x22,0xaa,0x29</span><br><span class="line">0x6e,0x1b,0xa9,0x7a,0x8a,0x27</span><br><span class="line">0x2f,0x80,0xf0,0x0e,0xaa,0x56</span><br><span class="line">0xf7,0x59,0x58,0x00,0xa9,0xf2</span><br><span class="line">0xf6,0x9a,0x4e,0x1c,0x48,0xc9</span><br><span class="line">[[0x71,0xdb,0x25,0x2e,0x7a,0x0f],[0x4c,0xa3,0x6a,0x22,0xaa,0x29],[0x6e,0x1b,0xa9,0x7a,0x8a,0x27],[0x2f,0x80,0xf0,0x0e,0xaa,0x56],[0xf7,0x59,0x58,0x00,0xa9,0xf2],[0xf6,0x9a,0x4e,0x1c,0x48,0xc9]]</span><br></pre></td></tr></table></figure>

<p>密文随机数（GF(255)）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1804289383,846930886,1681692777,1714636915,1957747793,424238335,719885386,1649760492,596516649,1189641421,1025202362,1350490027,783368690,1102520059,2044897763,1967513926,1365180540,1540383426,304089172,1303455736,35005211,521595368,294702567,1726956429,336465782,861021530,278722862,233665123,2145174067,468703135,1101513929,1801979802,1315634022,635723058,1369133069,1125898167,1059961393,2089018456,628175011,1656478042,1131176229,1653377373,859484421,1914544919,608413784,756898537,1734575198,1973594324,149798315,2038664370,1129566413,184803526,412776091,1424268980,1911759956,749241873,137806862,42999170,982906996,135497281,511702305,2084420925,1937477084,1827336327,572660336,1159126505,805750846,1632621729,1100661313,1433925857,1141616124,84353895,939819582,2001100545,1998898814,1548233367,610515434,1585990364,1374344043,760313750,1477171087,356426808,945117276,1889947178,1780695788,709393584,491705403,1918502651,752392754,1474612399,2053999932,1264095060,1411549676,1843993368,943947739,1984210012,855636226,1749698586,1469348094,1956297539</span><br></pre></td></tr></table></figure>

<p>密文矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[0xa3,0x97,0xa2,0x55,0x53,0xbe],[0xf1,0xfc,0xf9,0x79,0x6b,0x52],[0x14,0x13,0xe9,0xe2,0x2d,0x51],[0x8e,0x1f,0x56,0x08,0x57,0x27],[0xa7,0x05,0xd4,0xd0,0x52,0x82],[0x77,0x75,0x1b,0x99,0x4a,0xed]]</span><br></pre></td></tr></table></figure>

<p>使用sage解矩阵的乘法运算</p>
<p>问题：这个函数的作用为什么是将输入的password（明文）转换成array形式</p>
<p><img src="/images/DASCTF-Login/image-20220419214617366.png" alt="image-20220419214617366"></p>
<p>计算得到数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 81  50 210   2 195  45]</span><br><span class="line">[149 185 249 120 213  20]</span><br><span class="line">[227  41  66  32  81  59]</span><br><span class="line">[ 21  98  52 130 180 192]</span><br><span class="line">[ 46 154 253 232 186 213]</span><br><span class="line">[236   7  72 106  84 136]</span><br><span class="line">所以password是：5132d202c32d95b9f978d514e3294220513b15623482b4c02e9afde8bad5ec07486a5488</span><br></pre></td></tr></table></figure>

<p>将上面的token和login的数据输入之后登录成功：</p>
<p><img src="/images/DASCTF-Login/image-20220419225219658.png" alt="image-20220419225219658"></p>
<h3 id="运行调试两个程序"><a href="#运行调试两个程序" class="headerlink" title="运行调试两个程序"></a>运行调试两个程序</h3><p>如果需要动调：</p>
<p>ida之中动调的对象是服务器端口：</p>
<p>在Linux之中 使用./linux_server64 -p 1234 监听1234端口</p>
<p>在ida之中设置的端口号也应该是1234</p>
<p><img src="/images/DASCTF-Login/image-20220419225918050.png" alt="image-20220419225918050"></p>
<p>在Linux之中运行一下这两个程序</p>
<p>先将服务端运行起来 ./check</p>
<p>然后将客户端运行起来 ./login 127.0.0.1     // 因为服务端是在本地运行的，所以ip address 就是127.0.0.1</p>
<p>客户端需要输入ip address</p>
<p><img src="/images/DASCTF-Login/image-20220419224934834.png" alt="image-20220419224934834"></p>
<p><img src="/images/DASCTF-Login/image-20220419225000482.png" alt="image-20220419225000482"></p>
<h3 id="AES解密"><a href="#AES解密" class="headerlink" title="AES解密"></a>AES解密</h3><p><a href="https://blog.csdn.net/qq_28205153/article/details/55798628?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164903726916781685316114%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164903726916781685316114&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-55798628.142%5Ev5%5Earticle_score_rank,157%5Ev4%5Econtrol&utm_term=AES&spm=1018.2226.3001.4187">常规AES加密解密</a></p>
<p>魔改的部分：</p>
<ul>
<li>S盒子和逆S盒交换着使用了</li>
<li>密钥扩展中异或的部分魔改了</li>
<li>在进入加密器之前进行了和IV向量的异或运算</li>
</ul>
<p>这里面数据提取和处理的方法也要注意</p>
<h4 id="S盒"><a href="#S盒" class="headerlink" title="S盒"></a>S盒</h4><p>S盒的生成：S盒的大小规格是16*16 = 256的</p>
<p>客户端接受到的数据是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">52096ad53036a538bf40a39e81f3d7fb7ce339829b2fff87348e4344c4dee9cb547b9432a6c2233dee4c950b42fac34e082ea16628d924b2765ba2496d8bd12572f8f66486689816d4a45ccc5d65b6926c704850fdedb9da5e154657a78d9d8490d8ab008cbcd30af7e45805b8b34506d02c1e8fca3f0f02c1afbd0301138a6b3a9111414f67dcea97f2cfcef0b4e67396ac7422e7ad3585e2f937e81c75df6e47f11a711d29c5896fb7620eaa18be1bfc563e4bc6d279209adbc0fe78cd5af41fdda8338807c731b11210592780ec5f60517fa919b54a0d2de57a9f93c99cefa0e03b4dae2af5b0c8ebbb3c83539961172b047eba77d626e169146355210c7d</span><br></pre></td></tr></table></figure>

<p>利用接受到的数据生成S盒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d</span><br></pre></td></tr></table></figure>

<h4 id="pass-token的获取"><a href="#pass-token的获取" class="headerlink" title="pass_token的获取"></a>pass_token的获取</h4><p><img src="/images/DASCTF-Login/image-20220420162301465.png" alt="image-20220420162301465"></p>
<p>token的数组数据：（按照char的类型来取值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">token = &quot;11963777321199993924175387978397443935563034091716786597947508874393819454915798980986262132792605021295930274531653741552766395859285325677395421549163602968276475448835066393456449574469736327622969755801884982386140722904578598391534204834007447860153096480268812700725451958035204357033892179559153729604237187552716580637492579876006993181920209114166153317182827927606249871955662032809256743464460825303610341043145126848787575238499023185150429072724679210155061579052743238859739734301162335989939278904459012917375108407803445722785027315562371588439877746983153339473213449448259686486917983129418859935686&quot;</span><br></pre></td></tr></table></figure>

<p>pass的数组数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x51,0x32,0xd2,0x02,0xc3,0x2d,0x95,0xb9,0xf9,0x78,0xd5,0x14,0xe3,0x29,0x42,0x20,0x51,0x3b,0x15,0x62,0x34,0x82,0xb4,0xc0,0x2e,0x9a,0xfd,0xe8,0xba,0xd5,0xec,0x07,0x48,0x6a,0x54,0x88</span><br></pre></td></tr></table></figure>

<p>随机数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1804289383,846930886,1681692777,1714636915,1957747793,424238335,719885386,1649760492,596516649,1189641421,1025202362,1350490027,783368690,1102520059,2044897763,1967513926,1365180540,1540383426,304089172,1303455736,35005211,521595368,294702567,1726956429,336465782,861021530,278722862,233665123,2145174067,468703135,1101513929,1801979802,1315634022,635723058,1369133069,1125898167,1059961393,2089018456,628175011,1656478042,1131176229,1653377373,859484421,1914544919,608413784,756898537,1734575198,1973594324,149798315,2038664370,1129566413,184803526,412776091,1424268980,1911759956,749241873,137806862,42999170,982906996,135497281,511702305,2084420925,1937477084,1827336327,572660336,1159126505,805750846,1632621729,1100661313,1433925857,1141616124,84353895,939819582,2001100545,1998898814,1548233367,610515434,1585990364,1374344043,760313750,1477171087,356426808,945117276,1889947178,1780695788,709393584,491705403,1918502651,752392754,1474612399,2053999932,1264095060,1411549676,1843993368,943947739,1984210012,855636226,1749698586,1469348094,1956297539</span><br></pre></td></tr></table></figure>

<p>生成pass_token:（IV和密钥）这里的随机数使用的是第36个随机数之后的数，因为在程序的前面生成过一次36个随机数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">token = <span class="string">&quot;11963777321199993924175387978397443935563034091716786597947508874393819454915798980986262132792605021295930274531653741552766395859285325677395421549163602968276475448835066393456449574469736327622969755801884982386140722904578598391534204834007447860153096480268812700725451958035204357033892179559153729604237187552716580637492579876006993181920209114166153317182827927606249871955662032809256743464460825303610341043145126848787575238499023185150429072724679210155061579052743238859739734301162335989939278904459012917375108407803445722785027315562371588439877746983153339473213449448259686486917983129418859935686&quot;</span></span><br><span class="line">password = [<span class="number">0x51</span>,<span class="number">0x32</span>,<span class="number">0xd2</span>,<span class="number">0x02</span>,<span class="number">0xc3</span>,<span class="number">0x2d</span>,<span class="number">0x95</span>,<span class="number">0xb9</span>,<span class="number">0xf9</span>,<span class="number">0x78</span>,<span class="number">0xd5</span>,<span class="number">0x14</span>,<span class="number">0xe3</span>,<span class="number">0x29</span>,<span class="number">0x42</span>,<span class="number">0x20</span>,<span class="number">0x51</span>,<span class="number">0x3b</span>,<span class="number">0x15</span>,<span class="number">0x62</span>,<span class="number">0x34</span>,<span class="number">0x82</span>,<span class="number">0xb4</span>,<span class="number">0xc0</span>,<span class="number">0x2e</span>,<span class="number">0x9a</span>,<span class="number">0xfd</span>,<span class="number">0xe8</span>,<span class="number">0xba</span>,<span class="number">0xd5</span>,<span class="number">0xec</span>,<span class="number">0x07</span>,<span class="number">0x48</span>,<span class="number">0x6a</span>,<span class="number">0x54</span>,<span class="number">0x88</span>]</span><br><span class="line">random = [<span class="number">1804289383</span>,<span class="number">846930886</span>,<span class="number">1681692777</span>,<span class="number">1714636915</span>,<span class="number">1957747793</span>,<span class="number">424238335</span>,<span class="number">719885386</span>,<span class="number">1649760492</span>,<span class="number">596516649</span>,<span class="number">1189641421</span>,<span class="number">1025202362</span>,<span class="number">1350490027</span>,<span class="number">783368690</span>,<span class="number">1102520059</span>,<span class="number">2044897763</span>,<span class="number">1967513926</span>,<span class="number">1365180540</span>,<span class="number">1540383426</span>,<span class="number">304089172</span>,<span class="number">1303455736</span>,<span class="number">35005211</span>,<span class="number">521595368</span>,<span class="number">294702567</span>,<span class="number">1726956429</span>,<span class="number">336465782</span>,<span class="number">861021530</span>,<span class="number">278722862</span>,<span class="number">233665123</span>,<span class="number">2145174067</span>,<span class="number">468703135</span>,<span class="number">1101513929</span>,<span class="number">1801979802</span>,<span class="number">1315634022</span>,<span class="number">635723058</span>,<span class="number">1369133069</span>,<span class="number">1125898167</span>,<span class="number">1059961393</span>,<span class="number">2089018456</span>,<span class="number">628175011</span>,<span class="number">1656478042</span>,<span class="number">1131176229</span>,<span class="number">1653377373</span>,<span class="number">859484421</span>,<span class="number">1914544919</span>,<span class="number">608413784</span>,<span class="number">756898537</span>,<span class="number">1734575198</span>,<span class="number">1973594324</span>,<span class="number">149798315</span>,<span class="number">2038664370</span>,<span class="number">1129566413</span>,<span class="number">184803526</span>,<span class="number">412776091</span>,<span class="number">1424268980</span>,<span class="number">1911759956</span>,<span class="number">749241873</span>,<span class="number">137806862</span>,<span class="number">42999170</span>,<span class="number">982906996</span>,<span class="number">135497281</span>,<span class="number">511702305</span>,<span class="number">2084420925</span>,<span class="number">1937477084</span>,<span class="number">1827336327</span>,<span class="number">572660336</span>,<span class="number">1159126505</span>,<span class="number">805750846</span>,<span class="number">1632621729</span>,<span class="number">1100661313</span>,<span class="number">1433925857</span>,<span class="number">1141616124</span>,<span class="number">84353895</span>,<span class="number">939819582</span>,<span class="number">2001100545</span>,<span class="number">1998898814</span>,<span class="number">1548233367</span>,<span class="number">610515434</span>,<span class="number">1585990364</span>,<span class="number">1374344043</span>,<span class="number">760313750</span>,<span class="number">1477171087</span>,<span class="number">356426808</span>,<span class="number">945117276</span>,<span class="number">1889947178</span>,<span class="number">1780695788</span>,<span class="number">709393584</span>,<span class="number">491705403</span>,<span class="number">1918502651</span>,<span class="number">752392754</span>,<span class="number">1474612399</span>,<span class="number">2053999932</span>,<span class="number">1264095060</span>,<span class="number">1411549676</span>,<span class="number">1843993368</span>,<span class="number">943947739</span>,<span class="number">1984210012</span>,<span class="number">855636226</span>,<span class="number">1749698586</span>,<span class="number">1469348094</span>,<span class="number">1956297539</span>]</span><br><span class="line">token_pass=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>):</span><br><span class="line">    <span class="keyword">if</span> i&amp;<span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">        token_pass.append(<span class="built_in">ord</span>(token[random[i+<span class="number">36</span>]%<span class="built_in">len</span>(token)]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        token_pass.append(password[random[i+<span class="number">36</span>]%<span class="built_in">len</span>(password)])</span><br><span class="line"><span class="built_in">print</span>(token_pass)</span><br><span class="line">token_pass = [<span class="number">50</span>, <span class="number">48</span>, <span class="number">7</span>, <span class="number">54</span>, <span class="number">106</span>, <span class="number">55</span>, <span class="number">120</span>, <span class="number">49</span>, <span class="number">72</span>, <span class="number">57</span>, <span class="number">66</span>, <span class="number">57</span>, <span class="number">20</span>, <span class="number">49</span>, <span class="number">213</span>, <span class="number">50</span>, <span class="number">98</span>, <span class="number">54</span>, <span class="number">249</span>, <span class="number">56</span>, <span class="number">66</span>, <span class="number">48</span>, <span class="number">195</span>, <span class="number">49</span>, <span class="number">106</span>, <span class="number">53</span>, <span class="number">72</span>, <span class="number">56</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">84</span>, <span class="number">52</span>, <span class="number">41</span>, <span class="number">52</span>, <span class="number">81</span>, <span class="number">54</span>, <span class="number">21</span>, <span class="number">57</span>, <span class="number">210</span>, <span class="number">56</span>, <span class="number">210</span>, <span class="number">57</span>, <span class="number">32</span>, <span class="number">49</span>, <span class="number">185</span>, <span class="number">50</span>, <span class="number">46</span>, <span class="number">48</span>]</span><br></pre></td></tr></table></figure>

<h4 id="密钥扩展和逆S盒"><a href="#密钥扩展和逆S盒" class="headerlink" title="密钥扩展和逆S盒"></a>密钥扩展和逆S盒</h4><p>这里和常规的AES的密钥扩展是进行了魔改的(对比常规的AES加密的代码就能知道，密钥扩展这部分的代码需要自己写)</p>
<p>生成SBox的逆矩阵：</p>
<p><img src="/images/DASCTF-Login/image-20220420163223716.png" alt="image-20220420163223716"></p>
<p><img src="/images/DASCTF-Login/image-20220421131943315.png" alt="image-20220421131943315"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revSBox = [</span><br><span class="line">0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,</span><br><span class="line">0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,</span><br><span class="line">0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,</span><br><span class="line">0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,</span><br><span class="line">0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,</span><br><span class="line">0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,</span><br><span class="line">0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,</span><br><span class="line">0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,</span><br><span class="line">0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,</span><br><span class="line">0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,</span><br><span class="line">0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,</span><br><span class="line">0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,</span><br><span class="line">0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,</span><br><span class="line">0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,</span><br><span class="line">0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,</span><br><span class="line">0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行密钥扩展</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expandKeyNums</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 进行密钥扩展</span></span><br><span class="line">    <span class="type">uint8_t</span> v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> v11 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> v12 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> j =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化前16个字节 4列中的元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        roundKey[i*<span class="number">4</span>] = pass_token[i*<span class="number">4</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">1</span>] = pass_token[i*<span class="number">4</span>+<span class="number">1</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">2</span>] = pass_token[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">3</span>] = pass_token[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">4</span>;i&lt;<span class="number">44</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v9 = roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)];</span><br><span class="line">        v10 = roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)+<span class="number">1</span>];</span><br><span class="line">        v11 = roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)+<span class="number">2</span>];</span><br><span class="line">        v12 = roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> ((i&amp;<span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v10 = revSBox[v11];</span><br><span class="line">            v11 = revSBox[v12];</span><br><span class="line">            v12 = revSBox[roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)]];</span><br><span class="line">            v9 = revSBox[roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)+<span class="number">1</span>]] ^ para[i&gt;&gt;<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        roundKey[i*<span class="number">4</span>] = v9^roundKey[(i<span class="number">-4</span>)*<span class="number">4</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">1</span>] = v10^roundKey[(i<span class="number">-4</span>)*<span class="number">4</span>+<span class="number">1</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">2</span>] = v11^roundKey[(i<span class="number">-4</span>)*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">3</span>] = v12^roundKey[(i<span class="number">-4</span>)*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CBC模式的初始化向量的IV"><a href="#CBC模式的初始化向量的IV" class="headerlink" title="CBC模式的初始化向量的IV"></a>CBC模式的初始化向量的IV</h4><p>作为IV的pass_token的后16*2个字节，每次使用16个字节</p>
<p><img src="/images/DASCTF-Login/image-20220421132904388.png" alt="image-20220421132904388"></p>
<img src="/images/DASCTF-Login/image-20220420224347131.png" alt="image-20220420224347131" style="zoom:50%;" />

<p>密文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c =&#123;0xfe,0xf9,0xe7,0x3e,0xf6,0xa1,0x23,0xcc,0x57,0x61,0xc1,0x15,0x77,0xfb,0x9c,0xbb,0xca,0x2f,0xb1,0xe8,0x4f,0xd9,0x07,0xd8,0x0c,0x6b,0xea,0xcf,0xe8,0x42,0xa2,0xfa&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 加密过程第一步的异或运算(但是里面的数据还需要思考一下) 传入的参数是数据加密的轮数</span><br><span class="line">void XorIV(uint8_t round)</span><br><span class="line">&#123;</span><br><span class="line">        for(int i=0;i&lt;=15;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        verify[i]^=pass_token[16*round+16+i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AES加密的主逻辑"><a href="#AES加密的主逻辑" class="headerlink" title="AES加密的主逻辑"></a>AES加密的主逻辑</h4><p><img src="/images/DASCTF-Login/image-20220421133028414.png" alt="image-20220421133028414"></p>
<h4 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h4><p>这里用的S盒是revDate（SBox）</p>
<p><img src="/images/DASCTF-Login/image-20220420175507903.png" alt="image-20220420175507903"></p>
<p>逆字节代换（要用revSBox）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 逆字节代换()</span><br><span class="line">void reveSubBytes()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0; i&lt;16; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        verify[i] = revSBox[verify[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h4><p>行移位操作：</p>
<p><img src="/images/DASCTF-Login/image-20220420180004983.png" alt="image-20220420180004983"></p>
<p>行移位的逆运算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 行移位的逆运算 第一行不移动 第二行循环右移1位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reveShiftRows</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> round = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> tem = <span class="number">0</span>;<span class="comment">//临时存放值</span></span><br><span class="line">    <span class="type">int</span> j =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        round = i;</span><br><span class="line">        <span class="keyword">while</span>(round)</span><br><span class="line">        &#123;</span><br><span class="line">            tem = verify[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">3</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                verify[i*<span class="number">4</span>+j] = verify[i*<span class="number">4</span>+j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            verify[i*<span class="number">4</span>+j] = tem;</span><br><span class="line">            round--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h4><p>列混合：</p>
<p><img src="/images/DASCTF-Login/image-20220420185629111.png" alt="image-20220420185629111"></p>
<p>用到的矩阵（4*4）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x02, 0x03, 0x01, 0x01, </span><br><span class="line">0x01, 0x02, 0x03, 0x01, </span><br><span class="line">0x01, 0x01, 0x02, 0x03, </span><br><span class="line">0x03, 0x01, 0x01, 0x02,</span><br></pre></td></tr></table></figure>

<p>GF之中的运算：</p>
<p><img src="/images/DASCTF-Login/image-20220420190421308.png" alt="image-20220420190421308"></p>
<p>逆列混合使用到的矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   0xe, 0xb, 0xd, 0x9,</span><br><span class="line">0x9, 0xe, 0xb, 0xd,</span><br><span class="line">0xd, 0x9, 0xe, 0xb,</span><br><span class="line">0xb, 0xd, 0x9, 0xe </span><br></pre></td></tr></table></figure>

<p>逆列混合:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列混合</span></span><br><span class="line"><span class="comment">// 使用到的矩阵</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> deColCinfusion[<span class="number">16</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0xe</span>, <span class="number">0xb</span>, <span class="number">0xd</span>, <span class="number">0x9</span>,</span><br><span class="line">	<span class="number">0x9</span>, <span class="number">0xe</span>, <span class="number">0xb</span>, <span class="number">0xd</span>,</span><br><span class="line">	<span class="number">0xd</span>, <span class="number">0x9</span>, <span class="number">0xe</span>, <span class="number">0xb</span>,</span><br><span class="line">	<span class="number">0xb</span>, <span class="number">0xd</span>, <span class="number">0x9</span>, <span class="number">0xe</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GF之中的运算</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul2</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> result = s*<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> tem = (s*<span class="number">2</span>)&amp;<span class="number">0x00000100</span>;</span><br><span class="line">    <span class="keyword">if</span>(tem != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = result&amp;<span class="number">0xff</span>;</span><br><span class="line">        result^= <span class="number">0x1b</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul3</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul2(s)^s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul4</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul2(GFMul2(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul8</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul2(GFMul4(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul9</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul8(s)^s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul11</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul9(s)^GFMul2(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul12</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul8(s)^GFMul4(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul13</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul12(s)^s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul14</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul12(s)^GFMul2(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul</span><span class="params">(<span class="type">uint8_t</span> n,<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">        result = s;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">2</span>)  <span class="comment">// 2</span></span><br><span class="line">        result = GFMul2(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">3</span>)  <span class="comment">// 3</span></span><br><span class="line">        result = GFMul3(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">0x9</span>)  <span class="comment">// 9</span></span><br><span class="line">        result = GFMul9(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">0xb</span>)  <span class="comment">// 11</span></span><br><span class="line">        result = GFMul11(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">0xd</span>)  <span class="comment">// 13</span></span><br><span class="line">        result = GFMul13(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">0xe</span>)  <span class="comment">// 14</span></span><br><span class="line">        result = GFMul14(s);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆列混合</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deColCinfusions</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> temVerify[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> j =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temVerify[i] = verify[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            verify[i*<span class="number">4</span>+j] = GFMul(deColCinfusion[i*<span class="number">4</span>],temVerify[j])^GFMul(deColCinfusion[i*<span class="number">4</span>+<span class="number">1</span>],temVerify[<span class="number">4</span>+j])^GFMul(deColCinfusion[i*<span class="number">4</span>+<span class="number">2</span>],temVerify[<span class="number">2</span>*<span class="number">4</span>+j])^GFMul(deColCinfusion[i*<span class="number">4</span>+<span class="number">3</span>],temVerify[<span class="number">3</span>*<span class="number">4</span>+j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h4><p>轮密钥加：</p>
<p><img src="/images/DASCTF-Login/image-20220420221626691.png" alt="image-20220420221626691"></p>
<p>在10轮加密之前会使用一个拓展密钥（进行一次轮密钥加）</p>
<p>10轮加密之中每一轮会用一个拓展密钥</p>
<p>10轮加密之后会使用一个拓展密钥</p>
<p><img src="/images/DASCTF-Login/image-20220420222043252.png" alt="image-20220420222043252"></p>
<p>逆轮密钥加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 轮密钥加(传入的参数是每一轮使用的密钥的第一个数的索引)</span><br><span class="line">static void addRoundKey(uint8_t theIndex)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t i,j = 0;</span><br><span class="line">    for(i=0;i&lt;4;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0;j&lt;4;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            verify[4*i+j]^=roundKey[theIndex+4*j+i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AES解密脚本"><a href="#AES解密脚本" class="headerlink" title="AES解密脚本"></a>AES解密脚本</h4><p>AES解密脚本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="type">uint8_t</span> revSBox[] = &#123;<span class="number">0x63</span>,<span class="number">0x7c</span>,<span class="number">0x77</span>,<span class="number">0x7b</span>,<span class="number">0xf2</span>,<span class="number">0x6b</span>,<span class="number">0x6f</span>,<span class="number">0xc5</span>,<span class="number">0x30</span>,<span class="number">0x01</span>,<span class="number">0x67</span>,<span class="number">0x2b</span>,<span class="number">0xfe</span>,<span class="number">0xd7</span>,<span class="number">0xab</span>,<span class="number">0x76</span>,<span class="number">0xca</span>,<span class="number">0x82</span>,<span class="number">0xc9</span>,<span class="number">0x7d</span>,<span class="number">0xfa</span>,<span class="number">0x59</span>,<span class="number">0x47</span>,<span class="number">0xf0</span>,<span class="number">0xad</span>,<span class="number">0xd4</span>,<span class="number">0xa2</span>,<span class="number">0xaf</span>,<span class="number">0x9c</span>,<span class="number">0xa4</span>,<span class="number">0x72</span>,<span class="number">0xc0</span>,<span class="number">0xb7</span>,<span class="number">0xfd</span>,<span class="number">0x93</span>,<span class="number">0x26</span>,<span class="number">0x36</span>,<span class="number">0x3f</span>,<span class="number">0xf7</span>,<span class="number">0xcc</span>,<span class="number">0x34</span>,<span class="number">0xa5</span>,<span class="number">0xe5</span>,<span class="number">0xf1</span>,<span class="number">0x71</span>,<span class="number">0xd8</span>,<span class="number">0x31</span>,<span class="number">0x15</span>,<span class="number">0x04</span>,<span class="number">0xc7</span>,<span class="number">0x23</span>,<span class="number">0xc3</span>,<span class="number">0x18</span>,<span class="number">0x96</span>,<span class="number">0x05</span>,<span class="number">0x9a</span>,<span class="number">0x07</span>,<span class="number">0x12</span>,<span class="number">0x80</span>,<span class="number">0xe2</span>,<span class="number">0xeb</span>,<span class="number">0x27</span>,<span class="number">0xb2</span>,<span class="number">0x75</span>,<span class="number">0x09</span>,<span class="number">0x83</span>,<span class="number">0x2c</span>,<span class="number">0x1a</span>,<span class="number">0x1b</span>,<span class="number">0x6e</span>,<span class="number">0x5a</span>,<span class="number">0xa0</span>,<span class="number">0x52</span>,<span class="number">0x3b</span>,<span class="number">0xd6</span>,<span class="number">0xb3</span>,<span class="number">0x29</span>,<span class="number">0xe3</span>,<span class="number">0x2f</span>,<span class="number">0x84</span>,<span class="number">0x53</span>,<span class="number">0xd1</span>,<span class="number">0x00</span>,<span class="number">0xed</span>,<span class="number">0x20</span>,<span class="number">0xfc</span>,<span class="number">0xb1</span>,<span class="number">0x5b</span>,<span class="number">0x6a</span>,<span class="number">0xcb</span>,<span class="number">0xbe</span>,<span class="number">0x39</span>,<span class="number">0x4a</span>,<span class="number">0x4c</span>,<span class="number">0x58</span>,<span class="number">0xcf</span>,<span class="number">0xd0</span>,<span class="number">0xef</span>,<span class="number">0xaa</span>,<span class="number">0xfb</span>,<span class="number">0x43</span>,<span class="number">0x4d</span>,<span class="number">0x33</span>,<span class="number">0x85</span>,<span class="number">0x45</span>,<span class="number">0xf9</span>,<span class="number">0x02</span>,<span class="number">0x7f</span>,<span class="number">0x50</span>,<span class="number">0x3c</span>,<span class="number">0x9f</span>,<span class="number">0xa8</span>,<span class="number">0x51</span>,<span class="number">0xa3</span>,<span class="number">0x40</span>,<span class="number">0x8f</span>,<span class="number">0x92</span>,<span class="number">0x9d</span>,<span class="number">0x38</span>,<span class="number">0xf5</span>,<span class="number">0xbc</span>,<span class="number">0xb6</span>,<span class="number">0xda</span>,<span class="number">0x21</span>,<span class="number">0x10</span>,<span class="number">0xff</span>,<span class="number">0xf3</span>,<span class="number">0xd2</span>,<span class="number">0xcd</span>,<span class="number">0x0c</span>,<span class="number">0x13</span>,<span class="number">0xec</span>,<span class="number">0x5f</span>,<span class="number">0x97</span>,<span class="number">0x44</span>,<span class="number">0x17</span>,<span class="number">0xc4</span>,<span class="number">0xa7</span>,<span class="number">0x7e</span>,<span class="number">0x3d</span>,<span class="number">0x64</span>,<span class="number">0x5d</span>,<span class="number">0x19</span>,<span class="number">0x73</span>,<span class="number">0x60</span>,<span class="number">0x81</span>,<span class="number">0x4f</span>,<span class="number">0xdc</span>,<span class="number">0x22</span>,<span class="number">0x2a</span>,<span class="number">0x90</span>,<span class="number">0x88</span>,<span class="number">0x46</span>,<span class="number">0xee</span>,<span class="number">0xb8</span>,<span class="number">0x14</span>,<span class="number">0xde</span>,<span class="number">0x5e</span>,<span class="number">0x0b</span>,<span class="number">0xdb</span>,<span class="number">0xe0</span>,<span class="number">0x32</span>,<span class="number">0x3a</span>,<span class="number">0x0a</span>,<span class="number">0x49</span>,<span class="number">0x06</span>,<span class="number">0x24</span>,<span class="number">0x5c</span>,<span class="number">0xc2</span>,<span class="number">0xd3</span>,<span class="number">0xac</span>,<span class="number">0x62</span>,<span class="number">0x91</span>,<span class="number">0x95</span>,<span class="number">0xe4</span>,<span class="number">0x79</span>,<span class="number">0xe7</span>,<span class="number">0xc8</span>,<span class="number">0x37</span>,<span class="number">0x6d</span>,<span class="number">0x8d</span>,<span class="number">0xd5</span>,<span class="number">0x4e</span>,<span class="number">0xa9</span>,<span class="number">0x6c</span>,<span class="number">0x56</span>,<span class="number">0xf4</span>,<span class="number">0xea</span>,<span class="number">0x65</span>,<span class="number">0x7a</span>,<span class="number">0xae</span>,<span class="number">0x08</span>,<span class="number">0xba</span>,<span class="number">0x78</span>,<span class="number">0x25</span>,<span class="number">0x2e</span>,<span class="number">0x1c</span>,<span class="number">0xa6</span>,<span class="number">0xb4</span>,<span class="number">0xc6</span>,<span class="number">0xe8</span>,<span class="number">0xdd</span>,<span class="number">0x74</span>,<span class="number">0x1f</span>,<span class="number">0x4b</span>,<span class="number">0xbd</span>,<span class="number">0x8b</span>,<span class="number">0x8a</span>,<span class="number">0x70</span>,<span class="number">0x3e</span>,<span class="number">0xb5</span>,<span class="number">0x66</span>,<span class="number">0x48</span>,<span class="number">0x03</span>,<span class="number">0xf6</span>,<span class="number">0x0e</span>,<span class="number">0x61</span>,<span class="number">0x35</span>,<span class="number">0x57</span>,<span class="number">0xb9</span>,<span class="number">0x86</span>,<span class="number">0xc1</span>,<span class="number">0x1d</span>,<span class="number">0x9e</span>,<span class="number">0xe1</span>,<span class="number">0xf8</span>,<span class="number">0x98</span>,<span class="number">0x11</span>,<span class="number">0x69</span>,<span class="number">0xd9</span>,<span class="number">0x8e</span>,<span class="number">0x94</span>,<span class="number">0x9b</span>,<span class="number">0x1e</span>,<span class="number">0x87</span>,<span class="number">0xe9</span>,<span class="number">0xce</span>,<span class="number">0x55</span>,<span class="number">0x28</span>,<span class="number">0xdf</span>,<span class="number">0x8c</span>,<span class="number">0xa1</span>,<span class="number">0x89</span>,<span class="number">0x0d</span>,<span class="number">0xbf</span>,<span class="number">0xe6</span>,<span class="number">0x42</span>,<span class="number">0x68</span>,<span class="number">0x41</span>,<span class="number">0x99</span>,<span class="number">0x2d</span>,<span class="number">0x0f</span>,<span class="number">0xb0</span>,<span class="number">0x54</span>,<span class="number">0xbb</span>,<span class="number">0x16</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> para[] = &#123;  <span class="number">0x8D</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>, <span class="number">0x1B</span>, <span class="number">0x36</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> pass_token[] = &#123;<span class="number">50</span>, <span class="number">48</span>, <span class="number">7</span>, <span class="number">54</span>, <span class="number">106</span>, <span class="number">55</span>, <span class="number">120</span>, <span class="number">49</span>, <span class="number">72</span>, <span class="number">57</span>, <span class="number">66</span>, <span class="number">57</span>, <span class="number">20</span>, <span class="number">49</span>, <span class="number">213</span>, <span class="number">50</span>, <span class="number">98</span>, <span class="number">54</span>, <span class="number">249</span>, <span class="number">56</span>, <span class="number">66</span>, <span class="number">48</span>, <span class="number">195</span>, <span class="number">49</span>, <span class="number">106</span>, <span class="number">53</span>, <span class="number">72</span>, <span class="number">56</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">84</span>, <span class="number">52</span>, <span class="number">41</span>, <span class="number">52</span>, <span class="number">81</span>, <span class="number">54</span>, <span class="number">21</span>, <span class="number">57</span>, <span class="number">210</span>, <span class="number">56</span>, <span class="number">210</span>, <span class="number">57</span>, <span class="number">32</span>, <span class="number">49</span>, <span class="number">185</span>, <span class="number">50</span>, <span class="number">46</span>, <span class="number">48</span>&#125;;   <span class="comment">//前16个字节用来生成44*4的轮密钥    后16*2字节每16个字节用来进行AES的IV异或运算</span></span><br><span class="line"><span class="type">uint8_t</span> roundKey[<span class="number">4</span>*<span class="number">44</span>];<span class="comment">// 生成的轮密钥</span></span><br><span class="line"><span class="type">uint8_t</span> verify[<span class="number">16</span>];</span><br><span class="line"><span class="comment">// 待加密的数据</span></span><br><span class="line"><span class="type">uint8_t</span> c[] =&#123;<span class="number">0xfe</span>,<span class="number">0xf9</span>,<span class="number">0xe7</span>,<span class="number">0x3e</span>,<span class="number">0xf6</span>,<span class="number">0xa1</span>,<span class="number">0x23</span>,<span class="number">0xcc</span>,<span class="number">0x57</span>,<span class="number">0x61</span>,<span class="number">0xc1</span>,<span class="number">0x15</span>,<span class="number">0x77</span>,<span class="number">0xfb</span>,<span class="number">0x9c</span>,<span class="number">0xbb</span>,<span class="number">0xca</span>,<span class="number">0x2f</span>,<span class="number">0xb1</span>,<span class="number">0xe8</span>,<span class="number">0x4f</span>,<span class="number">0xd9</span>,<span class="number">0x07</span>,<span class="number">0xd8</span>,<span class="number">0x0c</span>,<span class="number">0x6b</span>,<span class="number">0xea</span>,<span class="number">0xcf</span>,<span class="number">0xe8</span>,<span class="number">0x42</span>,<span class="number">0xa2</span>,<span class="number">0xfa</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行密钥扩展</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expandKeyNums</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 进行密钥扩展</span></span><br><span class="line">    <span class="type">uint8_t</span> v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> v11 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> v12 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> j =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化前16个字节 4列中的元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        roundKey[i*<span class="number">4</span>] = pass_token[i*<span class="number">4</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">1</span>] = pass_token[i*<span class="number">4</span>+<span class="number">1</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">2</span>] = pass_token[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">3</span>] = pass_token[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">4</span>;i&lt;<span class="number">44</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v9 = roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)];</span><br><span class="line">        v10 = roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)+<span class="number">1</span>];</span><br><span class="line">        v11 = roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)+<span class="number">2</span>];</span><br><span class="line">        v12 = roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> ((i&amp;<span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v10 = revSBox[v11];</span><br><span class="line">            v11 = revSBox[v12];</span><br><span class="line">            v12 = revSBox[roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)]];</span><br><span class="line">            v9 = revSBox[roundKey[<span class="number">4</span>*(i<span class="number">-1</span>)+<span class="number">1</span>]] ^ para[i&gt;&gt;<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        roundKey[i*<span class="number">4</span>] = v9^roundKey[(i<span class="number">-4</span>)*<span class="number">4</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">1</span>] = v10^roundKey[(i<span class="number">-4</span>)*<span class="number">4</span>+<span class="number">1</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">2</span>] = v11^roundKey[(i<span class="number">-4</span>)*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line">        roundKey[i*<span class="number">4</span>+<span class="number">3</span>] = v12^roundKey[(i<span class="number">-4</span>)*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加密过程第一步的异或运算(但是里面的数据还需要思考一下) 传入的参数是数据加密的轮数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">XorIV</span><span class="params">(<span class="type">uint8_t</span> round)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">15</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        verify[i]^=pass_token[<span class="number">16</span>*round+<span class="number">16</span>+i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆字节代换()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reveSubBytes</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        verify[i] = revSBox[verify[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行移位的逆运算 第一行不移动 第二行循环右移1位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reveShiftRows</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> round = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> tem = <span class="number">0</span>;<span class="comment">//临时存放值</span></span><br><span class="line">    <span class="type">int</span> j =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        round = i;</span><br><span class="line">        <span class="keyword">while</span>(round)</span><br><span class="line">        &#123;</span><br><span class="line">            tem = verify[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">3</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                verify[i*<span class="number">4</span>+j] = verify[i*<span class="number">4</span>+j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            verify[i*<span class="number">4</span>+j] = tem;</span><br><span class="line">            round--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列混合</span></span><br><span class="line"><span class="comment">// 使用到的矩阵</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> deColCinfusion[<span class="number">16</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0xe</span>, <span class="number">0xb</span>, <span class="number">0xd</span>, <span class="number">0x9</span>,</span><br><span class="line">	<span class="number">0x9</span>, <span class="number">0xe</span>, <span class="number">0xb</span>, <span class="number">0xd</span>,</span><br><span class="line">	<span class="number">0xd</span>, <span class="number">0x9</span>, <span class="number">0xe</span>, <span class="number">0xb</span>,</span><br><span class="line">	<span class="number">0xb</span>, <span class="number">0xd</span>, <span class="number">0x9</span>, <span class="number">0xe</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GF之中的运算</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul2</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> result = s*<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> tem = (s*<span class="number">2</span>)&amp;<span class="number">0x00000100</span>;</span><br><span class="line">    <span class="keyword">if</span>(tem != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = result&amp;<span class="number">0xff</span>;</span><br><span class="line">        result^= <span class="number">0x1b</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul3</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul2(s)^s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul4</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul2(GFMul2(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul8</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul2(GFMul4(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul9</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul8(s)^s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul11</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul9(s)^GFMul2(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul12</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul8(s)^GFMul4(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul13</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul12(s)^s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul14</span><span class="params">(<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GFMul12(s)^GFMul2(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">GFMul</span><span class="params">(<span class="type">uint8_t</span> n,<span class="type">uint8_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">        result = s;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">2</span>)  <span class="comment">// 2</span></span><br><span class="line">        result = GFMul2(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">3</span>)  <span class="comment">// 3</span></span><br><span class="line">        result = GFMul3(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">0x9</span>)  <span class="comment">// 9</span></span><br><span class="line">        result = GFMul9(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">0xb</span>)  <span class="comment">// 11</span></span><br><span class="line">        result = GFMul11(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">0xd</span>)  <span class="comment">// 13</span></span><br><span class="line">        result = GFMul13(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">0xe</span>)  <span class="comment">// 14</span></span><br><span class="line">        result = GFMul14(s);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆列混合</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deColCinfusions</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> temVerify[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> j =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temVerify[i] = verify[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            verify[i*<span class="number">4</span>+j] = GFMul(deColCinfusion[i*<span class="number">4</span>],temVerify[j])^GFMul(deColCinfusion[i*<span class="number">4</span>+<span class="number">1</span>],temVerify[<span class="number">4</span>+j])^GFMul(deColCinfusion[i*<span class="number">4</span>+<span class="number">2</span>],temVerify[<span class="number">2</span>*<span class="number">4</span>+j])^GFMul(deColCinfusion[i*<span class="number">4</span>+<span class="number">3</span>],temVerify[<span class="number">3</span>*<span class="number">4</span>+j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮密钥加(传入的参数是每一轮使用的密钥的第一个数的索引)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">addRoundKey</span><span class="params">(<span class="type">uint8_t</span> theIndex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            verify[<span class="number">4</span>*i+j]^=roundKey[theIndex+<span class="number">4</span>*j+i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将4*4的矩阵进行转置</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">transMatri</span><span class="params">(<span class="type">uint8_t</span>* mutrix)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> temMutrix[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> i,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temMutrix[i] = mutrix[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            mutrix[<span class="number">4</span>*i+j] = temMutrix[i+<span class="number">4</span>*j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 密钥扩展</span></span><br><span class="line">    expandKeyNums();</span><br><span class="line">    <span class="type">uint8_t</span> i,j=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;verity:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i=i+<span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&lt;i+<span class="number">16</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            verify[j-i] = c[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始的时候要进行一次转置</span></span><br><span class="line">        transMatri(verify);</span><br><span class="line">        <span class="comment">//第一次轮密钥加</span></span><br><span class="line">        addRoundKey(<span class="number">16</span>*<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 10次解密</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 逆行移位</span></span><br><span class="line">            reveShiftRows();</span><br><span class="line">            <span class="comment">// 逆字节代换</span></span><br><span class="line">            reveSubBytes();</span><br><span class="line">            <span class="keyword">if</span> (j==<span class="number">9</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 轮密钥加密</span></span><br><span class="line">            addRoundKey(<span class="number">16</span>*(<span class="number">9</span>-j));</span><br><span class="line">            <span class="comment">//逆列混淆</span></span><br><span class="line">            deColCinfusions();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再进行一次轮密钥加密</span></span><br><span class="line">        addRoundKey(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//结束的时候要机进行一次转置</span></span><br><span class="line">        transMatri(verify);</span><br><span class="line">        <span class="comment">//最后要和IV进行异或运算</span></span><br><span class="line">        XorIV(i/<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">for</span>(j =<span class="number">0</span>;j&lt;<span class="number">16</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,verify[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">verity:<span class="number">7026271</span>d7bb5d404d63a72b88e6b4d63</span><br></pre></td></tr></table></figure>

<p><img src="/images/DASCTF-Login/image-20220421134033932.png" alt="image-20220421134033932"></p>
<p>所以flag是 DASCTF{7026271d7bb5d404d63a72b88e6b4d63}</p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>hill解密</tag>
        <tag>AES解密</tag>
      </tags>
  </entry>
  <entry>
    <title>SUSCTF_tttree（使用idapython去混淆的学习）</title>
    <url>/2022/03/06/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="SUSCTF-tttree（使用idapython去混淆的学习）"><a href="#SUSCTF-tttree（使用idapython去混淆的学习）" class="headerlink" title="SUSCTF_tttree（使用idapython去混淆的学习）"></a>SUSCTF_tttree（使用idapython去混淆的学习）</h1><p>这道题里面有大量的相同结构的混淆，所以采用了idapython的方式解混淆，这道题需要就是学习用idapython解混淆的过程。后面的平衡树的算法太难了，就没有继续往下解了。</p>
<h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><p>这里面有两个混淆，出题人声称采用了 这里参考了古月浪子大佬的一个混淆思路。</p>
<h3 id="混淆一"><a href="#混淆一" class="headerlink" title="混淆一"></a>混淆一</h3><p>重构序列</p>
<p><strong>花指令形式特征</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push rax </span><br><span class="line">push rax </span><br><span class="line">pushfq </span><br><span class="line">call $+5 </span><br><span class="line">pop rax </span><br><span class="line">add rax,xxxx </span><br><span class="line">push rax </span><br><span class="line">mov [rsp+10h], rax </span><br><span class="line">popfq </span><br><span class="line">pop rax</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：</p>
<p>当该花指令的后面接着的是retn这个指令的时候，就是跳转到这个计算得到的地址</p>
<p>当该花指令的后面接着的是jmp addr2这个指令时，相当于call addr2（addr1就是这个指令之后的返回地址）</p>
<p><strong>解混淆的方法</strong>：</p>
<p>如果是retn指令时:通过“pop rax”和”add rax,xxxx”这两个指令计算得到需要jmp的偏移地址，将jmp+偏移地址的指令写入花指令这个地方的地址，其余空间地址“nop”</p>
<p>如果时jmp addr2指令时，先将这个“pop rax”和”add rax,xxxx”这两个指令计算得到的目标地址（注意这个地方不是相对地址）push，将push+目标地址的指令写入花指令的地址，其余空间地址“nop”。然后先jmp “jmp addr2”的地址，再jmp “push”指令里面的地址</p>
<p>该程序之中的<strong>示例</strong>：</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306092253733.png" alt="image-20220306092253733"></p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306092311317.png" alt="image-20220306092311317"></p>
<h3 id="混淆二"><a href="#混淆二" class="headerlink" title="混淆二"></a>混淆二</h3><p><strong>无效push 和 pop</strong></p>
<p>花指令形式特征</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push [rax|...] </span><br><span class="line">pop [rax|...]</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：push之后马上pop出来，显然这个指令时无效的</p>
<p><strong>解混淆的方法</strong>：直接pop掉这两句就可以了</p>
<p>该程序之中的示例:</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306093739567.png" alt="image-20220306093739567"></p>
<h3 id="idapython脚本"><a href="#idapython脚本" class="headerlink" title="idapython脚本"></a>idapython脚本</h3><p><a href="https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/">idapython的教程</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct</span><br><span class="line">start = 0x140001000  #起始位置</span><br><span class="line">end = 0x14001C694    #结束位置</span><br><span class="line">address_m = [0 for x in range(11)]</span><br><span class="line">address_target = [&#x27;push    rax&#x27;,&#x27;push    rax&#x27;,&#x27;pushfq&#x27;,&#x27;call    $+5&#x27;,&#x27;pop     rax&#x27;,&#x27;add     rax,&#x27;,&#x27;mov &#x27;,&#x27;popfq&#x27;,&#x27;pop     rax&#x27;,&#x27;retn&#x27;]</span><br><span class="line">  # 第一种花指令的特征 注意这个里面的每一条指令中间的空格数都要和ida之中展示的汇编代码相同，所以最好是进行复制粘贴</span><br><span class="line"></span><br><span class="line">def check1():</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i in range(9):</span><br><span class="line">        if i == 5 or i == 6:</span><br><span class="line">            cnt += GetDisasm(address_m[i]).find(address_target[i]) != -1 # GetDisasm：获得对应位置的汇编地址 因为&#x27;add rax,&#x27;,&#x27;mov &#x27;这两个指令中有数据，每个部分的代码就会不一样，所以使用find函数来判断是否存在</span><br><span class="line">        else:</span><br><span class="line">            cnt += GetDisasm(address_m[i]) == address_target[i] # 除了那两个语句以外就需要判断剩下的这些语句是否相等就可以了</span><br><span class="line">    return cnt == 9  # 如果9条语句都和目标类型已知 就认为是第一种花指令</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def check2(x,y):</span><br><span class="line">    cnt = 0</span><br><span class="line">    cnt += print_insn_mnem(x) == &quot;push&quot; # idc.print_insn_mnem()获取操作符 判断操作符是否是push指令</span><br><span class="line">    cnt += print_insn_mnem(y) == &quot;pop&quot;  # idc.print_insn_mnem(y)获取操作符 判断操作符是否是 pop 指令</span><br><span class="line">    cnt += print_operand(x,0) == print_operand(y,0) # idc.print_operand(x, 0) 获取第一个操作数 判断这两个指令的操作数是否相等</span><br><span class="line">    return cnt == 3  # 当以上的三个条件都满足的时候就是第二种花指令</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def check3():</span><br><span class="line">    cnt = 0</span><br><span class="line">    cnt += print_insn_mnem(address_m[0]) == &quot;push&quot; # print_insn_mnem获取操作符 判断操作符是否是push</span><br><span class="line">    cnt += get_operand_type(address_m[0], 0) == o_imm # 如果操作数是一个确定的数值的话，那么返回类型，值为 5</span><br><span class="line">    return cnt == 2</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def nop(u,v): # u是指令的起始地址 v是结束的地址，但是v地址的指令不会被nop</span><br><span class="line">    patch_add = u</span><br><span class="line">    while(patch_add &lt; v):</span><br><span class="line">        patch_byte(patch_add,0x90)</span><br><span class="line">        patch_add += 1</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">p = start</span><br><span class="line">while p &lt;= end:</span><br><span class="line">    address_m[0] = p</span><br><span class="line">    p = next_head(p)   # 利用了 idc.next_head()使当前地址不断增长</span><br><span class="line"></span><br><span class="line">    # 将第二种花指令进行nop</span><br><span class="line">    while print_insn_mnem(p) == &quot;nop&quot;: # 如果是nop语句就跳过</span><br><span class="line">        p = next_head(p)</span><br><span class="line">    if check2(address_m[0], p) == 1: # 判断这两个连续的语句是否是满足第二种花指令的要求</span><br><span class="line">        p = next_head(p) # p定位到第二种花指令结束之后那个地址</span><br><span class="line">        nop(address_m[0], p) # address_m[0]是nop的起始位置  p是nop的结束位置</span><br><span class="line">    else:</span><br><span class="line">        p = address_m[0] # 如果不是花指令起点又回到最初的那个地方</span><br><span class="line"></span><br><span class="line">    # 将第一种花指令nop</span><br><span class="line">    address_m[0] = p # 将起始的地址放入到数组的第一项之中</span><br><span class="line">    for i in range(1, 11): # 判断这个地方连续的10条指令是否满足第一种花指令的要求，取出这10条指令的地址放入到数组之中</span><br><span class="line">        address_m[i] = next_head(address_m[i - 1])</span><br><span class="line"></span><br><span class="line">    if check1() == 1: # 判断是否是第一种花指令</span><br><span class="line">        addri = get_operand_value(address_m[5], 1) # get_operand_value(address_m[5], 1)  获取操作数的数值 即该条 &#x27;add rax,&#x27; 命令的第二个操作数的数值</span><br><span class="line">        addri += address_m[4]  # rax加上操作数，得到目标地址 x+a4-a0-5</span><br><span class="line">        if address_target[9] == GetDisasm(address_m[9]):  # 当最后一条指令是ret时</span><br><span class="line">            addri -= (address_m[0] + 5)</span><br><span class="line">            patch_byte(address_m[0], 0xE9) # 将这个地方的值修改为 0xE9 就是jmp指令 因为 0xE9 JMP 后面的四个字节是偏移 所以这里addri需要计算成偏移地址</span><br><span class="line">            patch_dword(address_m[0] + 1, addri &amp; 0xffffffff) # dw的数值来存放目标的地址</span><br><span class="line">            nop(address_m[0] + 5, address_m[10]) # 将剩下的nop掉</span><br><span class="line">            p = address_m[10]</span><br><span class="line">        else:</span><br><span class="line">            patch_byte(address_m[0], 0x68) # 0x68是push 入栈的操作</span><br><span class="line">            patch_dword(address_m[0] + 1, addri &amp; 0xffffffff) # 将对应的地址push</span><br><span class="line">            nop(address_m[0] + 5, address_m[9])</span><br><span class="line">            p = address_m[9]</span><br><span class="line">    else:</span><br><span class="line">        p = address_m[1] # 指向下一个指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对第一种花指令中结尾是push的操作</span><br><span class="line">p = start # 从程序的开始进行遍历</span><br><span class="line">while p &lt;= end:</span><br><span class="line">    address_m[0] = p</span><br><span class="line">    address_m[1] = next_head(p)</span><br><span class="line">    if check3() == 1: # 当指令满足check3()中指令的要求时进行的操作</span><br><span class="line">        addri = get_operand_value(address_m[0], 0) + 2 ** 32 # get_operand_value 获取push的地址的值   2 ** 32代表2的32次方</span><br><span class="line">        p = address_m[1]   # push指令后的下一条指令</span><br><span class="line">        while print_insn_mnem(p) == &quot;nop&quot;: # 如果遇到nop指令就跳过</span><br><span class="line">            p += 1</span><br><span class="line">        if print_insn_mnem(p) == &quot;jmp&quot;: # 如果是jmp指令</span><br><span class="line">            addrj = struct.unpack(&#x27;&lt;I&#x27;, get_bytes(p + 1, 4))[0] + p - address_m[0] # struct.unpack(&#x27;&lt;I&#x27;, get_bytes(p + 1, 4)) 利用小序端取得地址 这个得到的是一个元组 这条jmp指令的起始位置 减去上一条指令的位置</span><br><span class="line">            addri -= p + 5 # push的地址 减去jmp地址结束的那个地址</span><br><span class="line">            if addri &lt; 0:</span><br><span class="line">                addri += 2 ** 32 # 保持addri这个地址始终大于0</span><br><span class="line">            patch_byte(address_m[0], 0xe8) # 0xE8 CALL 后面的四个字节是地址</span><br><span class="line">            patch_dword(address_m[0] + 1, addrj &amp; 0xffffffff)</span><br><span class="line">            patch_byte(p, 0xe9) # 0xE9 JMP 后面的四个字节是偏移</span><br><span class="line">            p += 1</span><br><span class="line">            patch_dword(p, addri)# 需要跳转到的偏移地址</span><br><span class="line">            p += 4</span><br><span class="line">    else:</span><br><span class="line">        p = address_m[1] # 下一个指令</span><br><span class="line">print(&quot;Finish&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="idapython脚本学习"><a href="#idapython脚本学习" class="headerlink" title="idapython脚本学习"></a>idapython脚本学习</h2><p>idapython的指令<a href="https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/">查询</a></p>
<h3 id="跳转指令和机器码"><a href="#跳转指令和机器码" class="headerlink" title="跳转指令和机器码"></a>跳转指令和机器码</h3><p>注意相同的指令，但是不同的机器码后面所跟着的地址的要求是不一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xE8 CALL 后面的四个字节是地址</span><br><span class="line">0xE9 JMP 后面的四个字节是偏移</span><br><span class="line">0xEB JMP 后面的二个字节是偏移</span><br><span class="line">0xFF15 CALL 后面的四个字节是存放地址的地址</span><br><span class="line">0xFF25 JMP 后面的四个字节是存放地址的地址</span><br><span class="line"></span><br><span class="line">0x68 PUSH 后面的四个字节入栈</span><br><span class="line">0x6A PUSH 后面的一个字节入栈</span><br><span class="line">对于每条指令我们检查他的操作数类型是否为 o_imm(值为 5)，o_imm 类型的操作数就是一个确定的数值或者偏移，一旦这个发现这种类型的操作数</span><br></pre></td></tr></table></figure>

<h3 id="常用到的idapython的函数"><a href="#常用到的idapython的函数" class="headerlink" title="常用到的idapython的函数"></a>常用到的idapython的函数</h3><p>对指令（操作符 操作数等）进行操作的函数：</p>
<ul>
<li>**GetDisasm(ea)**：获得ea这个地址的汇编代码</li>
<li><strong>print_insn_mnem(ea)<strong>：获取ea这个地址的</strong>操作符</strong></li>
<li><strong>print_operand(ea, 0)</strong>:获取当前地址<strong>操作数</strong>。例如获取“MOV AH，06H“指令的AH这个操作数</li>
<li><strong>get_operand_value(ea, n)<strong>：获取</strong>操作数的数值</strong></li>
<li><strong>next_head(ea)<strong>：获取</strong>下一个</strong>指令地址 </li>
<li><strong>prev_head(ea)<strong>：获取</strong>上一个</strong>指令地址</li>
<li><strong>next_addr(ea)<strong>：获取</strong>下一个</strong>地址</li>
<li><strong>prev_addr(ea)<strong>：获取</strong>上一个</strong>地址</li>
<li>**get_operand_type(ea,n)**：获取操作数类型。其返回类型有八种 + 不同的处理器 6 种，这道题之中的o_imm代表是一个确定的数值。还有其它的类型，可以查看上面的那个网址</li>
</ul>
<p>补丁：</p>
<ul>
<li><strong>patch_byte/patch_word/patch_dword/patch_qword(ea, value)</strong>:打补丁，反调试  混淆等等都用得到，修改相应的机器码等，比如这道题之中的指令 patch_byte(address_m[0], 0xe8) 就是修改这个地址的机器码为0xe8 这个jmp指令</li>
</ul>
<p>机器码式搜索：</p>
<ul>
<li>**FindBinary(ea,flag, searchstr, radix=16)**：实行字节或者二进制的搜索。ea代表地址，flag 代表搜索方向或者条件（有具体的参数可以选择，根据需要查表填入）比如说SEARCH_UP和SEARCH_DOWN 用来指明搜索的方向。searchstr代表的是字节字符串，形如’55 48 89 E5’这个样子的</li>
</ul>
<p>对汇编之中函数操作的函数：</p>
<ul>
<li>**idautils.Functions()**：获取函数列表，使用for循环的方式遍历所有的这些地址，然后对每个函数对象进行相应的操作。例如 get_func_name(func) func就是这个函数列表之中的一个对象，这个函数获取这个函数对象的名称。</li>
<li>**get_func_attr(func, FUNCATTR_FLAGS)**：信息收集函数，可以用来检索关于函数的信息，例如它是否是库中代码，或者函数是否有返回值等。对于一个函数来说有九个可能的标志。</li>
</ul>
<h2 id="python函数说明"><a href="#python函数说明" class="headerlink" title="python函数说明"></a>python函数说明</h2><h3 id="struct-pack-和struct-unpack"><a href="#struct-pack-和struct-unpack" class="headerlink" title="struct.pack()和struct.unpack()"></a>struct.pack()和struct.unpack()</h3><p>使用这两个函数需要使用struct包</p>
<p>**struct.pack(fmt,v1,v2,…..)**：将v1,v2等参数的值进行一层包装，包装的方法由fmt指定。被包装的参数必须严格符合fmt。最后返回一个包装后的字符串。 将数据转换成c语言之中相应的存储的形式。</p>
<p><strong>struct.unpack(fmt,string)<strong>：顾名思义，解包。返回一个由解包数据(string)得到的一个</strong>元组(tuple)</strong>, 即使仅有一个数据也会被解包成元组。其中len(string) 必须等于 calcsize(fmt)，这里面涉及到了一个calcsize函数。struct.calcsize(fmt)：这个就是用来计算fmt格式所描述的结构的大小。</p>
<p><strong>fmt的构造</strong>：</p>
<p>格式字符串(format string)由一个或多个格式字符(format characters)组成</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306114015713.png" alt="image-20220306114015713"></p>
<p>在Format string 的首位，有一个可选字符来决定大端和小端：</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306114148873.png" alt="image-20220306114148873"></p>
<p>例子：</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306152233838.png" alt="image-20220306152233838"></p>
<h3 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a>find()函数</h3><p><strong>描述</strong>：Python find() 方法检测字符串中<strong>是否包含子字符串 str</strong> 。如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在<strong>指定范围</strong>内，如果包含子字符串返回开始的索引值，否则返回-1</p>
<p><strong>语法</strong>：str.find(str, beg=0, end=len(string))  </p>
<ul>
<li>str – 指定检索的字符串</li>
<li>beg – 开始索引，默认为0。</li>
<li>end – 结束索引，默认为字符串的长度。</li>
</ul>
<p><strong>返回值</strong>：如果包含子字符串返回开始的索引值，否则返回-1。</p>
<p><strong>注意</strong>：寻找目的是搜索的对象（子字符串）是不是在这串字符串里面，不在于它（子字符串）的位置在哪里。子字符串之中的空格是不能忽视的，并且搜索对象（子字符串）在字符串之中必须是连续完整存在的，这样才能说明字符串中包含了子字符串 str。</p>
<p>参考文章：<a href="https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/">https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/</a></p>
]]></content>
      <categories>
        <category>混淆</category>
      </categories>
      <tags>
        <tag>idapython</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF_Oct</title>
    <url>/2022/03/20/DASCTF-Oct/</url>
    <content><![CDATA[<h1 id="DASCTF-Oct-re"><a href="#DASCTF-Oct-re" class="headerlink" title="DASCTF_Oct_re"></a>DASCTF_Oct_re</h1><p>这两道题中都有加密的知识点，第一道题的SM4的解密在最后一步仍然有问题，希望大佬能够指点指点(●’◡’●)</p>
<h2 id="马猴烧酒"><a href="#马猴烧酒" class="headerlink" title="马猴烧酒"></a>马猴烧酒</h2><p><strong>知识点</strong>：</p>
<blockquote>
<ol>
<li>魔改SM4</li>
<li>魔改base64</li>
</ol>
</blockquote>
<p>用ida6将文件载入其中</p>
<p><img src="/images/DASCTF-Oct/image-20220318181826345.png" alt="image-20220318181826345"></p>
<p>定位到相应的代码的位置，这段代码开始的位置就有一段flag{this_is_fake_flag}的flag</p>
<p><img src="/images/DASCTF-Oct/image-20220318182418204.png" alt="image-20220318182418204"></p>
<h3 id="密钥的生成"><a href="#密钥的生成" class="headerlink" title="密钥的生成"></a>密钥的生成</h3><p>第一个函数是获取时间戳，第二个函数是对时间戳base64的变表加密，第三个异或运算得到密钥</p>
<h4 id="获取时间戳"><a href="#获取时间戳" class="headerlink" title="获取时间戳"></a>获取时间戳</h4><p>使用0x61624B82 演变得到一串数组</p>
<p><img src="/images/DASCTF-Oct/image-20220319151621929.png" alt="image-20220319151621929"></p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key = 0x61624B82</span><br><span class="line">a13 = 0</span><br><span class="line">a14 = 0</span><br><span class="line">while key:</span><br><span class="line">    a13 = key%10</span><br><span class="line">    key = key//10</span><br><span class="line">    a14 = 87</span><br><span class="line">    if a13&lt;=9:</span><br><span class="line">        a14 = 48</span><br><span class="line">    print(chr(a13+a14),end=&#x27;&#x27;)</span><br><span class="line">    </span><br><span class="line">obj = &#x27;0181383361&#x27;</span><br><span class="line">for i in range(len(obj)):</span><br><span class="line">    print(obj[len(obj)-1-i],end=&#x27;&#x27;)</span><br><span class="line"> </span><br><span class="line">得到的结果是 1633831810 这个字符串</span><br></pre></td></tr></table></figure>

<h4 id="魔改的base64加密"><a href="#魔改的base64加密" class="headerlink" title="魔改的base64加密"></a>魔改的base64加密</h4><p>用标准的base64加密这个字符串的结果是 MTYzMzgzMTgxMA== </p>
<p>分析本代码之中的base64加密 可以知道如果位数不是3的倍数位也是使用“=”</p>
<p>base64的变表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ=</span><br></pre></td></tr></table></figure>

<p>利用base64的变表和标准表的对应关系得到该代码base64加密的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oldkey = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&#x27;</span><br><span class="line">newkey = &#x27;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ=&#x27;</span><br><span class="line">theMap = &#123;&#125;</span><br><span class="line">for i in range(len(oldkey)):</span><br><span class="line">    theMap[oldkey[i]] = newkey[i]</span><br><span class="line">advert = &#x27;MTYzMzgzMTgxMA==&#x27;</span><br><span class="line">for i  in range(len(advert)):</span><br><span class="line">    print(theMap[advert[i]],end=&#x27;&#x27;)</span><br><span class="line">结果是：mtyNmN6Nmt6Lma==</span><br></pre></td></tr></table></figure>



<p><img src="/images/DASCTF-Oct/image-20220318191421527.png" alt="image-20220318191421527"></p>
<p><img src="/images/DASCTF-Oct/image-20220318191436020.png" alt="image-20220318191436020"></p>
<h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><p>将上面base64的加密结果和字符串  “flag{this_is_fake_flag}”进行异或运算</p>
<p><img src="/images/DASCTF-Oct/image-20220319154418390.png" alt="image-20220319154418390"></p>
<p>脚本（密钥）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tem1 = <span class="string">&#x27;mtyNmN6Nmt6Lma==&#x27;</span></span><br><span class="line">tem2 = <span class="string">&#x27;flag&#123;this_is_fake_flag&#125;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tem1)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">ord</span>(tem1[i])^<span class="built_in">ord</span>(tem2[i]))[<span class="number">2</span>:].zfill(<span class="number">2</span>),end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">[<span class="number">0x0b</span>,<span class="number">0x18</span>,<span class="number">0x18</span>,<span class="number">0x29</span>,<span class="number">0x16</span>,<span class="number">0x3a</span>,<span class="number">0x5e</span>,<span class="number">0x27</span>,<span class="number">0x1e</span>,<span class="number">0x2b</span>,<span class="number">0x5f</span>,<span class="number">0x3f</span>,<span class="number">0x32</span>,<span class="number">0x07</span>,<span class="number">0x5c</span>,<span class="number">0x56</span>]</span><br></pre></td></tr></table></figure>

<p>得到的这个数组将会作为SM4加密的key</p>
<h3 id="SM4加密"><a href="#SM4加密" class="headerlink" title="SM4加密"></a><strong>SM4加密</strong></h3><blockquote>
<ol>
<li>识别出SM4加密</li>
<li>找到SM4加密魔改的地方</li>
</ol>
</blockquote>
<p>加密之后的结果和相应的数组对比</p>
<p><img src="/images/DASCTF-Oct/image-20220318193700160.png" alt="image-20220318193700160"></p>
<p>需要解密的对象是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc = [0xf7,0xeb,0x5e,0x87,0x17,0x9c,0x74,0x94,0x44,0xb5,0xf5,0x12,0xf9,0x74,0x15,0x5f]</span><br></pre></td></tr></table></figure>

<p>轮函数每次会处理128bite的数据，会将这128bite的数据分成4个32bite的数据</p>
<p>SM4加密，每组加密的是128bit，每32bit加密之后的顺序发生了变化的</p>
<p><img src="/images/DASCTF-Oct/image-20220318193418765.png" alt="image-20220318193418765"></p>
<p>对每个8bit都用了s盒进行了处理，在内存之中找到s盒是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;0x48, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05&#125;,</span><br><span class="line">    &#123;0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99&#125;,</span><br><span class="line">    &#123;0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62&#125;,</span><br><span class="line">    &#123;0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6&#125;,</span><br><span class="line">    &#123;0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8&#125;,</span><br><span class="line">    &#123;0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35&#125;,</span><br><span class="line">    &#123;0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87&#125;,</span><br><span class="line">    &#123;0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E&#125;,</span><br><span class="line">    &#123;0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1&#125;,</span><br><span class="line">    &#123;0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3&#125;,</span><br><span class="line">    &#123;0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F&#125;,</span><br><span class="line">    &#123;0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51&#125;,</span><br><span class="line">    &#123;0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8&#125;,</span><br><span class="line">    &#123;0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0&#125;,</span><br><span class="line">    &#123;0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84&#125;,</span><br><span class="line">    &#123;0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0xD6&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const unsigned long CK[32] =</span><br><span class="line">&#123;</span><br><span class="line">    0xF4BFE18F, 0xA8AA055C, 0x8B266D2B, 0xB3819D47, 0x0B1B3A85, 0xF7DB86B6, 0xC3279F82, 0x39D9C102,</span><br><span class="line">    0xBEA224C9, 0xE75D4DAC, 0xAC61726C, 0x6F98AA6F, 0xFA2ADA4E, 0x6A7CFF92, 0xA8066E7B, 0x7BE32F9F,</span><br><span class="line">    0x8CD0FED3, 0x4B98AF71, 0x790C2CBC, 0xBF880433, 0xAA46F582, 0x69C17A2C, 0x80BBD5E4, 0x24A02531,</span><br><span class="line">    0x293D87B3, 0x75F159AD, 0xB750AE9D, 0x9886928C, 0x05577A22, 0xB425E19F, 0x124D4F63, 0xE26F66D1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="SM4解密脚本"><a href="#SM4解密脚本" class="headerlink" title="SM4解密脚本"></a>SM4解密脚本</h3><p>网上找一个SM4的c语言脚本，修改里面的Sbox，CK参数，以及将上面得到的key和解密的对象引入（但是我从网上找了两个解密的脚本，修改了里面相应的参数之后，仍然得不到想要的结果，并且在内存之中也没能找到修改之后的CK参数，希望指点指点）</p>
<p>SM.h头部文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __lk_sm4_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __lk_sm4_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpluscplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpluscplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_WORD_SIZE        32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_GCHAR_SIZE       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_GWORD_SIZE       4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>                LK_VOID;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>                 LK_INT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>        UINT;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> i386</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>   UWORD;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>       UWORD;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>   UCHAR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大端转化</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_GE(c, i) (\</span></span><br><span class="line"><span class="meta">        (c[(i)+0] &lt;&lt; 24) | ((c[(i)+1] &lt;&lt; 16)) |\</span></span><br><span class="line"><span class="meta">         (c[(i)+2] &lt;&lt; 8) | (c[(i)+3]) )</span></span><br><span class="line"><span class="comment">//小端转化</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_LE(c, n, i) &#123;\</span></span><br><span class="line"><span class="meta">        c[(i)+0] = ((n) &gt;&gt; 24) &amp; 0x000000ff;\</span></span><br><span class="line"><span class="meta">        c[(i)+1] = ((n) &gt;&gt; 16) &amp; 0x000000ff;\</span></span><br><span class="line"><span class="meta">        c[(i)+2] = ((n) &gt;&gt; 8) &amp; 0x000000ff;\</span></span><br><span class="line"><span class="meta">        c[(i)+3] = (n) &amp; 0x000000ff; &#125;</span></span><br><span class="line"><span class="comment">//循环左移</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOOPSHFT(LK_LSHIFA, LK_LSHIFN) (\</span></span><br><span class="line"><span class="meta">        ((LK_LSHIFA) &lt;&lt; (LK_LSHIFN)) | \</span></span><br><span class="line"><span class="meta">        ((LK_LSHIFA) &gt;&gt; (LK_WORD_SIZE - (LK_LSHIFN))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性变换函数L&#x27; L&#x27;(B)=B^(B&lt;&lt;&lt;13)^(B&lt;&lt;&lt;23)；</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_L0(LK_L0B) (\</span></span><br><span class="line"><span class="meta">    (LK_L0B)^(LOOPSHFT((LK_L0B), 13))^(LOOPSHFT((LK_L0B), 23)) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性变换函数L L(B) = B^(B&lt;&lt;&lt;2)^(B&lt;&lt;&lt;10)^(B&lt;&lt;&lt;18)^(B&lt;&lt;&lt;24)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_L1(LK_L1B) (\</span></span><br><span class="line"><span class="meta">    (LK_L1B)^(LOOPSHFT((LK_L1B), 2))^(LOOPSHFT((LK_L1B), 10))\</span></span><br><span class="line"><span class="meta">    ^(LOOPSHFT((LK_L1B), 18))^(LOOPSHFT((LK_L1B), 24)) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非线性变换 τ函数 (b0 , b1, b2 , b3 ) = τ (A) = ( Sbox (a0 ), Sbox (a1 ), Sbox (a2 ), Sbox (a3 ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_ST(LK_STA) (&#123;\</span></span><br><span class="line"><span class="meta">    LK_INT LK_i;\</span></span><br><span class="line"><span class="meta">    UINT LK_STB = LK_STA;\</span></span><br><span class="line"><span class="meta">    UCHAR *pcr = (UCHAR *)(&amp;LK_STB);\</span></span><br><span class="line"><span class="meta">    for (LK_i = 0; LK_i &lt; 4; LK_i++) &#123;\</span></span><br><span class="line"><span class="meta">        UCHAR high_bval = ((pcr[LK_i] &gt;&gt; 4) &amp; 0x0f);\</span></span><br><span class="line"><span class="meta">        UCHAR low_bval = (pcr[LK_i] &amp; 0x0f);\</span></span><br><span class="line"><span class="meta">        *(pcr+LK_i) = lk_sbox[high_bval][low_bval];\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    LK_STB;\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//合成置换 T  T(.)=L(τ(.))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_T1(LK_TA) (\</span></span><br><span class="line"><span class="meta">    LK_L1(LK_ST(LK_TA)) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//合成置换 T&#x27;  T&#x27;(.)=L&#x27;(τ(.))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_T0(LK_TA) (\</span></span><br><span class="line"><span class="meta">    LK_L0(LK_ST(LK_TA)) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//密钥扩展算法生成轮密钥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_SM4_INIT(lk_context, ekey) &#123;\</span></span><br><span class="line"><span class="meta">    UINT k[36], mk[4];\</span></span><br><span class="line"><span class="meta">    LK_INT i;\</span></span><br><span class="line"><span class="meta">    lk_sm4_context_t *t = (lk_sm4_context_t *)(lk_context);\</span></span><br><span class="line"><span class="meta">    memset(t, 0,sizeof(lk_sm4_context_t));\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 4; i++) &#123;\</span></span><br><span class="line"><span class="meta">        mk[i] = LK_GE(ekey, i * 4);\</span></span><br><span class="line"><span class="meta">        k[i] = mk[i]^lk_fk[i];\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 32; i++) &#123;\</span></span><br><span class="line"><span class="meta">        k[i+4] = (k[i] ^ LK_T0(k[i+1]^k[i+2]^k[i+3]^(lk_ck[i])));\</span></span><br><span class="line"><span class="meta">        t-&gt;e_rk[i] = k[i+4];\</span></span><br><span class="line"><span class="meta">        t-&gt;d_rk[31 - i] = t-&gt;e_rk[i];\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加密函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_SM4_ENC_F(lk_context) &#123;\</span></span><br><span class="line"><span class="meta">    LK_INT i;\</span></span><br><span class="line"><span class="meta">    UINT x[36];\</span></span><br><span class="line"><span class="meta">    lk_sm4_context_t *t = (lk_sm4_context_t *)(lk_context);\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 4; i++) &#123;\</span></span><br><span class="line"><span class="meta">        x[i] = LK_GE(t-&gt;buf, i * 4);\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 32; i++) &#123;\</span></span><br><span class="line"><span class="meta">        x[i + 4] = x[i]^(LK_T1(x[i+1]^x[i+2]^x[i+3]^t-&gt;e_rk[i]));\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;ebuf, x[35], 0)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;ebuf, x[34], 4)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;ebuf, x[33], 8)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;ebuf, x[32], 12)\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">//解密函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_SM4_DEC_F(lk_context) &#123;\</span></span><br><span class="line"><span class="meta">    LK_INT i;\</span></span><br><span class="line"><span class="meta">    UINT x[36];\</span></span><br><span class="line"><span class="meta">    lk_sm4_context_t *t = (lk_sm4_context_t *)(lk_context);\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 4; i++) &#123;\</span></span><br><span class="line"><span class="meta">        x[i] = LK_GE(t-&gt;ebuf, i * 4);\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 32; i++) &#123;\</span></span><br><span class="line"><span class="meta">        x[i + 4] = x[i]^LK_T1(x[i+1]^x[i+2]^x[i+3]^t-&gt;d_rk[i]);\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;buf, x[35], 0)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;buf, x[34], 4)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;buf, x[33], 8)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;buf, x[32], 12)\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lk_sm4_context_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//需要加密的明文,加密之前需要填充</span></span><br><span class="line">    UCHAR    buf[LK_GCHAR_SIZE];</span><br><span class="line">    <span class="comment">//加密之后的密文,如果是解密的话,解密之前需要填充</span></span><br><span class="line">    UCHAR    ebuf[LK_GCHAR_SIZE];</span><br><span class="line">    <span class="comment">//原密钥经过扩展之后的轮密钥,初始化接口自行填充</span></span><br><span class="line">    UINT    e_rk[LK_WORD_SIZE];</span><br><span class="line">    <span class="comment">//解密过程需要的轮密钥,初始化接口自行填充</span></span><br><span class="line">    UINT    d_rk[LK_WORD_SIZE];</span><br><span class="line">&#125; <span class="type">lk_sm4_context_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpluscplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> LK_VOID <span class="title function_">lk_sm4_enc</span><span class="params">(LK_VOID *p_context)</span>;</span><br><span class="line"><span class="keyword">extern</span> LK_VOID <span class="title function_">lk_sm4_dec</span><span class="params">(LK_VOID *p_context)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpluscplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;SM4.h&quot;</span></span><br><span class="line">//非线性转化用到的sbox对照表</span><br><span class="line">UCHAR lk_sbox[LK_GCHAR_SIZE][LK_GCHAR_SIZE] =  &#123;</span><br><span class="line">    &#123;<span class="number">0x48</span>, <span class="number">0x90</span>, <span class="number">0xE9</span>, <span class="number">0xFE</span>, <span class="number">0xCC</span>, <span class="number">0xE1</span>, <span class="number">0x3D</span>, <span class="number">0xB7</span>, <span class="number">0x16</span>, <span class="number">0xB6</span>, <span class="number">0x14</span>, <span class="number">0xC2</span>, <span class="number">0x28</span>, <span class="number">0xFB</span>, <span class="number">0x2C</span>, <span class="number">0x05</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x2B</span>, <span class="number">0x67</span>, <span class="number">0x9A</span>, <span class="number">0x76</span>, <span class="number">0x2A</span>, <span class="number">0xBE</span>, <span class="number">0x04</span>, <span class="number">0xC3</span>, <span class="number">0xAA</span>, <span class="number">0x44</span>, <span class="number">0x13</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x86</span>, <span class="number">0x06</span>, <span class="number">0x99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x9C</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x91</span>, <span class="number">0xEF</span>, <span class="number">0x98</span>, <span class="number">0x7A</span>, <span class="number">0x33</span>, <span class="number">0x54</span>, <span class="number">0x0B</span>, <span class="number">0x43</span>, <span class="number">0xED</span>, <span class="number">0xCF</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xE4</span>, <span class="number">0xB3</span>, <span class="number">0x1C</span>, <span class="number">0xA9</span>, <span class="number">0xC9</span>, <span class="number">0x08</span>, <span class="number">0xE8</span>, <span class="number">0x95</span>, <span class="number">0x80</span>, <span class="number">0xDF</span>, <span class="number">0x94</span>, <span class="number">0xFA</span>, <span class="number">0x75</span>, <span class="number">0x8F</span>, <span class="number">0x3F</span>, <span class="number">0xA6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x47</span>, <span class="number">0x07</span>, <span class="number">0xA7</span>, <span class="number">0xFC</span>, <span class="number">0xF3</span>, <span class="number">0x73</span>, <span class="number">0x17</span>, <span class="number">0xBA</span>, <span class="number">0x83</span>, <span class="number">0x59</span>, <span class="number">0x3C</span>, <span class="number">0x19</span>, <span class="number">0xE6</span>, <span class="number">0x85</span>, <span class="number">0x4F</span>, <span class="number">0xA8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x68</span>, <span class="number">0x6B</span>, <span class="number">0x81</span>, <span class="number">0xB2</span>, <span class="number">0x71</span>, <span class="number">0x64</span>, <span class="number">0xDA</span>, <span class="number">0x8B</span>, <span class="number">0xF8</span>, <span class="number">0xEB</span>, <span class="number">0x0F</span>, <span class="number">0x4B</span>, <span class="number">0x70</span>, <span class="number">0x56</span>, <span class="number">0x9D</span>, <span class="number">0x35</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x1E</span>, <span class="number">0x24</span>, <span class="number">0x0E</span>, <span class="number">0x5E</span>, <span class="number">0x63</span>, <span class="number">0x58</span>, <span class="number">0xD1</span>, <span class="number">0xA2</span>, <span class="number">0x25</span>, <span class="number">0x22</span>, <span class="number">0x7C</span>, <span class="number">0x3B</span>, <span class="number">0x01</span>, <span class="number">0x21</span>, <span class="number">0x78</span>, <span class="number">0x87</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xD4</span>, <span class="number">0x00</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x9F</span>, <span class="number">0xD3</span>, <span class="number">0x27</span>, <span class="number">0x52</span>, <span class="number">0x4C</span>, <span class="number">0x36</span>, <span class="number">0x02</span>, <span class="number">0xE7</span>, <span class="number">0xA0</span>, <span class="number">0xC4</span>, <span class="number">0xC8</span>, <span class="number">0x9E</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xEA</span>, <span class="number">0xBF</span>, <span class="number">0x8A</span>, <span class="number">0xD2</span>, <span class="number">0x40</span>, <span class="number">0xC7</span>, <span class="number">0x38</span>, <span class="number">0xB5</span>, <span class="number">0xA3</span>, <span class="number">0xF7</span>, <span class="number">0xF2</span>, <span class="number">0xCE</span>, <span class="number">0xF9</span>, <span class="number">0x61</span>, <span class="number">0x15</span>, <span class="number">0xA1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xE0</span>, <span class="number">0xAE</span>, <span class="number">0x5D</span>, <span class="number">0xA4</span>, <span class="number">0x9B</span>, <span class="number">0x34</span>, <span class="number">0x1A</span>, <span class="number">0x55</span>, <span class="number">0xAD</span>, <span class="number">0x93</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0xF5</span>, <span class="number">0x8C</span>, <span class="number">0xB1</span>, <span class="number">0xE3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x1D</span>, <span class="number">0xF6</span>, <span class="number">0xE2</span>, <span class="number">0x2E</span>, <span class="number">0x82</span>, <span class="number">0x66</span>, <span class="number">0xCA</span>, <span class="number">0x60</span>, <span class="number">0xC0</span>, <span class="number">0x29</span>, <span class="number">0x23</span>, <span class="number">0xAB</span>, <span class="number">0x0D</span>, <span class="number">0x53</span>, <span class="number">0x4E</span>, <span class="number">0x6F</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xD5</span>, <span class="number">0xDB</span>, <span class="number">0x37</span>, <span class="number">0x45</span>, <span class="number">0xDE</span>, <span class="number">0xFD</span>, <span class="number">0x8E</span>, <span class="number">0x2F</span>, <span class="number">0x03</span>, <span class="number">0xFF</span>, <span class="number">0x6A</span>, <span class="number">0x72</span>, <span class="number">0x6D</span>, <span class="number">0x6C</span>, <span class="number">0x5B</span>, <span class="number">0x51</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x8D</span>, <span class="number">0x1B</span>, <span class="number">0xAF</span>, <span class="number">0x92</span>, <span class="number">0xBB</span>, <span class="number">0xDD</span>, <span class="number">0xBC</span>, <span class="number">0x7F</span>, <span class="number">0x11</span>, <span class="number">0xD9</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x1F</span>, <span class="number">0x10</span>, <span class="number">0x5A</span>, <span class="number">0xD8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x0A</span>, <span class="number">0xC1</span>, <span class="number">0x31</span>, <span class="number">0x88</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>, <span class="number">0x7B</span>, <span class="number">0xBD</span>, <span class="number">0x2D</span>, <span class="number">0x74</span>, <span class="number">0xD0</span>, <span class="number">0x12</span>, <span class="number">0xB8</span>, <span class="number">0xE5</span>, <span class="number">0xB4</span>, <span class="number">0xB0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x89</span>, <span class="number">0x69</span>, <span class="number">0x97</span>, <span class="number">0x4A</span>, <span class="number">0x0C</span>, <span class="number">0x96</span>, <span class="number">0x77</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0xB9</span>, <span class="number">0xF1</span>, <span class="number">0x09</span>, <span class="number">0xC5</span>, <span class="number">0x6E</span>, <span class="number">0xC6</span>, <span class="number">0x84</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x18</span>, <span class="number">0xF0</span>, <span class="number">0x7D</span>, <span class="number">0xEC</span>, <span class="number">0x3A</span>, <span class="number">0xDC</span>, <span class="number">0x4D</span>, <span class="number">0x20</span>, <span class="number">0x79</span>, <span class="number">0xEE</span>, <span class="number">0x5F</span>, <span class="number">0x3E</span>, <span class="number">0xD7</span>, <span class="number">0xCB</span>, <span class="number">0x39</span>, <span class="number">0xD6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//系统参数FK</span><br><span class="line">UINT lk_fk[<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="number">0xA3B1BAC6</span>,<span class="number">0x56AA3350</span>,</span><br><span class="line">    <span class="number">0x677D9197</span>,<span class="number">0xB27022DC</span></span><br><span class="line">&#125;;</span><br><span class="line">//固定参数CK</span><br><span class="line">UINT lk_ck[<span class="number">32</span>] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="number">0xF4BFE18F</span>, <span class="number">0xA8AA055C</span>, <span class="number">0x8B266D2B</span>, <span class="number">0xB3819D47</span>, <span class="number">0x0B1B3A85</span>, <span class="number">0xF7DB86B6</span>, <span class="number">0xC3279F82</span>, <span class="number">0x39D9C102</span>,</span><br><span class="line">    <span class="number">0xBEA224C9</span>, <span class="number">0xE75D4DAC</span>, <span class="number">0xAC61726C</span>, <span class="number">0x6F98AA6F</span>, <span class="number">0xFA2ADA4E</span>, <span class="number">0x6A7CFF92</span>, <span class="number">0xA8066E7B</span>, <span class="number">0x7BE32F9F</span>,</span><br><span class="line">    <span class="number">0x8CD0FED3</span>, <span class="number">0x4B98AF71</span>, <span class="number">0x790C2CBC</span>, <span class="number">0xBF880433</span>, <span class="number">0xAA46F582</span>, <span class="number">0x69C17A2C</span>, <span class="number">0x80BBD5E4</span>, <span class="number">0x24A02531</span>,</span><br><span class="line">    <span class="number">0x293D87B3</span>, <span class="number">0x75F159AD</span>, <span class="number">0xB750AE9D</span>, <span class="number">0x9886928C</span>, <span class="number">0x05577A22</span>, <span class="number">0xB425E19F</span>, <span class="number">0x124D4F63</span>, <span class="number">0xE26F66D1</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LK_VOID lk_sm4_init(LK_VOID *p_context, UCHAR *ekey)</span><br><span class="line">&#123;</span><br><span class="line">    //进行密钥扩展,生成轮转密钥rk</span><br><span class="line">    LK_SM4_INIT(p_context, ekey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LK_VOID lk_sm4_enc(LK_VOID *p_context)</span><br><span class="line">&#123;</span><br><span class="line">    LK_SM4_ENC_F(p_context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LK_VOID lk_sm4_dec(LK_VOID *p_context)</span><br><span class="line">&#123;</span><br><span class="line">    LK_SM4_DEC_F(p_context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LK_INT main(LK_VOID)</span><br><span class="line">&#123;</span><br><span class="line">    LK_INT i;</span><br><span class="line">    lk_sm4_context_t context;</span><br><span class="line">    UCHAR ekey[<span class="number">16</span>] = &#123; <span class="number">0x0b</span>,<span class="number">0x18</span>,<span class="number">0x18</span>,<span class="number">0x29</span>,<span class="number">0x16</span>,<span class="number">0x3a</span>,<span class="number">0x5e</span>,<span class="number">0x27</span>,<span class="number">0x1e</span>,<span class="number">0x2b</span>,<span class="number">0x5f</span>,<span class="number">0x3f</span>,<span class="number">0x32</span>,<span class="number">0x07</span>,<span class="number">0x5c</span>,<span class="number">0x56</span> &#125;;</span><br><span class="line">    UCHAR data[<span class="number">16</span>] = &#123; <span class="number">0xf7</span>,<span class="number">0xeb</span>,<span class="number">0x5e</span>,<span class="number">0x87</span>,<span class="number">0x17</span>,<span class="number">0x9c</span>,<span class="number">0x74</span>,<span class="number">0x94</span>,<span class="number">0x44</span>,<span class="number">0xb5</span>,<span class="number">0xf5</span>,<span class="number">0x12</span>,<span class="number">0xf9</span>,<span class="number">0x74</span>,<span class="number">0x15</span>,<span class="number">0x5f</span> &#125;;</span><br><span class="line">    //初始化</span><br><span class="line">    lk_sm4_init(&amp;context, ekey);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    //待加密数据填充</span><br><span class="line">//    memcpy(context.buf, data, sizeof(data));</span><br><span class="line">//    //对数据进行加密</span><br><span class="line">//    lk_sm4_enc(&amp;context);</span><br><span class="line">//    //打印密文值</span><br><span class="line">//    printf(<span class="string">&quot;enc data:&quot;</span>);</span><br><span class="line">//    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LK_GCHAR_SIZE; i++)</span><br><span class="line">//        printf(<span class="string">&quot; %02x &quot;</span>, context.ebuf[i]);</span><br><span class="line">//    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //待解密的对象</span><br><span class="line">    printf(<span class="string">&quot;enc data：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sizeof(data) ; i++)</span><br><span class="line">        printf(<span class="string">&quot; %02x &quot;</span>, data[i]);</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    //对数据进行解密</span><br><span class="line">    memcpy(context.ebuf, data, sizeof(data));</span><br><span class="line">    lk_sm4_dec(&amp;context);</span><br><span class="line">    //打印解密数据</span><br><span class="line">    printf(<span class="string">&quot;dec data:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LK_GCHAR_SIZE; i++)</span><br><span class="line">        printf(<span class="string">&quot; %02x &quot;</span>, context.buf[i]);</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/images/DASCTF-Oct/image-20220320092347815.png" alt="image-20220320092347815"></p>
<p>misc  <a href="https://jxswcy.top/da212791.html">DASCTF Oct X writeup | jxswcy’s blog</a></p>
<h2 id="魔法叠加"><a href="#魔法叠加" class="headerlink" title="魔法叠加"></a>魔法叠加</h2><p>知识点：</p>
<blockquote>
<ul>
<li>pyc文件头部（py3.7）</li>
<li>base91解密</li>
</ul>
</blockquote>
<h3 id="修改pyc头部"><a href="#修改pyc头部" class="headerlink" title="修改pyc头部"></a>修改pyc头部</h3><p>文件头部修改成如图所示 这里是python3.7</p>
<p>这个pyc是python3.7的版本 ，所以修改magic头部为 42 0D，后面34 改为32，因为要减去两个多出来的字节</p>
<p><img src="/images/DASCTF-Oct/image-20220319095943868.png" alt="image-20220319095943868"></p>
<p>在网上找到一个pyc的文件头部（对比着来修改）<img src="/images/DASCTF-Oct/image-20220319102000542.png" alt="image-20220319102000542"></p>
<h3 id="unemployee6反编译"><a href="#unemployee6反编译" class="headerlink" title="unemployee6反编译"></a>unemployee6反编译</h3><p>修改完pyc的文件头部之后，用unemployee6进行反编译（看到下面的命名方式，可以自行修改一下命名）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uncompyle6 version 3.8.1.dev0</span></span><br><span class="line"><span class="comment"># Python bytecode 3.7.0 (3394)</span></span><br><span class="line"><span class="comment"># Decompiled from: Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)]</span></span><br><span class="line"><span class="comment"># Embedded file name: ./2.py</span></span><br><span class="line"><span class="comment"># Compiled at: 2021-10-20 11:56:04</span></span><br><span class="line"><span class="comment"># Size of source mod 2**32: 1928 bytes</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">O0O00O00O00O0O00O = [</span><br><span class="line"> <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;@&#x27;</span>, <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;`&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;~&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">O000O00000OO00OOO</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">    OOOO00OOO00O000OO = <span class="number">0</span></span><br><span class="line">    OOOOOOOOOO00O0OOO = <span class="number">0</span></span><br><span class="line">    OO0OOO000000OOOOO = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> O0O0OO0OOOOOOOO00 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(O000O00000OO00OOO)):</span><br><span class="line">        O000O0OOOOO00O0O0 = O000O00000OO00OOO[O0O0OO0OOOOOOOO00:O0O0OO0OOOOOOOO00 + <span class="number">1</span>]</span><br><span class="line">        OOOO00OOO00O000OO |= struct.unpack(<span class="string">&#x27;B&#x27;</span>, O000O0OOOOO00O0O0)[<span class="number">0</span>] &lt;&lt; OOOOOOOOOO00O0OOO</span><br><span class="line">        OOOOOOOOOO00O0OOO += <span class="number">8</span></span><br><span class="line">        <span class="keyword">if</span> OOOOOOOOOO00O0OOO &gt; <span class="number">13</span>:</span><br><span class="line">            OO00O0OO00OOO000O = OOOO00OOO00O000OO &amp; <span class="number">8191</span></span><br><span class="line">            <span class="keyword">if</span> OO00O0OO00OOO000O &gt; <span class="number">88</span>:</span><br><span class="line">                OOOO00OOO00O000OO &gt;&gt;= <span class="number">13</span></span><br><span class="line">                OOOOOOOOOO00O0OOO -= <span class="number">13</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                OO00O0OO00OOO000O = OOOO00OOO00O000OO &amp; <span class="number">16383</span></span><br><span class="line">                OOOO00OOO00O000OO &gt;&gt;= <span class="number">14</span></span><br><span class="line">                OOOOOOOOOO00O0OOO -= <span class="number">14</span></span><br><span class="line">            OO0OOO000000OOOOO += O0O00O00O00O0O0O0[(OO00O0OO00OOO000O % <span class="number">91</span>)] + O0O00O00O00O0O0O0[(OO00O0OO00OOO000O // <span class="number">91</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> OOOOOOOOOO00O0OOO:</span><br><span class="line">        OO0OOO000000OOOOO += O0O00O00O00O0O0O0[(OOOO00OOO00O000OO % <span class="number">91</span>)]</span><br><span class="line">        <span class="keyword">if</span> OOOOOOOOOO00O0OOO &gt; <span class="number">7</span> <span class="keyword">or</span> OOOO00OOO00O000OO &gt; <span class="number">90</span>:</span><br><span class="line">            OO0OOO000000OOOOO += O0O00O00O00O0O0O0[(OOOO00OOO00O000OO // <span class="number">91</span>)]</span><br><span class="line">    <span class="keyword">return</span> OO0OOO000000OOOOO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O0O00O00O00O0O0O0 = []</span><br><span class="line">OO000O00O00O0O0O0 = []</span><br><span class="line">O0O0O0O0000O0O00O = <span class="built_in">input</span>(<span class="string">&#x27;plz input O0O0O0O0000O0O00O:\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">52</span>):</span><br><span class="line">    O0O00O00O00O0O0O0 = O0O00O00O00O0O00O[i:] + O0O00O00O00O0O00O[<span class="number">0</span>:i]</span><br><span class="line">    O0O0O0O0000O0O00O = encode(O0O0O0O0000O0O00O.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">dic = <span class="built_in">open</span>(<span class="string">&#x27;./00.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">dic.write(O0O0O0O0000O0O00O)</span><br><span class="line">dic.close</span><br><span class="line"><span class="comment"># okay decompiling D:\re\buuctf\buu\ħ������\magic.pyc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面给的数组的长度是91 并且每次模的对象也是91，所以这里应该是[base91](<a href="https://github.com/aberaud/base91-python">aberaud/base91-python: A python implementation of Base91 as described on http://base91.sourceforge.net/ (github.com)</a>)</p>
<p>整理得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct</span><br><span class="line">key = [</span><br><span class="line"> &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;!&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;, &#x27;&quot;&#x27;]</span><br><span class="line"></span><br><span class="line">def encode(num):</span><br><span class="line">    &quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">    tem1 = 0</span><br><span class="line">    tem2 = 0</span><br><span class="line">    temstr = &#x27;&#x27;</span><br><span class="line">    for i in range(len(num)):</span><br><span class="line">        tem = num[i:i + 1]</span><br><span class="line">        tem1 |= struct.unpack(&#x27;B&#x27;, tem)[0] &lt;&lt; tem2</span><br><span class="line">        tem2 += 8</span><br><span class="line">        if tem2 &gt; 13:</span><br><span class="line">            tem0 = tem1 &amp; 8191</span><br><span class="line">            if tem0 &gt; 88:</span><br><span class="line">                tem1 &gt;&gt;= 13</span><br><span class="line">                tem2 -= 13</span><br><span class="line">            else:</span><br><span class="line">                tem0 = tem1 &amp; 16383</span><br><span class="line">                tem1 &gt;&gt;= 14</span><br><span class="line">                tem2 -= 14</span><br><span class="line">            temstr += key2[(tem0 % 91)] + key2[(tem0 // 91)]</span><br><span class="line"></span><br><span class="line">    if tem2:</span><br><span class="line">        temstr += key2[(tem1 % 91)]</span><br><span class="line">        if tem2 &gt; 7 or tem1 &gt; 90:</span><br><span class="line">            temstr += key2[(tem1 // 91)]</span><br><span class="line">    return temstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key2 = []</span><br><span class="line">OO000O00O00O0O0O0 = []</span><br><span class="line">text = input(&#x27;plz input text:\n&#x27;)</span><br><span class="line">for i in range(0, 52):</span><br><span class="line">    key2 = key[i:] + key[0:i]</span><br><span class="line">    text = encode(text.encode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">dic = open(&#x27;./00.txt&#x27;, &#x27;a&#x27;)</span><br><span class="line">dic.write(text)</span><br><span class="line">dic.close</span><br></pre></td></tr></table></figure>

<h3 id="base91的解密"><a href="#base91的解密" class="headerlink" title="base91的解密"></a>base91的解密</h3><p>加密解密base91的<strong>官方文档</strong>（注意每个函数参数类型）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct</span><br><span class="line"></span><br><span class="line">base91_alphabet = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;,</span><br><span class="line">	&#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;,</span><br><span class="line">	&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;,</span><br><span class="line">	&#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;,</span><br><span class="line">	&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;!&#x27;, &#x27;#&#x27;, &#x27;$&#x27;,</span><br><span class="line">	&#x27;%&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;,</span><br><span class="line">	&#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;, &#x27;&quot;&#x27;]</span><br><span class="line"></span><br><span class="line">decode_table = dict((v,k) for k,v in enumerate(base91_alphabet))</span><br><span class="line"></span><br><span class="line">def decode(encoded_str):</span><br><span class="line">    &#x27;&#x27;&#x27; Decode Base91 string to a bytearray &#x27;&#x27;&#x27;</span><br><span class="line">    v = -1</span><br><span class="line">    b = 0</span><br><span class="line">    n = 0</span><br><span class="line">    out = bytearray()</span><br><span class="line">    for strletter in encoded_str:</span><br><span class="line">        if not strletter in decode_table:</span><br><span class="line">            continue</span><br><span class="line">        c = decode_table[strletter]</span><br><span class="line">        if(v &lt; 0):</span><br><span class="line">            v = c</span><br><span class="line">        else:</span><br><span class="line">            v += c*91</span><br><span class="line">            b |= v &lt;&lt; n</span><br><span class="line">            n += 13 if (v &amp; 8191)&gt;88 else 14</span><br><span class="line">            while True:</span><br><span class="line">                out += struct.pack(&#x27;B&#x27;, b&amp;255)</span><br><span class="line">                b &gt;&gt;= 8</span><br><span class="line">                n -= 8</span><br><span class="line">                if not n&gt;7:</span><br><span class="line">                    break</span><br><span class="line">            v = -1</span><br><span class="line">    if v+1:</span><br><span class="line">        out += struct.pack(&#x27;B&#x27;, (b | v &lt;&lt; n) &amp; 255 )</span><br><span class="line">    return out</span><br><span class="line"></span><br><span class="line">def encode(bindata):</span><br><span class="line">    &#x27;&#x27;&#x27; Encode a bytearray to a Base91 string &#x27;&#x27;&#x27;</span><br><span class="line">    b = 0</span><br><span class="line">    n = 0</span><br><span class="line">    out = &#x27;&#x27;</span><br><span class="line">    for count in range(len(bindata)):</span><br><span class="line">        byte = bindata[count:count+1]</span><br><span class="line">        b |= struct.unpack(&#x27;B&#x27;, byte)[0] &lt;&lt; n</span><br><span class="line">        n += 8</span><br><span class="line">        if n&gt;13:</span><br><span class="line">            v = b &amp; 8191</span><br><span class="line">            if v &gt; 88:</span><br><span class="line">                b &gt;&gt;= 13</span><br><span class="line">                n -= 13</span><br><span class="line">            else:</span><br><span class="line">                v = b &amp; 16383</span><br><span class="line">                b &gt;&gt;= 14</span><br><span class="line">                n -= 14</span><br><span class="line">            out += base91_alphabet[v % 91] + base91_alphabet[v // 91]</span><br><span class="line">    if n:</span><br><span class="line">        out += base91_alphabet[b % 91]</span><br><span class="line">        if n&gt;7 or b&gt;90:</span><br><span class="line">            out += base91_alphabet[b // 91]</span><br><span class="line">    return out</span><br></pre></td></tr></table></figure>

<p>通过上面的循环我们可以知道一共进行了52次循环，所以利用对应每次变换得到的表进行每次的base91的解密</p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct</span><br><span class="line">base91_alphabet = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;,</span><br><span class="line">	&#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;,</span><br><span class="line">	&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;,</span><br><span class="line">	&#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;,</span><br><span class="line">	&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;!&#x27;, &#x27;#&#x27;, &#x27;$&#x27;,</span><br><span class="line">	&#x27;%&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;,</span><br><span class="line">	&#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;, &#x27;&quot;&#x27;]</span><br><span class="line"></span><br><span class="line">def decode(encoded_str):</span><br><span class="line">    &#x27;&#x27;&#x27; Decode Base91 string to a bytearray &#x27;&#x27;&#x27;</span><br><span class="line">    v = -1</span><br><span class="line">    b = 0</span><br><span class="line">    n = 0</span><br><span class="line">    out = b&#x27;&#x27;</span><br><span class="line">    for strletter in encoded_str():   </span><br><span class="line">        if not strletter in decode_table:</span><br><span class="line">            continue</span><br><span class="line">        c = decode_table[strletter]</span><br><span class="line">        if(v &lt; 0):</span><br><span class="line">            v = c</span><br><span class="line">        else:</span><br><span class="line">            v += c*91</span><br><span class="line">            b |= v &lt;&lt; n</span><br><span class="line">            n += 13 if (v &amp; 8191)&gt;88 else 14</span><br><span class="line">            while True:</span><br><span class="line">                out += struct.pack(&#x27;B&#x27;, b&amp;255)</span><br><span class="line">                b &gt;&gt;= 8</span><br><span class="line">                n -= 8</span><br><span class="line">                if not n&gt;7:</span><br><span class="line">                    break</span><br><span class="line">            v = -1</span><br><span class="line">    if v+1:</span><br><span class="line">        out += struct.pack(&#x27;B&#x27;, (b | v &lt;&lt; n) &amp; 255 )</span><br><span class="line">    return out</span><br><span class="line"></span><br><span class="line">with open(&quot;D:\\re\\buuctf\\buu\魔法叠加\\00.txt&quot;,&#x27;rb&#x27;) as f:</span><br><span class="line">    data = f.read()</span><br><span class="line">for i in range(51,-1,-1):</span><br><span class="line">    tem  = base91_alphabet[i:] + base91_alphabet[0:i]</span><br><span class="line">    decode_table = dict((v, k) for k, v in enumerate(tem))</span><br><span class="line">    data = decode(data.decode()) # 该函数之中传入的参数应该是字符串型 但是我们得到的是byte类型 所以需要decoed() 将byte转换成string类型的数据</span><br><span class="line">    print(i)</span><br><span class="line">print(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意byte 和 石头人相互转换的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># str to bytes</span><br><span class="line"> str.encode(s)</span><br><span class="line"></span><br><span class="line"> # bytes to str</span><br><span class="line"> bytes.decode(b)</span><br></pre></td></tr></table></figure>

<p>因为解密的长度太长了，所以就直接用别人跑出来的结果</p>
<p><img src="/images/DASCTF-Oct/image-20220319124833684.png" alt="image-20220319124833684"></p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>base91解密</tag>
        <tag>SM4解密</tag>
      </tags>
  </entry>
  <entry>
    <title>HFCTF2022_theShellcode</title>
    <url>/2022/04/15/HFCTF2022-theShellcode/</url>
    <content><![CDATA[<h2 id="the-shellcode"><a href="#the-shellcode" class="headerlink" title="the_shellcode"></a>the_shellcode</h2><p>用ida载入之后，显然这个地方被加壳了，这里是Themida壳</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220322202138711.png" alt="image-20220322202138711"></p>
<h3 id="定位到OPE"><a href="#定位到OPE" class="headerlink" title="定位到OPE"></a>定位到OPE</h3><p>这是是使用插件直接反反调试</p>
<h4 id="sharpOD"><a href="#sharpOD" class="headerlink" title="sharpOD"></a>sharpOD</h4><p>安装<a href="https://bbs.pediy.com/thread-218988.htm">sharpOD</a>，设置其中的配置：主要时要勾上图中标注的那个选项（这个可以去程序中的反调试）</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415130826836.png" alt="image-20220415130826836"></p>
<p>按f9就能够运行起程序，就能够运行起程序了</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415131021698.png" alt="image-20220415131021698"></p>
<h4 id="OPE定位并且下硬件断点"><a href="#OPE定位并且下硬件断点" class="headerlink" title="OPE定位并且下硬件断点"></a>OPE定位并且下硬件断点</h4><p>按E打开可执行模块窗口</p>
<blockquote>
<p>可执行模块窗口:（快捷键：<strong>Alt+E</strong>）列出了当前被调试进程加载的所有可执行模块。它也显示了很多有用的信息，比如模块大小、入口地址、模块版本、以及可执行文件路径等。</p>
</blockquote>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415131149355.png" alt="image-20220415131149355"></p>
<p>打开该模块我们看到时一堆乱码，在这里我们需要去掉模块分析（汇编窗口，右键  -&gt; 分析 -&gt; 从模块中删除分析）</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415132210877.png" alt="image-20220415132210877"></p>
<p>通过查找程序执行时输出的字符串 “please input the shellcode:” 定位到程序的正真入口的地方</p>
<p>右键-&gt;Search for -&gt; All referenced text strings </p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415132424418.png" alt="image-20220415132424418"></p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415132625126.png" alt="image-20220415132625126"></p>
<p>通过上面的字符串表我们就到达了程序的入口处了 push ebp的位置，我们就直接在这个地方下断点（方便之后直接定位到程序的入口）</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415132847653.png" alt="image-20220415132847653"></p>
<p>这个地方需要下硬件断点，这样定位到的才是这个代码的位置(因为重调之后这片数据又会成为未解压缩的状态)，程序的入口的位置是 0x9111c0</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415133232350.png" alt="image-20220415133232350"></p>
<p>再次运行程序就能够直接到达程序的入口点位置了</p>
<h3 id="dump和修复IAT表"><a href="#dump和修复IAT表" class="headerlink" title="dump和修复IAT表"></a>dump和修复IAT表</h3><p>直接dump下来的程序中的函数不能简单明了的知道它的作用，修复之后的代码更易懂</p>
<h4 id="直接dump程序"><a href="#直接dump程序" class="headerlink" title="直接dump程序"></a>直接dump程序</h4><p>使用Ollydump就可以将程序dump下来</p>
<p>在内存映射窗口查看起始地址 为910000</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415140509813.png" alt="image-20220415140509813"></p>
<p>设置起始地址和入口点地址，注意入口点位置是偏移地址</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415140738089.png" alt="image-20220415140738089"></p>
<p>因为这个程序里面的输入表有修改，所以这个地方dump出来的程序是不能够运行的</p>
<p>将dump出来的这个程序放入ida之中查看，通过字符串定位到关键代码的位置</p>
<p>这里的符号表没有修复，所以程序里面的函数不知道其含义，作用</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415141612009.png" alt="image-20220415141612009"></p>
<p>未修复的IAT表，已经修复的是能够直接知道函数的作用的，未修复的是直接用地址作为函数名的</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415142913315.png" alt="image-20220415142913315"></p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415143302046.png" alt="image-20220415143302046"></p>
<p>可以看到未修复的IAT就是通过不断地跳转到达目标函数地位置，动态调试地方式跟一下看一下函数地执行过程</p>
<h4 id="跟未修复的IAT表的过程"><a href="#跟未修复的IAT表的过程" class="headerlink" title="跟未修复的IAT表的过程"></a>跟未修复的IAT表的过程</h4><p>我们要跟地是未修复地，图中地第一个函数，可以知道它是已经修复地，第二个是未修复地，所以我们要跟进地是第二个</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415144031639.png" alt="image-20220415144031639"></p>
<p>F7跟进之后可以看到又是一个跳转，没有到达目标地代码</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415144320314.png" alt="image-20220415144320314"></p>
<p>又跟进入，又是一个跳转</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415144349910.png" alt="image-20220415144349910"></p>
<p>又跟进去，在这个页面之中我们Ctrl+F9,到达ret的地方</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415144516292.png" alt="image-20220415144516292"></p>
<p>查看它的堆栈，就看到它真正调用的函数名称</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415144604045.png" alt="image-20220415144604045"></p>
<p>通过这样的特性，我们编写脚本进行修复</p>
<h4 id="修复IAT表（脚本-Scylla）"><a href="#修复IAT表（脚本-Scylla）" class="headerlink" title="修复IAT表（脚本+Scylla）"></a>修复IAT表（脚本+Scylla）</h4><p>去掉不需要修复的IAT:</p>
<ul>
<li>IAT已经到达结束位置</li>
<li>IAT大于72C0 0000（说明IAT是正确指向）</li>
<li>IAT表的值为0（就不需要修复了）</li>
</ul>
<p>脚本：（从上面我能知道我的基址是0x910000）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VAR OEP</span><br><span class="line">MOV OEP, 009111C0     </span><br><span class="line"></span><br><span class="line">VAR IATAddr</span><br><span class="line">VAR tmpAddr</span><br><span class="line">MOV IATAddr, 00912FFC  </span><br><span class="line"></span><br><span class="line">RepairIATTable:</span><br><span class="line">  ADD IATAddr, 4</span><br><span class="line">  MOV tmpAddr, [IATAddr]</span><br><span class="line">  CMP tmpAddr, 72C00000  // IAT的正确指向</span><br><span class="line">  JA RepairIATTable      // 无符号大于则跳转（大于 72C00000 这个地址是正确的IAT）</span><br><span class="line">   </span><br><span class="line">  CMP tmpAddr, 0        // IAT的值是0 这个不需要修复</span><br><span class="line">  JE RepairIATTable     // 等于则跳转（如果是等于0是没必要修复的）</span><br><span class="line"></span><br><span class="line">  MOV eip, tmpAddr</span><br><span class="line">  RTR</span><br><span class="line">  MOV [IATAddr], [esp]</span><br><span class="line">  CMP IATAddr, 009130E0   // 已经到达结束位置</span><br><span class="line">  JAE Success             // 无符号大于等于则跳转（当大于这个结束的位置是错误的需要进行修复）</span><br><span class="line">  JMP RepairIATTable   // JMP 无条件跳转</span><br><span class="line"></span><br><span class="line">Success:</span><br><span class="line">  MOV eip, OEP</span><br><span class="line">  RET</span><br></pre></td></tr></table></figure>

<p>运行完之后我们就能看到IAT被修复了</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415150518388.png" alt="image-20220415150518388"></p>
<p>现在就需要使用，[Scylla](<a href="https://tool.pediy.com/index-detail-26.htm">输入表 (pediy.com)</a>)修复一下这个IAT表，再dump出来</p>
<p>用管理员权限打开Scylla x86，设置入口点，获得IAT表</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415154056291.png" alt="image-20220415154056291"></p>
<p>得到输入表，并且删除破坏的表</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415154211083.png" alt="image-20220415154211083"></p>
<p>先将程序 Dump，再对应dump下来的程序 Fix Dump</p>
<p>用ida打开这个修复的文件</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415154525798.png" alt="image-20220415154525798"></p>
<p>再打开程序除去作者编译的时候去掉的符号表，其它的IAT就被修复好了</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415154727563.png" alt="image-20220415154727563"></p>
<h3 id="代码分析1"><a href="#代码分析1" class="headerlink" title="代码分析1"></a>代码分析1</h3><h4 id="xxtea解密"><a href="#xxtea解密" class="headerlink" title="xxtea解密"></a>xxtea解密</h4><p>xxtea加密，但是注意里面有变形</p>
<p>对比标准的xxtea的MX：MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</p>
<p>这里的变形成：MX (((z&gt;&gt;6^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415163307268.png" alt="image-20220415163307268"></p>
<p>key值：116,111,114,97</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415163538840.png" alt="image-20220415163538840"></p>
<p>xxtea对比的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x4b6b89a1,0x74c15453,0x4092a06e,0x429b0c07,0x40281e84,0x8b5b44c9,0x66feb37b,0x3c77a603,0x79c5892d,</span><br><span class="line">0x0d7ada97,0x1d51aa56,0x02d4d703,0x4fa526ba,0x32fad64a,0x0c0f6091,0x562b7593,0xdb9add67,0x76165563,</span><br><span class="line">0xa5f79315,0x3aeb991d,0x1ab721d4,0xaacd9d2c,0x825c2b27,0x76a7761a,0xb4005f18,0x117f3763,0x512cc540,</span><br><span class="line">0xc594a16f,0xd0e24f8c,0x9ca3e2e9,0x0a9cc2d5,0x4629e61d,0x637129e3,0xca4e8ad7,0xf5dfaf71,0x474e68ab,</span><br><span class="line">0x542fbc3a,0xd6741617,0xad0dbbe5,0x62f7bbe3,0xc8d68c07,0x880e950e,0xf80f25ba,0x767a264c,0x9a7ce014,</span><br><span class="line">0x5c8bc9ee,0x5d9ef7d4,0xb999acde,0xb2ec8e13,0xee68232d,0x927c5fce,0xc9e3a85d,0xac74b56b,0x42b6e712,</span><br><span class="line">0xcd2898da,0xfcf11c58,0xf57075ee,0x5076e678,0xd4d66a35,0x95105ab9,0x1bb04403,0xb240b959,0x7b4e261a,</span><br><span class="line">0x23d129d8,0xf5e752cd,0x4ea78f70</span><br></pre></td></tr></table></figure>

<p>xxtea的key:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">116,111,114,97</span><br></pre></td></tr></table></figure>

<p>xxtea解密脚本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z&gt;&gt;6^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+<span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rolR</span><span class="params">(<span class="type">uint32_t</span> tem)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">67</span>]= &#123;<span class="number">0x4b6b89a1</span>,<span class="number">0x74c15453</span>,<span class="number">0x4092a06e</span>,<span class="number">0x429b0c07</span>,<span class="number">0x40281e84</span>,<span class="number">0x8b5b44c9</span>,<span class="number">0x66feb37b</span>,<span class="number">0x3c77a603</span>,<span class="number">0x79c5892d</span>,<span class="number">0x0d7ada97</span>,<span class="number">0x1d51aa56</span>,<span class="number">0x02d4d703</span>,<span class="number">0x4fa526ba</span>,<span class="number">0x32fad64a</span>,<span class="number">0x0c0f6091</span>,<span class="number">0x562b7593</span>,<span class="number">0xdb9add67</span>,<span class="number">0x76165563</span>,<span class="number">0xa5f79315</span>,<span class="number">0x3aeb991d</span>,<span class="number">0x1ab721d4</span>,<span class="number">0xaacd9d2c</span>,<span class="number">0x825c2b27</span>,<span class="number">0x76a7761a</span>,<span class="number">0xb4005f18</span>,<span class="number">0x117f3763</span>,<span class="number">0x512cc540</span>,<span class="number">0xc594a16f</span>,<span class="number">0xd0e24f8c</span>,<span class="number">0x9ca3e2e9</span>,<span class="number">0x0a9cc2d5</span>,<span class="number">0x4629e61d</span>,<span class="number">0x637129e3</span>,<span class="number">0xca4e8ad7</span>,<span class="number">0xf5dfaf71</span>,<span class="number">0x474e68ab</span>,<span class="number">0x542fbc3a</span>,<span class="number">0xd6741617</span>,<span class="number">0xad0dbbe5</span>,<span class="number">0x62f7bbe3</span>,<span class="number">0xc8d68c07</span>,<span class="number">0x880e950e</span>,<span class="number">0xf80f25ba</span>,<span class="number">0x767a264c</span>,<span class="number">0x9a7ce014</span>,<span class="number">0x5c8bc9ee</span>,<span class="number">0x5d9ef7d4</span>,<span class="number">0xb999acde</span>,<span class="number">0xb2ec8e13</span>,<span class="number">0xee68232d</span>,<span class="number">0x927c5fce</span>,<span class="number">0xc9e3a85d</span>,<span class="number">0xac74b56b</span>,<span class="number">0x42b6e712</span>,<span class="number">0xcd2898da</span>,<span class="number">0xfcf11c58</span>,<span class="number">0xf57075ee</span>,<span class="number">0x5076e678</span>,<span class="number">0xd4d66a35</span>,<span class="number">0x95105ab9</span>,<span class="number">0x1bb04403</span>,<span class="number">0xb240b959</span>,<span class="number">0x7b4e261a</span>,<span class="number">0x23d129d8</span>,<span class="number">0xf5e752cd</span>,<span class="number">0x4ea78f70</span>,<span class="number">0x0</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= &#123;<span class="number">116</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n= <span class="number">66</span>; <span class="comment">//n的绝对值表示v的长度，取正表示加密，取负表示解密</span></span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">66</span>;i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0x%x,&quot;</span>,(<span class="type">uint32_t</span> *)v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xxtea解密之后的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x6243e703,0x993831bb,0x925c2396,0x60925c81,0x5ca0925c,0xbd784193,</span><br><span class="line">0xff993152,0xe1650699,0x6110e30b,0x687e0e01,0x8717c718,0x925cba92,</span><br><span class="line">0xe1125c80,0x25c1618,0x78062cc3,0xf524,0x82161800,0x5cc0425c,</span><br><span class="line">0xd61801c2,0x7800cf1c,0x4d24,0xa15c4a00,0x9997185c,0x650699ff,</span><br><span class="line">0x18687e0e,0xab26d1c7,0x21e318a7,0x21e3d920,0x99ceab60,0x1c4e99ff,</span><br><span class="line">0xb5788216,0x7e0e5020,0xac71868,0xab70cf1c,0x687e0e8f,0x99ff99ba,</span><br><span class="line">0x21a25c4e,0xb57892e1,0x3bc570e0,0xbf333333,0x5cd78e5f,0xf8470e16,</span><br><span class="line">0x206c1618,0xd2c65904,0x5020b578,0x7e0e1e59,0xac71868,0xab70cf1c,</span><br><span class="line">0x687e0ea6,0xa321e1d9,0x9b2943b0,0x265c0000,0x7b7343,0x5c82a200,</span><br><span class="line">0xff4221e2,0x43a05f9e,0x9b29,0xcb43265c,0xa2009b2b,0x21e25c82,</span><br><span class="line">0xc29eff42,0xc2c2c2c2,0xc2c2c2c2,0xfac21e0b,0x4f905cd2,0xffffff58</span><br></pre></td></tr></table></figure>

<h4 id="循环右移"><a href="#循环右移" class="headerlink" title="循环右移"></a>循环右移</h4><p>循环右移3位：（每8位数）</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415203305044.png" alt="image-20220415203305044"></p>
<p>脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">src = [<span class="number">0x03</span>,<span class="number">0xe7</span>,<span class="number">0x43</span>,<span class="number">0x62</span>,<span class="number">0xbb</span>,<span class="number">0x31</span>,<span class="number">0x38</span>,<span class="number">0x99</span>,<span class="number">0x96</span>,<span class="number">0x23</span>,<span class="number">0x5c</span>,<span class="number">0x92</span>,<span class="number">0x81</span>,<span class="number">0x5c</span>,<span class="number">0x92</span>,<span class="number">0x60</span>,<span class="number">0x5c</span>,<span class="number">0x92</span>,<span class="number">0xa0</span>,<span class="number">0x5c</span>,<span class="number">0x93</span>,<span class="number">0x41</span>,<span class="number">0x78</span>,<span class="number">0xbd</span>,<span class="number">0x52</span>,<span class="number">0x31</span>,<span class="number">0x99</span>,<span class="number">0xff</span>,<span class="number">0x99</span>,<span class="number">0x06</span>,<span class="number">0x65</span>,<span class="number">0xe1</span>,<span class="number">0x0b</span>,<span class="number">0xe3</span>,<span class="number">0x10</span>,<span class="number">0x61</span>,<span class="number">0x01</span>,<span class="number">0x0e</span>,<span class="number">0x7e</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0xc7</span>,<span class="number">0x17</span>,<span class="number">0x87</span>,<span class="number">0x92</span>,<span class="number">0xba</span>,<span class="number">0x5c</span>,<span class="number">0x92</span>,<span class="number">0x80</span>,<span class="number">0x5c</span>,<span class="number">0x12</span>,<span class="number">0xe1</span>,<span class="number">0x18</span>,<span class="number">0x16</span>,<span class="number">0x5c</span>,<span class="number">0x02</span>,<span class="number">0xc3</span>,<span class="number">0x2c</span>,<span class="number">0x06</span>,<span class="number">0x78</span>,<span class="number">0x24</span>,<span class="number">0xf5</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x16</span>,<span class="number">0x82</span>,<span class="number">0x5c</span>,<span class="number">0x42</span>,<span class="number">0xc0</span>,<span class="number">0x5c</span>,<span class="number">0xc2</span>,<span class="number">0x01</span>,<span class="number">0x18</span>,<span class="number">0xd6</span>,<span class="number">0x1c</span>,<span class="number">0xcf</span>,<span class="number">0x00</span>,<span class="number">0x78</span>,<span class="number">0x24</span>,<span class="number">0x4d</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x4a</span>,<span class="number">0x5c</span>,<span class="number">0xa1</span>,<span class="number">0x5c</span>,<span class="number">0x18</span>,<span class="number">0x97</span>,<span class="number">0x99</span>,<span class="number">0xff</span>,<span class="number">0x99</span>,<span class="number">0x06</span>,<span class="number">0x65</span>,<span class="number">0x0e</span>,<span class="number">0x7e</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0xc7</span>,<span class="number">0xd1</span>,<span class="number">0x26</span>,<span class="number">0xab</span>,<span class="number">0xa7</span>,<span class="number">0x18</span>,<span class="number">0xe3</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0xd9</span>,<span class="number">0xe3</span>,<span class="number">0x21</span>,<span class="number">0x60</span>,<span class="number">0xab</span>,<span class="number">0xce</span>,<span class="number">0x99</span>,<span class="number">0xff</span>,<span class="number">0x99</span>,<span class="number">0x4e</span>,<span class="number">0x1c</span>,<span class="number">0x16</span>,<span class="number">0x82</span>,<span class="number">0x78</span>,<span class="number">0xb5</span>,<span class="number">0x20</span>,<span class="number">0x50</span>,<span class="number">0x0e</span>,<span class="number">0x7e</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0xc7</span>,<span class="number">0x0a</span>,<span class="number">0x1c</span>,<span class="number">0xcf</span>,<span class="number">0x70</span>,<span class="number">0xab</span>,<span class="number">0x8f</span>,<span class="number">0x0e</span>,<span class="number">0x7e</span>,<span class="number">0x68</span>,<span class="number">0xba</span>,<span class="number">0x99</span>,<span class="number">0xff</span>,<span class="number">0x99</span>,<span class="number">0x4e</span>,<span class="number">0x5c</span>,<span class="number">0xa2</span>,<span class="number">0x21</span>,<span class="number">0xe1</span>,<span class="number">0x92</span>,<span class="number">0x78</span>,<span class="number">0xb5</span>,<span class="number">0xe0</span>,<span class="number">0x70</span>,<span class="number">0xc5</span>,<span class="number">0x3b</span>,<span class="number">0x33</span>,<span class="number">0x33</span>,<span class="number">0x33</span>,<span class="number">0xbf</span>,<span class="number">0x5f</span>,<span class="number">0x8e</span>,<span class="number">0xd7</span>,<span class="number">0x5c</span>,<span class="number">0x16</span>,<span class="number">0x0e</span>,<span class="number">0x47</span>,<span class="number">0xf8</span>,<span class="number">0x18</span>,<span class="number">0x16</span>,<span class="number">0x6c</span>,<span class="number">0x20</span>,<span class="number">0x04</span>,<span class="number">0x59</span>,<span class="number">0xc6</span>,<span class="number">0xd2</span>,<span class="number">0x78</span>,<span class="number">0xb5</span>,<span class="number">0x20</span>,<span class="number">0x50</span>,<span class="number">0x59</span>,<span class="number">0x1e</span>,<span class="number">0x0e</span>,<span class="number">0x7e</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0xc7</span>,<span class="number">0x0a</span>,<span class="number">0x1c</span>,<span class="number">0xcf</span>,<span class="number">0x70</span>,<span class="number">0xab</span>,<span class="number">0xa6</span>,<span class="number">0x0e</span>,<span class="number">0x7e</span>,<span class="number">0x68</span>,<span class="number">0xd9</span>,<span class="number">0xe1</span>,<span class="number">0x21</span>,<span class="number">0xa3</span>,<span class="number">0xb0</span>,<span class="number">0x43</span>,<span class="number">0x29</span>,<span class="number">0x9b</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x5c</span>,<span class="number">0x26</span>,<span class="number">0x43</span>,<span class="number">0x73</span>,<span class="number">0x7b</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xa2</span>,<span class="number">0x82</span>,<span class="number">0x5c</span>,<span class="number">0xe2</span>,<span class="number">0x21</span>,<span class="number">0x42</span>,<span class="number">0xff</span>,<span class="number">0x9e</span>,<span class="number">0x5f</span>,<span class="number">0xa0</span>,<span class="number">0x43</span>,<span class="number">0x29</span>,<span class="number">0x9b</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x5c</span>,<span class="number">0x26</span>,<span class="number">0x43</span>,<span class="number">0xcb</span>,<span class="number">0x2b</span>,<span class="number">0x9b</span>,<span class="number">0x00</span>,<span class="number">0xa2</span>,<span class="number">0x82</span>,<span class="number">0x5c</span>,<span class="number">0xe2</span>,<span class="number">0x21</span>,<span class="number">0x42</span>,<span class="number">0xff</span>,<span class="number">0x9e</span>,<span class="number">0xc2</span>,<span class="number">0xc2</span>,<span class="number">0xc2</span>,<span class="number">0xc2</span>,<span class="number">0xc2</span>,<span class="number">0xc2</span>,<span class="number">0xc2</span>,<span class="number">0xc2</span>,<span class="number">0xc2</span>,<span class="number">0x0b</span>,<span class="number">0x1e</span>,<span class="number">0xc2</span>,<span class="number">0xfa</span>,<span class="number">0xd2</span>,<span class="number">0x5c</span>,<span class="number">0x90</span>,<span class="number">0x4f</span>,<span class="number">0x58</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(src)):</span><br><span class="line">    src[i] = ((src[i]&gt;&gt;<span class="number">3</span>)&amp;<span class="number">0xff</span>) | ((src[i]&lt;&lt;<span class="number">5</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x&quot;</span>+<span class="built_in">hex</span>(src[i])[<span class="number">2</span>:].zfill(<span class="number">2</span>),end=<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x60,0xfc,0x68,0x4c,0x77,0x26,0x07,0x33,0xd2,0x64,0x8b,0x52,0x30,0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,</span><br><span class="line">0x28,0x0f,0xb7,0x4a,0x26,0x33,0xff,0x33,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x03,0xf8,</span><br><span class="line">0xe2,0xf0,0x52,0x57,0x8b,0x52,0x10,0x8b,0x42,0x3c,0x03,0xc2,0x8b,0x40,0x78,0x85,0xc0,0x0f,0x84,0xbe,0x00,</span><br><span class="line">0x00,0x00,0x03,0xc2,0x50,0x8b,0x48,0x18,0x8b,0x58,0x20,0x03,0xda,0x83,0xf9,0x00,0x0f,0x84,0xa9,0x00,0x00,</span><br><span class="line">0x00,0x49,0x8b,0x34,0x8b,0x03,0xf2,0x33,0xff,0x33,0xc0,0xac,0xc1,0xcf,0x0d,0x03,0xf8,0x3a,0xc4,0x75,0xf4,</span><br><span class="line">0x03,0x7c,0x24,0x04,0x3b,0x7c,0x24,0x0c,0x75,0xd9,0x33,0xff,0x33,0xc9,0x83,0xc2,0x50,0x0f,0xb6,0x04,0x0a,</span><br><span class="line">0xc1,0xcf,0x0d,0x03,0xf8,0x41,0x83,0xf9,0x0e,0x75,0xf1,0xc1,0xcf,0x0d,0x57,0x33,0xff,0x33,0xc9,0x8b,0x54,</span><br><span class="line">0x24,0x3c,0x52,0x0f,0xb6,0x1c,0x0e,0xb8,0x67,0x66,0x66,0x66,0xf7,0xeb,0xd1,0xfa,0x8b,0xc2,0xc1,0xe8,0x1f,</span><br><span class="line">0x03,0xc2,0x8d,0x04,0x80,0x2b,0xd8,0x5a,0x0f,0xb6,0x04,0x0a,0x2b,0xc3,0xc1,0xcf,0x0d,0x03,0xf8,0x41,0x83,</span><br><span class="line">0xf9,0x0e,0x75,0xd4,0xc1,0xcf,0x0d,0x3b,0x3c,0x24,0x74,0x16,0x68,0x25,0x73,0x00,0x00,0x8b,0xc4,0x68,0x6e,</span><br><span class="line">0x6f,0x00,0x00,0x54,0x50,0x8b,0x5c,0x24,0x48,0xff,0xd3,0xeb,0x14,0x68,0x25,0x73,0x00,0x00,0x8b,0xc4,0x68,</span><br><span class="line">0x79,0x65,0x73,0x00,0x54,0x50,0x8b,0x5c,0x24,0x48,0xff,0xd3,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,</span><br><span class="line">0x61,0xc3,0x58,0x5f,0x5a,0x8b,0x12,0xe9,0x0b,0xff,0xff,0xff</span><br></pre></td></tr></table></figure>

<h4 id="base解密"><a href="#base解密" class="headerlink" title="base解密"></a>base解密</h4><p>这个地方的逆运算实际上是base系列的加密</p>
<p>每三个元素为一组，然后每次去6位的数，这个六位的数在表中的索引是什么</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415203354030.png" alt="image-20220415203354030"></p>
<p>base的表：(注意数据的顺序)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x40, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x3E, 0x42, 0x42, 0x42, 0x3F, 0x34, 0x35, </span><br><span class="line">0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x42, 0x42, </span><br><span class="line">0x42, 0x41, 0x42, 0x42, 0x42, 0x00, 0x01, 0x02, 0x03, 0x04, </span><br><span class="line">0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, </span><br><span class="line">0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, </span><br><span class="line">0x19, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x1A, 0x1B, 0x1C, </span><br><span class="line">0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, </span><br><span class="line">0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, </span><br><span class="line">0x31, 0x32, 0x33, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, </span><br><span class="line">0x42, 0x42, 0x42, 0x42, 0x42, 0x42</span><br></pre></td></tr></table></figure>

<p>分析代码逆向解密脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = [  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x40</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x3E</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x3F</span>, <span class="number">0x34</span>, <span class="number">0x35</span>,</span><br><span class="line">  <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x3A</span>, <span class="number">0x3B</span>, <span class="number">0x3C</span>, <span class="number">0x3D</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x41</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>,</span><br><span class="line">  <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>, <span class="number">0x08</span>, <span class="number">0x09</span>, <span class="number">0x0A</span>, <span class="number">0x0B</span>, <span class="number">0x0C</span>, <span class="number">0x0D</span>, <span class="number">0x0E</span>,</span><br><span class="line">  <span class="number">0x0F</span>, <span class="number">0x10</span>, <span class="number">0x11</span>, <span class="number">0x12</span>, <span class="number">0x13</span>, <span class="number">0x14</span>, <span class="number">0x15</span>, <span class="number">0x16</span>, <span class="number">0x17</span>, <span class="number">0x18</span>,</span><br><span class="line">  <span class="number">0x19</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x1A</span>, <span class="number">0x1B</span>, <span class="number">0x1C</span>,</span><br><span class="line">  <span class="number">0x1D</span>, <span class="number">0x1E</span>, <span class="number">0x1F</span>, <span class="number">0x20</span>, <span class="number">0x21</span>, <span class="number">0x22</span>, <span class="number">0x23</span>, <span class="number">0x24</span>, <span class="number">0x25</span>, <span class="number">0x26</span>,</span><br><span class="line">  <span class="number">0x27</span>, <span class="number">0x28</span>, <span class="number">0x29</span>, <span class="number">0x2A</span>, <span class="number">0x2B</span>, <span class="number">0x2C</span>, <span class="number">0x2D</span>, <span class="number">0x2E</span>, <span class="number">0x2F</span>, <span class="number">0x30</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>, <span class="number">0x42</span>]</span><br><span class="line">src = [<span class="number">0x60</span>,<span class="number">0xfc</span>,<span class="number">0x68</span>,<span class="number">0x4c</span>,<span class="number">0x77</span>,<span class="number">0x26</span>,<span class="number">0x07</span>,<span class="number">0x33</span>,<span class="number">0xd2</span>,<span class="number">0x64</span>,<span class="number">0x8b</span>,<span class="number">0x52</span>,<span class="number">0x30</span>,<span class="number">0x8b</span>,<span class="number">0x52</span>,<span class="number">0x0c</span>,<span class="number">0x8b</span>,<span class="number">0x52</span>,<span class="number">0x14</span>,<span class="number">0x8b</span>,<span class="number">0x72</span>,<span class="number">0x28</span>,<span class="number">0x0f</span>,<span class="number">0xb7</span>,<span class="number">0x4a</span>,<span class="number">0x26</span>,<span class="number">0x33</span>,<span class="number">0xff</span>,<span class="number">0x33</span>,<span class="number">0xc0</span>,<span class="number">0xac</span>,<span class="number">0x3c</span>,<span class="number">0x61</span>,<span class="number">0x7c</span>,<span class="number">0x02</span>,<span class="number">0x2c</span>,<span class="number">0x20</span>,<span class="number">0xc1</span>,<span class="number">0xcf</span>,<span class="number">0x0d</span>,<span class="number">0x03</span>,<span class="number">0xf8</span>,<span class="number">0xe2</span>,<span class="number">0xf0</span>,<span class="number">0x52</span>,<span class="number">0x57</span>,<span class="number">0x8b</span>,<span class="number">0x52</span>,<span class="number">0x10</span>,<span class="number">0x8b</span>,<span class="number">0x42</span>,<span class="number">0x3c</span>,<span class="number">0x03</span>,<span class="number">0xc2</span>,<span class="number">0x8b</span>,<span class="number">0x40</span>,<span class="number">0x78</span>,<span class="number">0x85</span>,<span class="number">0xc0</span>,<span class="number">0x0f</span>,<span class="number">0x84</span>,<span class="number">0xbe</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0xc2</span>,<span class="number">0x50</span>,<span class="number">0x8b</span>,<span class="number">0x48</span>,<span class="number">0x18</span>,<span class="number">0x8b</span>,<span class="number">0x58</span>,<span class="number">0x20</span>,<span class="number">0x03</span>,<span class="number">0xda</span>,<span class="number">0x83</span>,<span class="number">0xf9</span>,<span class="number">0x00</span>,<span class="number">0x0f</span>,<span class="number">0x84</span>,<span class="number">0xa9</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x49</span>,<span class="number">0x8b</span>,<span class="number">0x34</span>,<span class="number">0x8b</span>,<span class="number">0x03</span>,<span class="number">0xf2</span>,<span class="number">0x33</span>,<span class="number">0xff</span>,<span class="number">0x33</span>,<span class="number">0xc0</span>,<span class="number">0xac</span>,<span class="number">0xc1</span>,<span class="number">0xcf</span>,<span class="number">0x0d</span>,<span class="number">0x03</span>,<span class="number">0xf8</span>,<span class="number">0x3a</span>,<span class="number">0xc4</span>,<span class="number">0x75</span>,<span class="number">0xf4</span>,<span class="number">0x03</span>,<span class="number">0x7c</span>,<span class="number">0x24</span>,<span class="number">0x04</span>,<span class="number">0x3b</span>,<span class="number">0x7c</span>,<span class="number">0x24</span>,<span class="number">0x0c</span>,<span class="number">0x75</span>,<span class="number">0xd9</span>,<span class="number">0x33</span>,<span class="number">0xff</span>,<span class="number">0x33</span>,<span class="number">0xc9</span>,<span class="number">0x83</span>,<span class="number">0xc2</span>,<span class="number">0x50</span>,<span class="number">0x0f</span>,<span class="number">0xb6</span>,<span class="number">0x04</span>,<span class="number">0x0a</span>,<span class="number">0xc1</span>,<span class="number">0xcf</span>,<span class="number">0x0d</span>,<span class="number">0x03</span>,<span class="number">0xf8</span>,<span class="number">0x41</span>,<span class="number">0x83</span>,<span class="number">0xf9</span>,<span class="number">0x0e</span>,<span class="number">0x75</span>,<span class="number">0xf1</span>,<span class="number">0xc1</span>,<span class="number">0xcf</span>,<span class="number">0x0d</span>,<span class="number">0x57</span>,<span class="number">0x33</span>,<span class="number">0xff</span>,<span class="number">0x33</span>,<span class="number">0xc9</span>,<span class="number">0x8b</span>,<span class="number">0x54</span>,<span class="number">0x24</span>,<span class="number">0x3c</span>,<span class="number">0x52</span>,<span class="number">0x0f</span>,<span class="number">0xb6</span>,<span class="number">0x1c</span>,<span class="number">0x0e</span>,<span class="number">0xb8</span>,<span class="number">0x67</span>,<span class="number">0x66</span>,<span class="number">0x66</span>,<span class="number">0x66</span>,<span class="number">0xf7</span>,<span class="number">0xeb</span>,<span class="number">0xd1</span>,<span class="number">0xfa</span>,<span class="number">0x8b</span>,<span class="number">0xc2</span>,<span class="number">0xc1</span>,<span class="number">0xe8</span>,<span class="number">0x1f</span>,<span class="number">0x03</span>,<span class="number">0xc2</span>,<span class="number">0x8d</span>,<span class="number">0x04</span>,<span class="number">0x80</span>,<span class="number">0x2b</span>,<span class="number">0xd8</span>,<span class="number">0x5a</span>,<span class="number">0x0f</span>,<span class="number">0xb6</span>,<span class="number">0x04</span>,<span class="number">0x0a</span>,<span class="number">0x2b</span>,<span class="number">0xc3</span>,<span class="number">0xc1</span>,<span class="number">0xcf</span>,<span class="number">0x0d</span>,<span class="number">0x03</span>,<span class="number">0xf8</span>,<span class="number">0x41</span>,<span class="number">0x83</span>,<span class="number">0xf9</span>,<span class="number">0x0e</span>,<span class="number">0x75</span>,<span class="number">0xd4</span>,<span class="number">0xc1</span>,<span class="number">0xcf</span>,<span class="number">0x0d</span>,<span class="number">0x3b</span>,<span class="number">0x3c</span>,<span class="number">0x24</span>,<span class="number">0x74</span>,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x25</span>,<span class="number">0x73</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x8b</span>,<span class="number">0xc4</span>,<span class="number">0x68</span>,<span class="number">0x6e</span>,<span class="number">0x6f</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x54</span>,<span class="number">0x50</span>,<span class="number">0x8b</span>,<span class="number">0x5c</span>,<span class="number">0x24</span>,<span class="number">0x48</span>,<span class="number">0xff</span>,<span class="number">0xd3</span>,<span class="number">0xeb</span>,<span class="number">0x14</span>,<span class="number">0x68</span>,<span class="number">0x25</span>,<span class="number">0x73</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x8b</span>,<span class="number">0xc4</span>,<span class="number">0x68</span>,<span class="number">0x79</span>,<span class="number">0x65</span>,<span class="number">0x73</span>,<span class="number">0x00</span>,<span class="number">0x54</span>,<span class="number">0x50</span>,<span class="number">0x8b</span>,<span class="number">0x5c</span>,<span class="number">0x24</span>,<span class="number">0x48</span>,<span class="number">0xff</span>,<span class="number">0xd3</span>,<span class="number">0x58</span>,<span class="number">0x58</span>,<span class="number">0x58</span>,<span class="number">0x58</span>,<span class="number">0x58</span>,<span class="number">0x58</span>,<span class="number">0x58</span>,<span class="number">0x58</span>,<span class="number">0x58</span>,<span class="number">0x61</span>,<span class="number">0xc3</span>,<span class="number">0x58</span>,<span class="number">0x5f</span>,<span class="number">0x5a</span>,<span class="number">0x8b</span>,<span class="number">0x12</span>,<span class="number">0xe9</span>,<span class="number">0x0b</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>]</span><br><span class="line"><span class="comment"># 每三个数为一组</span></span><br><span class="line">shellcode= [<span class="number">0</span>]*<span class="number">352</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(src),<span class="number">3</span>):</span><br><span class="line">    shellcode[(i//<span class="number">3</span>)*<span class="number">4</span>+<span class="number">3</span>] = src[i+<span class="number">2</span>]&amp;<span class="number">0x3f</span></span><br><span class="line">    shellcode[(i//<span class="number">3</span>)*<span class="number">4</span>+<span class="number">2</span>] = ((src[i+<span class="number">2</span>]&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0x03</span>) | (((src[i+<span class="number">1</span>]&amp;<span class="number">0x0f</span>)&lt;&lt;<span class="number">2</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line">    shellcode[(i // <span class="number">3</span>) * <span class="number">4</span> + <span class="number">1</span>] = ((src[i+<span class="number">1</span>]&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0x0f</span>) | (((src[i]&amp;<span class="number">0x03</span>)&lt;&lt;<span class="number">4</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line">    shellcode[(i // <span class="number">3</span>) * <span class="number">4</span> ] = (src[i]&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x3f</span></span><br><span class="line">    shellcode[(i//<span class="number">3</span>)*<span class="number">4</span>+<span class="number">3</span>] = table.index(shellcode[(i//<span class="number">3</span>)*<span class="number">4</span>+<span class="number">3</span>])</span><br><span class="line">    shellcode[(i // <span class="number">3</span>) * <span class="number">4</span> + <span class="number">2</span>] = table.index(shellcode[(i//<span class="number">3</span>)*<span class="number">4</span>+<span class="number">2</span>])</span><br><span class="line">    shellcode[(i // <span class="number">3</span>) * <span class="number">4</span> + <span class="number">1</span>] = table.index(shellcode[(i // <span class="number">3</span>) * <span class="number">4</span> + <span class="number">1</span>])</span><br><span class="line">    shellcode[(i // <span class="number">3</span>) * <span class="number">4</span>] = table.index(shellcode[(i // <span class="number">3</span>) * <span class="number">4</span> ])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(shellcode)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(shellcode[i]),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">YPxoTHcmBzPSZItSMItSDItSFItyKA+3SiYz/zPArDxhfAIsIMHPDQP44vBSV4tSEItCPAPCi0B4hcAPhL4AAAADwlCLSBiLWCAD2oP5AA+EqQAAAEmLNIsD8jP/M8Cswc8NA/g6xHX0A3wkBDt8JAx12TP/M8mDwlAPtgQKwc8NA/hBg/kOdfHBzw1XM/8zyYtUJDxSD7YcDrhnZmZm9+vR+ovCwegfA8KNBIAr2FoPtgQKK8PBzw0D+EGD+Q511MHPDTs8JHQWaCVzAACLxGhubwAAVFCLXCRI/9PrFGglcwAAi8RoeWVzAFRQi1wkSP/TWFhYWFhYWFhYYcNYX1qLEukL////</span><br></pre></td></tr></table></figure>

<p>向程序之中输入这串字符串就到达了下部分的输入flag</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415183207776.png" alt="image-20220415183207776"></p>
<h3 id="代码分析2"><a href="#代码分析2" class="headerlink" title="代码分析2"></a>代码分析2</h3><p>这个部分的函数并不能直接得到，它是将上部分输入的shellcode的base加密的结果写入内存之中，并将这部分数据解析为函数来运行</p>
<h4 id="分配内存空间生成函数"><a href="#分配内存空间生成函数" class="headerlink" title="分配内存空间生成函数"></a>分配内存空间生成函数</h4><p>下一部分按照我们输入的shellcode进行base加密（第一次加密）之后的元素，并且将加密的这个结果写入这个空间之中，通过xref这个写入的数组Src我们能够得到</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415183626210.png" alt="image-20220415183626210"></p>
<p>所以写入的数据是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x60,0xfc,0x68,0x4c,0x77,0x26,0x07,0x33,0xd2,0x64,0x8b,0x52,0x30,0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x33,0xff,0x33,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x03,0xf8,0xe2,0xf0,0x52,0x57,0x8b,0x52,0x10,0x8b,0x42,0x3c,0x03,0xc2,0x8b,0x40,0x78,0x85,0xc0,0x0f,0x84,0xbe,0x00,0x00,0x00,0x03,0xc2,0x50,0x8b,0x48,0x18,0x8b,0x58,0x20,0x03,0xda,0x83,0xf9,0x00,0x0f,0x84,0xa9,0x00,0x00,0x00,0x49,0x8b,0x34,0x8b,0x03,0xf2,0x33,0xff,0x33,0xc0,0xac,0xc1,0xcf,0x0d,0x03,0xf8,0x3a,0xc4,0x75,0xf4,0x03,0x7c,0x24,0x04,0x3b,0x7c,0x24,0x0c,0x75,0xd9,0x33,0xff,0x33,0xc9,0x83,0xc2,0x50,0x0f,0xb6,0x04,0x0a,0xc1,0xcf,0x0d,0x03,0xf8,0x41,0x83,0xf9,0x0e,0x75,0xf1,0xc1,0xcf,0x0d,0x57,0x33,0xff,0x33,0xc9,0x8b,0x54,0x24,0x3c,0x52,0x0f,0xb6,0x1c,0x0e,0xb8,0x67,0x66,0x66,0x66,0xf7,0xeb,0xd1,0xfa,0x8b,0xc2,0xc1,0xe8,0x1f,0x03,0xc2,0x8d,0x04,0x80,0x2b,0xd8,0x5a,0x0f,0xb6,0x04,0x0a,0x2b,0xc3,0xc1,0xcf,0x0d,0x03,0xf8,0x41,0x83,0xf9,0x0e,0x75,0xd4,0xc1,0xcf,0x0d,0x3b,0x3c,0x24,0x74,0x16,0x68,0x25,0x73,0x00,0x00,0x8b,0xc4,0x68,0x6e,0x6f,0x00,0x00,0x54,0x50,0x8b,0x5c,0x24,0x48,0xff,0xd3,0xeb,0x14,0x68,0x25,0x73,0x00,0x00,0x8b,0xc4,0x68,0x79,0x65,0x73,0x00,0x54,0x50,0x8b,0x5c,0x24,0x48,0xff,0xd3,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x61,0xc3,0x58,0x5f,0x5a,0x8b,0x12,0xe9,0x0b,0xff,0xff,0xff</span><br></pre></td></tr></table></figure>

<h4 id="利用010生成文件得到代码"><a href="#利用010生成文件得到代码" class="headerlink" title="利用010生成文件得到代码"></a>利用010生成文件得到代码</h4><p>将上面这些16进制数据放入010之中，保存为16进制文件，再用ida32打开文件，打开之后，将其声明一下函数，f5反编译，就得到</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415190525034.png" alt="image-20220415190525034"></p>
<p>根据输入的flag参数定位到关键代码的位置,分析逻辑</p>
<ul>
<li><p>flag和v17的输入进行相同轮数的操作，操作相似，只是flag中加入了v12的某项值</p>
</li>
<li><p>每轮flag和v17加密的结果都要相同，说明flag的每个数都要比v17的每个数大v12[j]%5，这样每轮之中flag减去v12[j]%5，运算结果就相等了</p>
</li>
<li><p>我们需要得到v17和v12这两个数组</p>
</li>
</ul>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415191447782.png" alt="image-20220415191447782"></p>
<h4 id="动态调试得到数据"><a href="#动态调试得到数据" class="headerlink" title="动态调试得到数据"></a>动态调试得到数据</h4><p>使用动态调试的方式得到输入v17和v12，调试程序到图中所示位置（call的那个函数就是程序运行中初始化得到的函数）</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415194339948.png" alt="image-20220415194339948"></p>
<p>进入这个call的程序之中，对比我们之前反编译得到的该函数（ida），知道该函数就是我们要找到的这个函数，可以结合ida之中的反编译和汇编代码来分析代码，定位到我们需要的数据的位置</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415194621421.png" alt="image-20220415194621421"></p>
<p>向下调试，根据循环和移位的特征运算来定位</p>
<p>通过特征代码 移位运算ror和com+jnz定位到v17</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415195511967.png" alt="image-20220415195511967"></p>
<p>定位到v17的数据是：    is program cannot be run in DOS mode（我们实际上只需要14位的数据）</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415195538685.png" alt="image-20220415195538685"></p>
<p>向下走在下一个循环之中定位到v12 ：LoadLibraryExA   </p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415200128273.png" alt="image-20220415200128273"></p>
<h4 id="解密得flag"><a href="#解密得flag" class="headerlink" title="解密得flag"></a>解密得flag</h4><p>动态调试的数据以及第二部分代码的分析，我们能够得到第二次输入的flag的数据，根据最后的提示，将第一部分的输入和第二部分的输入结合在一起然后md5散列就能够得到我们要的HFCTF{}</p>
<p>解密脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">flag = &quot;&quot;</span><br><span class="line">code = &quot;is program cannot be run in DOS mode&quot;</span><br><span class="line">key = &quot;LoadLibraryExA&quot;</span><br><span class="line">for i in range(14):</span><br><span class="line">    flag+=chr(ord(code[i])+ord(key[i])%5)</span><br><span class="line">print(flag)</span><br><span class="line">shellcode = &quot;YPxoTHcmBzPSZItSMItSDItSFItyKA+3SiYz/zPArDxhfAIsIMHPDQP44vBSV4tSEItCPAPCi0B4hcAPhL4AAAADwlCLSBiLWCAD2oP5AA+EqQAAAEmLNIsD8jP/M8Cswc8NA/g6xHX0A3wkBDt8JAx12TP/M8mDwlAPtgQKwc8NA/hBg/kOdfHBzw1XM/8zyYtUJDxSD7YcDrhnZmZm9+vR+ovCwegfA8KNBIAr2FoPtgQKK8PBzw0D+EGD+Q511MHPDTs8JHQWaCVzAACLxGhubwAAVFCLXCRI/9PrFGglcwAAi8RoeWVzAFRQi1wkSP/TWFhYWFhYWFhYYcNYX1qLEukL////&quot;</span><br><span class="line">flag = shellcode+flag</span><br><span class="line">hl = hashlib.md5()</span><br><span class="line">hl.update(flag.encode(&quot;utf-8&quot;))</span><br><span class="line">print(&quot;HFCTF&#123;&quot;+hl.hexdigest()+&quot;&#125;&quot;)</span><br><span class="line">jt&quot;psojvcq!gan</span><br><span class="line">HFCTF&#123;2b794e95022f2fe46106c21bbf57a755&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/HFCTF2022-theShellcode/image-20220415201009353.png" alt="image-20220415201009353"></p>
<p>最后将这两个结果拼接一下，并且再md5一下就能得到最后的结果了</p>
<p>HFCTF{2B794E95022F2FE46106C21BBF57A755}</p>
<p><img src="/images/HFCTF2022-theShellcode/image-20220415201230903.png" alt="image-20220415201230903"></p>
<h2 id="RITCTF-SOUP"><a href="#RITCTF-SOUP" class="headerlink" title="RITCTF_SOUP"></a>RITCTF_SOUP</h2><p>用ida打开，将对比的字符串，每两个数一组，写成数组的形式，作为密文</p>
<p>用动态调试的方法，得到RC4的密钥是 soup，上解密脚本解密</p>
<p>RC4的解密脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">RC4初始化函数</span><br><span class="line">*/</span><br><span class="line">void rc4_init(unsigned char* s, unsigned char* key, unsigned long Len_k)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0, j = 0;</span><br><span class="line">	char k[256] = &#123; 0 &#125;;</span><br><span class="line">	unsigned char tmp = 0;</span><br><span class="line">	for (i = 0; i &lt; 256; i++) &#123;</span><br><span class="line">		s[i] = i;</span><br><span class="line">		k[i] = key[i % Len_k];</span><br><span class="line">	&#125;</span><br><span class="line">	for (i = 0; i &lt; 256; i++) &#123;</span><br><span class="line">		j = (j + s[i] + k[i]) % 256;</span><br><span class="line">		tmp = s[i];</span><br><span class="line">		s[i] = s[j];</span><br><span class="line">		s[j] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">RC4加解密函数</span><br><span class="line">unsigned char* Data     加解密的数据</span><br><span class="line">unsigned long Len_D     加解密数据的长度</span><br><span class="line">unsigned char* key      密钥</span><br><span class="line">unsigned long Len_k     密钥长度</span><br><span class="line">*/</span><br><span class="line">void rc4_crypt(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k) //加解密</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char s[256];</span><br><span class="line">	rc4_init(s, key, Len_k);</span><br><span class="line">	int i = 0, j = 0, t = 0;</span><br><span class="line">	unsigned long k = 0;</span><br><span class="line">	unsigned char tmp;</span><br><span class="line">	for (k = 0; k &lt; Len_D; k++) &#123;</span><br><span class="line">		i = (i + 1) % 256;</span><br><span class="line">		j = (j + s[i]) % 256;</span><br><span class="line">		tmp = s[i];</span><br><span class="line">		s[i] = s[j];</span><br><span class="line">		s[j] = tmp;</span><br><span class="line">		t = (s[i] + s[j]) % 256;</span><br><span class="line">		Data[k] = Data[k] ^ s[t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//字符串密钥</span><br><span class="line">	unsigned char key[] = &quot;soup&quot;;</span><br><span class="line">	unsigned long key_len = sizeof(key) - 1;</span><br><span class="line">	//数组密钥</span><br><span class="line">	//unsigned char key[] = &#123;&#125;;</span><br><span class="line">	//unsigned long key_len = sizeof(key);</span><br><span class="line"></span><br><span class="line">	//加解密数据</span><br><span class="line">	unsigned char data[] = &#123; 0x85,0x5E,0x6E,0xAD,0x05,0x7B,0x46,0xA9,0xD7,0x5F,0x3E,0x07,0x2F,0x35,0x04,0x38 &#125;;</span><br><span class="line">	//加解密</span><br><span class="line">	rc4_crypt(data, sizeof(data), key, key_len);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; sizeof(data); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%c&quot;, data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">得到的flag是：BR0CC0L1_CH3DD@R</span><br></pre></td></tr></table></figure>

<p>提交的flag是 RS{BR0CC0L1_CH3DD@R}</p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>Themida脱壳</tag>
        <tag>sharpOD反调试</tag>
        <tag>修复IAT表(Scylla)</tag>
        <tag>RC4</tag>
      </tags>
  </entry>
  <entry>
    <title>TEA系列加密解密</title>
    <url>/2022/02/28/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h1 id="TEA系列加密解密"><a href="#TEA系列加密解密" class="headerlink" title="TEA系列加密解密"></a>TEA系列加密解密</h1><h2 id="TEA加密解密"><a href="#TEA加密解密" class="headerlink" title="TEA加密解密"></a>TEA加密解密</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>在密码学中，微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。</p>
<p>代码的特点： </p>
<ul>
<li>加密使用的数据为2个32位无符号整数，密钥为4个32位无符号整数即密钥长度为128位（当加密解密的对象是一串数组的时候，需要将这个32位无符号整数的数组<strong>每两个32位无符号整数划分为一组</strong>，对每一组数据单独加密解密得到结果）</li>
<li>该算法使用了一个常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 <strong>0×9E3779B9</strong>）作为魔数</li>
</ul>
</blockquote>
<h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>拥有一个叫做<a href="https://en.wikipedia.org/wiki/Feistel_cipher">Feistel 结构</a>的密码学结构。这种密码学结构通俗的来讲就是会将加密的plaintext分成L、R两部分，并且满足 <code>L_&#123;i+1&#125; = R_i, R_&#123;i+1&#125; = F(K_i,R_i) \oplus L_i</code> 这种交换式的加密方式的一种结构。</p>
<p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228191440573.png" alt="image-20220228191440573"></p>
<h3 id="TEA加密算法的实现"><a href="#TEA加密算法的实现" class="headerlink" title="TEA加密算法的实现"></a>TEA加密算法的实现</h3><p>参数要求：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组）</p>
<p>加密特征：存在一个<strong>delta值</strong>，这个值会不停的增加到<strong>sum</strong>之中，形成一种循环的效果；会有一个<strong>位移-&gt;与密钥相加-&gt;异或</strong>的过程；计算delta的sum状态值也会参与</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TEA解密算法的实现"><a href="#TEA解密算法的实现" class="headerlink" title="TEA解密算法的实现"></a>TEA解密算法的实现</h3><p>参数要求：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//解密函数  </span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */  </span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */  </span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */  </span><br><span class="line">    sum = delta &lt;&lt; 5;   //32轮运算，所以是2的5次方；16轮运算，所以是2的4次方；8轮运算，所以是2的3次方</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */  </span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);  </span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">    &#125;                                              /* end cycle */  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>解密数组：{0x3e8947cb,0xcc944639,0x31358388,0x3b0b6893,0xda627361,0x3b2e6427}</p>
<p>key数组：{0x4445,0x4144,0x4245,0x4546}</p>
<p>因为在解密的过程之中会产生移位的运算，这个过程会产生溢出，所以每组解密的对象声明成 <strong>v1[3]={0x3e8947cb,0xcc944639,0x0}</strong> 这样的形式</p>
<p>解密的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */</span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v1[3]=&#123;0x3e8947cb,0xcc944639,0x0&#125;,k[4]=&#123;0x4445,0x4144,0x4245,0x4546&#125;;</span><br><span class="line">    uint32_t v2[3]=&#123;0x31358388,0x3b0b6893,0x0&#125;;</span><br><span class="line">    uint32_t v3[3]=&#123;0xda627361,0x3b2e6427&#125;;</span><br><span class="line">    decrypt(v1, k);</span><br><span class="line">    decrypt(v2, k);</span><br><span class="line">    decrypt(v3, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s %s %s\n&quot;,(char*)v1,(char*)v2,(char*)v3);   // 注意如何将一串数组以字符串的形式输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出的结果：fvBXQdEa rcbvhBPx cOA8Ag6J</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p>printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p>
<p>参数的格式</p>
<p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228193403698.png" alt="image-20220228193403698"></p>
<h2 id="XTEA加密解密"><a href="#XTEA加密解密" class="headerlink" title="XTEA加密解密"></a>XTEA加密解密</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作</p>
</blockquote>
<h3 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228193746682.png" alt="image-20220228193746682"></p>
<h3 id="XTEA加密算法的实现"><a href="#XTEA加密算法的实现" class="headerlink" title="XTEA加密算法的实现"></a>XTEA加密算法的实现</h3><p>相较于TEA的变化：</p>
<ul>
<li>由之前的**<code>((v1&lt;&lt;4) + k0) ^ ((v1&gt;&gt;5) + k1)</code>** 变化成了 **<code>((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1)</code>**，此时v1内部数据的加密变化不再受到密钥的影响。</li>
<li>原先的<code>v1 + sum</code>变成了<code>(sum + key[sum &amp; 3])</code>以及<code>sum + key[(sum&gt;&gt;11) &amp; 3]</code>，密钥变成了<strong>轮转</strong>使用，而不是固定只针对某种数据进行加密（解密）。并且此时密钥的选取<strong>受到sum的影响</strong></li>
<li><code>sum += delta</code>的时机由每次加密开头就发生变化到v0，v1<strong>两个block加密的中间</strong>。</li>
</ul>
<p>输入的参数：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组），注意这里循环的次数不是固定的了，是需要传入的参数<strong>num_rounds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  </span><br><span class="line">    unsigned int i;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;  </span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  </span><br><span class="line">        sum += delta;  </span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="XTEA解密算法的实现"><a href="#XTEA解密算法的实现" class="headerlink" title="XTEA解密算法的实现"></a>XTEA解密算法的实现</h3><p>输入的参数：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组），注意这里循环的次数不是固定的了，是需要传入的参数<strong>num_rounds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  </span><br><span class="line">    unsigned int i;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;  </span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */</span><br><span class="line"></span><br><span class="line">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[3]=&#123;0x73647979,0x726b6f5f,0x0&#125;;</span><br><span class="line">    uint32_t v1[2]=&#123;0x646f675f,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]=&#123;0X95C4C,0X871D,0X1A7B7,0X12C7C7&#125;;</span><br><span class="line">    unsigned int r=32;//num_rounds建议取值为32</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line">    printf(&quot;加密前原始数据：%s%s\n&quot;,(char*)v,(char*)v1);</span><br><span class="line">    encipher(r, v, k);</span><br><span class="line">    encipher(r, v1, k);</span><br><span class="line">    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v1[0]);</span><br><span class="line">    decipher(r, v, k);</span><br><span class="line">    decipher(r, v1, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s%s\n&quot;,(char*)v,(char*)v1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">加密前原始数据：yyds_okr_god</span><br><span class="line">加密后的数据：3461349474 1314311102 3609197830</span><br><span class="line">解密后的数据：yyds_okr_god</span><br></pre></td></tr></table></figure>

<h2 id="XXTEA加密解密"><a href="#XXTEA加密解密" class="headerlink" title="XXTEA加密解密"></a>XXTEA加密解密</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>XTEA再度进化， 变成了支持块加密<code>XXTEA</code></p>
</blockquote>
<h3 id="加密过程-2"><a href="#加密过程-2" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228200301853.png" alt="image-20220228200301853"></p>
<h3 id="XXTEA加密解密算法的实现"><a href="#XXTEA加密解密算法的实现" class="headerlink" title="XXTEA加密解密算法的实现"></a>XXTEA加密解密算法的实现</h3><p>特点：在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥, 是目前TEA系列中最安全的算法，但性能较上两种有所降低。</p>
<p>参数：输入的是<strong>至少拥有两个元素的32bit的数组</strong>，密钥的长度仍然是<strong>128位</strong>，即拥有<strong>4个元素32位</strong>长度的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdint.h&gt;  </span><br><span class="line">#define DELTA 0x9e3779b9  </span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))  </span><br><span class="line">  </span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])  </span><br><span class="line">&#123;  </span><br><span class="line">    uint32_t y, z, sum;  </span><br><span class="line">    unsigned p, rounds, e;  </span><br><span class="line">    if (n &gt; 1)            /* Coding Part */  </span><br><span class="line">    &#123;  </span><br><span class="line">        rounds = 6 + 52/n;  </span><br><span class="line">        sum = 0;  </span><br><span class="line">        z = v[n-1];  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            sum += DELTA;  </span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;  </span><br><span class="line">            for (p=0; p&lt;n-1; p++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                y = v[p+1];  </span><br><span class="line">                z = v[p] += MX;  </span><br><span class="line">            &#125;  </span><br><span class="line">            y = v[0];  </span><br><span class="line">            z = v[n-1] += MX;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (--rounds);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */  </span><br><span class="line">    &#123;  </span><br><span class="line">        n = -n;  </span><br><span class="line">        rounds = 6 + 52/n;  </span><br><span class="line">        sum = rounds*DELTA;  </span><br><span class="line">        y = v[0];  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;  </span><br><span class="line">            for (p=n-1; p&gt;0; p--)  </span><br><span class="line">            &#123;  </span><br><span class="line">                z = v[p-1];  </span><br><span class="line">                y = v[p] -= MX;  </span><br><span class="line">            &#125;  </span><br><span class="line">            z = v[n-1];  </span><br><span class="line">            y = v[0] -= MX;  </span><br><span class="line">            sum -= DELTA;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (--rounds);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span><br><span class="line"></span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t y, z, sum;</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n-1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=0; p&lt;n-1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+1];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n-1] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=n-1; p&gt;0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p-1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n-1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[4]= &#123;0x73647979,0x726b6f5f,0x646f675f,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]= &#123;0X95C4C,0X871D,0X1A7B7,0X12C7C7&#125;;</span><br><span class="line">    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line">    printf(&quot;加密前原始数据：%s\n&quot;,(char*)v);</span><br><span class="line">    btea(v, n, k);</span><br><span class="line">    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v[3]);</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s\n&quot;,(char*)v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">加密前原始数据：yyds_okr_god</span><br><span class="line">加密后的数据：609835868 2980644312 0</span><br><span class="line">解密后的数据：yyds_okr_god</span><br></pre></td></tr></table></figure>

<h2 id="逆向中TEA系列加密的识别"><a href="#逆向中TEA系列加密的识别" class="headerlink" title="逆向中TEA系列加密的识别"></a>逆向中TEA系列加密的识别</h2><p>解决逆向题大部分出现TEA的场合都是【识别算法-&gt;编写对应解密程序】</p>
<p>分析二进制文件中的算法的时候有几个识别的特征</p>
<ul>
<li>可能存在针对<strong>64bit</strong>以及<strong>128bit</strong>数字的操作（输入的<strong>msg和key</strong>） ，一般会用<strong>无符号的32位的数组</strong>表示</li>
<li>存在<strong>先进行位移，然后异或</strong>的类似操作（<code>(z&gt;&gt;5^y&lt;&lt;2) </code>这类混合变换）**<code>(z&gt;&gt;5^y&lt;&lt;2)</code><strong>就是xxtea加密了，存在</strong>(v0 &lt;&lt; 4)** 和 **(v0 &gt;&gt; 5)**移位就是tea和xtea加密了</li>
<li>前面一个复杂的混合变换的结果可能会<strong>叠加</strong>到另一个值上，两者相互叠加（Feistel 结构）</li>
<li><strong>获取密钥</strong>的时候，会使用某一个常量值作为下标（<code>key[(sum&gt;&gt;11) &amp; 3]</code>）存在轮换的方式获得密钥 就是xtea或者xxtea了</li>
<li>会在算法开始定义一个<strong>delta</strong>，并且这个值不断的参与算法，但是<strong>从来不会受到输入的影响</strong>（delta数值如果没有魔改就是0x9e3779b9）如果出现了<strong>0x9e3779b9</strong>这个数字一般就能确定是TEA加密系列</li>
</ul>
<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/4272e0805da3">https://www.jianshu.com/p/4272e0805da3</a></p>
<p><a href="https://www.anquanke.com/post/id/224198#h3-2">https://www.anquanke.com/post/id/224198#h3-2</a></p>
]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>TEA</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF2022-FATE</title>
    <url>/2022/05/04/DASCTF2022-FATE/</url>
    <content><![CDATA[<h2 id="CrackMe"><a href="#CrackMe" class="headerlink" title="CrackMe"></a>CrackMe</h2><p>MFC的逆向分析CracckMe,写题的时候在网上搜到了<a href="https://bbs.pediy.com/thread-221038.htm">逆向分析CrackMe</a> 这篇文章，通过OD+IDA的方式定位到关键代码处，然后进行解密的操作。</p>
<p>知识点： MD5 Sha1 Hashcat Wincrpt</p>
<h3 id="定位关键函数"><a href="#定位关键函数" class="headerlink" title="定位关键函数"></a>定位关键函数</h3><p>OD来定位关键代码和提取数据，因为这个程序有反调试，而OD之中有插件，能够很好的反反调试而提取相关的数据。</p>
<p>IDA能够很好的反编译相应的代码，搞清楚函数的逻辑。</p>
<p>搜索MessageBoxA，因为当输入flag和key之后，输入错误会弹出弹窗，而MessageBoxA 有可能是表示弹窗的函数位置</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426200327902.png" alt="image-20220426200327902"></p>
<p><strong>（Ctrl+G）跟踪表达式【TextA/W】</strong> 就找到引用这个函数的地址，看到这个地址之后，发现它的下方就是“Wrong!!!“字符串，就找到对应输出Wrong的这个函数的位置，</p>
<p><img src="/images/DASCTF2022-FATE/image-20220423131904713.png" alt="image-20220423131904713"></p>
<p>定位到输出wrong!!!的代码处</p>
<p><img src="/images/DASCTF2022-FATE/image-20220423132053957.png" alt="image-20220423132053957"></p>
<p>并且在它的下面就是输出successful的代码处</p>
<p><img src="/images/DASCTF2022-FATE/image-20220423132133014.png" alt="image-20220423132133014"></p>
<p>在ida之中能更加容易的分析代码，所以通过这两个输出wrong和Success的地址，在ida之中定位到这两个函数，并且通过他们向上就找（交叉引用的方法）到对输入的key和flag进行验证的函数。</p>
<p>关键函数的位置:0x4C31E0</p>
<p><img src="/images/DASCTF2022-FATE/image-20220423140534625.png" alt="image-20220423140534625"></p>
<h3 id="分析关键函数逻辑"><a href="#分析关键函数逻辑" class="headerlink" title="分析关键函数逻辑"></a>分析关键函数逻辑</h3><p>这里将key分成了两部分进行加密，前4个字节使用MD5加密，后4个字节使用Sha1加密，key的md5加密的结果会作为AES加密的密钥，flag的加密是AES加密</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426201914088.png" alt="image-20220426201914088"></p>
<h4 id="4个加密函数"><a href="#4个加密函数" class="headerlink" title="4个加密函数"></a>4个加密函数</h4><p>这里有4个加密的函数，在每个函数的里面都是调用<strong>Wincrypt</strong>的函数来进行加密的操作，但当时我做的时候完全没有注意到这个点，都是通过加密之后的长度来判断用的是什么加密（所以把key解密出来了），不然也不至于最后一步没有解出来。</p>
<p>所以自己以后对于这种情况，要查明这里面调用的函数中引用的参数表示什么意思，有什么作用！！！！！</p>
<p><img src="/images/DASCTF2022-FATE/image-20220425204459582.png" alt="image-20220425204459582"></p>
<p>Algid 的数值：将输入的8个字节的key分成两个部分，前4个字节用md5加密，后4个字节用Sha1加密</p>
<p><img src="/images/DASCTF2022-FATE/image-20220425205856887.png" alt="image-20220425205856887"></p>
<p><img src="/images/DASCTF2022-FATE/image-20220425205920813.png" alt="image-20220425205920813"></p>
<p>所以第一个是对输入的flag进行md5的hash加密</p>
<p><img src="/images/DASCTF2022-FATE/image-20220423135349916.png" alt="image-20220423135349916"></p>
<h4 id="提取加密结果的数据（OD）"><a href="#提取加密结果的数据（OD）" class="headerlink" title="提取加密结果的数据（OD）"></a>提取加密结果的数据（OD）</h4><p>加密结果的对比的函数</p>
<p><img src="/images/DASCTF2022-FATE/image-20220423175915409.png" alt="image-20220423175915409"></p>
<p>三个对比加密数据的汇编代码处</p>
<p><img src="/images/DASCTF2022-FATE/image-20220423142415880.png" alt="image-20220423142415880"></p>
<p><img src="/images/DASCTF2022-FATE/image-20220423142438993.png" alt="image-20220423142438993"></p>
<p><img src="/images/DASCTF2022-FATE/image-20220423142505141.png" alt="image-20220423142505141"></p>
<p>通过ida之中三个对输入的加密结果判断的函数的地址，在od之中对应的地址下断点，动调调试找到对比的数据（密文）</p>
<h3 id="md5解密"><a href="#md5解密" class="headerlink" title="md5解密"></a>md5解密</h3><p>第一组（md5） =》 找个<a href="https://www.cmd5.com/">在线网址</a>解密</p>
<p>数据地址009AF460</p>
<p><img src="/images/DASCTF2022-FATE/image-20220423143845071.png" alt="image-20220423143845071"></p>
<p>密文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">009AF460  9F 77 C2 A4 AC 5C 0A 67  焪陇琝.g</span><br><span class="line">009AF468  13 21 BB E1 E9 97 2A F6  !会闂*?</span><br></pre></td></tr></table></figure>

<p>   密文：9F77C2A4AC5C0A671321BBE1E9972AF6   明文：NocT</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426202804265.png" alt="image-20220426202804265"></p>
<h3 id="SHA1解密"><a href="#SHA1解密" class="headerlink" title="SHA1解密"></a>SHA1解密</h3><p>第二组（SHA1）=》(使用<a href="https://github.com/hashcat/hashcat">HashCat</a>解密) <a href="https://xz.aliyun.com/t/4008">Hashcat使用手册</a></p>
<p>长度是：20</p>
<p><img src="/images/DASCTF2022-FATE/image-20220423155222571.png" alt="image-20220423155222571"></p>
<p>密文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">010FF59C  D5 9F 8E 94 B0 E1 DE 6E  諢帞搬辬</span><br><span class="line">010FF5A4  32 95 18 A0 C4 44 AA 94  2?犇D獢</span><br><span class="line">010FF5AC  DE 7C 8D 44              迀岲..</span><br></pre></td></tr></table></figure>

<p>密文：d59f8e94b0e1de6e329518a0c444aa94de7c8d44 明文：uRne</p>
<p>所以key的值就是： NocTuRne </p>
<p><img src="/images/DASCTF2022-FATE/image-20220423165125938.png" alt="image-20220423165125938"></p>
<p>最后得到的key： NocTuRne</p>
<h3 id="Wincrpt解密AES"><a href="#Wincrpt解密AES" class="headerlink" title="Wincrpt解密AES"></a>Wincrpt解密AES</h3><p>第三组（AES）</p>
<p>长度是 0x30</p>
<p><img src="/images/DASCTF2022-FATE/image-20220423165627288.png" alt="image-20220423165627288"></p>
<p>密文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">003AFC20  5B 9C EE B2 3B B7 D7 34  [滎?纷4</span><br><span class="line">003AFC28  F3 1B 75 14 C6 B2 1F E8  ?u撇?</span><br><span class="line">003AFC30  DE 33 44 74 75 1B 47 6A  ?DtuGj</span><br><span class="line">003AFC38  D4 37 51 88 FC 67 E6 60  ?Q堻g鎌</span><br><span class="line">003AFC40  DA 0D 58 07 81 43 53 EA  ?X丆S?</span><br><span class="line">003AFC48  7B 52 85 6C 86 65 AF B4  &#123;R卨唀</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5B,0x9C,0xEE,0xB2,0x3B,0xB7,0xD7,0x34,0xF3,0x1B,0x75,0x14,0xC6,0xB2,0x1F,0xE8,0xDE,0x33,0x44,0x74,0x75,0x1B,0x47,0x6A,0xD4,0x37,0x51,0x88,0xFC,0x67,0xE6,0x60,0xDA,0x0D,0x58,0x07,0x81,0x43,0x53,0xEA,0x7B,0x52,0x85,0x6C,0x86,0x65,0xAF,0xB4</span><br></pre></td></tr></table></figure>

<p>AES的密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5c,0x53,0xa4,0xa4,0x1d,0x52,0x43,0x7a,0x9f,0xa1,0xe9,0xc2,0x6c,0xa5,0x90,0x90</span><br></pre></td></tr></table></figure>

<p>我实在是没有想到啊，最后这一步居然是AES解密</p>
<h4 id="Wincrpt"><a href="#Wincrpt" class="headerlink" title="Wincrpt"></a>Wincrpt</h4><p>最后一步直接使用Wincrpt中的CryptEncrypt对应的CryptDecrypt这个函数来进行解密</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426133237250.png" alt="image-20220426133237250"></p>
<h4 id="CryptDecrypt的讲解"><a href="#CryptDecrypt的讲解" class="headerlink" title="CryptDecrypt的讲解"></a>CryptDecrypt的讲解</h4><p>在调用<strong>CryptEncrypt之前，应用程序必须通过调用</strong><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>函数获取散列对象的 句柄。<a href="https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">加密完成后，可以使用CryptGetHashParam</a>函数获取哈希值，也可以使用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptSignHash</a>函数对哈希进行签名 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL CryptEncrypt(</span><br><span class="line">  [in]      HCRYPTKEY  hKey,</span><br><span class="line">  [in]      HCRYPTHASH hHash,</span><br><span class="line">  [in]      BOOL       Final,</span><br><span class="line">  [in]      DWORD      dwFlags,</span><br><span class="line">  [in, out] BYTE       *pbData,</span><br><span class="line">  [in, out] DWORD      *pdwDataLen,</span><br><span class="line">  [in]      DWORD      dwBufLen</span><br><span class="line">);</span><br><span class="line">[in] hKey: 用于解密的密钥句柄。</span><br><span class="line">[in] hHash: 哈希对象的句柄。如果要同时解密和散列数据，则在此参数中传递散列对象的句柄。散列值用解密后的明文更新。此选项在同时解密             和验证签名时很有用。如果不进行散列，则此参数必须为零。</span><br><span class="line">[in] Final: 一个布尔值，指定这是否是正在解密的系列中的最后一部分。如果这是最后一个或唯一一个块，则此值为TRUE 。如果这不是最后一             个块，则此值为FALSE。        </span><br><span class="line">[in] dwFlags: 标志值</span><br><span class="line">[in, out] pbData： 指向包含要加密的明文的缓冲区的指针。此缓冲区中的明文被此函数创建的密文覆盖。</span><br><span class="line">[in, out] pdwDataLen： 一个指向DWORD值的指针，该值在输入时包含pbData缓冲区中明文的长度（以字节为单位）。退出时，此DWORD包含                        写入pbData缓冲区的密文的长度（以字节为单位）。</span><br><span class="line">[in] dwBufLen： 指定输入pbData缓冲区的总大小（以字节为单位） 。</span><br></pre></td></tr></table></figure>

<h4 id="CryptDecrypt的讲解-1"><a href="#CryptDecrypt的讲解-1" class="headerlink" title="CryptDecrypt的讲解"></a>CryptDecrypt的讲解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL CryptDecrypt(</span><br><span class="line">  [in]      HCRYPTKEY  hKey,</span><br><span class="line">  [in]      HCRYPTHASH hHash,</span><br><span class="line">  [in]      BOOL       Final,</span><br><span class="line">  [in]      DWORD      dwFlags,</span><br><span class="line">  [in, out] BYTE       *pbData,</span><br><span class="line">  [in, out] DWORD      *pdwDataLen</span><br><span class="line">);</span><br><span class="line">hkey: 用于解密的密钥句柄,此密钥指定要使用的解密算法</span><br><span class="line">[in] hHash: 哈希对象的句柄。如果要同时解密和散列数据，则在此参数中传递散列对象的句柄。散列值用解密后的明文更新。此选项在同时解密             和验证签名时很有用。如果不进行散列，则此参数必须为零。</span><br><span class="line">[in] Final: 一个布尔值，指定这是否是正在解密的系列中的最后一部分。如果这是最后一个或唯一一个块，则此值为TRUE 。如果这不是最后一             个块，则此值为FALSE。</span><br><span class="line">[in] dwFlags: 标志值(见下图)</span><br><span class="line">[in, out] pbData： 指向包含要解密的数据的缓冲区的指针。解密完成后，明文被放回同一个缓冲区。</span><br><span class="line">[in, out] pdwDataLen： 指向指示pbData缓冲区长度的DWORD值的指针。在调用此函数之前，调用应用程序将DWORD值设置为要解密的字节                        数。返回时，DWORD值包含解密后的明文的字节数。</span><br></pre></td></tr></table></figure>

<img src="/images/DASCTF2022-FATE/image-20220426132654399.png" alt="image-20220426132654399" style="zoom: 67%;" />

<h4 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h4><p>这里调用了CryptEncrypt进行AES的加密的操作，所以这里我们直接使用CryptDecrypt来解密就可以了，可以直接从网上去找用它来<a href="https://www.writebug.com/git/DemonGan/CryptoApi">解密的脚本</a>，也可以直接把加密的函数脱出来，将里面CryptEncrypt函数修改成CryptDecrypt函数就可以了（两个脚本的逻辑都是一样的）</p>
<p>第一种脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;tchar.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;wincrypt.h&gt;</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">      BOOL v6; // [esp+4h] [ebp-18h]</span><br><span class="line">  HCRYPTKEY phKey; // [esp+Ch] [ebp-10h] BYREF</span><br><span class="line">  HCRYPTPROV phProv; // [esp+10h] [ebp-Ch] BYREF</span><br><span class="line">  HCRYPTHASH phHash; // [esp+14h] [ebp-8h] BYREF</span><br><span class="line"></span><br><span class="line">  phProv = 0;</span><br><span class="line">  phHash = 0;</span><br><span class="line">  phKey = 0;</span><br><span class="line">  BYTE a3[] = &#123;0x5B,0x9C,0xEE,0xB2,0x3B,0xB7,0xD7,0x34,0xF3,0x1B,0x75,0x14,0xC6,0xB2,0x1F,0xE8,0xDE,0x33,0x44,0x74,0x75,0x1B,0x47,0x6A,0xD4,0x37,0x51,0x88,0xFC,0x67,0xE6,0x60,0xDA,0x0D,0x58,0x07,0x81,0x43,0x53,0xEA,0x7B,0x52,0x85,0x6C,0x86,0x65,0xAF,0xB4&#125;;</span><br><span class="line">  BYTE pbData[] =&#123;0x5c,0x53,0xa4,0xa4,0x1d,0x52,0x43,0x7a,0x9f,0xa1,0xe9,0xc2,0x6c,0xa5,0x90,0x90&#125;;</span><br><span class="line">  DWORD dwDataLen = 0x10;</span><br><span class="line">  DWORD *pdwDataLen ;</span><br><span class="line">  *pdwDataLen = 0x20;</span><br><span class="line">  v6 = CryptAcquireContextA(&amp;phProv, 0, 0, 0x18u, 0xF0000000);</span><br><span class="line">  if ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = CryptCreateHash(phProv, 0x8003u, 0, 0, &amp;phHash);</span><br><span class="line">    if ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = CryptHashData(phHash, pbData, dwDataLen, 0);</span><br><span class="line">      if ( v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = CryptDeriveKey(phProv, 0x660Eu, phHash, 1u, &amp;phKey);</span><br><span class="line">        if ( v6 )</span><br><span class="line">          v6 = CryptDecrypt(phKey, 0, 1, 0, a3, pdwDataLen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">cout&lt;&lt;a3&lt;&lt;endl;</span><br><span class="line">  if ( phKey )</span><br><span class="line">    CryptDestroyKey(phKey);</span><br><span class="line">  if ( phHash )</span><br><span class="line">    CryptDestroyHash(phHash);</span><br><span class="line">  if ( phProv )</span><br><span class="line">    CryptReleaseContext(phProv, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;windef.h&gt;</span><br><span class="line">#include &lt;wincrypt.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">BOOL AesDecrypt()</span><br><span class="line">&#123;</span><br><span class="line">	BOOL bRet = TRUE;</span><br><span class="line">	HCRYPTPROV hCryptProv = NULL;</span><br><span class="line">	HCRYPTHASH hCryptHash = NULL;</span><br><span class="line">	HCRYPTKEY hCryptKey = NULL;</span><br><span class="line"></span><br><span class="line">	BYTE pPassword[] = &#123; 0x5c,0x53,0xa4,0xa4,0x1d,0x52,0x43,0x7a,0x9f,0xa1,0xe9,0xc2,0x6c,0xa5,0x90,0x90 &#125;;</span><br><span class="line">    DWORD dwPasswordLength = 0x10;</span><br><span class="line">    BYTE pData[] = &#123; 0x5B, 0x9C, 0xEE, 0xB2, 0x3B, 0xB7, 0xD7, 0x34, 0xF3, 0x1B, 0x75, 0x14, 0xC6, 0xB2, 0x1F, 0xE8, 0xDE, 0x33, 0x44, 0x74, 0x75, 0x1B, 0x47, 0x6A, 0xD4, 0x37, 0x51, 0x88, 0xFC, 0x67, 0xE6, 0x60, 0xDA, 0x0D, 0x58, 0x07, 0x81, 0x43, 0x53, 0xEA, 0x7B, 0x52, 0x85, 0x6C, 0x86, 0x65, 0xAF, 0xB4 &#125;;</span><br><span class="line">	DWORD dwDataLength = 0x20;</span><br><span class="line">	DWORD dwBufferLength = 0x108;</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		// 获取CSP句柄</span><br><span class="line">		bRet = ::CryptAcquireContext(&amp;hCryptProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);</span><br><span class="line">		if (FALSE == bRet)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 创建HASH对象</span><br><span class="line">		bRet = ::CryptCreateHash(hCryptProv, CALG_MD5, NULL, 0, &amp;hCryptHash);</span><br><span class="line">		if (FALSE == bRet)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 对密钥进行HASH计算</span><br><span class="line">		bRet = ::CryptHashData(hCryptHash, pPassword, dwPasswordLength, 0);</span><br><span class="line">		if (FALSE == bRet)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 使用HASH来生成密钥</span><br><span class="line">		bRet = ::CryptDeriveKey(hCryptProv, CALG_AES_128, hCryptHash, CRYPT_EXPORTABLE, &amp;hCryptKey);</span><br><span class="line">		if (FALSE == bRet)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 解密数据</span><br><span class="line">		bRet = ::CryptDecrypt(hCryptKey, NULL, TRUE, 0, pData, &amp;dwDataLength);</span><br><span class="line">		if (FALSE == bRet)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; while (FALSE);</span><br><span class="line">cout&lt;&lt;pData&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	// 关闭释放</span><br><span class="line">	if (hCryptKey)</span><br><span class="line">	&#123;</span><br><span class="line">		::CryptDestroyKey(hCryptKey);</span><br><span class="line">	&#125;</span><br><span class="line">	if (hCryptHash)</span><br><span class="line">	&#123;</span><br><span class="line">		::CryptDestroyHash(hCryptHash);</span><br><span class="line">	&#125;</span><br><span class="line">	if (hCryptProv)</span><br><span class="line">	&#123;</span><br><span class="line">		::CryptReleaseContext(hCryptProv, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    AesDecrypt();</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后解得的结果是：</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426195628830.png" alt="image-20220426195628830"></p>
<p>最后的flag ：DASCTF{H@sh_a^d_Aes_6y_W1nCrypt}</p>
<h2 id="fakePica"><a href="#fakePica" class="headerlink" title="fakePica"></a>fakePica</h2><p>先用PKID查壳，太久没做APK的题目，当时做的时候都忘了进行查壳了，以后一定要注意，不要直接就jeb里面拖</p>
<p>可以看到这是一个梆梆加固</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426205532076.png" alt="image-20220426205532076"></p>
<h3 id="分析APK加固的方法"><a href="#分析APK加固的方法" class="headerlink" title="分析APK加固的方法"></a>分析APK加固的方法</h3><p>这里讲述的是通过反编译代码分析是梆梆加固的过程</p>
<p>先用jeb打开文件，在文件的主函数之中并没有找到MainActivity，但是发现引入了有关AppAplication的包，就可以猜测加了壳</p>
<p>再用APKTool得到程序的相关的文件，查看lib文件</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426210811471.png" alt="image-20220426210811471"></p>
<p>这两个so文件就是梆梆加固的so文件（通过下面lib文件和对应的加固方法的字典就能知道），可以用python写一个脚本来辨认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">markNameMap.put(&quot;libchaosvmp.so&quot;, &quot;娜迦&quot;);</span><br><span class="line">markNameMap.put(&quot;libddog.so&quot;, &quot;娜迦&quot;);</span><br><span class="line">markNameMap.put(&quot;libfdog.so&quot;, &quot;娜迦&quot;);</span><br><span class="line">markNameMap.put(&quot;libedog.so&quot;, &quot;娜迦企业版&quot;);</span><br><span class="line">markNameMap.put(&quot;libexec.so&quot;, &quot;爱加密&quot;);</span><br><span class="line">markNameMap.put(&quot;libexecmain.so&quot;, &quot;爱加密&quot;);</span><br><span class="line">markNameMap.put(&quot;ijiami.dat&quot;, &quot;爱加密&quot;);</span><br><span class="line">markNameMap.put(&quot;ijiami.ajm&quot;, &quot;爱加密企业版&quot;);</span><br><span class="line">markNameMap.put(&quot;libsecexe.so&quot;, &quot;梆梆免费版&quot;);</span><br><span class="line">markNameMap.put(&quot;libsecmain.so&quot;, &quot;梆梆免费版&quot;);</span><br><span class="line">markNameMap.put(&quot;libSecShell.so&quot;, &quot;梆梆免费版&quot;);</span><br><span class="line">markNameMap.put(&quot;libDexHelper.so&quot;, &quot;梆梆企业版&quot;);</span><br><span class="line">markNameMap.put(&quot;libDexHelper-x86.so&quot;, &quot;梆梆企业版&quot;);</span><br><span class="line">markNameMap.put(&quot;libprotectClass.so&quot;, &quot;360&quot;);</span><br><span class="line">markNameMap.put(&quot;libjiagu.so&quot;, &quot;360&quot;);</span><br><span class="line">markNameMap.put(&quot;libjiagu_art.so&quot;, &quot;360&quot;);</span><br><span class="line">markNameMap.put(&quot;libjiagu_x86.so&quot;, &quot;360&quot;);</span><br><span class="line">markNameMap.put(&quot;libegis.so&quot;, &quot;通付盾&quot;);</span><br><span class="line">markNameMap.put(&quot;libNSaferOnly.so&quot;, &quot;通付盾&quot;);</span><br><span class="line">markNameMap.put(&quot;libnqshield.so&quot;, &quot;网秦&quot;);</span><br><span class="line">markNameMap.put(&quot;libbaiduprotect.so&quot;, &quot;百度&quot;);</span><br><span class="line">markNameMap.put(&quot;aliprotect.dat&quot;, &quot;阿里聚安全&quot;);</span><br><span class="line">markNameMap.put(&quot;libsgmain.so&quot;, &quot;阿里聚安全&quot;);</span><br><span class="line">markNameMap.put(&quot;libsgsecuritybody.so&quot;, &quot;阿里聚安全&quot;);</span><br><span class="line">markNameMap.put(&quot;libmobisec.so&quot;, &quot;阿里聚安全&quot;);</span><br><span class="line">markNameMap.put(&quot;libtup.so&quot;, &quot;腾讯&quot;);</span><br><span class="line">markNameMap.put(&quot;libexec.so&quot;, &quot;腾讯&quot;);</span><br><span class="line">markNameMap.put(&quot;libshell.so&quot;, &quot;腾讯&quot;);</span><br><span class="line">markNameMap.put(&quot;mix.dex&quot;, &quot;腾讯&quot;);</span><br><span class="line">markNameMap.put(&quot;lib/armeabi/mix.dex&quot;, &quot;腾讯&quot;);</span><br><span class="line">markNameMap.put(&quot;lib/armeabi/mixz.dex&quot;, &quot;腾讯&quot;);</span><br><span class="line">markNameMap.put(&quot;libtosprotection.armeabi.so&quot;, &quot;腾讯御安全&quot;);</span><br><span class="line">markNameMap.put(&quot;libtosprotection.armeabi-v7a.so&quot;, &quot;腾讯御安全&quot;);</span><br><span class="line">markNameMap.put(&quot;libtosprotection.x86.so&quot;, &quot;腾讯御安全&quot;);</span><br><span class="line">markNameMap.put(&quot;libnesec.so&quot;, &quot;网易易盾&quot;);</span><br><span class="line">markNameMap.put(&quot;libAPKProtect.so&quot;, &quot;APKProtect&quot;);</span><br><span class="line">markNameMap.put(&quot;libkwscmm.so&quot;, &quot;几维安全&quot;);</span><br><span class="line">markNameMap.put(&quot;libkwscr.so&quot;, &quot;几维安全&quot;);</span><br><span class="line">markNameMap.put(&quot;libkwslinker.so&quot;, &quot;几维安全&quot;);</span><br><span class="line">markNameMap.put(&quot;libx3g.so&quot;, &quot;顶像科技&quot;);</span><br><span class="line">markNameMap.put(&quot;libapssec.so&quot;, &quot;盛大&quot;);</span><br><span class="line">markNameMap.put(&quot;librsprotect.so&quot;, &quot;瑞星&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="blackdex-APK脱壳"><a href="#blackdex-APK脱壳" class="headerlink" title="blackdex-APK脱壳"></a>blackdex-APK脱壳</h3><p>使用<a href="https://github.com/CodingGay/BlackDex">blackdex</a>软件进行脱壳</p>
<h4 id="判断32位还是64位的APK文件"><a href="#判断32位还是64位的APK文件" class="headerlink" title="判断32位还是64位的APK文件"></a>判断32位还是64位的APK文件</h4><p>首先判断一个APK是32位还是64位的</p>
<p>32位和64的架构</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426213154347.png" alt="image-20220426213154347"></p>
<p>查看lib文件夹</p>
<p>这里是armeabi-v7a 就说明是32位的</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426213235800.png" alt="image-20220426213235800"></p>
<p>所以运行32位的blackdex（将对应位数的blackdex的apk文件放入模拟器之中）,将需要脱壳的apk文件也拖入模拟器之中，运行脱壳的Apk文件，在这个程序之中选中需要脱壳的这个软件，就可以直接脱壳了，它脱壳完成之后将脱壳得到的dex文件存入下面这个文件目录之中</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426213832469.png" alt="image-20220426213832469"></p>
<p>在虚拟器的文件管理之中打开该文件夹，并且选中该文件夹（这个文件夹之中有4个dex文件），再打开共享文件夹，在共享文件夹的地方选中图中选项</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426215804244.png" alt="image-20220426215804244"></p>
<p>共享文件打开的地方：（高级功能之中能够对电脑端的共享文件夹进行重新的设置）</p>
<p>这样达到的效果就是电脑端的该文件夹和模拟器端的该文件夹是同步的。</p>
<p><img src="/images/DASCTF2022-FATE/image-20220426215837100.png" alt="image-20220426215837100"></p>
<p><img src="/images/DASCTF2022-FATE/image-20220426215849767.png" alt="image-20220426215849767"></p>
<h3 id="分析脱壳得到的dex文件"><a href="#分析脱壳得到的dex文件" class="headerlink" title="分析脱壳得到的dex文件"></a>分析脱壳得到的dex文件</h3><p>将这些dex文件拖进jeb之中分析：</p>
<blockquote>
<p>dex文件：</p>
<ul>
<li><p>dex文件是Android系统的可执行文件，包含应用程序的全部操作指令以及运行时数据。</p>
</li>
<li><p>当java程序编译成class后，还需要使用dex工具将所有的class文件整合到一个dex文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，dex文件是传统jar文件大小的50％左右。</p>
</li>
<li><p>dex文件的作用是记录整个工程（通常是一个Android工程）的所有类文件的信息。</p>
</li>
</ul>
</blockquote>
<p>逐个打开每个dex文件，在cookie_8836564.dex文件之中找到MainActivity函数</p>
<h4 id="AES解密"><a href="#AES解密" class="headerlink" title="AES解密"></a>AES解密</h4><p>打开这个mainActivity这个类就能很直观的看到用的是AES加密，并且是直接调用的Java的接口，所以就是标准的AES解密</p>
<p><img src="/images/DASCTF2022-FATE/image-20220427092404661.png" alt="image-20220427092404661"></p>
<p>AES的 key = “picapicapicapica” </p>
<p>AES的 IV向量 IV = “0102030405060708”</p>
<p>第一组的密文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-114, 0x5F, -37, 0x7F, -110, 0x71, 41, 74, 40, 73, 19, 0x7C, -57, -88, 39, -116, -16, -75, -3, -45, -73, -6, -104, -6, -78, 0x79, 110, 74, -90, -47, -28, -28</span><br><span class="line"></span><br><span class="line">0x8e,0x5f,0xdb,0x7f,0x92,0x71,0x29,0x4a,0x28,0x49,0x13,0x7c,0xc7,0xa8,0x27,0x8c,0xf0,0xb5,0xfd,0xd3,0xb7,0xfa,0x98,0xfa,0xb2,0x79,0x6e,0x4a,0xa6,0xd1,0xe4,0xe4</span><br><span class="line"></span><br><span class="line">8e5fdb7f9271294a2849137cc7a8278cf0b5fdd3b7fa98fab2796e4aa6d1e4e4</span><br><span class="line"></span><br><span class="line">明文： picacomic@gmail.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/DASCTF2022-FATE/image-20220427003406872.png" alt="image-20220427003406872"></p>
<p>第二组的密文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-40, 26, 0x5F, -49, -40, -123, 72, -90, -100, -41, 0x7A, -4, 25, -101, -58, 0x74</span><br><span class="line"></span><br><span class="line">0xd8,0x1a,0x5f,0xcf,0xd8,0x85,0x48,0xa6,0x9c,0xd7,0x7a,0xfc,0x19,0x9b,0xc6,0x74</span><br><span class="line"></span><br><span class="line">明文： picacomic</span><br></pre></td></tr></table></figure>

<p><img src="/images/DASCTF2022-FATE/image-20220427003510166.png" alt="image-20220427003510166"></p>
<p><img src="/images/DASCTF2022-FATE/image-20220427003744579.png" alt="image-20220427003744579"></p>
<p><img src="/images/DASCTF2022-FATE/image-20220427003747472.png" alt="image-20220427003747472"></p>
<p>flag{<a href="mailto:&#112;&#x69;&#x63;&#x61;&#x63;&#111;&#x6d;&#x69;&#x63;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x70;&#105;&#x63;&#97;&#99;&#x6f;&#x6d;&#x69;&#99;">&#112;&#x69;&#x63;&#x61;&#x63;&#111;&#x6d;&#x69;&#x63;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x70;&#105;&#x63;&#97;&#99;&#x6f;&#x6d;&#x69;&#99;</a>}</p>
<h2 id="奇怪的交易"><a href="#奇怪的交易" class="headerlink" title="奇怪的交易"></a>奇怪的交易</h2><p>当时用ida打开这个文件的时候就发现这个文件里面怎么提到了python的东西，当时还以为是在c语言之中运行python文件，结果发现是用python来打包elf文件，自己平时知识点的积累还是太少了</p>
<p><a href="https://lu1u.xyz/">Lu1u师傅</a> </p>
<p>使用pyinstxtractor解包就得到了对应的pyc文件</p>
<p><img src="/images/DASCTF2022-FATE/image-20220427135100720.png" alt="image-20220427135100720"></p>
<h3 id="pyc文件以及其中的pyz文件解包"><a href="#pyc文件以及其中的pyz文件解包" class="headerlink" title="pyc文件以及其中的pyz文件解包"></a>pyc文件以及其中的pyz文件解包</h3><p>这个地方用<a href="https://github.com/extremecoders-re/pyinstxtractor/wiki/Frequently-Asked-Questions">pyinstxtractor解包</a>源文件的时候要使用python3.10的环境运行这个pyinstxtractor.py文件。这样pyz文件解包的文件才能够在PYZ-00.pyz_extracted文件夹之中获得</p>
<p>安装和使用Miniconda3 这个软件的作用是用来管理环境的（这里用来在本机上配置python3.10环境）</p>
<p><a href="https://docs.conda.io/en/latest/miniconda.html">下载的地址</a></p>
<p><a href="https://ywnz.com/linuxjc/3834.html">安装和卸载的地址</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/133494097">使用软件</a></p>
<p>如何判断这个文件打包的时候使用的是python版本的是3.10的呢？</p>
<p>答：随便使用一个版本的pyinstxtractor来解包文件，通过它的依赖文件就可以进行判断</p>
<p><img src="/images/DASCTF2022-FATE/image-20220502181556493.png" alt="image-20220502181556493"></p>
<p>这道题目的python版本是3.10，它的magic的num可以通过struct.pyc文件的前4个字节获得，或者通过PYZ-00.pyz文件的5到8字节数据能够得到</p>
<p><img src="/images/DASCTF2022-FATE/image-20220502181645404.png" alt="image-20220502181645404"></p>
<p>用这个magic number将pyc文件补全（因为在打包文件的时候常常会将pyc文件的magic number去掉，我们在恢复的时候需要自己去补全，补全之后就能够进行反编译了，但是这里反编译因为是python3.10，所以不能使用python-uncompyle6得到，要使用pycdc来进行反编译</p>
<p>对奇怪的交易.pyc 文件头4个字节进行重新设置</p>
<p>python3.10版本的pyc文件的文件头是 </p>
<p><img src="/images/DASCTF2022-FATE/image-20220427173936449.png" alt="image-20220427173936449"></p>
<p>设置完之后，用在线pyc反编译软件可以反编译，也可以使用pycdc进行反编译 ，再用pycdas得到字节码</p>
<p>对照着字节码对下面反编译的结果进行修复</p>
<ul>
<li><p>RSA低指数加密</p>
</li>
<li><p>从cpu包中引入函数encrypt()加密</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Source Generated with Decompyle++</span><br><span class="line"># File: 奇怪的交易.pyc (Python 3.10)</span><br><span class="line"></span><br><span class="line">from cup import *</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    flag = input(&#x27;\xe8\xaf\xb7\xe8\xbe\x93\xe5\x85\xa5flag&#x27;)</span><br><span class="line">    pub_key = [   0x649EE967E7916A825CC9FD3320BEABF263BEAC68C080F52824A0F521EDB6B78577EC52BF1C9E78F4BB71192F9A23F1A17AA76E5979E4D953329D3CA65FB4A71DA57412B59DFD6AEDF0191C5555D3E5F582B81B5E6B23163E9889204A81AFFDF119FE25C92F4ED59BD3285BCD7AAE14824240D2E33C5A97848F4EB7AAC203DE6330D2B4D8FF61691544FBECD120F99A157B3D2F58FA51B2887A9D06CA383C44D071314A12B17928B96F03A06E959A5AFEFA0183664F52CD32B9FC72A04B45913FCB2D5D2D3A415A14F611CF1EAC2D6C785142A8E9CC41B67A6CD85001B06EDB8CA767D367E56E0AE651491BF8A8C17A38A1835DB9E4A9292B1D86D5776C98CC25L,</span><br><span class="line">        0x647327833ACFEF1F9C83E74E171FC300FA347D4A6769476C33DA82C95120ACB38B62B33D429206FE6E9BB0BB7AB748A1036971BEA36EC47130B749C1C9FF6FE03D0F7D9FC5346EB0E575BDFA6C530AA57CD676894FC080D2DD049AB59625F4B9C78BCFD95CDCD2793E440E26E189D251121CB6EB177FEDB596409034E8B0C5BBD9BD9342235DBB226C9170EFE347FF0FD2CFF9A1F7B647CC83E4D8F005FD7125A89251C768AFE70BDD54B88116814D5030F499BCAC4673CCCC342FB4B6AC58EA5A64546DC25912B6C430529F6A7F449FD96536DE269D1A1B015A4AC6B6E46EE19DCE8143726A6503E290E4BAE6BD78319B5878981F6CFFDB3B818209341FD68BL]</span><br><span class="line">    m = libnum.s2n(flag)</span><br><span class="line">    c = str(pow(m, pub_key[1], pub_key[0]))  // RSA的公钥 pub_key[1]  模的对象pub_key[0]</span><br><span class="line">    array0 = []</span><br><span class="line">    array1 = [0xd28ed952,0x57c844df,0xd91ba938,0xf9f3bd2d,0x8ef8e43d,0x24d0a6d4,0x57e35037,0x57b9a2ea,0x3c5f16c0,0xd7821910,0x3b3d098c,0x1a22518d,0xc83555b7,0xe8dff468,0xbdbdffd,0xc5b84feb,0xd9f837c6,0x248c0bef,0x8efa4edd,0x5cc7851,0x8b4b608c,0x57b785f2,0xc0b62792,0x22c8fc3e,0xaab1c22d,0xbdb9c266,0x528335db,0xae9f9816,0xd1f40b3c,0x8206ddc3,0xc4e0badc,0xe407bd26,0x8ae5685,0x8016c6a5,0xaf4ab9d3,0x1e35204a,0x3b483e49,0x85082a0b,0xca0bc95a,0xa7be567c,0x41eb42c8,0x6aad143c,0xdfefb591,0x93346b38,0x4547158e,0x289465d1,0xaee1a7a2,0x80e574ae,0xf154f55f,0x7e755cdc,0xfcbda653,0x8e902444,0xca742e12,0xb8424071,0xb4b15ec2,0x943bfa09,0xbc97cd93,0x4ca0c180,0x2f9e8e58,0x8b58328f,0xf9822360,0xd1fd15ee,0x40398f89,0x559e65ca,0xa2d6c17e,0x59d616ed,0x1dd8eeb5,0xbd8c105,0x8e014807,0x347aaa04,0x7573b596,0xbfc6ee25,0x4540463f,0x2168859c,0x6a405498,0x9d93febe,0x4c9a89ad,0x2f041932,0x47454f1e,0xf2174a07,0x62a2dc3,0x952bfe83,0xf730ac4c,0x24cf49f1,0x3a4e5490,0x6a2f4289,0x8379d23a,0xead737ee,0xe41555fb,0x27500d24,0x99f3b244,0x5d1878b8,0x842c31a4,0x46e33b42,0xa14f3e4,0xa5ce044c,0x4ee902b9,0x31276ee4,0x1854ae7c,0xe0178482,0xf412bbbc,0x59f173e1,0x9ae5225,0xde740b00,0xb7cb64fd,0xebcadb1f,0x8eae2326,0x933c216c,0xd7d1f649,0x1cb99f66,0xa448ac16,0xbc082807,0x4b2a6481,0x7afa8587,0x8474a61d,0x60c272b,0xbc5654d1,0x669749b9,0x40470389,0xa8546b9,0xd3c5280f,0x5d597033,0x73920388,0x595d57ad,0xc59872f8,0x317471ac,0xe51502a2,0x38cc9816,0x4c81d679,0x79e45563,0xebe6a798,0xe09575cd,0xaddf4157,0xc4770191,0x1cbf464d,0x675e4574,0xdac71054,0x99807e43,0xa88d74b1,0xcb77e028,0x5b67a7bb,0xeeebc3b6,0xe7e680e5,0x10450af8,0x12eccbeb,0xc4b10cdc,0x91776399,0x1a32a98,0x63576ed2,0x6796abb9,0x2cc32a20,0x8e364d8f,0xa0985a77,0x218d8f16,0x837d6dc3]</span><br><span class="line">    i = 0</span><br><span class="line">    // 我觉得按常理来说是将数据的每四个字节为一组，</span><br><span class="line">    while i &lt; len(c):</span><br><span class="line">        tem = 0</span><br><span class="line">        for ii in c[i:i+4]:</span><br><span class="line">        	tem = (tem&lt;&lt;8)+ord(ii)   //将输入的元素的4个数按照大序端的方式排成一个数</span><br><span class="line">        array0.append(tem)  // 每四个字节的数据一起加密</span><br><span class="line">        i += 4</span><br><span class="line">        if not i &lt; len(c):  // 判断字节的长度</span><br><span class="line">            temArray = [ 54,54,54,54]</span><br><span class="line">            strLen = len(array0)</span><br><span class="line">            res = encrypt(strLen, array0, temArray)</span><br><span class="line">            if array0 == array1:</span><br><span class="line">                print(&#x27;You are right!&#x27;)</span><br><span class="line">                input(&#x27;&#x27;)</span><br><span class="line">                quit()</span><br><span class="line">            else:</span><br><span class="line">                print(&#x27;Why not drink a cup of tea and have a rest?&#x27;)</span><br><span class="line">    continue</span><br><span class="line">array0是输入的数据</span><br><span class="line">strLen是输入数据的长度</span><br><span class="line">temArray应该是密钥</span><br><span class="line">array1是密文</span><br></pre></td></tr></table></figure>

<p>但是因为这个反编译的代码不太正确，所以使用pycdas得到它的字节码： <a href="https://zhuanlan.zhihu.com/p/45101508">字节码</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Code]</span><br><span class="line">    File Name: 奇怪的交易.py</span><br><span class="line">    Object Name: &lt;module&gt;</span><br><span class="line">    Arg Count: 0</span><br><span class="line">    Pos Only Arg Count: 0</span><br><span class="line">    KW Only Arg Count: 0</span><br><span class="line">    Locals: 0</span><br><span class="line">    Stack Size: 6</span><br><span class="line">    Flags: 0x00000040 (CO_NOFREE)</span><br><span class="line">    [Names]</span><br><span class="line">        &#x27;cup&#x27;</span><br><span class="line">        &#x27;__name__&#x27;</span><br><span class="line">        &#x27;input&#x27;</span><br><span class="line">        &#x27;flag&#x27;</span><br><span class="line">        &#x27;pub_key&#x27;</span><br><span class="line">        &#x27;libnum&#x27;</span><br><span class="line">        &#x27;s2n&#x27;</span><br><span class="line">        &#x27;m&#x27;</span><br><span class="line">        &#x27;str&#x27;</span><br><span class="line">        &#x27;pow&#x27;</span><br><span class="line">        &#x27;c&#x27;</span><br><span class="line">        &#x27;\xe1\x98\xa1&#x27;</span><br><span class="line">        &#x27;\xe1\x98\x99&#x27;</span><br><span class="line">        &#x27;i&#x27;</span><br><span class="line">        &#x27;len&#x27;</span><br><span class="line">        &#x27;\xe1\x98\x9e&#x27;</span><br><span class="line">        &#x27;ii&#x27;</span><br><span class="line">        &#x27;ord&#x27;</span><br><span class="line">        &#x27;append&#x27;</span><br><span class="line">        &#x27;\xe1\x98\x9d&#x27;</span><br><span class="line">        &#x27;\xe1\x98\xa0&#x27;</span><br><span class="line">        &#x27;encrypt&#x27;</span><br><span class="line">        &#x27;res&#x27;</span><br><span class="line">        &#x27;print&#x27;</span><br><span class="line">        &#x27;quit&#x27;</span><br><span class="line">    [Var Names]</span><br><span class="line">    [Free Vars]</span><br><span class="line">    [Cell Vars]</span><br><span class="line">    [Constants]</span><br><span class="line">        0</span><br><span class="line">        (</span><br><span class="line">            &#x27;*&#x27;</span><br><span class="line">        )</span><br><span class="line">        &#x27;__main__&#x27;</span><br><span class="line">        True</span><br><span class="line">        &#x27;\xe8\xaf\xb7\xe8\xbe\x93\xe5\x85\xa5flag&#x27;</span><br><span class="line">        0x649EE967E7916A825CC9FD3320BEABF263BEAC68C080F52824A0F521EDB6B78577EC52BF1C9E78F4BB71192F9A23F1A17AA76E5979E4D953329D3CA65FB4A71DA57412B59DFD6AEDF0191C5555D3E5F582B81B5E6B23163E9889204A81AFFDF119FE25C92F4ED59BD3285BCD7AAE14824240D2E33C5A97848F4EB7AAC203DE6330D2B4D8FF61691544FBECD120F99A157B3D2F58FA51B2887A9D06CA383C44D071314A12B17928B96F03A06E959A5AFEFA0183664F52CD32B9FC72A04B45913FCB2D5D2D3A415A14F611CF1EAC2D6C785142A8E9CC41B67A6CD85001B06EDB8CA767D367E56E0AE651491BF8A8C17A38A1835DB9E4A9292B1D86D5776C98CC25L</span><br><span class="line">        0x647327833ACFEF1F9C83E74E171FC300FA347D4A6769476C33DA82C95120ACB38B62B33D429206FE6E9BB0BB7AB748A1036971BEA36EC47130B749C1C9FF6FE03D0F7D9FC5346EB0E575BDFA6C530AA57CD676894FC080D2DD049AB59625F4B9C78BCFD95CDCD2793E440E26E189D251121CB6EB177FEDB596409034E8B0C5BBD9BD9342235DBB226C9170EFE347FF0FD2CFF9A1F7B647CC83E4D8F005FD7125A89251C768AFE70BDD54B88116814D5030F499BCAC4673CCCC342FB4B6AC58EA5A64546DC25912B6C430529F6A7F449FD96536DE269D1A1B015A4AC6B6E46EE19DCE8143726A6503E290E4BAE6BD78319B5878981F6CFFDB3B818209341FD68BL</span><br><span class="line">        1</span><br><span class="line">        (</span><br><span class="line">        0xd28ed952,0x57c844df,0xd91ba938,0xf9f3bd2d,0x8ef8e43d,0x24d0a6d4,0x57e35037,0x57b9a2ea,0x3c5f16c0,0xd7821910,0x3b3d098c,0x1a22518d,0xc83555b7,0xe8dff468,0xbdbdffd,0xc5b84feb,0xd9f837c6,0x248c0bef,0x8efa4edd,0x5cc7851,0x8b4b608c,0x57b785f2,0xc0b62792,0x22c8fc3e,0xaab1c22d,0xbdb9c266,0x528335db,0xae9f9816,0xd1f40b3c,0x8206ddc3,0xc4e0badc,0xe407bd26,0x8ae5685,0x8016c6a5,0xaf4ab9d3,0x1e35204a,0x3b483e49,0x85082a0b,0xca0bc95a,0xa7be567c,0x41eb42c8,0x6aad143c,0xdfefb591,0x93346b38,0x4547158e,0x289465d1,0xaee1a7a2,0x80e574ae,0xf154f55f,0x7e755cdc,0xfcbda653,0x8e902444,0xca742e12,0xb8424071,0xb4b15ec2,0x943bfa09,0xbc97cd93,0x4ca0c180,0x2f9e8e58,0x8b58328f,0xf9822360,0xd1fd15ee,0x40398f89,0x559e65ca,0xa2d6c17e,0x59d616ed,0x1dd8eeb5,0xbd8c105,0x8e014807,0x347aaa04,0x7573b596,0xbfc6ee25,0x4540463f,0x2168859c,0x6a405498,0x9d93febe,0x4c9a89ad,0x2f041932,0x47454f1e,0xf2174a07,0x62a2dc3,0x952bfe83,0xf730ac4c,0x24cf49f1,0x3a4e5490,0x6a2f4289,0x8379d23a,0xead737ee,0xe41555fb,0x27500d24,0x99f3b244,0x5d1878b8,0x842c31a4,0x46e33b42,0xa14f3e4,0xa5ce044c,0x4ee902b9,0x31276ee4,0x1854ae7c,0xe0178482,0xf412bbbc,0x59f173e1,0x9ae5225,0xde740b00,0xb7cb64fd,0xebcadb1f,0x8eae2326,0x933c216c,0xd7d1f649,0x1cb99f66,0xa448ac16,0xbc082807,0x4b2a6481,0x7afa8587,0x8474a61d,0x60c272b,0xbc5654d1,0x669749b9,0x40470389,0xa8546b9,0xd3c5280f,0x5d597033,0x73920388,0x595d57ad,0xc59872f8,0x317471ac,0xe51502a2,0x38cc9816,0x4c81d679,0x79e45563,0xebe6a798,0xe09575cd,0xaddf4157,0xc4770191,0x1cbf464d,0x675e4574,0xdac71054,0x99807e43,0xa88d74b1,0xcb77e028,0x5b67a7bb,0xeeebc3b6,0xe7e680e5,0x10450af8,0x12eccbeb,0xc4b10cdc,0x91776399,0x1a32a98,0x63576ed2,0x6796abb9,0x2cc32a20,0x8e364d8f,0xa0985a77,0x218d8f16,0x837d6dc3,</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">        4</span><br><span class="line">        8</span><br><span class="line">        (</span><br><span class="line">            54</span><br><span class="line">            54</span><br><span class="line">            54</span><br><span class="line">            54</span><br><span class="line">        )</span><br><span class="line">        &#x27;You are right!&#x27;</span><br><span class="line">        &#x27;&#x27;</span><br><span class="line">        &#x27;Why not drink a cup of tea and have a rest?&#x27;</span><br><span class="line">        None</span><br><span class="line">    [Disassembly]</span><br><span class="line">        0       LOAD_CONST              0: 0</span><br><span class="line">        2       LOAD_CONST              1: (&#x27;*&#x27;,)</span><br><span class="line">        4       IMPORT_NAME             0: cup</span><br><span class="line">        6       IMPORT_STAR             </span><br><span class="line">        8       LOAD_NAME               1: __name__</span><br><span class="line">        10      LOAD_CONST              2: &#x27;__main__&#x27;</span><br><span class="line">        12      COMPARE_OP              2 (==)</span><br><span class="line">        14      POP_JUMP_IF_FALSE       119 (to 238)</span><br><span class="line">        16      NOP                     </span><br><span class="line">        18      LOAD_NAME               2: input</span><br><span class="line">        20      LOAD_CONST              4: &#x27;\xe8\xaf\xb7\xe8\xbe\x93\xe5\x85\xa5flag&#x27;</span><br><span class="line">        22      CALL_FUNCTION           1</span><br><span class="line">        24      STORE_NAME              3: flag</span><br><span class="line">        26      LOAD_CONST              5: 0x649EE967E7916A825CC9FD3320BEABF263BEAC68C080F52824A0F521EDB6B78577EC52BF1C9E78F4BB71192F9A23F1A17AA76E5979E4D953329D3CA65FB4A71DA57412B59DFD6AEDF0191C5555D3E5F582B81B5E6B23163E9889204A81AFFDF119FE25C92F4ED59BD3285BCD7AAE14824240D2E33C5A97848F4EB7AAC203DE6330D2B4D8FF61691544FBECD120F99A157B3D2F58FA51B2887A9D06CA383C44D071314A12B17928B96F03A06E959A5AFEFA0183664F52CD32B9FC72A04B45913FCB2D5D2D3A415A14F611CF1EAC2D6C785142A8E9CC41B67A6CD85001B06EDB8CA767D367E56E0AE651491BF8A8C17A38A1835DB9E4A9292B1D86D5776C98CC25L</span><br><span class="line">        28      LOAD_CONST              6: 0x647327833ACFEF1F9C83E74E171FC300FA347D4A6769476C33DA82C95120ACB38B62B33D429206FE6E9BB0BB7AB748A1036971BEA36EC47130B749C1C9FF6FE03D0F7D9FC5346EB0E575BDFA6C530AA57CD676894FC080D2DD049AB59625F4B9C78BCFD95CDCD2793E440E26E189D251121CB6EB177FEDB596409034E8B0C5BBD9BD9342235DBB226C9170EFE347FF0FD2CFF9A1F7B647CC83E4D8F005FD7125A89251C768AFE70BDD54B88116814D5030F499BCAC4673CCCC342FB4B6AC58EA5A64546DC25912B6C430529F6A7F449FD96536DE269D1A1B015A4AC6B6E46EE19DCE8143726A6503E290E4BAE6BD78319B5878981F6CFFDB3B818209341FD68BL</span><br><span class="line">        30      BUILD_LIST              2</span><br><span class="line">        32      STORE_NAME              4: pub_key</span><br><span class="line">        34      LOAD_NAME               5: libnum</span><br><span class="line">        36      LOAD_METHOD             6: s2n</span><br><span class="line">        38      LOAD_NAME               3: flag</span><br><span class="line">        40      CALL_METHOD             1</span><br><span class="line">        42      STORE_NAME              7: m</span><br><span class="line">        44      LOAD_NAME               8: str</span><br><span class="line">        46      LOAD_NAME               9: pow</span><br><span class="line">        48      LOAD_NAME               7: m</span><br><span class="line">        50      LOAD_NAME               4: pub_key</span><br><span class="line">        52      LOAD_CONST              7: 1</span><br><span class="line">        54      BINARY_SUBSCR           </span><br><span class="line">        56      LOAD_NAME               4: pub_key</span><br><span class="line">        58      LOAD_CONST              0: 0</span><br><span class="line">        60      BINARY_SUBSCR           </span><br><span class="line">        62      CALL_FUNCTION           3</span><br><span class="line">        64      CALL_FUNCTION           1</span><br><span class="line">        66      STORE_NAME              10: c</span><br><span class="line">        68      BUILD_LIST              0</span><br><span class="line">        70      STORE_NAME              11: store</span><br><span class="line">        72      BUILD_LIST              0</span><br><span class="line">        74      LOAD_CONST              8: (0xD28ED952L, 1472742623, 0xD91BA938L, 0xF9F3BD2DL, 0x8EF8E43DL, 617653972, 1474514999, 1471783658, 1012864704, 0xD7821910L, 993855884, 438456717, 0xC83555B7L, 0xE8DFF468L, 198959101, 0xC5B84FEBL, 0xD9F837C6L, 613157871, 0x8EFA4EDDL, 97286225, 0x8B4B608CL, 1471645170, 0xC0B62792L, 583597118, 0xAAB1C22DL, 0xBDB9C266L, 1384330715, 0xAE9F9816L, 0xD1F40B3CL, 0x8206DDC3L, 0xC4E0BADCL, 0xE407BD26L, 145643141, 0x8016C6A5L, 0xAF4AB9D3L, 506798154, 994590281, 0x85082A0BL, 0xCA0BC95AL, 0xA7BE567CL, 1105937096, 1789727804, 0xDFEFB591L, 0x93346B38L, 1162286478, 680814033, 0xAEE1A7A2L, 0x80E574AEL, 0xF154F55FL, 2121620700, 0xFCBDA653L, 0x8E902444L, 0xCA742E12L, 0xB8424071L, 0xB4B15EC2L, 0x943BFA09L, 0xBC97CD93L, 1285603712, 798920280, 0x8B58328FL, 0xF9822360L, 0xD1FD15EEL, 1077514121, 1436444106, 0xA2D6C17EL, 1507202797, 500756149, 198754565, 0x8E014807L, 880454148, 1970517398, 0xBFC6EE25L, 1161840191, 560498076, 1782600856, 0x9D93FEBEL, 1285196205, 788797746, 1195724574, 0xF2174A07L, 103427523, 0x952BFE83L, 0xF730AC4CL, 617564657, 978211984, 1781482121, 0x8379D23AL, 0xEAD737EEL, 0xE41555FBL, 659557668, 0x99F3B244L, 1561884856, 0x842C31A4L, 1189296962, 169145316, 0xA5CE044CL, 1323893433, 824667876, 408202876, 0xE0178482L, 0xF412BBBCL, 1508996065, 162419237, 0xDE740B00L, 0xB7CB64FDL, 0xEBCADB1FL, 0x8EAE2326L, 0x933C216CL, 0xD7D1F649L, 481927014, 0xA448AC16L, 0xBC082807L, 1261069441, 2063238535, 0x8474A61DL, 101459755, 0xBC5654D1L, 1721190841, 1078395785, 176506553, 0xD3C5280FL, 1566142515, 1938949000, 1499289517, 0xC59872F8L, 829714860, 0xE51502A2L, 952932374, 1283577465, 2045007203, 0xEBE6A798L, 0xE09575CDL, 0xADDF4157L, 0xC4770191L, 482297421, 1734231412, 0xDAC71054L, 0x99807E43L, 0xA88D74B1L, 0xCB77E028L, 1533519803, 0xEEEBC3B6L, 0xE7E680E5L, 272960248, 317508587, 0xC4B10CDCL, 0x91776399L, 27470488, 1666674386, 1737927609, 750987808, 0x8E364D8FL, 0xA0985A77L, 562925334, 0x837D6DC3L)</span><br><span class="line">        76      LIST_EXTEND             1</span><br><span class="line">        78      STORE_NAME              12: ᘙ</span><br><span class="line">        80      LOAD_CONST              0: 0</span><br><span class="line">        82      STORE_NAME              13: i</span><br><span class="line">        84      LOAD_NAME               13: i</span><br><span class="line">        86      LOAD_NAME               14: len      while i&lt;len(c):</span><br><span class="line">        88      LOAD_NAME               10: c</span><br><span class="line">        90      CALL_FUNCTION           1</span><br><span class="line">        92      COMPARE_OP              0 (&lt;)</span><br><span class="line">        94      POP_JUMP_IF_FALSE       84 (to 168) // 当不成立的时候就错误的跳转</span><br><span class="line">        96      LOAD_CONST              0: 0</span><br><span class="line">        98      STORE_NAME              15: index   index = 0</span><br><span class="line">        100     LOAD_NAME               10: c</span><br><span class="line">        102     LOAD_NAME               13: i</span><br><span class="line">        104     LOAD_NAME               13: i</span><br><span class="line">        106     LOAD_CONST              9: 4</span><br><span class="line">        108     BINARY_ADD                   // i+4</span><br><span class="line">        110     BUILD_SLICE             2    c[i:i+4]</span><br><span class="line">        112     BINARY_SUBSCR               // 读取其中的值    </span><br><span class="line">        114     GET_ITER                    // 开始迭代</span><br><span class="line">        116     FOR_ITER                10 (to 138)</span><br><span class="line">        118     STORE_NAME              16: ii</span><br><span class="line">        120     LOAD_NAME               15: index</span><br><span class="line">        122     LOAD_CONST              10: 8</span><br><span class="line">        124     BINARY_LSHIFT           // index&lt;&lt;8</span><br><span class="line">        126     LOAD_NAME               17: ord</span><br><span class="line">        128     LOAD_NAME               16: ii</span><br><span class="line">        130     CALL_FUNCTION           1</span><br><span class="line">        132     BINARY_ADD              (index&lt;&lt;8)+ord(ii)</span><br><span class="line">        134     STORE_NAME              15: index   index =  (index&lt;&lt;8)+ord(ii)</span><br><span class="line">        136     JUMP_ABSOLUTE           58</span><br><span class="line">        138     LOAD_NAME               11: store</span><br><span class="line">        140     LOAD_METHOD             18: append</span><br><span class="line">        142     LOAD_NAME               15: index   </span><br><span class="line">        144     CALL_METHOD             1    store.append(index)</span><br><span class="line">        146     POP_TOP                 </span><br><span class="line">        148     LOAD_NAME               13: i</span><br><span class="line">        150     LOAD_CONST              9: 4</span><br><span class="line">        152     INPLACE_ADD               // i = i+4</span><br><span class="line">        154     STORE_NAME              13: i</span><br><span class="line">        156     LOAD_NAME               13: i</span><br><span class="line">        158     LOAD_NAME               14: len</span><br><span class="line">        160     LOAD_NAME               10: c</span><br><span class="line">        162     CALL_FUNCTION           1</span><br><span class="line">        164     COMPARE_OP              0 (&lt;)  i&lt;len(c)</span><br><span class="line">        166     POP_JUMP_IF_TRUE        48 (to 96)     if not i&lt;len(c):</span><br><span class="line">        168     BUILD_LIST              0</span><br><span class="line">        170     LOAD_CONST              11: (54, 54, 54, 54)</span><br><span class="line">        172     LIST_EXTEND             1</span><br><span class="line">        174     STORE_NAME              19: ᘝ</span><br><span class="line">        176     LOAD_NAME               14: len</span><br><span class="line">        178     LOAD_NAME               11: store</span><br><span class="line">        180     CALL_FUNCTION           1</span><br><span class="line">        182     STORE_NAME              20: ᘠ</span><br><span class="line">        184     LOAD_NAME               21: encrypt</span><br><span class="line">        186     LOAD_NAME               20: ᘠ</span><br><span class="line">        188     LOAD_NAME               11: store</span><br><span class="line">        190     LOAD_NAME               19: ᘝ</span><br><span class="line">        192     CALL_FUNCTION           3</span><br><span class="line">        194     STORE_NAME              22: res</span><br><span class="line">        196     LOAD_NAME               11: store</span><br><span class="line">        198     LOAD_NAME               12: ᘙ</span><br><span class="line">        200     COMPARE_OP              2 (==)</span><br><span class="line">        202     POP_JUMP_IF_FALSE       114 (to 228)</span><br><span class="line">        204     LOAD_NAME               23: print</span><br><span class="line">        206     LOAD_CONST              12: &#x27;You are right!&#x27;</span><br><span class="line">        208     CALL_FUNCTION           1</span><br><span class="line">        210     POP_TOP                 </span><br><span class="line">        212     LOAD_NAME               2: input</span><br><span class="line">        214     LOAD_CONST              13: &#x27;&#x27;</span><br><span class="line">        216     CALL_FUNCTION           1</span><br><span class="line">        218     POP_TOP                 </span><br><span class="line">        220     LOAD_NAME               24: quit</span><br><span class="line">        222     CALL_FUNCTION           0</span><br><span class="line">        224     POP_TOP                 </span><br><span class="line">        226     JUMP_FORWARD            4 (to 236)</span><br><span class="line">        228     LOAD_NAME               23: print</span><br><span class="line">        230     LOAD_CONST              14: &#x27;Why not drink a cup of tea and have a rest?&#x27;</span><br><span class="line">        232     CALL_FUNCTION           1</span><br><span class="line">        234     POP_TOP                 </span><br><span class="line">        236     JUMP_ABSOLUTE           9</span><br><span class="line">        238     LOAD_CONST              15: None</span><br><span class="line">        240     RETURN_VALUE            </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="pyz文件解密"><a href="#pyz文件解密" class="headerlink" title="pyz文件解密"></a>pyz文件解密</h3><p>送上面修复的反编译的结果之中我们能够看到，这里引用了一个函数，这个函数是重cup这个包中导入的</p>
<p>这个包的获得是在PYZ-00.pyz_extracted文件夹：</p>
<blockquote>
<p>一般一个稍微大一点的项目都会分成多个py文件，甚至会依赖其他模块，这些被依赖的文件解析后都会放入PYZ-00.pyz_extracted文件夹之中，这个文件之中相当于放的是核心代码，这个文件之中放入的就是PYZ-00.pyz这个文件解压之后得到的文件，注意这个文件想要用pyinstxtractor.py正常得到，我们需要在这个pyc相对应的python环境之中运行该脚本（上面已经介绍了怎么管理多个python环境）</p>
</blockquote>
<p>这里的pyz文件进行了加密，因为pyinstaller可以将文件pyc进行一定的压缩加密，以防止被逆向</p>
<p><a href="https://bbs.pediy.com/thread-271253.htm">pyz文件加密解密</a></p>
<h4 id="pyz文件加密的密钥和过程的文件"><a href="#pyz文件加密的密钥和过程的文件" class="headerlink" title="pyz文件加密的密钥和过程的文件"></a>pyz文件加密的密钥和过程的文件</h4><p>通过pyinstxtractor获得了部分没有加密的pyc文件，其中就有archive.pyc文件（得到加密过程）和crypto_key文件(得到具体key参数)</p>
<p><img src="/images/DASCTF2022-FATE/image-20220504152929032.png" alt="image-20220504152929032"></p>
<p>archive.pyc文件:(反编译)</p>
<p><img src="/images/DASCTF2022-FATE/image-20220504153248511.png" alt="image-20220504153248511"></p>
<p>加密的关键代码</p>
<p><img src="/images/DASCTF2022-FATE/image-20220504153401888.png" alt="image-20220504153401888"></p>
<p>crypto_key文件:(反编译)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key = &#x27;0000000000000tea&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/images/DASCTF2022-FATE/image-20220504153121767.png" alt="image-20220504153121767"></p>
<p>因为在源加密代码之中加密函数是从cup这个包之中引入的，所以我们在那个解压缩之后得到的文件夹之中找到对应的对应的包的加密文件</p>
<p><img src="/images/DASCTF2022-FATE/image-20220504154026910.png" alt="image-20220504154026910"></p>
<h4 id="pyz文件解密脚本"><a href="#pyz文件解密脚本" class="headerlink" title="pyz文件解密脚本"></a>pyz文件解密脚本</h4><p><a href="https://github.com/extremecoders-re/pyinstxtractor/wiki/Frequently-Asked-Questions">解密</a>该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import tinyaes</span><br><span class="line">import zlib</span><br><span class="line"></span><br><span class="line">CRYPT_BLOCK_SIZE = 16</span><br><span class="line"></span><br><span class="line"># key obtained from pyimod00_crypto_key</span><br><span class="line">key = bytes(&#x27;0000000000000tea&#x27;, &#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">inf = open(&#x27;cup.pyc.encrypted&#x27;, &#x27;rb&#x27;) # encrypted file input</span><br><span class="line">outf = open(&#x27;cup.pyc&#x27;, &#x27;wb&#x27;) # output file</span><br><span class="line"></span><br><span class="line"># Initialization vector</span><br><span class="line">iv = inf.read(CRYPT_BLOCK_SIZE)</span><br><span class="line"></span><br><span class="line">cipher = tinyaes.AES(key, iv)</span><br><span class="line"></span><br><span class="line"># Decrypt and decompress</span><br><span class="line">plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))</span><br><span class="line"></span><br><span class="line"># Write pyc header</span><br><span class="line"># The header below is for Python 3.8</span><br><span class="line">outf.write(b&#x27;\x6f\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0&#x27;)</span><br><span class="line"></span><br><span class="line"># Write decrypted data</span><br><span class="line">outf.write(plaintext)</span><br><span class="line"></span><br><span class="line">inf.close()</span><br><span class="line">outf.close()</span><br></pre></td></tr></table></figure>

<p>各个python版本打包的pyc文件的文件头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 2.7: \x03\xf3\x0d\x0a\0\0\0\0</span><br><span class="line">Python 3.0: \x3b\x0c\x0d\x0a\0\0\0\0</span><br><span class="line">Python 3.1: \x4f\x0c\x0d\x0a\0\0\0\0</span><br><span class="line">Python 3.2: \x6c\x0c\x0d\x0a\0\0\0\0</span><br><span class="line">Python 3.3: \x9e\x0c\x0d\x0a\0\0\0\0\0\0\0\0</span><br><span class="line">Python 3.4: \xee\x0c\x0d\x0a\0\0\0\0\0\0\0\0</span><br><span class="line">Python 3.5: \x17\x0d\x0d\x0a\0\0\0\0\0\0\0\0</span><br><span class="line">Python 3.6: \x33\x0d\x0d\x0a\0\0\0\0\0\0\0\0</span><br><span class="line">Python 3.7: \x42\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0</span><br><span class="line">Python 3.8: \x55\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0</span><br><span class="line">Python 3.9: \x61\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0</span><br><span class="line">Python 3.10: \x6f\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0</span><br></pre></td></tr></table></figure>

<h3 id="xxtea解密"><a href="#xxtea解密" class="headerlink" title="xxtea解密"></a>xxtea解密</h3><p>得到的加密函数encrypt()的pyc文件，所以对这个文件反编译就能够知道函数逻辑</p>
<p>可以看到这里加密的方法是xxtea，这里反编译得到的代码还是有点问题，但是我们可以明显的知道这个地方用的都是xxtea加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># visit https://tool.lu/pyc/ for more information</span><br><span class="line"># Version: Python 3.10</span><br><span class="line"></span><br><span class="line">import libnum</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">def MX(z, y, total, key, p, e):</span><br><span class="line">    temp1 = (z.value &gt;&gt; 5 ^ y.value &lt;&lt; 2) + (y.value &gt;&gt; 3 ^ z.value &lt;&lt; 4)</span><br><span class="line">    temp2 = (total.value ^ y.value) + (key[p &amp; 3 ^ e.value] ^ z.value)</span><br><span class="line">    return c_uint32(temp1 ^ temp2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt(n, v, key):</span><br><span class="line">    DELTA = 0x9E3779B9L</span><br><span class="line">    rounds = 6 + 52 // n</span><br><span class="line">    total = c_uint32(0)</span><br><span class="line">    z = c_uint32(v[n - 1])</span><br><span class="line">    e = c_uint32(0)</span><br><span class="line">    while rounds &gt; 0:</span><br><span class="line">        total.value += DELTA</span><br><span class="line">        e.value = total.value &gt;&gt; 2 &amp; 3</span><br><span class="line">        y = c_uint32(v[0])</span><br><span class="line">        v[n - 1] = c_uint32(v[n - 1] + MX(z, y, total, key, n - 1, e).value).value</span><br><span class="line">        z.value = v[n - 1]</span><br><span class="line">        rounds -= 1</span><br><span class="line">        if not rounds &gt; 0:</span><br><span class="line">            return v</span><br></pre></td></tr></table></figure>

<p>所以xxtea解密：</p>
<p>因为加密的数据是按照大序端存放的，并且给得到的是经过rsa加密的数字的字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9E3779B9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+<span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[]= &#123;<span class="number">0xd28ed952</span>,<span class="number">0x57c844df</span>,<span class="number">0xd91ba938</span>,<span class="number">0xf9f3bd2d</span>,<span class="number">0x8ef8e43d</span>,<span class="number">0x24d0a6d4</span>,<span class="number">0x57e35037</span>,<span class="number">0x57b9a2ea</span>,<span class="number">0x3c5f16c0</span>,<span class="number">0xd7821910</span>,<span class="number">0x3b3d098c</span>,<span class="number">0x1a22518d</span>,<span class="number">0xc83555b7</span>,<span class="number">0xe8dff468</span>,<span class="number">0xbdbdffd</span>,<span class="number">0xc5b84feb</span>,<span class="number">0xd9f837c6</span>,<span class="number">0x248c0bef</span>,<span class="number">0x8efa4edd</span>,<span class="number">0x5cc7851</span>,<span class="number">0x8b4b608c</span>,<span class="number">0x57b785f2</span>,<span class="number">0xc0b62792</span>,<span class="number">0x22c8fc3e</span>,<span class="number">0xaab1c22d</span>,<span class="number">0xbdb9c266</span>,<span class="number">0x528335db</span>,<span class="number">0xae9f9816</span>,<span class="number">0xd1f40b3c</span>,<span class="number">0x8206ddc3</span>,<span class="number">0xc4e0badc</span>,<span class="number">0xe407bd26</span>,<span class="number">0x8ae5685</span>,<span class="number">0x8016c6a5</span>,<span class="number">0xaf4ab9d3</span>,<span class="number">0x1e35204a</span>,<span class="number">0x3b483e49</span>,<span class="number">0x85082a0b</span>,<span class="number">0xca0bc95a</span>,<span class="number">0xa7be567c</span>,<span class="number">0x41eb42c8</span>,<span class="number">0x6aad143c</span>,<span class="number">0xdfefb591</span>,<span class="number">0x93346b38</span>,<span class="number">0x4547158e</span>,<span class="number">0x289465d1</span>,<span class="number">0xaee1a7a2</span>,<span class="number">0x80e574ae</span>,<span class="number">0xf154f55f</span>,<span class="number">0x7e755cdc</span>,<span class="number">0xfcbda653</span>,<span class="number">0x8e902444</span>,<span class="number">0xca742e12</span>,<span class="number">0xb8424071</span>,<span class="number">0xb4b15ec2</span>,<span class="number">0x943bfa09</span>,<span class="number">0xbc97cd93</span>,<span class="number">0x4ca0c180</span>,<span class="number">0x2f9e8e58</span>,<span class="number">0x8b58328f</span>,<span class="number">0xf9822360</span>,<span class="number">0xd1fd15ee</span>,<span class="number">0x40398f89</span>,<span class="number">0x559e65ca</span>,<span class="number">0xa2d6c17e</span>,<span class="number">0x59d616ed</span>,<span class="number">0x1dd8eeb5</span>,<span class="number">0xbd8c105</span>,<span class="number">0x8e014807</span>,<span class="number">0x347aaa04</span>,<span class="number">0x7573b596</span>,<span class="number">0xbfc6ee25</span>,<span class="number">0x4540463f</span>,<span class="number">0x2168859c</span>,<span class="number">0x6a405498</span>,<span class="number">0x9d93febe</span>,<span class="number">0x4c9a89ad</span>,<span class="number">0x2f041932</span>,<span class="number">0x47454f1e</span>,<span class="number">0xf2174a07</span>,<span class="number">0x62a2dc3</span>,<span class="number">0x952bfe83</span>,<span class="number">0xf730ac4c</span>,<span class="number">0x24cf49f1</span>,<span class="number">0x3a4e5490</span>,<span class="number">0x6a2f4289</span>,<span class="number">0x8379d23a</span>,<span class="number">0xead737ee</span>,<span class="number">0xe41555fb</span>,<span class="number">0x27500d24</span>,<span class="number">0x99f3b244</span>,<span class="number">0x5d1878b8</span>,<span class="number">0x842c31a4</span>,<span class="number">0x46e33b42</span>,<span class="number">0xa14f3e4</span>,<span class="number">0xa5ce044c</span>,<span class="number">0x4ee902b9</span>,<span class="number">0x31276ee4</span>,<span class="number">0x1854ae7c</span>,<span class="number">0xe0178482</span>,<span class="number">0xf412bbbc</span>,<span class="number">0x59f173e1</span>,<span class="number">0x9ae5225</span>,<span class="number">0xde740b00</span>,<span class="number">0xb7cb64fd</span>,<span class="number">0xebcadb1f</span>,<span class="number">0x8eae2326</span>,<span class="number">0x933c216c</span>,<span class="number">0xd7d1f649</span>,<span class="number">0x1cb99f66</span>,<span class="number">0xa448ac16</span>,<span class="number">0xbc082807</span>,<span class="number">0x4b2a6481</span>,<span class="number">0x7afa8587</span>,<span class="number">0x8474a61d</span>,<span class="number">0x60c272b</span>,<span class="number">0xbc5654d1</span>,<span class="number">0x669749b9</span>,<span class="number">0x40470389</span>,<span class="number">0xa8546b9</span>,<span class="number">0xd3c5280f</span>,<span class="number">0x5d597033</span>,<span class="number">0x73920388</span>,<span class="number">0x595d57ad</span>,<span class="number">0xc59872f8</span>,<span class="number">0x317471ac</span>,<span class="number">0xe51502a2</span>,<span class="number">0x38cc9816</span>,<span class="number">0x4c81d679</span>,<span class="number">0x79e45563</span>,<span class="number">0xebe6a798</span>,<span class="number">0xe09575cd</span>,<span class="number">0xaddf4157</span>,<span class="number">0xc4770191</span>,<span class="number">0x1cbf464d</span>,<span class="number">0x675e4574</span>,<span class="number">0xdac71054</span>,<span class="number">0x99807e43</span>,<span class="number">0xa88d74b1</span>,<span class="number">0xcb77e028</span>,<span class="number">0x5b67a7bb</span>,<span class="number">0xeeebc3b6</span>,<span class="number">0xe7e680e5</span>,<span class="number">0x10450af8</span>,<span class="number">0x12eccbeb</span>,<span class="number">0xc4b10cdc</span>,<span class="number">0x91776399</span>,<span class="number">0x1a32a98</span>,<span class="number">0x63576ed2</span>,<span class="number">0x6796abb9</span>,<span class="number">0x2cc32a20</span>,<span class="number">0x8e364d8f</span>,<span class="number">0xa0985a77</span>,<span class="number">0x218d8f16</span>,<span class="number">0x837d6dc3</span>,<span class="number">0x0</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= &#123;<span class="number">54</span>,<span class="number">54</span>,<span class="number">54</span>,<span class="number">54</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n= <span class="number">155</span>; <span class="comment">//n的绝对值表示v的长度，取正表示加密，取负表示解密</span></span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line"><span class="comment">//    printf(&quot;加密前原始数据：%s\n&quot;,(char*)v);</span></span><br><span class="line"><span class="comment">//    btea(v, n, k);</span></span><br><span class="line"><span class="comment">//    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v[3]);</span></span><br><span class="line">    btea(v, -n, k);</span><br><span class="line"><span class="comment">//    printf(&quot;解密后的数据：%s\n&quot;,(char*)v);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">155</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,((v[i]&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>));</span><br><span class="line">        v[i] = v[i]&lt;&lt;<span class="number">8</span>; <span class="comment">// 将这个数左移8位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>xxtea解密结果：（RSA的密文）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10610336534759505889607399322387179316771488492347274741918862678692508953185876570981227584004676580623553664818853686933004290078153620168054665086468417541382824708104480882577200529822968531743002301934310349005341104696887943182074473298650903541494918266823037984054778903666406545980557074219162536057146090758158128189406073809226361445046225524917089434897957301396534515964547462425719205819342172669899546965221084098690893672595962129879041507903210851706793788311452973769358455761907303633956322972510500253009083922781934406731633755418753858930476576720874219359466503538931371444470303193503733920039</span><br></pre></td></tr></table></figure>

<h3 id="RSA低解密指数攻击"><a href="#RSA低解密指数攻击" class="headerlink" title="RSA低解密指数攻击"></a>RSA低解密指数攻击</h3><p>RSA解密，在题目之中提供了n和公钥 </p>
<p>素数分解的网站 <a href="http://www.factordb.com/index.php%EF%BC%88%E8%BF%99%E9%81%93%E9%A2%98%E7%94%A8%E4%B8%8D%E4%B8%8A%EF%BC%89">http://www.factordb.com/index.php（这道题用不上）</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 0x647327833ACFEF1F9C83E74E171FC300FA347D4A6769476C33DA82C95120ACB38B62B33D429206FE6E9BB0BB7AB748A1036971BEA36EC47130B749C1C9FF6FE03D0F7D9FC5346EB0E575BDFA6C530AA57CD676894FC080D2DD049AB59625F4B9C78BCFD95CDCD2793E440E26E189D251121CB6EB177FEDB596409034E8B0C5BBD9BD9342235DBB226C9170EFE347FF0FD2CFF9A1F7B647CC83E4D8F005FD7125A89251C768AFE70BDD54B88116814D5030F499BCAC4673CCCC342FB4B6AC58EA5A64546DC25912B6C430529F6A7F449FD96536DE269D1A1B015A4AC6B6E46EE19DCE8143726A6503E290E4BAE6BD78319B5878981F6CFFDB3B818209341FD68B</span><br><span class="line">n = </span><br><span class="line">0x649EE967E7916A825CC9FD3320BEABF263BEAC68C080F52824A0F521EDB6B78577EC52BF1C9E78F4BB71192F9A23F1A17AA76E5979E4D953329D3CA65FB4A71DA57412B59DFD6AEDF0191C5555D3E5F582B81B5E6B23163E9889204A81AFFDF119FE25C92F4ED59BD3285BCD7AAE14824240D2E33C5A97848F4EB7AAC203DE6330D2B4D8FF61691544FBECD120F99A157B3D2F58FA51B2887A9D06CA383C44D071314A12B17928B96F03A06E959A5AFEFA0183664F52CD32B9FC72A04B45913FCB2D5D2D3A415A14F611CF1EAC2D6C785142A8E9CC41B67A6CD85001B06EDB8CA767D367E56E0AE651491BF8A8C17A38A1835DB9E4A9292B1D86D5776C98CC25</span><br></pre></td></tr></table></figure>

<p>这里的RSA是低解密指数攻击</p>
<blockquote>
<p>在RSA中d也称为解密指数，当d比较小的时候，e也就显得特别大了。<br>适用情况：e过大或过小（一般e过大时使用）</p>
<p>使用工具：工具rsa-wiener-attack</p>
</blockquote>
<p><a href="https://github.com/Mr-Aur0ra/RSA/blob/master/PKCS1_OAEP%E6%A8%A1%E5%BC%8F%E7%9A%84RSA/%E5%9F%BA%E4%BA%8Ersa-wiener-attack%E8%A7%A3%E9%A2%98/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.md">使用工具rsa-wiener-attack解密</a></p>
<p><a href="https://github.com/pablocelayes/rsa-wiener-attack">rsa-wiener-attack下载地址</a></p>
<p>利用这个工具是为了得到d，然后再使用RSA解密运算 pow(c,d,n) 得到最终的密文</p>
<p>RSA解密脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">import ContinuedFractions, Arithmetic</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line">def wiener_hack(e, n):</span><br><span class="line">    # firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git !</span><br><span class="line">    frac = ContinuedFractions.rational_to_contfrac(e, n)</span><br><span class="line">    convergents = ContinuedFractions.convergents_from_contfrac(frac)</span><br><span class="line">    for (k, d) in convergents:</span><br><span class="line">        if k != 0 and (e * d - 1) % k == 0:</span><br><span class="line">            phi = (e * d - 1) // k</span><br><span class="line">            s = n - phi + 1</span><br><span class="line">            discr = s * s - 4 * n</span><br><span class="line">            if (discr &gt;= 0):</span><br><span class="line">                t = Arithmetic.is_perfect_square(discr)</span><br><span class="line">                if t != -1 and (s + t) % 2 == 0:</span><br><span class="line">                    print(&quot;First: Hacked d.&quot;)</span><br><span class="line">                    return d</span><br><span class="line">    return False</span><br><span class="line">n = 0x649EE967E7916A825CC9FD3320BEABF263BEAC68C080F52824A0F521EDB6B78577EC52BF1C9E78F4BB71192F9A23F1A17AA76E5979E4D953329D3CA65FB4A71DA57412B59DFD6AEDF0191C5555D3E5F582B81B5E6B23163E9889204A81AFFDF119FE25C92F4ED59BD3285BCD7AAE14824240D2E33C5A97848F4EB7AAC203DE6330D2B4D8FF61691544FBECD120F99A157B3D2F58FA51B2887A9D06CA383C44D071314A12B17928B96F03A06E959A5AFEFA0183664F52CD32B9FC72A04B45913FCB2D5D2D3A415A14F611CF1EAC2D6C785142A8E9CC41B67A6CD85001B06EDB8CA767D367E56E0AE651491BF8A8C17A38A1835DB9E4A9292B1D86D5776C98CC25</span><br><span class="line">e = 0x647327833ACFEF1F9C83E74E171FC300FA347D4A6769476C33DA82C95120ACB38B62B33D429206FE6E9BB0BB7AB748A1036971BEA36EC47130B749C1C9FF6FE03D0F7D9FC5346EB0E575BDFA6C530AA57CD676894FC080D2DD049AB59625F4B9C78BCFD95CDCD2793E440E26E189D251121CB6EB177FEDB596409034E8B0C5BBD9BD9342235DBB226C9170EFE347FF0FD2CFF9A1F7B647CC83E4D8F005FD7125A89251C768AFE70BDD54B88116814D5030F499BCAC4673CCCC342FB4B6AC58EA5A64546DC25912B6C430529F6A7F449FD96536DE269D1A1B015A4AC6B6E46EE19DCE8143726A6503E290E4BAE6BD78319B5878981F6CFFDB3B818209341FD68B</span><br><span class="line">c = 10610336534759505889607399322387179316771488492347274741918862678692508953185876570981227584004676580623553664818853686933004290078153620168054665086468417541382824708104480882577200529822968531743002301934310349005341104696887943182074473298650903541494918266823037984054778903666406545980557074219162536057146090758158128189406073809226361445046225524917089434897957301396534515964547462425719205819342172669899546965221084098690893672595962129879041507903210851706793788311452973769358455761907303633956322972510500253009083922781934406731633755418753858930476576720874219359466503538931371444470303193503733920039</span><br><span class="line"></span><br><span class="line">d = wiener_hack(e, n)</span><br><span class="line">m = pow(c,d,n)</span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line">b&#x27;flag&#123;You_Need_Some_Tea&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>所以最后的flag是  flag{You_Need_Some_Tea} </p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>md5</tag>
        <tag>SHA1</tag>
        <tag>Wincrpt解密AES</tag>
        <tag>APK加固</tag>
        <tag>APK脱壳(blackdex)</tag>
        <tag>pyc文件解包(pyinstxtractor)</tag>
        <tag>pyz文件解密</tag>
        <tag>pyc文件反编译(pycdc工具)</tag>
        <tag>RSA低解密指数攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>VNCTF_2022</title>
    <url>/2022/02/25/VNCTF-2022/</url>
    <content><![CDATA[<h2 id="VN2022"><a href="#VN2022" class="headerlink" title="VN2022"></a>VN2022</h2><h4 id="cm狗"><a href="#cm狗" class="headerlink" title="cm狗"></a>cm狗</h4><p>用jadx软件载入这个apk文件</p>
<p>判断flag的函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141557259.png" alt="image-20220215141557259"></p>
<p>判断的函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141619535.png" alt="image-20220215141619535"></p>
<p>loadDexClass()的这个函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141712322.png" alt="image-20220215141712322"></p>
<p>这里copyfile了一个dex的文件，这里copyFile()函数里面应该还有一系列的操作，一系列操作的结果最后写入了创建的一个文件里面</p>
<p>找到这个文件，并且找到这个函数</p>
<p><img src="/images/VNCTF-2022/image-20220219205934006.png" alt="image-20220219205934006"></p>
<p>该函数的详情</p>
<p><img src="/images/VNCTF-2022/image-20220219210128389.png" alt="image-20220219210128389"></p>
<p>主要的代码</p>
<p><img src="/images/VNCTF-2022/image-20220219210151167.png" alt="image-20220219210151167"></p>
<p><img src="/images/VNCTF-2022/image-20220219210531948.png" alt="image-20220219210531948"></p>
<p>注意这个地方是每次取1024出来，外层有个while(true)的循环的操作</p>
<p>得到的这个文件名称是 classes.dex</p>
<p><img src="/images/VNCTF-2022/image-20220219213108277.png" alt="image-20220219213108277"></p>
<p>对文件进行操作的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v0 = &#x27;vn2022&#x27;</span><br><span class="line">with open(&quot;D:\\re\\buuctf\\VN\\3\\ooo&quot;,&#x27;rb&#x27;) as f1:</span><br><span class="line">    c = f1.read()</span><br><span class="line">with open(&quot;D:\\re\\buuctf\\VN\\3\\out&quot;,&#x27;wb&#x27;) as f2:</span><br><span class="line">    for i in range(len(c)):</span><br><span class="line">        f2.write((c[i]^ord(v0[i %1024 % len(v0)])).to_bytes(1,byteorder=&quot;little&quot;,signed=False))</span><br><span class="line">print(&quot;OK&quot;)</span><br></pre></td></tr></table></figure>

<p>将得到的这个文件命名为class.dex，这是一个dex文件，首先使用dex2jar 将 dex文件转变成jar文件，然后使用jd-gui打开这个得到的jar文件，注意使用dex2jar得到jar文件的时候，需要将dex文件放入到dex2jar的文件夹目录之下</p>
<p>得到的这个文件之中 </p>
<p>加密函数 （xxtea加密）</p>
<p><img src="/images/VNCTF-2022/image-20220219223231506.png" alt="image-20220219223231506"></p>
<p>在hcheck这个函数之中，首先给了一堆数字，然后将输入的flag以及xxtea的密钥输入，对输入进行加密，加密的结果就是上面定义的一系列数值</p>
<p><img src="/images/VNCTF-2022/image-20220219223525059.png" alt="image-20220219223525059"></p>
<p><img src="/images/VNCTF-2022/image-20220219223528938.png" alt="image-20220219223528938"></p>
<p>去网上找一个xxtea解密的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9            //固定的一个常量</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   //固定的运算</span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])   //v是要加密的两个元素的数组</span><br><span class="line">&#123;                                                      //n为数组的长度</span><br><span class="line">    uint32_t y, z, sum;                                //无符号整型</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52/n;               //固定的得出轮数</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n-1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;                //每次进行叠加</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;          //固定运算</span><br><span class="line">            for (p=0; p&lt;n-1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+1];</span><br><span class="line">                v[p] += MX;</span><br><span class="line">                      z = v[p];</span><br><span class="line">                        &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n-1] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=n-1; p&gt;0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p-1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n-1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int8_t a[]= &#123;68, 39, -92, 108, -82, -18, 72, -55, 74, -56, 38, 11, 60, 84, 97, -40, 87, 71, 99, -82, 120, 104, 47, -71, -58, -57, 0, 33, 42, 38, -44, -39, -60, 113, -2, 92, -75, 118, -77, 50, -121, 43, 32, -106 &#125;;</span><br><span class="line">    uint32_t *v = (uint32_t *)a;</span><br><span class="line">    uint32_t *k= (uint32_t *)&quot;H4pPY_VNCTF!!OvO&quot;;</span><br><span class="line">    int n= 11;</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    printf(&quot;decrypto result:%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n&quot;,v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10]);</span><br><span class="line">    printf(&quot;result:%s&quot;,v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">VNCTF&#123;93ee7688-f216-42cb-a5c2-191ff4e412ba&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220219230318245.png" alt="image-20220219230318245"></p>
<p>所以最后的flag 是 VNCTF{93ee7688-f216-42cb-a5c2-191ff4e412ba}</p>
<h4 id="BabyMaze"><a href="#BabyMaze" class="headerlink" title="BabyMaze"></a>BabyMaze</h4><p>这道题如果直接使用employee6 解pyc得到代码是不行的，因为在这个代码里面有花指令，</p>
<p>方法一：直接使用pycda中的得到bytecode的底层的代码</p>
<p>看见迷宫，拼一下迷宫，按照w代表向上走，s代表向下走，a代表向左走，d代表向右走的方式走迷宫</p>
<p>python的pyc文件的反编译pycdc和pycdas这两个文件，pycdc反编译为python的代码，pycdas这个文件会将pyc文件编译成字节码的形式 <a href="http://www.syjblog.com/?p=470">pyc反编译</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/89935120">pyc的结构体</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Bytecode object */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">   PyObject_HEAD</span><br><span class="line">   int co_argcount;            /* Code Block的位置参数个数，比如说一个函数的位置参数个数*/</span><br><span class="line">   int co_nlocals;             /* Code Block中局部变量的个数，包括其中位置参数的个数 */</span><br><span class="line">   int co_stacksize;           /* 执行该段Code Block需要的栈空间 */</span><br><span class="line">   int co_flags;               /* CO_..., see below */</span><br><span class="line">   PyObject *co_code;          /* Code Block编译所得的字节码指令序列。以PyStingObjet的形式存在 */</span><br><span class="line">   PyObject *co_consts;        /* PyTupleObject对象，保存CodeBlock中的所常量 */</span><br><span class="line">   PyObject *co_names;         /* PyTupleObject对象，保存CodeBlock中的所有符号 */</span><br><span class="line">   PyObject *co_varnames;      /* Code Block中的局部变量名集合 */</span><br><span class="line">   PyObject *co_freevars;      /* Python实现闭包需要用的东西 */</span><br><span class="line">   PyObject *co_cellvars;      /* Code Block中内部嵌套函数所引用的局部变量名集合 */</span><br><span class="line">   /* The rest doesn&#x27;t count for hash/cmp */</span><br><span class="line">   PyObject *co_filename;      /* Code Block所对应的.py文件的完整路径 */</span><br><span class="line">   PyObject *co_name;          /* Code Block的名字，通常是函数名或类名 */</span><br><span class="line">   int co_firstlineno;         /* Code Block在对应的.py文件中起始行 */</span><br><span class="line">   PyObject *co_lnotab;        /* 字节码指令与.py文件中source code行号的对应关系，以PyStringObject的形式存在 */</span><br><span class="line">   void *co_zombieframe;     /* for optimization only (see frameobject.c) */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>

<p>得到：走出的迷宫的结果</p>
<p>ssssddssaassddddwwwwddwwddddddwwddddddssddwwddddddddssssaawwaassaassaassddssaassaawwwwwwaaaaaaaassaassddddwwddssddssssaassddssssaaaaaawwddwwaawwwwaassssssssssssddddssddssddddddddwwaaaaaawwwwddssddwwwwwwwwddssddssssssssddddss</p>
<p>将上面的解md5(32小写)得到最后的结果  VNCTF{801f190737434100e7d2790bd5b0732e}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                   1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">68      BUILD_LIST              31 1 5 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">132     BUILD_LIST              31 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1</span><br><span class="line">196     BUILD_LIST              31 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1</span><br><span class="line">260     BUILD_LIST              31 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1</span><br><span class="line">324     BUILD_LIST              31 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">388     BUILD_LIST              31 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1</span><br><span class="line">452     BUILD_LIST              31 1 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1</span><br><span class="line">516     BUILD_LIST              31 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1</span><br><span class="line">580     BUILD_LIST              31 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">644     BUILD_LIST              31 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1</span><br><span class="line">708     BUILD_LIST              31 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">772     BUILD_LIST              31 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1</span><br><span class="line">836     BUILD_LIST              31 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">900     BUILD_LIST              31 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1</span><br><span class="line">964     BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">1028    BUILD_LIST              31 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 0 1</span><br><span class="line">1092    BUILD_LIST              31 1 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">1156    BUILD_LIST              31 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1</span><br><span class="line">1220    BUILD_LIST              31 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">1284    BUILD_LIST              31 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 0 1</span><br><span class="line">1348    BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1412    BUILD_LIST              31 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1476    BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1540    BUILD_LIST              31 1 0 1 1 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1604    BUILD_LIST              31 1 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1</span><br><span class="line">1668    BUILD_LIST              31 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1</span><br><span class="line">1732    BUILD_LIST              31 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1</span><br><span class="line">1796    BUILD_LIST              31 1 0 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1</span><br><span class="line">1860    BUILD_LIST              31 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 7 1</span><br><span class="line">1924    BUILD_LIST              31 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>VNCTF{801f190737434100e7d2790bd5b0732e}</p>
<h4 id="时空飞行"><a href="#时空飞行" class="headerlink" title="时空飞行"></a>时空飞行</h4><p>运行一下这个程序，因为不能直接运行，所以使用IDA调试运行，所以现在我们需要找到日期和符来歌（根据运行之中的提示语句得到）</p>
<p><img src="/images/VNCTF-2022/image-20220221120512364.png" alt="image-20220221120512364"></p>
<p>变化之后的日期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0FD07C452h, 0EC90A488h, 68D33CD1h, 96F64587h</span><br></pre></td></tr></table></figure>

<p>对输入的日期进行加密的过程</p>
<p><img src="/images/VNCTF-2022/image-20220221122556035.png" alt="image-20220221122556035"></p>
<p>v5[v3] = sub_401A3B(v5[i + 3] ^ v5[i + 2] ^ (unsigned int)v5[i + 1] ^ dword_405040[i]) ^ v4;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v5[4] = sub_401A3B(v5[3] ^ v5[2] ^ (unsigned int)v5[1] ^ dword_405040[0]) ^ v5[0];</span><br><span class="line">v5[5] = sub_401A3B(v5[4] ^ v5[3] ^ (unsigned int)v5[2] ^ dword_405040[1]) ^ v5[1];</span><br><span class="line">... ...</span><br><span class="line">v5[34] = sub_401A3B(v5[33] ^ v5[32] ^ (unsigned int)v5[31] ^ dword_405040[2]) ^ v5[30];</span><br><span class="line">v5[35] = sub_401A3B(v5[34] ^ v5[33] ^ (unsigned int)v5[32] ^ dword_405040[3]) ^ v5[31];</span><br></pre></td></tr></table></figure>

<p>sub_401A3B()这个函数的作用</p>
<p><img src="/images/VNCTF-2022/image-20220221123230352.png" alt="image-20220221123230352"></p>
<p>a1和a1向左移13位的结果和a1向右移9位的结果做异或运算，</p>
<p>逆向分析的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">unsigned int CalcRound(unsigned int key)&#123;</span><br><span class="line">    return key ^((((key&amp;0xffffffff)&lt;&lt;13)|((key&amp;0xffffffff)&gt;&gt;(32-13)))^(((key&amp;0xffffffff)&lt;&lt;(32-9))|((key&amp;0xffffffff)&gt;&gt;9)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long CK[32] = &#123;</span><br><span class="line">0x00070e15,0x1c232a31,0x383f464d,0x545b6269,</span><br><span class="line">0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,</span><br><span class="line">0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,</span><br><span class="line">0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,</span><br><span class="line">0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,</span><br><span class="line">0x30373e45,0x4c535a61,0x686f767d,0x848b9299,</span><br><span class="line">0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,</span><br><span class="line">0x10171e25,0x2c333a41,0x484f565d,0x646b7279</span><br><span class="line">&#125;;</span><br><span class="line">    unsigned int result[] = &#123;0x0FD07C452, 0x0EC90A488, 0x68D33CD1, 0x96F64587&#125;;</span><br><span class="line">    unsigned int re_result[36];</span><br><span class="line">    for(int i=32;i&lt;36;i++)&#123;</span><br><span class="line">        re_result[i] =result[i-32];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=31;i&gt;=0;i--)&#123;</span><br><span class="line">        re_result[i] = CalcRound(re_result[i+1]^re_result[i+2]^re_result[i+3]^CK[i])^re_result[i+4];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned long tem[4] = &#123;0xA3B1BAC6,0x56AA3350,0x677D9197,0xB27022DC&#125;;</span><br><span class="line">    for(int i=0;i&lt;=3;i++)&#123;</span><br><span class="line">        re_result[i]=re_result[i]^tem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char *data = (unsigned char *)re_result;   //因为日期的表示是8个数字，每个数字是用8位来代表</span><br><span class="line">    for(int i=1;i&lt;=2;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=4;j++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;,data[i*4 - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">20211205</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221133215573.png" alt="image-20220221133215573"></p>
<p>将得到的日期放入之后，就要进行符来歌的输入</p>
<p><img src="/images/VNCTF-2022/image-20220221133557404.png" alt="image-20220221133557404"></p>
<p>最后需要对比的元素是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1ebe,0x1e8e,0x1e44,0x1e39,0x1e5b,0x1e8,0x1e36,0x1e8f,0x1edd,0x1e5e,0x1e94,0x1eb5,0x1e1,0x1e70,0x1eab,0x1e63,0x1ebb,0x1e72,0x1e50,0x1e13,0x1e5d,0x1e25,0x1e16,0x1e78</span><br></pre></td></tr></table></figure>

<p>在上面函数 之中对这个数组中的元素做了一定的运算，下面得到的就是运算加密之后的数组</p>
<p><img src="/images/VNCTF-2022/image-20220221170531828.png" alt="image-20220221170531828"></p>
<p>所以需要比较的数组是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221183335046.png" alt="image-20220221183335046"></p>
<p>用爆破的方式得到上面的解，发现这里某些会有多个解所以需要使用递归的方式，深度优先算法解得所有的解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [ 0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3]</span><br><span class="line">i=0</span><br><span class="line">flags=[]</span><br><span class="line">flag = [0]*24</span><br><span class="line">flag[23] = 0xe3</span><br><span class="line">def DFS(deep):</span><br><span class="line">  global flags</span><br><span class="line">  global flag</span><br><span class="line">  if deep ==0:</span><br><span class="line">    flags.append(flag.copy())</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">    for j in range(1,0xff):</span><br><span class="line">      tem = j^((j % 0x12+ flag[deep] + 0x05) ^ 0x41)</span><br><span class="line">      if tem == obj[deep-1]:</span><br><span class="line">        flag[deep-1]=j</span><br><span class="line">        DFS(deep-1)</span><br><span class="line">              </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  DFS(23)</span><br><span class="line">  for i in range(len(flags)):</span><br><span class="line">    print(flags[i])</span><br><span class="line">[20, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[21, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[22, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[23, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[28, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[29, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[30, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[31, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[128, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[129, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[130, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[131, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[136, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[137, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[138, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[139, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[72, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[73, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[74, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[75, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[80, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[81, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[82, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[83, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[88, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[89, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[184, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[185, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[186, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[187, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221183354391.png" alt="image-20220221183354391"></p>
<p>通过这个我们可以获得 a1[60] a1[61] a1[62] a1[63] a1[64] a1[65] 5个数</p>
<p>对输入的每32个字节的操作：将32位数 F1F1 F2F2 F3F3 F4F4 排列为 F4F4 F3F3 F2F2 F1F1 </p>
<p><img src="/images/VNCTF-2022/image-20220221184405201.png" alt="image-20220221184405201"></p>
<p>将所有输入的字符进行上面的运算，然后重新赋值给a1 则可以知道数组之中有6个元素</p>
<p><img src="/images/VNCTF-2022/image-20220221184743758.png" alt="image-20220221184743758"></p>
<p>然后就需要进行一系列的运算，</p>
<p><img src="/images/VNCTF-2022/image-20220221185657924.png" alt="image-20220221185657924"></p>
<p>当v5不是6的倍数的时候 </p>
<p>当i不是6的倍数的时候：v5[7] = v5[1]^v5[6]   v5[i] = v5[i-6] ^ v5[i-1] </p>
<p>当i是6的倍数的时候：v5[i] = v5[i-6] ^ T(v5[i-1],v3)  v3代表的是第几个6的倍数</p>
<p><strong>T函数的讲解</strong>：</p>
<p><img src="/images/VNCTF-2022/image-20220221190435689.png" alt="image-20220221190435689"></p>
<p>其中的第一个函数：将a1分解成了4个元素的数组0x  F0F0 F1F1 F2F2 F3F3</p>
<p><img src="/images/VNCTF-2022/image-20220221190819733.png" alt="image-20220221190819733"></p>
<p>其中的第二个函数：将数组中的元素循环右移一位 ；例如 a=[a0,a1,a2,a3] 转化成 a=[a1,a2,a3,a0] </p>
<p>[F3F3,F2F2,F1F1,F0F0] [F2F2,F1F1,F0F0,F3F3]</p>
<p><img src="/images/VNCTF-2022/image-20220221191008054.png" alt="image-20220221191008054"></p>
<p>其中第三个函数：整合上面的数组之中的元素  0x F3F3 F0F0 F1F1 F2F2</p>
<p><img src="/images/VNCTF-2022/image-20220221191329845.png" alt="image-20220221191329845"></p>
<p>所以这个函数的作用是 将 0x  F0F0 F1F1 F2F2 F3F3 转化成 0x F3F3 F0F0 F1F1 F2F2 循环左移动了8位 然后再和对应那个6的倍数作为脚标找到数组对应的元素</p>
<p>作为索引对象的数组是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000,</span><br><span class="line">           0x36000000]</span><br></pre></td></tr></table></figure>

<p>每组得到了6个数字，将这六个元素作为66个元素之中的后六位元素</p>
<p>逆向：</p>
<p>当i不是6的倍数时： v5[i-6] = v5[i]^v5[i-1]</p>
<p>当i是6的倍数时： v5[i-6] = v5[i]^ T(v5[i-1],v3) # v3 = i%6 T是将数循环左移动了8位，再和对应的数字进行异或运算</p>
<p>逆向得到的66个元素的前6个元素，将前6个元素转化为字符输出</p>
<p>所有运算的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [ 0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3]</span><br><span class="line">inner_index = [0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000,</span><br><span class="line">           0x36000000]</span><br><span class="line">i=0</span><br><span class="line">flags=[]</span><br><span class="line">flag = [0]*24</span><br><span class="line">flag[23] = 0xe3</span><br><span class="line"># 用递归 ，深度遍历的方法得到所有的解</span><br><span class="line">def DFS(deep):</span><br><span class="line">  global flags</span><br><span class="line">  global flag</span><br><span class="line">  if deep ==0:</span><br><span class="line">    flags.append(flag.copy())</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">    for j in range(1,0xff):</span><br><span class="line">      tem = j^((j % 0x12+ flag[deep] + 0x05) ^ 0x41)</span><br><span class="line">      if tem == obj[deep-1]:</span><br><span class="line">        flag[deep-1]=j</span><br><span class="line">        DFS(deep-1)</span><br><span class="line"></span><br><span class="line"># 位移运算</span><br><span class="line">def rol8(num):</span><br><span class="line">  return ((num&amp;0xffffff)&lt;&lt;8) |((num&amp;0xff000000)&gt;&gt;(32-8))</span><br><span class="line"></span><br><span class="line"># 位移加上 异或运算</span><br><span class="line">def T(num,i):</span><br><span class="line">  num = rol8(num)</span><br><span class="line">  return num^inner_index[i-1]</span><br><span class="line"></span><br><span class="line"># 根据是否是6的倍数进行的不同的异或运算</span><br><span class="line">def multiple(final_flag):</span><br><span class="line">  for i in range(65,5,-1):</span><br><span class="line">    if i%6 !=0:</span><br><span class="line">      final_flag[i-6] = final_flag[i]^final_flag[i-1]</span><br><span class="line">    else:</span><br><span class="line">      final_flag[i - 6] = final_flag[i] ^ T(final_flag[i - 1], i//6)</span><br><span class="line">  return final_flag</span><br><span class="line"></span><br><span class="line"># 将得到的数组进行输出</span><br><span class="line">def print_flag(final_flag):</span><br><span class="line">  for i in range(len(final_flag)):</span><br><span class="line">    for j in range(4):</span><br><span class="line">      print(chr((final_flag[i] &amp; 0xff000000)&gt;&gt;(32-8)),end=&quot;&quot;)</span><br><span class="line">      final_flag[i] = final_flag[i] &lt;&lt; 8</span><br><span class="line">  print()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  DFS(23)</span><br><span class="line">  re_flags = []</span><br><span class="line">  for j in range(len(flags)):</span><br><span class="line">    flag = flags[j]</span><br><span class="line">    tem = []</span><br><span class="line">    # 将每4个8位数组合成 一个16进制的32位数</span><br><span class="line">    for i in range(0, len(flag), 4):</span><br><span class="line">      tem.append(int(</span><br><span class="line">        &quot;0x&quot; + hex(flag[i + 3])[2:].zfill(2) + hex(flag[i + 2])[2:].zfill(2) + hex(flag[i + 1])[2:].zfill(2) + hex(</span><br><span class="line">          flag[i])[2:].zfill(2),16))</span><br><span class="line">    re_flags.append(tem.copy())   # re_flags 里面将24个元素每4个一组转化为一个数</span><br><span class="line"></span><br><span class="line">  # 异或运算的逆向</span><br><span class="line">  final_flag = [0]*66</span><br><span class="line">  re_flags2 = []</span><br><span class="line">  for i in range(len(re_flags)):</span><br><span class="line">    final_flag = [0]*66</span><br><span class="line">    for j in range(6):  #将已知的5个值放入其中</span><br><span class="line">      final_flag[60+j] = re_flags[i][j]</span><br><span class="line">      </span><br><span class="line">    # 利用这5个元素推理出所有的数字</span><br><span class="line">    final_flag = multiple(final_flag)</span><br><span class="line">    tem = []</span><br><span class="line">    for j in range(6):</span><br><span class="line">      tem.append(final_flag[j])</span><br><span class="line">    print(tem)</span><br><span class="line">    re_flags2.append(tem.copy())</span><br><span class="line">  for i in range(len(re_flags2)):</span><br><span class="line">    print_flag(re_flags2[i])</span><br></pre></td></tr></table></figure>

<p>在所有的输出之中找到flag  VNCTF{TimeFlightMachine}</p>
<h4 id="cmgo！"><a href="#cmgo！" class="headerlink" title="cmgo！"></a>cmgo！</h4><p>将这个exe文件拖入ida之中，从函数名称的窗口之中就可以看到这里进行了程序的无符号化，使得函数的名称不能够直观的得到，所以函数的入口难以找到，无符号golang逆向技巧，使用IDAGolangHelper这一脚本，打开脚本文件（文件-脚本文件）找到这个脚本文件夹，选中rename function之后选择go版本,所以将这个exe拖进IDA7.6之中，找到程序入口main.main</p>
<p><img src="/images/VNCTF-2022/image-20220221232254810.png" alt="image-20220221232254810"></p>
<p>找到初始化虚拟机的地方和opcode</p>
<p><img src="/images/VNCTF-2022/image-20220222081345526.png" alt="image-20220222081345526"></p>
<p>第二个函数 mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084558720.png" alt="image-20220222084558720"></p>
<p>第三个函数  mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084616048.png" alt="image-20220222084616048"></p>
<p><img src="/images/VNCTF-2022/image-20220222084743697.png" alt="image-20220222084743697"></p>
<p>第四个函数 mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084926787.png" alt="image-20220222084926787"></p>
<p>第五个函数 push</p>
<p><img src="/images/VNCTF-2022/image-20220222085210002.png" alt="image-20220222085210002"></p>
<p>第六个函数 和push类似的样子</p>
<p><img src="/images/VNCTF-2022/image-20220222085400565.png" alt="image-20220222085400565"></p>
<p>第七个函数 pop</p>
<p><img src="/images/VNCTF-2022/image-20220222085437971.png" alt="image-20220222085437971"></p>
<p>第八个函数 add</p>
<p><img src="/images/VNCTF-2022/image-20220222085652595.png" alt="image-20220222085652595"></p>
<p>第九个函数 sub</p>
<p><img src="/images/VNCTF-2022/image-20220222085733426.png" alt="image-20220222085733426"></p>
<p>第十个函数 div</p>
<p><img src="/images/VNCTF-2022/image-20220222085838161.png" alt="image-20220222085838161"></p>
<p>第十一个函数 mul</p>
<p><img src="/images/VNCTF-2022/image-20220222085928057.png" alt="image-20220222085928057"></p>
<p>第十二个函数 xor</p>
<p><img src="/images/VNCTF-2022/image-20220222090005356.png" alt="image-20220222090005356"></p>
<p>第十三个函数  jmp</p>
<p><img src="/images/VNCTF-2022/image-20220222090054005.png" alt="image-20220222090054005"></p>
<p>第十四个函数 jmp（多了一个判断条件）当等于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090501248.png" alt="image-20220222090501248"></p>
<p>第十五个函数 jnp</p>
<p><img src="/images/VNCTF-2022/image-20220222090557647.png" alt="image-20220222090557647"></p>
<p>第十六个函数 jlp 当小于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090652596.png" alt="image-20220222090652596"></p>
<p>第十七个函数 jhp 当大于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090801331.png" alt="image-20220222090801331"></p>
<p>第十八个函数 scanf</p>
<p><img src="/images/VNCTF-2022/image-20220222091046004.png" alt="image-20220222091046004"></p>
<p>第十九个函数 print</p>
<p><img src="/images/VNCTF-2022/image-20220222091135371.png" alt="image-20220222091135371"></p>
<p>第二十个函数 quit</p>
<p><img src="/images/VNCTF-2022/image-20220222091303160.png" alt="image-20220222091303160"></p>
<p>初始化虚拟机并且载入opcode之后，要运行这个虚拟机，所以查看虚拟机的运行的函数，用流程图的方式查看函数的逻辑，找到逻辑之中的循环，找到其中的关键代码</p>
<p><img src="/images/VNCTF-2022/image-20220222120534330.png" alt="image-20220222120534330"></p>
<p>进行动调得到函数的对应关系，动态调试得到的对应关系,</p>
<p><img src="/images/VNCTF-2022/image-20220223001010055.png" alt="image-20220223001010055"></p>
<p>跟踪到[rbx+rdi*8+1008h]这个里面，通过按D将db的数据转化成dq</p>
<p><img src="/images/VNCTF-2022/image-20220223001105287.png" alt="image-20220223001105287"></p>
<p>通过他们的顺序，就能知道code 和 函数的对应关系</p>
<p>opcode的 0-16对应函数1-17</p>
<p>97 98 99对应函数18 19 20</p>
<p>将opcode得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov r0 0X57</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6C</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X63</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6D</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X74</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X56</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X4E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X43</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X54</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X46</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X30</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X21</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0XA</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X69</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X70</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X75</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X74</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X66</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6C</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X61</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X67</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X3A</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0XA</span><br><span class="line">pushchar(r0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov r19 0X49</span><br><span class="line">mov r3 0X0</span><br><span class="line">mov r1 0X2B</span><br><span class="line">mov r2 0X1</span><br><span class="line">scanf(r0)</span><br><span class="line">push r0</span><br><span class="line">sub r1 r2</span><br><span class="line">if r1 != r3:quit </span><br><span class="line">mov r0 0X0</span><br><span class="line">push r0</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">mov r0 r6</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">mov r0 r6</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">mov r0 r7</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">mov r0 r7</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">mov r0 r8</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">mov r0 r8</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">mov r0 r9</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">mov r0 r9</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">mov r0 r10</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">mov r0 r10</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">mov r0 r11</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">mov r0 r11</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">mov r0 r12</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">mov r0 r12</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100  //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">mov r0 r13</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">mov r0 r13</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">mov r0 r15</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">mov r0 r15</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">mov r0 r16</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">mov r0 r16</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">push r6</span><br><span class="line">push r7</span><br><span class="line">push r8</span><br><span class="line">push r9</span><br><span class="line">push r10</span><br><span class="line">push r11</span><br><span class="line">push r12</span><br><span class="line">push r13</span><br><span class="line">push r14</span><br><span class="line">push r15</span><br><span class="line">push r16</span><br><span class="line">//第一次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X11C</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0XE8D1D5DF</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   // 0XE8D1D5DF 数据的比较</span><br><span class="line">mov r0 0XF5E3C114</span><br><span class="line">if r2 != r0:quit   //  0XF5E3C114</span><br><span class="line">// 第二次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X127</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X228EC216</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit  //  0X228EC216 数据的比较</span><br><span class="line">mov r0 0X89D45A61</span><br><span class="line">if r2 != r0:quit   //  0X89D45A61</span><br><span class="line">// 第三次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X132</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X655B8F69</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit    //  0X655B8F69 数据的比较</span><br><span class="line">mov r0 0X2484A07A</span><br><span class="line">if r2 != r0:quit    //  0X2484A07A</span><br><span class="line">// 第四次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X13D</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0XD9E5E7F8</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   //  0XD9E5E7F8 数据的比较</span><br><span class="line">mov r0 0X3A441532</span><br><span class="line">if r2 != r0:quit   //   0X3A441532</span><br><span class="line">// 第五次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X148</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X91AB7E88</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   // 0X91AB7E88</span><br><span class="line">mov r0 0X69FC64BC</span><br><span class="line">if r2 != r0:quit   //  0X69FC64BC</span><br><span class="line">pop r1</span><br><span class="line">mov r0 0X7D3765</span><br><span class="line">if r1 != r0:quit   //  0X7D3765</span><br><span class="line">mov r0 0X189</span><br><span class="line">jmp r0</span><br><span class="line">quit!</span><br><span class="line"></span><br><span class="line">mov r3 0X9E3779B9  //tea函数开始的地方 delta</span><br><span class="line">mov r4 0X95C4C     //k0</span><br><span class="line">mov r5 0X871D      //k1</span><br><span class="line">mov r6 0X1A7B7     //k2</span><br><span class="line">mov r7 0X12C7C7    //k3</span><br><span class="line">mov r8 0X0</span><br><span class="line">mov r17 0X10  //用于位移的一堆数字</span><br><span class="line">mov r18 0X20</span><br><span class="line">mov r19 0X160</span><br><span class="line">mov r10 0X0</span><br><span class="line">mov r11 0X20</span><br><span class="line">mov r12 0X1</span><br><span class="line">add r8 r3</span><br><span class="line">mov r0 r2</span><br><span class="line">mul r0 r17</span><br><span class="line">add r0 r4</span><br><span class="line">mov r14 r0</span><br><span class="line">mov r0 r2</span><br><span class="line">add r0 r8</span><br><span class="line">mov r15 r0</span><br><span class="line">mov r0 r2</span><br><span class="line">div r0 r18</span><br><span class="line">add r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">xor r0 r15</span><br><span class="line">xor r0 r16</span><br><span class="line">add r1 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">mul r0 r17</span><br><span class="line">add r0 r6</span><br><span class="line">mov r14 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">add r0 r8</span><br><span class="line">mov r15 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">div r0 r18</span><br><span class="line">add r0 r7</span><br><span class="line">mov r16 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">xor r0 r15</span><br><span class="line">xor r0 r16</span><br><span class="line">add r2 r0</span><br><span class="line">sub r11 r12</span><br><span class="line">if r11 != r10:quit </span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">mov r0 0X6E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">mov r0 0X79</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X73</span><br><span class="line">pushchar(r0)</span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">v[2]=&#123;0XE8D1D5DF,0XF5E3C114,0X228EC216,0X89D45A61,0X655B8F69,0X2484A07A,0XD9E5E7F8,0X3A441532,0X91AB7E88,0X69FC64BC,0X7D3765&#125;</span><br></pre></td></tr></table></figure>

<p>网上的TEA的加密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上的TEA的解密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void decrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up; sum is 32*delta */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目之中的TEA解密的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Decrypt(unsigned long* EntryData,unsigned long* Key) &#123;</span><br><span class="line">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br><span class="line">unsigned long x = EntryData[0];</span><br><span class="line">unsigned long y = EntryData[1];</span><br><span class="line"></span><br><span class="line">unsigned long sum = 0xC6EF3720;</span><br><span class="line">unsigned long delta = 0x9E3779B9;</span><br><span class="line">sum = delta &lt;&lt; 5;   //注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.</span><br><span class="line">//总共加密32轮 那么反序也解密32轮</span><br><span class="line">for (int i = 0; i &lt; 32; i++) &#123;</span><br><span class="line">// 先将y解开 然后参与运算在解x</span><br><span class="line">y -= ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);</span><br><span class="line">x -= ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);</span><br><span class="line">sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">//最后加密的结果重新写入到数组中</span><br><span class="line">EntryData[0] = x;</span><br><span class="line">EntryData[1] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">//通过对比元素的代码处将其分为6组，每两个是一组，只有前10个进行了加密的操作</span><br><span class="line">   unsigned long t1[3] = &#123;0XE8D1D5DF,0XF5E3C114,0x0&#125;;</span><br><span class="line">   unsigned long t2[3] = &#123;0X228EC216,0X89D45A61,0x0&#125;;</span><br><span class="line">   unsigned long t3[3] = &#123;0X655B8F69,0X2484A07A,0x0&#125;;</span><br><span class="line">   unsigned long t4[3] = &#123;0XD9E5E7F8,0X3A441532,0x0&#125;;</span><br><span class="line">   unsigned long t5[3] = &#123;0X91AB7E88,0X69FC64BC,0x0&#125;;</span><br><span class="line">   unsigned long t6[2] = &#123;0X7D3765,0x0&#125;;</span><br><span class="line">//printf(&quot;待加密的数值 = %s\r\n&quot;, (char*)Data);</span><br><span class="line"></span><br><span class="line">unsigned long key[4] = &#123; 0X95C4C,0X871D,0X1A7B7,0X12C7C7 &#125;;</span><br><span class="line"></span><br><span class="line">// 分析代码我们可以得到一共加密了5次，所以数组之中只有10个分组进行了加密的操作</span><br><span class="line">Decrypt(t1, key);</span><br><span class="line">Decrypt(t2, key);</span><br><span class="line">Decrypt(t3, key);</span><br><span class="line">Decrypt(t4, key);</span><br><span class="line">Decrypt(t5, key);</span><br><span class="line"></span><br><span class="line">printf(&quot;解密后的数值 = %s%s%s%s%s%s\r\n&quot;, (char*)t1,(char*)t2,(char*)t3,(char*)t4,(char*)t5,(char *)t6);</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">VNCTF&#123;ecd63ae5-8945-4ac4-b5a5-34fc3ade81e7&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>starCTF2022_Simple+NaCl</title>
    <url>/2022/04/25/starCTF2022-Simple-NaCl/</url>
    <content><![CDATA[<h3 id="Simple-File-System"><a href="#Simple-File-System" class="headerlink" title="Simple_File_System"></a>Simple_File_System</h3><p>这道题当时卡在这里就是不知道存放的数据在哪里，结果后来发现就是在image.flag文件之中（被自己蠢哭了！！！！）</p>
<h4 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h4><p>将程序运行一遍，将加密之后的文本的内容写入一个文件之中，再将这个文件放入010之中，提取前5个字节的内容，也就是 *CTF{ 加密之后的结果，然后再将image.flag文件放入ida之中，搜素这5个字节，将这段数据提取出来，这段数据就是flag加密之后的结果了，分析加密过程，逆得结果</p>
<h4 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h4><p>分析代码就能找到对flag文件加密的关键代码</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220418125656492.png"></p>
<p>异或的对象 0xDEEDBEEF</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220418125729850.png" alt="image-20220418125729850"></p>
<h4 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src = [0x00,0xD2,0xFC,0xD8,0xA2,0xDA,0xBA,0x9E,0x9C,0x26,0xF8,0xF6,0xB4,0xCE,0x3C,0xCC,0x96,0x88,0x98,0x34,0x82,0xDE,0x80,0x36,0x8A,0xD8,0xC0,0xF0,0x38,0xAE,0x40]</span><br><span class="line">for i in range(len(src)):</span><br><span class="line">    src[i] = ((src[i]&lt;&lt;5)&amp;0xff) |((src[i]&gt;&gt;3)&amp;0xff)</span><br><span class="line">    src[i]^=0xDE</span><br><span class="line">    src[i] = ((src[i]&lt;&lt;4)&amp;0xff) |((src[i]&gt;&gt;4)&amp;0xff)</span><br><span class="line">    src[i]^=0xED</span><br><span class="line">    src[i] = ((src[i] &lt;&lt; 3) &amp; 0xff) | ((src[i] &gt;&gt; 5) &amp; 0xff)</span><br><span class="line">    src[i]^=0xBE</span><br><span class="line">    src[i] = ((src[i]&lt;&lt;2)&amp;0xff) |((src[i]&gt;&gt;6)&amp;0xff)</span><br><span class="line">    src[i]^=0xEF</span><br><span class="line">    src[i] = ((src[i]&lt;&lt;1)&amp;0xff) |((src[i]&gt;&gt;7)&amp;0xff)</span><br><span class="line">    print(chr(src[i]),end=&quot;&quot;)</span><br><span class="line">*CTF&#123;Gwed9VQpM4Lanf0kEj1oFJR6&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NaCl"><a href="#NaCl" class="headerlink" title="NaCl"></a>NaCl</h3><p>这道题可以通过动调的方式搞清楚加密的逻辑，然后来解密，但是这里是通过去 “花指令”的方式来达到目的，使得加密的过程能通过F5反编译得到</p>
<h4 id="去花指令"><a href="#去花指令" class="headerlink" title="去花指令"></a>去花指令</h4><p>首先通过字符串定位到程序的关键代码处</p>
<h5 id="花指令的分析"><a href="#花指令的分析" class="headerlink" title="花指令的分析"></a>花指令的分析</h5><p>其中的特殊的代码解释，这个保存到r15-8这个地址的函数，是程序接下来运行的函数</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220421195649369.png" alt="image-20220421195649369"></p>
<p>动态调试能够发现很多部分函数的结束的地方都会有这样一段代码，这段代码会在r15所指向的内存之中保存一个数组的内存地址，以及一个函数的地址，最后跳转到一个函数</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220421200405124.png" alt="image-20220421200405124"></p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220421200416106.png" alt="image-20220421200416106"></p>
<p>继续向下动调，发现跳转到的函数的结尾，从r15-8这个位置之中取出存放的函数的地址，并且跳转到这个函数（jmp rdi），因为跳转到的这个函数是上一个函数接下来要运行的程序，所以相当于return了</p>
<p>取出跳转回来的函数地址</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220421202150714.png" alt="image-20220421202150714"></p>
<p>向r15-8之中存放的地址是这个函数接下来要运行的函数（ 跳转到另外一个函数之后，跳转回来的地址）</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220421202125732.png" alt="image-20220421202125732"></p>
<p>并且在每段程序之中align 10h的数据是并不运行的，是花指令，我们需要nop掉这部分的代码</p>
<h5 id="idaPython去花指令"><a href="#idaPython去花指令" class="headerlink" title="idaPython去花指令"></a>idaPython去花指令</h5><p>使用idapython 实现的效果</p>
<ul>
<li>将r15-8之中放入函数的过程，直接nop掉（我觉得也可以不nop掉这部分的程序，我也将不nop和nop掉着部分的汇编都进行了尝试，发现都是可以的），将jmp到的函数，改为call对应的函数（call =&gt; 0xE8）</li>
<li>然后将跳转到的这个函数之中后面为了跳转回来的指令修改了成ret指令</li>
<li>将align 10h 之中的无效指令nop掉</li>
<li>将 jmp     rdi 的指令转换成ret （我觉得对r15操作的指令就每必要修改了）</li>
</ul>
<p><a href="https://wonderkun.cc/2020/12/11/idapython%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">idaPython</a>之中经常会用到的APT</p>
<ul>
<li><p>**idc.print_insn_mnem(ea)**来获取每条指令的操作符，判断操作符是否为 call 或者 jmp</p>
</li>
<li><p><strong>print(“0x%x %s” % (line, idc.GetDisasm(line)))</strong>  将对应地址的汇编得到</p>
</li>
<li><p><strong>dism_addr = list(idautils.FuncItems(func))</strong> 实际上返回的是一个迭代器，但是我们将它强制转换为 list 类型。这个 list 以一种连续的方式存储着所有指令的起始地址。</p>
</li>
<li><p><strong>idc.next_head(line) 和 idc.prev_head(line)</strong> 获取附近指令的地址</p>
</li>
<li><p><strong>idc.get_operand_type(ea,n)</strong> 获取操作数类型 ea 是一个地址，n 是一个索引。</p>
<p>操作数类型的种类</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220421225837234.png" alt="image-20220421225837234"></p>
</li>
<li><p><strong>ida_ida.inf_get_min_ea()</strong> 和 <strong>ida_ida.inf_get_max_ea()</strong> 获取可执行文件的最大地址和最小地址，我们遍历了所有的函数和指令。</p>
</li>
<li><p>用来打补丁的 i<strong>da_bytes.patch_byte(ea, value)</strong> 、 <strong>ida_bytes.patch_word(ea, value)<strong>、</strong>ida_bytes.patch_dword(ea, value)<strong>、</strong>ida_bytes.patch_qword(ea, value)</strong> 这里面的 value 是替换的机器码</p>
</li>
<li><p><strong>idc.GetOperandValue(ea, n)</strong> 获取操作数引用的地址（<strong>取值</strong>）</p>
</li>
<li><p><strong>idc.print_operand(here(),0)</strong> 获取操作数 如rdx（<strong>取符号</strong>）</p>
</li>
<li><p><strong>idc.print_insn_mnem(here())</strong> 获取操作符 如 mov</p>
</li>
<li><p><strong>idc.GetDisasm(ea)</strong> 获取汇编 如mov rdx, rdi</p>
</li>
<li><p><strong>idc.NextHead(ea)</strong>- 返回下一条指令(无效指令算一条)</p>
</li>
<li><p><strong>idc.PrevHead(ea)</strong>- 返回上一条指令</p>
</li>
<li><p><strong>idc.NextAddr(ea)</strong>- 返回下一地址</p>
</li>
<li><p><strong>idc.PrevAddr(ea)</strong>- 返回上一地址</p>
</li>
</ul>
<p>需要处理的3个位置的汇编代码</p>
<p>第一种:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SFI:000000000808040C                 lea     r15, [r15-8]</span><br><span class="line">SFI:0000000008080410                 lea     r12, sub_8080420</span><br><span class="line">SFI:0000000008080417                 mov     [r15], r12</span><br><span class="line">SFI:000000000808041A                 jmp     loc_80802A0</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SFI:00000000080802E0                 lea     r15, [r15+8]    ; 取地址</span><br><span class="line">SFI:00000000080802E4                 mov     edi, [r15-8]    ; 获取跳转的函数</span><br><span class="line">SFI:00000000080802E8                 and     edi, 0FFFFFFE0h</span><br><span class="line">SFI:00000000080802EB                 lea     rdi, [r13+rdi+0]</span><br><span class="line">SFI:00000000080802F0                 jmp     rdi </span><br></pre></td></tr></table></figure>

<p>第三种nop掉的指令（第一种汇编代码之后的代码）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面jmp之后的指令align 20h 中的数据全部nop掉</span><br></pre></td></tr></table></figure>

<p>nop掉jmp前面的汇编代码的效果是：</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220422220410076.png" alt="image-20220422220410076"></p>
<p>不nop掉jmp前面那部分的汇编代码的效果：</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220422220437967.png" alt="image-20220422220437967"></p>
<p>两种方式中主要的加密函数都被保存下来了，只是中间数据的展示方式是不一样的</p>
<p>idaPython脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import ida_ida</span><br><span class="line">import idc</span><br><span class="line">import ida_bytes</span><br><span class="line">start = ida_ida.inf_get_min_ea()</span><br><span class="line">end  = ida_ida.inf_get_max_ea()</span><br><span class="line"># 两种需要处理的汇编代码的地方</span><br><span class="line">part1 = [&quot;lea     r15,&quot;,&quot;lea     r12,&quot;,&quot;mov     [r15],&quot;,&quot;jmp     loc_&quot;]</span><br><span class="line">part2 = [&quot;lea     r15,&quot;,&quot;mov     edi,&quot;,&quot;and     edi,&quot;,&quot;lea     rdi&quot;,&quot;jmp     rdi&quot;]</span><br><span class="line"># 用p来存放当前指向的汇编指令的位置</span><br><span class="line">p = start</span><br><span class="line"># 存放连续取得的五条指令的地址</span><br><span class="line">current_instruct = [0]*5</span><br><span class="line"># 转为call指令</span><br><span class="line">def nop(start,end):</span><br><span class="line">    while start&lt;end:</span><br><span class="line">        ida_bytes.patch_byte(start, 0x90)</span><br><span class="line">        start+=1</span><br><span class="line"></span><br><span class="line">def part1_Operate():</span><br><span class="line">    # nop(current_instruct[0],current_instruct[3])</span><br><span class="line">    temStr = idc.print_operand(current_instruct[1], 1)[4:]</span><br><span class="line">    nopEndAddr = int(&quot;0x&quot;+temStr,16)</span><br><span class="line">    nopStartAddre = idc.next_head(current_instruct[3])</span><br><span class="line">    # nopEndAddr = idc.next_head(nopStartAddre)</span><br><span class="line">    print(nopEndAddr)</span><br><span class="line">    print(nopStartAddre)</span><br><span class="line">    nop(nopStartAddre,nopEndAddr)</span><br><span class="line">    ida_bytes.patch_byte(current_instruct[3], 0xE8)</span><br><span class="line">    print(&quot;part1 Successful!&quot;)</span><br><span class="line"></span><br><span class="line"># 转为ret指令</span><br><span class="line">def part2_Operate():</span><br><span class="line">    # nop(current_instruct[0],current_instruct[4])</span><br><span class="line">    ida_bytes.patch_byte(current_instruct[4], 0x90)</span><br><span class="line">    ida_bytes.patch_byte(current_instruct[4]+1,0xC3)</span><br><span class="line">    print(&quot;part2 Successful!&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;start&quot;)</span><br><span class="line">while p&lt;=end:</span><br><span class="line">    current_instruct[0] = p</span><br><span class="line">    current_instruct[1] = idc.next_head(current_instruct[0])</span><br><span class="line">    current_instruct[2] = idc.next_head(current_instruct[1])</span><br><span class="line">    current_instruct[3] = idc.next_head(current_instruct[2])</span><br><span class="line">    current_instruct[4] = idc.next_head(current_instruct[3])</span><br><span class="line">    p = current_instruct[1]</span><br><span class="line">    for i in range(len(part1)):</span><br><span class="line">        if idc.GetDisasm(current_instruct[i])[0:len(part1[i])] != part1[i]:</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        p = idc.next_head(current_instruct[3])</span><br><span class="line">        # print(&quot;将jmp指令转换成call指令，并且将剩下的align中的指令nop掉&quot;)</span><br><span class="line">        part1_Operate()</span><br><span class="line">    for i in range(len(part2)):</span><br><span class="line">        if idc.GetDisasm(current_instruct[i])[0:len(part2[i])] != part2[i]:</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        p=idc.next_head(current_instruct[4])</span><br><span class="line">        print(p)</span><br><span class="line">        part2_Operate()</span><br><span class="line">        # print(&quot;将jmp指令转化成ret指令来返回&quot;)</span><br><span class="line">print(&quot;finish&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="xtae解密"><a href="#xtae解密" class="headerlink" title="xtae解密"></a>xtae解密</h4><p>这个地方的xtea的delta变了，轮数变了</p>
<h5 id="加密过程分析"><a href="#加密过程分析" class="headerlink" title="加密过程分析"></a>加密过程分析</h5><p>8个32位的数据，分成了4次加密，每次加密2个32位的数据，加密的轮数依次是 2 4 8 16</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220425194620856.png" alt="image-20220425194620856"></p>
<h5 id="xtea的数据提取"><a href="#xtea的数据提取" class="headerlink" title="xtea的数据提取"></a>xtea的数据提取</h5><p>密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3020100h, 7060504h, 0B0A0908h, 0F0E0D0Ch</span><br></pre></td></tr></table></figure>

<p>密文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x66, 0xC2, 0xF5, 0xFD, 0x86, 0x82, 0x32, 0x7A, 0x04, 0x40, </span><br><span class="line">0x94, 0xCE, 0xDC, 0x8A, 0xE0, 0x5D, 0x0A, 0xBD, 0xE4, 0xA6, </span><br><span class="line">0xDC, 0xAD, 0xCA, 0x16, 0x0C, 0x6F, 0xCD, 0x13, 0x36, 0xD9, </span><br><span class="line">0x75, 0x1A</span><br><span class="line">0xfdf5c266,0x7a328286,0xce944004,0x5de08adc,0xa6e4bd0a,0x16caaddc,0x13cd6f0c,0x1a75d936</span><br></pre></td></tr></table></figure>

<p>4次加密的轮数  2 4 8 16 </p>
<h5 id="xtea解密脚本"><a href="#xtea解密脚本" class="headerlink" title="xtea解密脚本"></a>xtea解密脚本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x10325476, sum=delta*num_rounds;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[3]=&#123;0xfdf5c266,0x7a328286,0x0&#125;;</span><br><span class="line">    uint32_t v1[3]=&#123;0xce944004,0x5de08adc,0x0&#125;;</span><br><span class="line">    uint32_t v2[3]=&#123;0xa6e4bd0a,0x16caaddc,0x0&#125;;</span><br><span class="line">    uint32_t v3[3]=&#123;0x13cd6f0c,0x1a75d936,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]=&#123;0X3020100,0X7060504,0X0B0A0908,0X0F0E0D0C&#125;;</span><br><span class="line">    unsigned int r=32;//num_rounds建议取值为32</span><br><span class="line">    decipher(2, v, k);</span><br><span class="line">    decipher(4, v1, k);</span><br><span class="line">    decipher(8, v2, k);</span><br><span class="line">    decipher(16,v3, k);</span><br><span class="line"></span><br><span class="line">    printf(&quot;0x%x,0x%x\n&quot;,v[0], v[1]);</span><br><span class="line">    printf(&quot;0x%x,0x%x\n&quot;,v1[0], v1[1]);</span><br><span class="line">    printf(&quot;0x%x,0x%x\n&quot;,v2[0], v2[1]);</span><br><span class="line">    printf(&quot;0x%x,0x%x\n&quot;,v3[0], v3[1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>xtea解密之后的4个数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xe71f5179,0xb55f9204</span><br><span class="line">0x722d4a3a,0x238e8b65</span><br><span class="line">0x4385e0f2,0x6703757a</span><br><span class="line">0xaabe9be3,0x4de4253b</span><br></pre></td></tr></table></figure>

<h4 id="异或操作解密"><a href="#异或操作解密" class="headerlink" title="异或操作解密"></a>异或操作解密</h4><h5 id="异或加密的过程分析"><a href="#异或加密的过程分析" class="headerlink" title="异或加密的过程分析"></a>异或加密的过程分析</h5><p>异或加密的函数</p>
<ul>
<li><p>将异或的数据直接提取出来（动调）</p>
</li>
<li><p>v5-&gt;tailData4 的 值等于这个循环完成之后 v5-&gt;headData4 的 值，所以逆向的时候异或现在的head的这个值，这样就能够得到之前的head的值，然后将新的head的值给head，把之前的head的值给tail</p>
</li>
<li><p>要异或的数据的值是要倒着来的</p>
</li>
<li><p>将tailData的数据作为前面的4个字节 将headData的数据作为后面的4个字节 这样组成结果的8个字节</p>
</li>
</ul>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220423225006570.png" alt="image-20220423225006570"></p>
<h5 id="异或数据提取"><a href="#异或数据提取" class="headerlink" title="异或数据提取"></a>异或数据提取</h5><p>通过动调的方式获得异或的对象(每4个字节为一组来取用)，并且在解密的时候解密使用的异或的对象是倒着来取的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0x0F, 0x0E, </span><br><span class="line">0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x1B, 0xE8, 0x3F, 0xCD, </span><br><span class="line">0x77, 0x54, 0xC4, 0xD7, 0x36, 0x92, 0x3E, 0x9F, 0x87, 0xF1, </span><br><span class="line">0x07, 0x01, 0x81, 0xCB, 0x93, 0xF9, 0x6C, 0x16, 0x74, 0xBF, </span><br><span class="line">0x27, 0x84, 0x19, 0xDA, 0xFF, 0xAB, 0x05, 0x1A, 0xE4, 0xE5, </span><br><span class="line">0x07, 0x93, 0x45, 0x0E, 0x8B, 0xCB, 0xF5, 0xF7, 0x6D, 0x30, </span><br><span class="line">0x97, 0x01, 0x30, 0xAD, 0x56, 0xB0, 0x86, 0xAA, 0xBA, 0x63, </span><br><span class="line">0x92, 0x44, 0x1B, 0x40, 0xA4, 0x3F, 0x17, 0xF9, 0x41, 0x1E, </span><br><span class="line">0x7D, 0x1E, 0xCB, 0xC6, 0x7A, 0x0D, 0xEB, 0x18, 0x00, 0x48, </span><br><span class="line">0xEC, 0xD4, 0x2B, 0xF9, 0x86, 0xB4, 0xF3, 0xF9, 0x37, 0x87, </span><br><span class="line">0x25, 0x3D, 0x5E, 0x76, 0x37, 0x35, 0x3D, 0xDB, 0x2B, 0x55, </span><br><span class="line">0x44, 0xEE, 0x4C, 0xC9, 0xD0, 0x11, 0xCB, 0x5B, 0x60, 0x9B, </span><br><span class="line">0xB3, 0x98, 0x3B, 0x90, 0xA3, 0xEE, 0xC2, 0x24, 0xA2, 0x10, </span><br><span class="line">0x6E, 0x89, 0xC0, 0xF0, 0x47, 0x22, 0xAA, 0x5C, 0x4E, 0xB8, </span><br><span class="line">0xF0, 0x04, 0x2C, 0x8D, 0x2C, 0x84, 0xC7, 0x3B, 0x06, 0xD6, </span><br><span class="line">0x50, 0x1A, 0x7C, 0x91, 0xA1, 0x49, 0x0C, 0xB5, 0x1C, 0x7E, </span><br><span class="line">0x26, 0xB8, 0x27, 0xFC, 0xBC, 0xDF, 0xDD, 0x5F, 0x04, 0xC4, </span><br><span class="line">0x0F, 0xDE, 0x07, 0x09, 0xB3, 0xB2</span><br></pre></td></tr></table></figure>

<h5 id="解密脚本-1"><a href="#解密脚本-1" class="headerlink" title="解密脚本"></a>解密脚本</h5><p>逆向的时候需要注意的是 使用的src中的数是逆着取用的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">src = [<span class="number">0x04050607</span>,<span class="number">0x00010203</span>,<span class="number">0x0c0d0e0f</span>,<span class="number">0x08090a0b</span>,<span class="number">0xcd3fe81b</span>,<span class="number">0xd7c45477</span>,<span class="number">0x9f3e9236</span>,<span class="number">0x0107f187</span>,<span class="number">0xf993cb81</span>,<span class="number">0xbf74166c</span>,<span class="number">0xda198427</span>,<span class="number">0x1a05abff</span>,<span class="number">0x9307e5e4</span>,<span class="number">0xcb8b0e45</span>,<span class="number">0x306df7f5</span>,<span class="number">0xad300197</span>,<span class="number">0xaa86b056</span>,<span class="number">0x449263ba</span>,<span class="number">0x3fa4401b</span>,<span class="number">0x1e41f917</span>,<span class="number">0xc6cb1e7d</span>,<span class="number">0x18eb0d7a</span>,<span class="number">0xd4ec4800</span>,<span class="number">0xb486f92b</span>,<span class="number">0x8737f9f3</span>,<span class="number">0x765e3d25</span>,<span class="number">0xdb3d3537</span>,<span class="number">0xee44552b</span>,<span class="number">0x11d0c94c</span>,<span class="number">0x9b605bcb</span>,<span class="number">0x903b98b3</span>,<span class="number">0x24c2eea3</span>,<span class="number">0x896e10a2</span>,<span class="number">0x2247f0c0</span>,<span class="number">0xb84e5caa</span>,<span class="number">0x8d2c04f0</span>,<span class="number">0x3bc7842c</span>,<span class="number">0x1a50d606</span>,<span class="number">0x49a1917c</span>,<span class="number">0x7e1cb50c</span>,<span class="number">0xfc27b826</span>,<span class="number">0x5fdddfbc</span>,<span class="number">0xde0fc404</span>,<span class="number">0xb2b30907</span>]</span><br><span class="line">headData = <span class="number">0xe71f5179</span></span><br><span class="line">tailData = <span class="number">0xb55f9204</span></span><br><span class="line">encDate = [<span class="number">0xe71f5179</span>,<span class="number">0xb55f9204</span>,<span class="number">0x722d4a3a</span>,<span class="number">0x238e8b65</span>,<span class="number">0x4385e0f2</span>,<span class="number">0x6703757a</span>,<span class="number">0xaabe9be3</span>,<span class="number">0x4de4253b</span>]</span><br><span class="line">tem = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(encDate),<span class="number">2</span>):</span><br><span class="line">    headData = encDate[j]</span><br><span class="line">    tailData = encDate[j+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">44</span>):</span><br><span class="line">        tem = headData</span><br><span class="line">        v6 = (((headData &amp; <span class="number">0x7fffffff</span>) &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span>) | ((headData &gt;&gt; (<span class="number">32</span> - <span class="number">1</span>)) &amp; <span class="number">0x01</span>)</span><br><span class="line">        v7 = ((((headData &amp; <span class="number">0x00ffffff</span>) &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xffffffff</span>) | ((headData &gt;&gt; (<span class="number">32</span> - <span class="number">8</span>)) &amp; <span class="number">0xff</span>)) &amp; v6</span><br><span class="line">        headData = ((((headData &amp; <span class="number">0x3fffffff</span>) &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xffffffff</span>) | ((headData &gt;&gt; (<span class="number">32</span> - <span class="number">2</span>)) &amp; <span class="number">0x03</span>)) ^ v7</span><br><span class="line">        headData = headData ^ tailData ^ src[<span class="number">43</span> - i]</span><br><span class="line">        tailData = tem</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(headData),end=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(tailData),end=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="number">0x4a496f62</span>,<span class="number">0x6d4d3770</span>,<span class="number">0x504f3652</span>,<span class="number">0x73435451</span>,<span class="number">0x386b4645</span>,<span class="number">0x30672d4c</span>,<span class="number">0x6976424e</span>,<span class="number">0x78685975</span></span><br></pre></td></tr></table></figure>

<p>分析代码知道tailData是低位的数据 headData是高位的数据</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220425184851589.png" alt="image-20220425184851589"></p>
<p>并且这四个字节的排列顺序是：将input的数据的低字节放到的高字节，高字节放到了低字节</p>
<p><img src="/images/starCTF2022-Simple-NaCl/image-20220425185217259.png" alt="image-20220425185217259"></p>
<p>所以最后数据输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encode = [<span class="number">0x4a496f62</span>,<span class="number">0x6d4d3770</span>,<span class="number">0x504f3652</span>,<span class="number">0x73435451</span>,<span class="number">0x386b4645</span>,<span class="number">0x30672d4c</span>,<span class="number">0x6976424e</span>,<span class="number">0x78685975</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(encode),<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">while</span> encode[i+<span class="number">1</span>-j]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>((encode[i+<span class="number">1</span>-j]&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            encode[i+<span class="number">1</span>-j] = (encode[i+<span class="number">1</span>-j]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0xffffffff</span></span><br><span class="line">得到最后的结果：mM7pJIobsCTQPO6R0g-L8kFExhYuivBN</span><br></pre></td></tr></table></figure>

<p>*CTF{mM7pJIobsCTQPO6R0g-L8kFExhYuivBN}</p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>idaPython</tag>
        <tag>xtea</tag>
        <tag>文件系统</tag>
        <tag>花指令</tag>
      </tags>
  </entry>
  <entry>
    <title>starCTF2021</title>
    <url>/2022/04/13/starCTF/</url>
    <content><![CDATA[<h1 id="StarCTF2021"><a href="#StarCTF2021" class="headerlink" title="StarCTF2021"></a>StarCTF2021</h1><p>自己的程序分析能力还要加强啊！！！！chacha20的解密不知道问题出在哪里？？？ qemu-riscv64也没能配置好环境，调试不了程序，所以 Favourite Architecture flag0 只解了一半，希望有大佬能指导指导咋搞啊？？？</p>
<h2 id="Stram"><a href="#Stram" class="headerlink" title="Stram"></a>Stram</h2><p>这是一个rust编写的elf文件</p>
<p><img src="/images/starCTF/image-20220407133426419.png" alt="image-20220407133426419"></p>
<h3 id="程序流程分析"><a href="#程序流程分析" class="headerlink" title="程序流程分析"></a>程序流程分析</h3><p>找到main函数，进入第一个函数之中</p>
<p><img src="/images/starCTF/image-20220408122043365.png" alt="image-20220408122043365"></p>
<h4 id="读取输入数据"><a href="#读取输入数据" class="headerlink" title="读取输入数据"></a>读取输入数据</h4><p>打开flag文件，读取其中的数据</p>
<p><img src="/images/starCTF/image-20220408122229158.png" alt="image-20220408122229158"></p>
<p><img src="/images/starCTF/image-20220408122233905.png" alt="image-20220408122233905"></p>
<h4 id="对输入的加密过程"><a href="#对输入的加密过程" class="headerlink" title="对输入的加密过程"></a>对输入的加密过程</h4><p>这里的加密过程调用了<a href="https://docs.rs/c2-chacha/0.2.0/src/c2_chacha/guts.rs.html">rustcrypto_api</a></p>
<p>init_chacha: 利用输入生成随机数种子</p>
<p><img src="/images/starCTF/image-20220408122809423.png" alt="image-20220408122809423"></p>
<p>refill_wide：流密钥加密的过程</p>
<p><img src="/images/starCTF/image-20220408122923674.png" alt="image-20220408122923674"></p>
<p>因为密钥的生成和输入显然是有关系的，这样的流密钥加密我们并不能够直接解密，所以使用爆破的方法</p>
<h4 id="加密结果的输出"><a href="#加密结果的输出" class="headerlink" title="加密结果的输出"></a>加密结果的输出</h4><p>加密的结果会被写入到一个名为output的文件之中</p>
<p><img src="/images/starCTF/image-20220408123238791.png" alt="image-20220408123238791"></p>
<p>所以该程序的输入，我们可以通过写入flag文件输入；该程序输出的获取，我们可以通过读取ouput文件得知</p>
<h3 id="python和程序的交互（subprocess模块）"><a href="#python和程序的交互（subprocess模块）" class="headerlink" title="python和程序的交互（subprocess模块）"></a>python和程序的交互（subprocess模块）</h3><p><a href="https://www.cnblogs.com/security-darren/p/4733368.html">subprocess模块</a></p>
<ul>
<li><p>subprocess.Popen 类:<strong>创建并返回一个子进程</strong>，并在这个进程中执行指定的程序。</p>
</li>
<li><p>```<br>subprocess.Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* p.wait() : 等待子进程 p 终止，返回 p.returncode 属性(wait() 立即阻塞父进程，直到子进程结束！)</span><br><span class="line"></span><br><span class="line">* p.communicate(input=None): 和子进程 p 交流，将参数 *input* （字符串）中的数据发送到子进程的 stdin，同时从子进程的 stdout 和 stderr 读取数据，直到EOF。(只能通过**管道**和**子进程通信**，也就是说，只有调用 **Popen()** 创建子进程的时候参数 **stdin=subprocess.PIPE**，才能通过 **p.communicate(input)** 向子进程的 stdin **发送数据**；只有参数 **stout 和 stderr** 也都为 **subprocess.PIPE** ，才能通过**p.communicate()** 从子进程**接收数据**，否则接收到的二元组中，对应的位置是None。)</span><br><span class="line"></span><br><span class="line">* subprocess.PIPE: 调用本模块提供的若干函数时，作为 std* 参数的值，为标准流文件打开一个管道。</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br><span class="line">![image-20220407175812946](/images/starCTF/image-20220407175812946.png)</span><br><span class="line"></span><br><span class="line">### 脚本</span><br><span class="line"></span><br><span class="line">脚本的执行流程：</span><br><span class="line"></span><br><span class="line">* 由加密的字符的顺序来爆破每一个元素，以防前面的加密会对后面的加密过程产生影响（index数组的遍历）</span><br><span class="line">* 向flag文件之中写入数据（初始化的数组，并且将对应的爆破对象的数据修改）</span><br><span class="line">* 运行程序</span><br><span class="line">* 读取output之中文件的数据</span><br><span class="line">* 将读取的数据之中对应的数据和目标的数据对比，如果相同，则爆破成功该元素，跳出循环</span><br><span class="line">* 再一次循环</span><br><span class="line"></span><br><span class="line">脚本中需要书写的函数：</span><br><span class="line"></span><br><span class="line">* 向flag文件之中写入数据</span><br><span class="line">* 从ouput文件之中读取数据，并且和目标的数据进行对比</span><br><span class="line">* 将数组转换成str形式的数据并返回</span><br><span class="line">* 运行该程序</span><br><span class="line"></span><br><span class="line">对比的数据（从提供的output文件之中得到）</span><br><span class="line"></span><br><span class="line">```data</span><br><span class="line">0x9A,0x7A,0x42,0x92,0x3C,0xE3,0x1B,0xA4,0xB8,0x72,0x96,0x2F,0x01,0x98,0x5E,0x29,0x22,0xF5,0x9A,0x14,0x0D,0x4C,0x18,0x2A,0x38,0x41,0xD4,0xF3,0xA9,0xE8,0x60,0xEE,0xDA,0x03,0xDC,0x1C,0xA1,0x86,0x12,0xFE,0x18,0x42,0x89,0x80,0x91,0xDC</span><br></pre></td></tr></table></figure></li>
</ul>
<p>读取文件的顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4,11,18,25,32,39,0,7,14,21,28,35,42,3,10,17,24,31,38,45,6,13,20,27,34,41,2,9,16,23,30,37,44,5,12,19,26,33,40,1,8,15,22,29,36,43</span><br></pre></td></tr></table></figure>

<p>因为要运行程序，所以需要先配置环境rust环境(我是在ubuntu里面配置的环境)</p>
<p>这里爆破一定要使用递归的方法（因为相同的计算结果可能有多种输入都满足，用递归的方法排除不满足的结果）</p>
<p>爆破脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">index = [4,11,18,25,32,39,0,7,14,21,28,35,42,3,10,17,24,31,38,45,6,13,20,27,34,41,2,9,16,23,30,37,44,5,12,19,26,33,40,1,8,15,22,29,36,43]</span><br><span class="line">rightOut = [0x9A,0x7A,0x42,0x92,0x3C,0xE3,0x1B,0xA4,0xB8,0x72,0x96,0x2F,0x01,0x98,0x5E,0x29,0x22,0xF5,0x9A,0x14,0x0D,0x4C,0x18,0x2A,0x38,0x41,0xD4,0xF3,0xA9,0xE8,0x60,0xEE,0xDA,0x03,0xDC,0x1C,0xA1,0x86,0x12,0xFE,0x18,0x42,0x89,0x80,0x91,0xDC]</span><br><span class="line">flag = [0x21]*46</span><br><span class="line"></span><br><span class="line">def implemnt():</span><br><span class="line">    ox = subprocess.Popen(&#x27;./a&#x27;,stdout=subprocess.PIPE,shell=True)</span><br><span class="line">    out,erro = ox.communicate()</span><br><span class="line">    status = ox.wait()</span><br><span class="line"></span><br><span class="line">def writeFlag(flag):</span><br><span class="line">    f = open(&#x27;flag&#x27;,&#x27;wb&#x27;)</span><br><span class="line">    f.write(str.encode(flag))</span><br><span class="line">    f.close</span><br><span class="line"></span><br><span class="line">def checkOutput(theIndex):</span><br><span class="line">    f = open(&#x27;output&#x27;,&#x27;rb&#x27;)</span><br><span class="line">    judge = f.read()</span><br><span class="line">    f.close</span><br><span class="line">    # print(judge[theIndex],end=&quot; : &quot;)</span><br><span class="line">    # print(rightOut[theIndex])</span><br><span class="line">    if len(judge) != 46:</span><br><span class="line">        return False</span><br><span class="line">    if judge[theIndex] == rightOut[theIndex]:</span><br><span class="line">        return True</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line">def ArrayToStr(arr):</span><br><span class="line">    tem = &#x27;&#x27;</span><br><span class="line">    for i in range(len(arr)):</span><br><span class="line">        tem+=chr(arr[i])</span><br><span class="line">    return tem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dfs(i):</span><br><span class="line">    if i&gt;=46:</span><br><span class="line">        print(ArrayToStr(flag))</span><br><span class="line">        return 0</span><br><span class="line">    for j in range(33,126,1):</span><br><span class="line">        flag[index[i]] = j</span><br><span class="line">        flagStr = ArrayToStr(flag)</span><br><span class="line">        writeFlag(flagStr)</span><br><span class="line">        implemnt()</span><br><span class="line">        if checkOutput(index[i]):</span><br><span class="line">            print(ArrayToStr(flag))</span><br><span class="line">            dfs(i+1)</span><br><span class="line">        else:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">dfs(0)</span><br><span class="line">print(&quot;suc&quot;)</span><br><span class="line">print()</span><br><span class="line">print(ArrayToStr(flag))</span><br></pre></td></tr></table></figure>

<p>flag：*ctf{EbXZCOD56vEHNSofFvRHG7XtgFJXcUXUGnaaaaaa}</p>
<p><img src="/images/starCTF/image-20220408000131371.png" alt="image-20220408000131371"></p>
<h2 id="wherekey"><a href="#wherekey" class="headerlink" title="wherekey"></a>wherekey</h2><p>知识点：静态编译文件的符号表恢复、sage的线性方程求解</p>
<h3 id="导入签名文件"><a href="#导入签名文件" class="headerlink" title="导入签名文件"></a>导入签名文件</h3><p>这是一个静态编译的elf文件</p>
<p><img src="/images/starCTF/image-20220408132906464.png" alt="image-20220408132906464"></p>
<p>ldd命令是Linux查看动态链接库的命令，执行该命令我们可以查看到，所以这个是静态编译</p>
<p><img src="/images/starCTF/image-20220408133153683.png" alt="image-20220408133153683"></p>
<p>所以需要<a href="https://xz.aliyun.com/t/4484">恢复一下库函数</a>的符号</p>
<p>FLIRT：IDA之中所提供的，库文件快速识别与鉴定技术，能通过一个静态链接库的签名文件，来快速识别被去符号的程序中的函数，从而为函数找到符号</p>
<p>将sig文件导入到ida之中，网上有大佬把各个平台各个版本的sig都放到github上面，我们只需要下载下来导入就可以了(但是如果有特殊需要可以按照上面提供的文章制作SIG文件)</p>
<p>相关sig文件的下载地址：</p>
<p><a href="https://github.com/Maktm/FLIRTDB">https://github.com/Maktm/FLIRTDB</a></p>
<p><a href="https://github.com/push0ebp/sig-database">https://github.com/push0ebp/sig-database</a></p>
<p>大致的挑选sig的版本，可以通过用file命令和strings命令去找版本信息，从而挑选sig，但是这样也很难准确找到，使用下面脚本找</p>
<p>使用iscan的脚本可以匹配测试出最佳的sig：<a href="https://github.com/maroueneboubakri/lscan">https://github.com/maroueneboubakri/lscan</a></p>
<p>上面这个脚本之中指定的-S 参数要是一个只有SIG文件的文件夹</p>
<p>我找了一个Ubuntu20.版本的SIG文件（签名文件），导入之后识别了500多个函数</p>
<h3 id="程序逻辑分析"><a href="#程序逻辑分析" class="headerlink" title="程序逻辑分析"></a>程序逻辑分析</h3><p>查看字符串，通过Please enter key 定位到一段代码，这个地方有花指令（去花指令）</p>
<h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>这个地方是jmp jnz型的花指令，nop掉jmp和jnz那个地方的花指令就可以（逐个进行jmp，因为该指令字节之中可能会有效的字节）</p>
<p><img src="/images/starCTF/image-20220408194407936.png" alt="image-20220408194407936"></p>
<p>又通过 /dev/tty 定位到一段代码（也就是主函数之中，字符串上面的那个函数）</p>
<p><img src="/images/starCTF/image-20220408192144886.png" alt="image-20220408192144886"></p>
<ul>
<li>bsd_signal() 函数为使用 BSD 形式的 signal() 函数编写的程序提供了部分兼容的接口。(所以这里有信号的传送)</li>
<li>_libc_open64()函数读取文件，获得输入（可能就是输入的额flag）</li>
</ul>
<p>bsd_signal()的函数联系到一个函数：（这个地方能够返回一些值）</p>
<p><img src="/images/starCTF/image-20220408193332857.png" alt="image-20220408193332857"></p>
<p>再在主函数之中向下翻看函数，找到第二个有效函数sub_402072();</p>
<p>在这个函数的开头我们发现了读取文件的操作的函数，并且这里读取的内容和之前 “/dev/tty ”输入数据相关联</p>
<p><img src="/images/starCTF/image-20220408194929090.png" alt="image-20220408194929090"></p>
<p><img src="/images/starCTF/image-20220408195007066.png" alt="image-20220408195007066"></p>
<p>在最开始接受信号的函数之中，通过下面两个数据，跟进到内存之中，发现了一个字符串</p>
<p><img src="/images/starCTF/image-20220408200209847.png" alt="image-20220408200209847"></p>
<p><img src="/images/starCTF/image-20220408200307920.png" alt="image-20220408200307920"></p>
<p>通过字符串找到对应的函数</p>
<p><img src="/images/starCTF/image-20220408200333547.png" alt="image-20220408200333547"></p>
<p>这个函数本身内部只有简单的操作，我交叉引用了一下，找到了下面这个函数</p>
<p><img src="/images/starCTF/image-20220408200503270.png" alt="image-20220408200503270"></p>
<p>再向上xref 找到一个含有_libc_recvfrom()的函数，dword_4C8520关联到socket接口（接受输入的数据）</p>
<p><img src="/images/starCTF/image-20220408201150205.png" alt="image-20220408201150205"></p>
<p><img src="/images/starCTF/image-20220408201758219.png" alt="image-20220408201758219"></p>
<p><img src="/images/starCTF/image-20220408201806836.png" alt="image-20220408201806836"></p>
<ul>
<li>recvfrom()函数：经socket接收数据</li>
<li><a href="https://blog.csdn.net/m0_37875954/article/details/76795627">sys_socket()</a>:创建插口</li>
</ul>
<p>所以上面的逻辑是，程序执行socket产生，tty文件中的数据被recvfrom()函数接收（5个数），接收之后进入到这个加密函数之中，最后对比的结果是：0x4C5150位置的数据（我们在主函数之中最后unk_4C5130数据能够定位到这段数据的周围）后面的分析也可以知道输入的字符串的长度应该是25字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x38, 0x6D, 0x4B, 0x4B, 0xB9, </span><br><span class="line">0x8A, 0xF9, 0x8A, 0xBB, 0x5C, </span><br><span class="line">0x8A, 0x9A, 0xBA, 0x6B, 0xD2, </span><br><span class="line">0xC6, 0xBB, 0x05, 0x90, 0x56, </span><br><span class="line">0x93, 0xE6, 0x12, 0xBD, 0x4F</span><br></pre></td></tr></table></figure>

<h3 id="线性方程求解"><a href="#线性方程求解" class="headerlink" title="线性方程求解"></a>线性方程求解</h3><p>分析加密的过程：</p>
<p>初始化数组：</p>
<p><img src="/images/starCTF/image-20220408205815225.png" alt="image-20220408205815225"></p>
<p>每轮初始化的结果依次是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;faori&quot;</span><br><span class="line">&quot;lruee&quot;</span><br><span class="line">&quot;ae__n&quot;</span><br><span class="line">&quot;g_sfd&quot;</span><br><span class="line">&quot;&#123;yur&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>输入的元素和上面初始化的结果(每轮和一组字符串)进行逐byte的相乘之后相加则得到最后的结果（要模257）</p>
<p><img src="/images/starCTF/image-20220408210401423.png" alt="image-20220408210401423"></p>
<p>所以这个地方就是线性方程组求解问题（一共有五组线性方程组，每组之中五个变量，5个方程，每个方程对应在模257的运算之中得到相应的结果）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[102,108,97,103,123,],</span><br><span class="line">[97,114,101,95,121,],</span><br><span class="line">[111,117,95,115,117,],</span><br><span class="line">[114,101,95,102,114,],</span><br><span class="line">[105,101,110,100,125,]]</span><br><span class="line"></span><br><span class="line">5组方程分别的结果：</span><br><span class="line"> [[0x38, 0x6D, 0x4B, 0x4B, 0xB9],</span><br><span class="line"> [0x8A, 0xF9, 0x8A, 0xBB, 0x5C], </span><br><span class="line"> [0x8A, 0x9A, 0xBA, 0x6B, 0xD2], </span><br><span class="line"> [0xC6, 0xBB, 0x05, 0x90, 0x56], </span><br><span class="line"> [0x93, 0xE6, 0x12, 0xBD, 0x4F]]</span><br><span class="line"> </span><br><span class="line"> 下面的矩阵乘以上面矩阵的逆矩阵</span><br></pre></td></tr></table></figure>

<p>使用Sage解有限域的矩阵的运算</p>
<p>Sage的使用：</p>
<p>将每轮加密使用的密钥矩阵声明M 在有限域之中（作为右乘元素）</p>
<p><img src="/images/starCTF/image-20220409094704039.png" alt="image-20220409094704039"></p>
<p>将加密的结果声明成二维数组，其中的每组元素就是一个线性方程的解</p>
<p><img src="/images/starCTF/image-20220409094808398.png" alt="image-20220409094808398"></p>
<p>第一组解：[72,97,50,51,95]</p>
<p><img src="/images/starCTF/image-20220409094916865.png" alt="image-20220409094916865"></p>
<p>第二组解：[102 ,48,110, 95 ,57]</p>
<p><img src="/images/starCTF/image-20220409094950173.png" alt="image-20220409094950173"></p>
<p>第三组解：[110,100 ,95 ,71 ,48]</p>
<p><img src="/images/starCTF/image-20220409095206154.png" alt="image-20220409095206154"></p>
<p>第四组解：[111,100 ,45 ,49,117]</p>
<p><img src="/images/starCTF/image-20220409095311499.png" alt="image-20220409095311499"></p>
<p>第五组解：[ 99,107 ,45 ,79 ,72]</p>
<p><img src="/images/starCTF/image-20220409095353846.png" alt="image-20220409095353846"></p>
<p>整体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tuple(M.solve_right(Matrix(GF(257),(arrayFlag[i] for i in range(5))).transpose()).transpose())</span><br><span class="line">((72, 97, 50, 51, 95),</span><br><span class="line"> (102, 48, 110, 95, 57),</span><br><span class="line"> (110, 100, 95, 71, 48),</span><br><span class="line"> (111, 100, 45, 49, 117),</span><br><span class="line"> (99, 107, 45, 79, 72))</span><br></pre></td></tr></table></figure>



<p><img src="/images/starCTF/image-20220409101502916.png" alt="image-20220409101502916"></p>
<p>转为字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = [[<span class="number">72</span>,<span class="number">97</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">95</span>],[<span class="number">102</span> ,<span class="number">48</span>,<span class="number">110</span>, <span class="number">95</span> ,<span class="number">57</span>],[<span class="number">110</span>,<span class="number">100</span> ,<span class="number">95</span> ,<span class="number">71</span> ,<span class="number">48</span>],[<span class="number">111</span>,<span class="number">100</span> ,<span class="number">45</span> ,<span class="number">49</span>,<span class="number">117</span>],[ <span class="number">99</span>,<span class="number">107</span> ,<span class="number">45</span> ,<span class="number">79</span> ,<span class="number">72</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(obj)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(obj[i][j]),end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Ha23_f0n_9nd_G0od-1uck-OH</p>
<p>*ctf{Ha23_f0n_9nd_G0od-1uck-OH}</p>
<h2 id="Favourite-Architecture-flag0"><a href="#Favourite-Architecture-flag0" class="headerlink" title="Favourite Architecture flag0"></a>Favourite Architecture flag0</h2><p>这道题使用的 qemu-riscv64 框架 RISC-V的反编译在ida之中不能完成，要使用<a href="https://ghidra-sre.org/releaseNotes_9.2.html">Ghidra</a>这款软件反编译</p>
<p>运行该程序，加载了Input the flag 这个字符串，我们能够通过字符串定位到代码之中的位置</p>
<p><img src="/images/starCTF/image-20220409122603408.png" alt="image-20220409122603408"></p>
<h3 id="定位关键代码"><a href="#定位关键代码" class="headerlink" title="定位关键代码"></a>定位关键代码</h3><p>在Ghidra之中查看字符串窗口，找到关键的字符串（有特别含义的）</p>
<p><img src="/images/starCTF/image-20220409124436585.png" alt="image-20220409124436585"></p>
<p>通过上面的三个字符串定位到相应的代码位置</p>
<p>定位到相对应的代码位置（这三个字符串都在同一函数之中）</p>
<p><img src="/images/starCTF/image-20220409124726333.png" alt="image-20220409124726333"></p>
<p>在GHidra之中按Ctrl+E反汇编，但是这里不能直接反汇编（这个地方的反编译失败和gp在最开始的设置的数值有关）</p>
<h3 id="重置gp"><a href="#重置gp" class="headerlink" title="重置gp"></a>重置gp</h3><p>看反编译代码，这里的指针调用使用了gp</p>
<p><img src="/images/starCTF/image-20220409143211328.png" alt="image-20220409143211328"></p>
<p>gp在程序运行的时候就会进行初始化</p>
<p><img src="/images/starCTF/image-20220409143310349.png" alt="image-20220409143310349"></p>
<p>这里初始化成的是0x6f178，不正确，需要修改gp的值</p>
<blockquote>
<p>gp：</p>
<ul>
<li>gp寄存器在启动代码中加载为__global_pointer$的地址，并且之后不能被改变。</li>
<li>通过gp指针，访问其值±2KB，即4KB范围内的全局变量，可以节约一条指令。4KB区域可以位于寻址内存中任意位置，但是为了使优化更有效率，最好覆盖最频繁使用的RAM区域。</li>
</ul>
<p>根据gp寄存器的作用，我将gp寄存器的值修改为需要反编译的代码附近 </p>
</blockquote>
<p>重置gp的步骤：</p>
<ul>
<li>Ctrl+A选中所有的反汇编的代码</li>
<li>Ctrl+R打开寄存器的修改界面</li>
<li>选择gp寄存器</li>
<li>将值修改为hex的00010400这个地址</li>
</ul>
<h3 id="反编译关键代码"><a href="#反编译关键代码" class="headerlink" title="反编译关键代码"></a>反编译关键代码</h3><p>再回到目标的代码处，Ctr+E 就能够对该段代码进行反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined8 UndefinedFunction_00010400(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  ulonglong uVar1;</span><br><span class="line">  longlong lVar2;</span><br><span class="line">  undefined8 uVar3;</span><br><span class="line">  undefined auStack488 [192];</span><br><span class="line">  undefined auStack296 [256];</span><br><span class="line">  ulonglong uStack40;</span><br><span class="line">  longlong lStack32;</span><br><span class="line">  int iStack20;</span><br><span class="line">  </span><br><span class="line">  FUN_00017d74(uRam000000000000fcb0,0);</span><br><span class="line">  FUN_00017d74(uRam000000000000fca8,0);</span><br><span class="line">  FUN_00017d74(uRam000000000000fca0,0);</span><br><span class="line">  FUN_0001605a(&quot;Input the flag: &quot;);</span><br><span class="line">  FUN_00016a5a(auStack296);</span><br><span class="line">  uVar1 = FUN_000204e4(auStack296);</span><br><span class="line">  if (uVar1 == ((longlong)(iRam000000000000fc64 + iRam000000000000fc60) &amp; 0xffffffffU)) &#123;</span><br><span class="line">    lStack32 = FUN_00020386(auStack296 + ((longlong)iRam000000000000fc60 &amp; 0xffffffff));</span><br><span class="line">    FUN_0001118a(auStack488,&quot;tzgkwukglbslrmfjsrwimtwyyrkejqzo&quot;,&quot;oaeqjfhclrqk&quot;,0x80);</span><br><span class="line">    FUN_000111ea(auStack488,auStack296,iRam000000000000fc60);</span><br><span class="line">    lVar2 = FUN_00020e2a(auStack296,&amp;DAT_0006d000,iRam000000000000fc60);</span><br><span class="line">    if (lVar2 == 0) &#123;</span><br><span class="line">      uStack40 = FUN_000204e4(lStack32);</span><br><span class="line">      iStack20 = 0;</span><br><span class="line">      while ((ulonglong)(longlong)iStack20 &lt; uStack40 &gt;&gt; 3) &#123;</span><br><span class="line">        FUN_000102ae(iStack20 * 8 + lStack32,&amp;DAT_0006d060);</span><br><span class="line">        lVar2 = FUN_00020e2a(iStack20 * 8 + lStack32,(longlong)(iStack20 * 8) + 0x6d030,8);</span><br><span class="line">        if (lVar2 != 0) goto LAB_0001057a;</span><br><span class="line">        iStack20 = iStack20 + 1;</span><br><span class="line">      &#125;</span><br><span class="line">      FUN_00016bc8(&quot;You are right :D&quot;);</span><br><span class="line">      uVar3 = 0;</span><br><span class="line">      goto LAB_00010588;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LAB_0001057a:</span><br><span class="line">  FUN_00016bc8(&quot;You are wrong ._.&quot;);</span><br><span class="line">  uVar3 = 1;</span><br><span class="line">LAB_00010588:</span><br><span class="line">  gp = UndefinedFunction_00010400;</span><br><span class="line">  return uVar3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="chacha20加密"><a href="#chacha20加密" class="headerlink" title="chacha20加密"></a>chacha20加密</h3><p>第一个加密的过程：将输入进行了异或运算，异或运算的对象上一个函数初始化的结果</p>
<p><img src="/images/starCTF/image-20220409145605305.png" alt="image-20220409145605305"></p>
<p>加密之后对比的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">88 e7 03 b4 36 cd 97 ab 5a a5 a6 0b df ce 08 3b 9d 90 32 3c 4e 15 14 bd 8d 38 38 b0 ee 2a bc 4b f9 aa 24 26 76 a3 a5 75 5e 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x88,0xe7,0x03,0xb4,0x36,0xcd,0x97,0xab,0x5a,0xa5,0xa6,0x0b,0xdf,0xce,0x08,0x3b,0x9d,0x90,0x32,0x3c,0x4e,0x15,0x14,0xbd,0x8d,0x38,0x38,0xb0,0xee,0x2a,0xbc,0x4b,0xf9,0xaa,0x24,0x26,0x76,0xa3,0xa5,0x75,0x5e]</span><br></pre></td></tr></table></figure>

<p>进入这个加密函数之中，进入里面引用了字符串的函数之中（FUN_000106ce(param_1,param_2,param_3)）</p>
<p>这个函数之中是初始化密钥，经过搜索字符串“expand 32-byte k”，这个地方使用的可能是<strong>Salsa20</strong>的流密码 =&gt; <strong>chacha20</strong></p>
<p><img src="/images/starCTF/image-20220409165149123.png" alt="image-20220409165149123"></p>
<p><img src="/images/starCTF/image-20220409165113356.png" alt="image-20220409165113356"></p>
<p><img src="/images/starCTF/image-20220409164221139.png" alt="image-20220409164221139"></p>
<p><img src="/images/starCTF/image-20220409180108114.png" alt="image-20220409180108114"></p>
<p>前半部分的解密是chahca20  密钥是32字节的 tzgkwukglbslrmfjsrwimtwyyrkejqzo 随机数是16字节的 oaeqjfhclrqk</p>
<p>flag{have_you_tried_ghidra9.2_decompiler_</p>
<p>但是这里的流密码加密中间应该是做了修改的，我不知道具体是在哪里，猜测有可能是最后的异或的对象做了修改（下面两个就是chacha20的密钥和随机数）</p>
<p><img src="/images/starCTF/image-20220409175857337.png" alt="image-20220409175857337"></p>
<h3 id="tea加密"><a href="#tea加密" class="headerlink" title="tea加密"></a>tea加密</h3><p>第二个加密（在while循环里面） 这个地方是tea加密</p>
<p><img src="/images/starCTF/image-20220409150540764.png" alt="image-20220409150540764"></p>
<p>tea加密：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span> <span class="params">(<span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">const</span> <span class="type">uint32_t</span> k[<span class="number">4</span>])</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, i;           <span class="comment">/* set up */</span></span><br><span class="line">    <span class="type">uint32_t</span> delta=<span class="number">0x9E3779B9</span>;                     <span class="comment">/* a key schedule constant */</span></span><br><span class="line">    <span class="type">uint32_t</span> k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];   <span class="comment">/* cache key */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;                         <span class="comment">/* basic cycle start */</span></span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);</span><br><span class="line">    &#125;                                              <span class="comment">/* end cycle */</span></span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变形：进行的是16轮加密 -0x61c88647 所以解密代码之中的 减delta -&gt; 加delta 其中的sum = delta &lt;&lt; 4（16轮）进行解密</p>
<p>密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1368A0BB,0x190ACE1E,0x35D8A357,0x26BF2C61</span><br></pre></td></tr></table></figure>

<p>加密的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xC45087F9,0x703F2B2,</span><br><span class="line">0x6974F43C,0xEDB4BB59,</span><br><span class="line">0xFF0B02A,0x8520F2,</span><br><span class="line">0xFDCD23DD,0x35024875,</span><br><span class="line">0xF1D7B6D3,0x74F21BE1,</span><br><span class="line">0xCB2DBF12,0xA4B453F6</span><br></pre></td></tr></table></figure>

<p>tea解密脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], i;  /* set up */</span><br><span class="line">    int32_t delta=-0x61c88647 , sum=0xC6EF3720;  /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    sum = delta * 16;</span><br><span class="line">    for (i=0; i&lt;16; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v1[3]=&#123;0xC45087F9,0x703F2B2,0x0&#125;,k[4]=&#123;0x1368A0BB,0x190ACE1E,0x35D8A357,0x26BF2C61&#125;;</span><br><span class="line">    uint32_t v2[3]=&#123;0x6974F43C,0xEDB4BB59,0x0&#125;;</span><br><span class="line">    uint32_t v3[3]=&#123;0xFF0B02A,0x8520F2,0x0&#125;;</span><br><span class="line">    uint32_t v4[3]=&#123;0xFDCD23DD,0x35024875,0x0&#125;;</span><br><span class="line">    uint32_t v5[3]=&#123;0xF1D7B6D3,0x74F21BE1,0x0&#125;;</span><br><span class="line">    uint32_t v6[3]=&#123;0xCB2DBF12,0xA4B453F6,0x0&#125;;</span><br><span class="line">    decrypt(v1, k);</span><br><span class="line">    decrypt(v2, k);</span><br><span class="line">    decrypt(v3, k);</span><br><span class="line">    decrypt(v4, k);</span><br><span class="line">    decrypt(v5, k);</span><br><span class="line">    decrypt(v6, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s%s%s%s%s%s\n&quot;,(char*)v1,(char*)v2,(char*)v3,(char *)v4,(char *)v5,(char *)v6);   // 注意如何将一串数组以字符串的形式输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">解密后的数据：if_you_have_hexriscv_plz_share_it_with_me_thx:P&#125;</span><br></pre></td></tr></table></figure>

<p>这就是后半部分的flag</p>
<p>所以整个flag是 flag{have_you_tried_ghidra9.2_decompiler_if_you_have_hexriscv_plz_share_it_with_me_thx:P}</p>
<h3 id="chacha20加密的分析过程（未解）-自己的分析过程"><a href="#chacha20加密的分析过程（未解）-自己的分析过程" class="headerlink" title="chacha20加密的分析过程（未解）-自己的分析过程"></a>chacha20加密的分析过程（未解）-自己的分析过程</h3><p>下面是我的解密的思路，但是不知道到底是哪里的数据出问题了，并不能解得答案？？？？？</p>
<p>初始化 ，利用下面的特征我推测出来这个地方是进行chacha20加密的方法，密钥是tzgkwukglbslrmfjsrwimtwyyrkejqzo（32字节）</p>
<p>随机数 oaeqjfhclrq（12字节）</p>
<p><img src="/images/starCTF/image-20220410084430925.png" alt="image-20220410084430925"></p>
<p><img src="/images/starCTF/image-20220410084449792.png" alt="image-20220410084449792"></p>
<p><img src="/images/starCTF/image-20220410084912851.png" alt="image-20220410084912851"></p>
<p><img src="/images/starCTF/image-20220410084516526.png" alt="image-20220410084516526"></p>
<p>初始化之后进入加密函数之中</p>
<p><img src="/images/starCTF/image-20220410084546592.png" alt="image-20220410084546592"></p>
<p>我猜测下面标注的这个函数是利用初始化的表生成密钥流的过程</p>
<p><img src="/images/starCTF/image-20220410084607632.png" alt="image-20220410084607632"></p>
<p><img src="/images/starCTF/image-20220410084639998.png" alt="image-20220410084639998"></p>
<p>生成的密钥流用下面的方法和输入的字符进行异或运算</p>
<p><img src="/images/starCTF/image-20220410084700362.png" alt="image-20220410084700362"></p>
<p>最后生成的密文是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x88,0xe7,0x03,0xb4,0x36,0xcd,0x97,0xab,0x5a,0xa5,0xa6,0x0b,0xdf,0xce,0x08,0x3b,0x9d,0x90,0x32,0x3c,0x4e,0x15,0x14,0xbd,0x8d,0x38,0x38,0xb0,0xee,0x2a,0xbc,0x4b,0xf9,0xaa,0x24,0x26,0x76,0xa3,0xa5,0x75,0x5e]</span><br><span class="line">hex表示：</span><br><span class="line">88e703b436cd97ab5aa5a60bdfce083b9d90323c4e1514bd8d3838b0ee2abc4bf9aa242676a3a5755e</span><br></pre></td></tr></table></figure>

<p>但是这里并不能解密，中间的加密步骤相比于常规的chacha20加密有可能被改了，我猜测是不是最后一步异或的过程，常规的流密钥加密</p>
<p>单次运算的结果</p>
<p><img src="/images/starCTF/image-20220410104954137.png" alt="image-20220410104954137"></p>
<p>Java的Chacha20的解密脚本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Coco2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChaCha20</span> &#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">// byte[] key, byte[] nonce, int counter</span></span><br><span class="line">		<span class="type">byte</span>[] key = &#123;<span class="number">116</span>,<span class="number">122</span>,<span class="number">103</span>,<span class="number">107</span>,<span class="number">119</span>,<span class="number">117</span>,<span class="number">107</span>,<span class="number">103</span>,<span class="number">108</span>,<span class="number">98</span>,<span class="number">115</span>,<span class="number">108</span>,<span class="number">114</span>,<span class="number">109</span>,<span class="number">102</span>,<span class="number">106</span>,<span class="number">115</span>,<span class="number">114</span>,<span class="number">119</span>,<span class="number">105</span>,<span class="number">109</span>,<span class="number">116</span>,<span class="number">119</span>,<span class="number">121</span>,<span class="number">121</span>,<span class="number">114</span>,<span class="number">107</span>,<span class="number">101</span>,<span class="number">106</span>,<span class="number">113</span>,<span class="number">122</span>,<span class="number">111</span>&#125;;</span><br><span class="line">		<span class="type">byte</span>[] nonce = &#123;<span class="number">111</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">113</span>,<span class="number">106</span>,<span class="number">102</span>,<span class="number">104</span>,<span class="number">99</span>,<span class="number">108</span>,<span class="number">114</span>,<span class="number">113</span>,<span class="number">107</span>&#125;;</span><br><span class="line">		<span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0x29</span>];</span><br><span class="line">		<span class="type">byte</span>[] src = &#123;(<span class="type">byte</span>) <span class="number">0x88</span>,(<span class="type">byte</span>) <span class="number">0xe7</span>,<span class="number">0x03</span>,(<span class="type">byte</span>) <span class="number">0xb4</span>,<span class="number">0x36</span>,(<span class="type">byte</span>) <span class="number">0xcd</span>,(<span class="type">byte</span>) <span class="number">0x97</span>,(<span class="type">byte</span>) <span class="number">0xab</span>,<span class="number">0x5a</span>,(<span class="type">byte</span>) <span class="number">0xa5</span>,(<span class="type">byte</span>) <span class="number">0xa6</span>,<span class="number">0x0b</span>,(<span class="type">byte</span>) <span class="number">0xdf</span>,(<span class="type">byte</span>) <span class="number">0xce</span>,<span class="number">0x08</span>,<span class="number">0x3b</span>,(<span class="type">byte</span>) <span class="number">0x9d</span>,(<span class="type">byte</span>) <span class="number">0x90</span>,<span class="number">0x32</span>,<span class="number">0x3c</span>,<span class="number">0x4e</span>,<span class="number">0x15</span>,<span class="number">0x14</span>,(<span class="type">byte</span>) <span class="number">0xbd</span>,(<span class="type">byte</span>) <span class="number">0x8d</span>,<span class="number">0x38</span>,<span class="number">0x38</span>,(<span class="type">byte</span>) <span class="number">0xb0</span>,(<span class="type">byte</span>) <span class="number">0xee</span>,<span class="number">0x2a</span>,(<span class="type">byte</span>) <span class="number">0xbc</span>,<span class="number">0x4b</span>,(<span class="type">byte</span>) <span class="number">0xf9</span>,(<span class="type">byte</span>) <span class="number">0xaa</span>,<span class="number">0x24</span>,<span class="number">0x26</span>,<span class="number">0x76</span>,(<span class="type">byte</span>) <span class="number">0xa3</span>,(<span class="type">byte</span>) <span class="number">0xa5</span>,<span class="number">0x75</span>,<span class="number">0x5e</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> src.length;</span><br><span class="line">		System.out.println(<span class="string">&quot;加密的对象是：&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(src));</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">ChaCha20</span> <span class="variable">cha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChaCha20</span>(key,nonce,counter);</span><br><span class="line">			cha.encrypt(dst, src, len);</span><br><span class="line">			System.out.println(<span class="string">&quot;加密或者解密之后的结果：&quot;</span>);</span><br><span class="line">			System.out.println(Arrays.toString(dst));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (WrongKeySizeException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (WrongNonceSizeException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Key size in byte</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">KEY_SIZE</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Nonce size in byte (reference implementation)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NONCE_SIZE_REF</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Nonce size in byte (IETF draft)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NONCE_SIZE_IETF</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化表的时候使用</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">littleEndianToInt</span><span class="params">(<span class="type">byte</span>[] bs, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (bs[i] &amp; <span class="number">0xff</span>) | ((bs[i + <span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>) | ((bs[i + <span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) | ((bs[i + <span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 得到密钥之后使用</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">intToLittleEndian</span><span class="params">(<span class="type">int</span> n, <span class="type">byte</span>[] bs, <span class="type">int</span> off)</span> &#123;</span><br><span class="line">        bs[  off] = (<span class="type">byte</span>)(n       );</span><br><span class="line">        bs[++off] = (<span class="type">byte</span>)(n &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        bs[++off] = (<span class="type">byte</span>)(n &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        bs[++off] = (<span class="type">byte</span>)(n &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ROTATE</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (v &lt;&lt; c) | (v &gt;&gt;&gt; (<span class="number">32</span> - c));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 0 4 8 12</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quarterRound</span><span class="params">(<span class="type">int</span>[] x, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        x[a] += x[b];</span><br><span class="line">        x[d] = ROTATE(x[d] ^ x[a], <span class="number">16</span>);</span><br><span class="line">        x[c] += x[d];</span><br><span class="line">        x[b] = ROTATE(x[b] ^ x[c], <span class="number">12</span>);</span><br><span class="line">        x[a] += x[b];</span><br><span class="line">        x[d] = ROTATE(x[d] ^ x[a], <span class="number">8</span>);</span><br><span class="line">        x[c] += x[d];</span><br><span class="line">        x[b] = ROTATE(x[b] ^ x[c], <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 密钥流的生成过程中使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrongNonceSizeException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2687731889587117531L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrongKeySizeException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">290509589749955895L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 初始化表的时候</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChaCha20</span><span class="params">(<span class="type">byte</span>[] key, <span class="type">byte</span>[] nonce, <span class="type">int</span> counter)</span></span><br><span class="line">            <span class="keyword">throws</span> WrongKeySizeException, WrongNonceSizeException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key.length != KEY_SIZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WrongKeySizeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.matrix[ <span class="number">0</span>] = <span class="number">0x61707865</span>;</span><br><span class="line">        <span class="built_in">this</span>.matrix[ <span class="number">1</span>] = <span class="number">0x3320646e</span>;</span><br><span class="line">        <span class="built_in">this</span>.matrix[ <span class="number">2</span>] = <span class="number">0x79622d32</span>;</span><br><span class="line">        <span class="built_in">this</span>.matrix[ <span class="number">3</span>] = <span class="number">0x6b206574</span>;</span><br><span class="line">        <span class="built_in">this</span>.matrix[ <span class="number">4</span>] = littleEndianToInt(key, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.matrix[ <span class="number">5</span>] = littleEndianToInt(key, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">this</span>.matrix[ <span class="number">6</span>] = littleEndianToInt(key, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">this</span>.matrix[ <span class="number">7</span>] = littleEndianToInt(key, <span class="number">12</span>);</span><br><span class="line">        <span class="built_in">this</span>.matrix[ <span class="number">8</span>] = littleEndianToInt(key, <span class="number">16</span>);</span><br><span class="line">        <span class="built_in">this</span>.matrix[ <span class="number">9</span>] = littleEndianToInt(key, <span class="number">20</span>);</span><br><span class="line">        <span class="built_in">this</span>.matrix[<span class="number">10</span>] = littleEndianToInt(key, <span class="number">24</span>);</span><br><span class="line">        <span class="built_in">this</span>.matrix[<span class="number">11</span>] = littleEndianToInt(key, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nonce.length == NONCE_SIZE_REF) &#123;        <span class="comment">// reference implementation</span></span><br><span class="line">            <span class="built_in">this</span>.matrix[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.matrix[<span class="number">13</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.matrix[<span class="number">14</span>] = littleEndianToInt(nonce, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.matrix[<span class="number">15</span>] = littleEndianToInt(nonce, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nonce.length == NONCE_SIZE_IETF) &#123;</span><br><span class="line">            <span class="built_in">this</span>.matrix[<span class="number">12</span>] = counter;</span><br><span class="line">            <span class="built_in">this</span>.matrix[<span class="number">13</span>] = littleEndianToInt(nonce, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.matrix[<span class="number">14</span>] = littleEndianToInt(nonce, <span class="number">4</span>);</span><br><span class="line">            <span class="built_in">this</span>.matrix[<span class="number">15</span>] = littleEndianToInt(nonce, <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WrongNonceSizeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 密钥流的生成，利用生成的密钥流进行异或运算加密</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">byte</span>[] src, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] x = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="type">byte</span>[] output = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">64</span>];</span><br><span class="line">        <span class="type">int</span> i, dpos = <span class="number">0</span>, spos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">16</span>; i-- &gt; <span class="number">0</span>; ) x[i] = <span class="built_in">this</span>.matrix[i];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">20</span>; i &gt; <span class="number">0</span>; i -= <span class="number">2</span>) &#123;</span><br><span class="line">                quarterRound(x, <span class="number">0</span>, <span class="number">4</span>,  <span class="number">8</span>, <span class="number">12</span>);</span><br><span class="line">                quarterRound(x, <span class="number">1</span>, <span class="number">5</span>,  <span class="number">9</span>, <span class="number">13</span>);</span><br><span class="line">                quarterRound(x, <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">14</span>);</span><br><span class="line">                quarterRound(x, <span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>);</span><br><span class="line">                quarterRound(x, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line">                quarterRound(x, <span class="number">1</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line">                quarterRound(x, <span class="number">2</span>, <span class="number">7</span>,  <span class="number">8</span>, <span class="number">13</span>);</span><br><span class="line">                quarterRound(x, <span class="number">3</span>, <span class="number">4</span>,  <span class="number">9</span>, <span class="number">14</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">16</span>; i-- &gt; <span class="number">0</span>; ) x[i] += <span class="built_in">this</span>.matrix[i];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">16</span>; i-- &gt; <span class="number">0</span>; ) intToLittleEndian(x[i], output, <span class="number">4</span> * i);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> (1) check block count 32-bit vs 64-bit; (2) java int is signed!</span></span><br><span class="line">            <span class="built_in">this</span>.matrix[<span class="number">12</span>] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.matrix[<span class="number">12</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.matrix[<span class="number">13</span>] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;生成的密钥是：&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(output));</span><br><span class="line">            <span class="keyword">if</span> (len &lt;= <span class="number">64</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = len; i-- &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">                    dst[i + dpos] = (<span class="type">byte</span>) (src[i + spos] ^ output[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">64</span>; i-- &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">                dst[i + dpos] = (<span class="type">byte</span>) (src[i + spos] ^ output[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            len -= <span class="number">64</span>;</span><br><span class="line">            spos += <span class="number">64</span>;</span><br><span class="line">            dpos += <span class="number">64</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 解密就是加密</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">byte</span>[] src, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        encrypt(dst, src, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">加密的对象是：</span><br><span class="line">[-<span class="number">120</span>, -<span class="number">25</span>, <span class="number">3</span>, -<span class="number">76</span>, <span class="number">54</span>, -<span class="number">51</span>, -<span class="number">105</span>, -<span class="number">85</span>, <span class="number">90</span>, -<span class="number">91</span>, -<span class="number">90</span>, <span class="number">11</span>, -<span class="number">33</span>, -<span class="number">50</span>, <span class="number">8</span>, <span class="number">59</span>, -<span class="number">99</span>, -<span class="number">112</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">78</span>, <span class="number">21</span>, <span class="number">20</span>, -<span class="number">67</span>, -<span class="number">115</span>, <span class="number">56</span>, <span class="number">56</span>, -<span class="number">80</span>, -<span class="number">18</span>, <span class="number">42</span>, -<span class="number">68</span>, <span class="number">75</span>, -<span class="number">7</span>, -<span class="number">86</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">118</span>, -<span class="number">93</span>, -<span class="number">91</span>, <span class="number">117</span>, <span class="number">94</span>]</span><br><span class="line">生成的密钥是：</span><br><span class="line">[-<span class="number">97</span>, <span class="number">114</span>, -<span class="number">91</span>, <span class="number">36</span>, -<span class="number">54</span>, -<span class="number">100</span>, <span class="number">77</span>, -<span class="number">116</span>, <span class="number">39</span>, -<span class="number">85</span>, -<span class="number">55</span>, -<span class="number">56</span>, <span class="number">78</span>, -<span class="number">44</span>, <span class="number">66</span>, <span class="number">29</span>, <span class="number">106</span>, -<span class="number">73</span>, -<span class="number">56</span>, -<span class="number">39</span>, <span class="number">41</span>, -<span class="number">111</span>, <span class="number">17</span>, -<span class="number">107</span>, <span class="number">97</span>, -<span class="number">54</span>, -<span class="number">18</span>, <span class="number">8</span>, <span class="number">91</span>, -<span class="number">50</span>, -<span class="number">29</span>, <span class="number">118</span>, <span class="number">11</span>, <span class="number">26</span>, -<span class="number">100</span>, -<span class="number">89</span>, -<span class="number">64</span>, -<span class="number">8</span>, <span class="number">10</span>, -<span class="number">41</span>, <span class="number">86</span>, <span class="number">92</span>, <span class="number">22</span>, -<span class="number">56</span>, <span class="number">18</span>, -<span class="number">55</span>, -<span class="number">116</span>, -<span class="number">105</span>, -<span class="number">66</span>, -<span class="number">53</span>, <span class="number">80</span>, <span class="number">8</span>, <span class="number">8</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">100</span>, <span class="number">90</span>, <span class="number">115</span>, -<span class="number">106</span>, <span class="number">58</span>, <span class="number">7</span>, <span class="number">122</span>, -<span class="number">103</span>, <span class="number">32</span>]</span><br><span class="line">加密或者解密之后的结果：</span><br><span class="line">[<span class="number">23</span>, -<span class="number">107</span>, -<span class="number">90</span>, -<span class="number">112</span>, -<span class="number">4</span>, <span class="number">81</span>, -<span class="number">38</span>, <span class="number">39</span>, <span class="number">125</span>, <span class="number">14</span>, <span class="number">111</span>, -<span class="number">61</span>, -<span class="number">111</span>, <span class="number">26</span>, <span class="number">74</span>, <span class="number">38</span>, -<span class="number">9</span>, <span class="number">39</span>, -<span class="number">6</span>, -<span class="number">27</span>, <span class="number">103</span>, -<span class="number">124</span>, <span class="number">5</span>, <span class="number">40</span>, -<span class="number">20</span>, -<span class="number">14</span>, -<span class="number">42</span>, -<span class="number">72</span>, -<span class="number">75</span>, -<span class="number">28</span>, <span class="number">95</span>, <span class="number">61</span>, -<span class="number">14</span>, -<span class="number">80</span>, -<span class="number">72</span>, -<span class="number">127</span>, -<span class="number">74</span>, <span class="number">91</span>, -<span class="number">81</span>, -<span class="number">94</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<p>用c语言编写的得到密钥流的脚本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define KEY_SIZE 32</span></span><br><span class="line"><span class="comment">//#define NONCE_SIZE_REF 8</span></span><br><span class="line"><span class="comment">//#define NONCE_SIZE_IETF 12</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> matrix[<span class="number">16</span>];</span><br><span class="line"><span class="type">uint32_t</span> key[<span class="number">8</span>] = &#123;<span class="number">0x6b677a74</span>,<span class="number">0x676b7577</span>,<span class="number">0x6c73626c</span>,<span class="number">0x6a666d72</span>,<span class="number">0x69777273</span>,<span class="number">0x7977746d</span>,<span class="number">0x656b7279</span>,<span class="number">0x6f7a716a</span>&#125;;</span><br><span class="line"><span class="type">uint32_t</span> nonce[<span class="number">3</span>] = &#123;<span class="number">0x7165616f</span>,<span class="number">0x6368666a</span>,<span class="number">0x6b71726c</span>&#125;;</span><br><span class="line"><span class="type">int</span> counter=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ROTATE</span><span class="params">(<span class="type">uint32_t</span> v, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> (v &lt;&lt; c) | (v &gt;&gt; (<span class="number">32</span> - c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quarterRound</span><span class="params">(<span class="type">uint32_t</span>* x, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">        x[a] += x[b];</span><br><span class="line">        x[d] = ROTATE(x[d] ^ x[a], <span class="number">16</span>);</span><br><span class="line">        x[c] += x[d];</span><br><span class="line">        x[b] = ROTATE(x[b] ^ x[c], <span class="number">12</span>);</span><br><span class="line">        x[a] += x[b];</span><br><span class="line">        x[d] = ROTATE(x[d] ^ x[a], <span class="number">8</span>);</span><br><span class="line">        x[c] += x[d];</span><br><span class="line">        x[b] = ROTATE(x[b] ^ x[c], <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// uint8_t* key, uint8_t* nonce, int counter</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ChaCha20</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        matrix[ <span class="number">0</span>] = <span class="number">0x61707865</span>;</span><br><span class="line">        matrix[ <span class="number">1</span>] = <span class="number">0x3320646e</span>;</span><br><span class="line">        matrix[ <span class="number">2</span>] = <span class="number">0x79622d32</span>;</span><br><span class="line">        matrix[ <span class="number">3</span>] = <span class="number">0x6b206574</span>;</span><br><span class="line">        matrix[ <span class="number">4</span>] = key[<span class="number">0</span>];</span><br><span class="line">        matrix[ <span class="number">5</span>] = key[<span class="number">1</span>];</span><br><span class="line">        matrix[ <span class="number">6</span>] = key[<span class="number">2</span>];</span><br><span class="line">        matrix[ <span class="number">7</span>] = key[<span class="number">3</span>];</span><br><span class="line">        matrix[ <span class="number">8</span>] = key[<span class="number">4</span>];</span><br><span class="line">        matrix[ <span class="number">9</span>] = key[<span class="number">5</span>];</span><br><span class="line">        matrix[<span class="number">10</span>] = key[<span class="number">6</span>];</span><br><span class="line">        matrix[<span class="number">11</span>] = key[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">        matrix[<span class="number">12</span>] = counter;</span><br><span class="line">        matrix[<span class="number">13</span>] = nonce[<span class="number">0</span>];</span><br><span class="line">        matrix[<span class="number">14</span>] = nonce[<span class="number">1</span>];</span><br><span class="line">        matrix[<span class="number">15</span>] = nonce[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uint8_t* dst, uint8_t src, int len</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> x[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> i, dpos = <span class="number">0</span>, spos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">16</span>; i-- &gt; <span class="number">0</span>; ) x[i] = matrix[i];</span><br><span class="line"><span class="comment">//    for (i=0;i&lt;16;i++) printf(&quot;%d &quot;,x[i]);</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">        quarterRound(x, <span class="number">0</span>, <span class="number">4</span>,  <span class="number">8</span>, <span class="number">12</span>);</span><br><span class="line">        quarterRound(x, <span class="number">1</span>, <span class="number">5</span>,  <span class="number">9</span>, <span class="number">13</span>);</span><br><span class="line">        quarterRound(x, <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">14</span>);</span><br><span class="line">        quarterRound(x, <span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>);</span><br><span class="line">        quarterRound(x, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line">        quarterRound(x, <span class="number">1</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line">        quarterRound(x, <span class="number">2</span>, <span class="number">7</span>,  <span class="number">8</span>, <span class="number">13</span>);</span><br><span class="line">        quarterRound(x, <span class="number">3</span>, <span class="number">4</span>,  <span class="number">9</span>, <span class="number">14</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">16</span>;i++ ) x[i] += matrix[i];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;0x%x,&quot;</span>,x[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ChaCha20();</span><br><span class="line">    encrypt();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">得到的密钥流是：</span><br><span class="line"><span class="number">0x24a5729f</span>,<span class="number">0x8c4d9cca</span>,<span class="number">0xc8c9ab27</span>,<span class="number">0x1d42d44e</span>,<span class="number">0xd9c8b76a</span>,<span class="number">0x95119129</span>,<span class="number">0x8eeca61</span>,<span class="number">0x76e3ce5b</span>,<span class="number">0xa79c1a0b</span>,<span class="number">0xd70af8c0</span>,<span class="number">0xc8165c56</span>,<span class="number">0x978cc912</span>,<span class="number">0x850cbbe</span>,<span class="number">0x9cfefe08</span>,<span class="number">0x3a96735a</span>,<span class="number">0x20997a07</span></span><br></pre></td></tr></table></figure>

<p>我对比了源码和我的解密脚本，以及密钥流的生成过程，我觉得是一样的，到底是哪里处问题了，望指正。</p>
<h4 id="RCT-Harmony"><a href="#RCT-Harmony" class="headerlink" title="RCT-Harmony"></a>RCT-Harmony</h4><p>就是为了练习一下使用Ghidra</p>
<p>这道题是RISC-V题目</p>
<p><img src="/images/starCTF/image-20220410155031767.png" alt="image-20220410155031767"></p>
<p>使用Ghidra打开该程序</p>
<p>通过查看字符串的表，我们找到特殊的字符串 </p>
<p><img src="/images/starCTF/image-20220410160020112.png" alt="image-20220410160020112"></p>
<p>加密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void UndefinedFunction_8000095c(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  int iStack84;</span><br><span class="line">  undefined4 uStack72;</span><br><span class="line">  undefined4 uStack68;</span><br><span class="line">  undefined4 uStack64;</span><br><span class="line">  undefined4 uStack60;</span><br><span class="line">  undefined4 uStack56;</span><br><span class="line">  undefined2 uStack52;</span><br><span class="line">  undefined uStack50;</span><br><span class="line">  undefined uStack49;</span><br><span class="line">  undefined4 uStack48;</span><br><span class="line">  undefined4 uStack44;</span><br><span class="line">  undefined4 uStack40;</span><br><span class="line">  undefined4 uStack36;</span><br><span class="line">  undefined4 uStack32;</span><br><span class="line">  undefined4 uStack28;</span><br><span class="line">  undefined2 uStack24;</span><br><span class="line">  </span><br><span class="line">  do &#123;</span><br><span class="line">    FUN_80000832(&quot;Welcome to RCTF 2021...\n\r&quot;);</span><br><span class="line">    uStack72 = 0x4d524148;</span><br><span class="line">    uStack68 = 0x44594e4f;</span><br><span class="line">    uStack64 = 0x4d414552;</span><br><span class="line">    uStack60 = 0x4f505449;</span><br><span class="line">    uStack56 = 0x42495353;</span><br><span class="line">    uStack52 = 0x454c;</span><br><span class="line">    uStack50 = 0;</span><br><span class="line">    uStack48 = 0x44434241;</span><br><span class="line">    uStack44 = 0x48474645;</span><br><span class="line">    uStack40 = 0x4c4b4a49;</span><br><span class="line">    uStack36 = 0x504f4e4d;</span><br><span class="line">    uStack32 = 0x54535251;</span><br><span class="line">    uStack28 = 0x58575655;</span><br><span class="line">    uStack24 = 0x5a59;</span><br><span class="line">    iStack84 = 0;</span><br><span class="line">    while (iStack84 &lt; 0x16) &#123;</span><br><span class="line">      if (*(char *)((int)&amp;uStack72 + iStack84) + 3 &lt; 0x5b) &#123;</span><br><span class="line">        *(char *)((int)&amp;uStack72 + iStack84) = *(char *)((int)&amp;uStack72 + iStack84) + &#x27;\x03&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">      // 注意这个地方的起点是 &amp;uStack49</span><br><span class="line">        *(undefined *)((int)&amp;uStack72 + iStack84) =</span><br><span class="line">             (&amp;uStack49)[(*(char *)((int)&amp;uStack72 + iStack84) + -0x57) % 0x1a];</span><br><span class="line">      &#125;</span><br><span class="line">      iStack84 = iStack84 + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    FUN_80000832(&quot;The result of encryption: %s\n\r&quot;,&amp;uStack72);</span><br><span class="line">    FUN_800059a2(1000);</span><br><span class="line">  &#125; while( true );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过该字符串定位到对应的位置，Ctrl+E反编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src1= [0x48,0x41,0x52,0x4d,0x4f,0x4e,0x59,0x44,0x52,0x45,0x41,0x4d,0x49,0x54,0x50,0x4f,0x53,0x53,0x49,0x42,0x4c,0x45]</span><br><span class="line">src2= [0x0,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a]</span><br><span class="line">print(len(src1))</span><br><span class="line">print(len(src2))</span><br><span class="line">print(&quot;RCTF&#123;&quot;,end=&quot;&quot;)</span><br><span class="line">for i  in range(len(src1)):</span><br><span class="line">    if src1[i]+3 &lt; 0x5b:</span><br><span class="line">        src1[i] = src1[i] +3</span><br><span class="line">    else:</span><br><span class="line">        src1[i] = src2[(src1[i]-0x57) % 0x1a]</span><br><span class="line">    print(chr(src1[i]),end=&quot;&quot;)</span><br><span class="line">print(&quot;&#125;&quot;)</span><br><span class="line">RCTF&#123;KDUPRQBGUHDPLWSRVVLEOH&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ChineseGame"><a href="#ChineseGame" class="headerlink" title="ChineseGame"></a>ChineseGame</h2><p>先导入一个签名文件，将函数符号化，这个程序是用c++写的，所以找签名文件的时候找c++的签名文件会更好</p>
<p>数组之中的元素数据</p>
<p><img src="/images/starCTF/image-20220410233525377.png" alt="image-20220410233525377"></p>
<h3 id="函数逻辑分析"><a href="#函数逻辑分析" class="headerlink" title="函数逻辑分析"></a>函数逻辑分析</h3><p>进入到v9的赋值函数之中</p>
<p><img src="/images/starCTF/image-20220411194148967.png" alt="image-20220411194148967"></p>
<p>这里赋值了10个数，用1表示[101,200]的数 用0表示[0,100)的数</p>
<p>所以初始化的结果是1011111111</p>
<p>主体的逻辑：</p>
<p>通过输入0和1来判断如何给v9中的元素重新赋值<img src="/images/starCTF/image-20220411215259390.png" alt="image-20220411215259390"></p>
<p>当输入的元素是0时：</p>
<p>将对应v9的值重新赋值为一个小于100的数</p>
<p>能赋值的条件：</p>
<ol>
<li>是v9[9]</li>
<li>该值本生就小于100</li>
<li>当该值大于100，它后面的那位大于100，它再后面的每一位都小于100</li>
</ol>
<p><img src="/images/starCTF/image-20220411215515316.png" alt="image-20220411215515316"></p>
<p>当输入的元素是1时：</p>
<p>将对应v9的值重新赋值为一个大于100的数</p>
<p>能赋值的条件：</p>
<ol>
<li>是v9[9]</li>
<li>该值本生就大于100</li>
<li>当该值大于100，它后面的那位大于100，它再后面的每一位都小于100</li>
</ol>
<p><img src="/images/starCTF/image-20220411220002871.png" alt="image-20220411220002871"></p>
<p>最后判断的条件：</p>
<p>v9中的所有数都是小于100时就成功了</p>
<p><img src="/images/starCTF/image-20220411220039939.png" alt="image-20220411220039939"></p>
<p>这里将大于100的状态定义为1 小于100的状态定义为0</p>
<p>所以就是将1011111111 =》 0000000000</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>我起初以为要自己来走，后来看别人的wp发现，这个给的数组就是正确的走的方式，为了保证每一次走的位置有意义（相应的v9的状态能发生变化），我们要判断这个点当前的状态，然后输出使其达到取反的方式（0or1）</p>
<p>脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src = [0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x07,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x09,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x07,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x08,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x07,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x0a,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x07,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x08,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x07,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x09,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x07,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x08,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x07,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x06,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x05,0x01,0x02,0x01,0x03,0x01,0x02,0x01,0x04,0x01,0x02,0x01,0x03,0x01,0x02,0x01]</span><br><span class="line">status = [1]*10 # 当状态为1的时候是值大于100时 这时候需要选择0改变状态</span><br><span class="line">status[1] = 0  # 当状态为0时时值小于100时   这时候需要选择1</span><br><span class="line"># 根据使用表中的数据定位到的状态来输出值</span><br><span class="line">for i in range(len(src)):</span><br><span class="line">    if status[10-src[i]] == 1:</span><br><span class="line">        status[10-src[i]] = 0</span><br><span class="line">        print(&quot;0&quot;,end=&quot;&quot;)</span><br><span class="line">    else:</span><br><span class="line">        status[10-src[i]] = 1</span><br><span class="line">        print(&quot;1&quot;,end=&quot;&quot;)</span><br><span class="line">print(&quot;最后的状态是：&quot;)</span><br><span class="line">print(status)</span><br><span class="line">0010001101100011001000110110011100100111011000110010001101100111001000110110001100100111011001110010011101100011001001110110011100100011011000110010011101100111001001110110001100100011011001110010001101100011001000110110011100100111011000110010011101100111001000110110001100100011011001110010011101100011001000110110011100100011011000110010001101100111001001110110001100100111011001110010001101100011001001110110011100100111011000110010001101100111001000110110001100100111011001110010011101100011001001110110011100100011011000110010001101100111001001110110001100100011011001110010001101100011001000110110011100100111011000110010011101100111001000110110001100100111011001110010011101100011001000110110011100100011011000110010001101100111001001110110001100100111011001110010001101100011001000110110011100100111011000110010001101100111001000110110001100100</span><br><span class="line">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>

<p>因为复现的时候环境关了，但是通过上面最后status都是0，达到了我们的最后目的可以知道这个路线是正确的</p>
<p>网上最后得到的flag是：*CTF{4ncient_G4me_Fr0m_4ncient_Ch1na!}</p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>复现</tag>
        <tag>subprocess模块</tag>
        <tag>签名文件</tag>
        <tag>线性方程求解</tag>
        <tag>Ghidra反编译</tag>
        <tag>qemu-riscv64</tag>
        <tag>chacha20</tag>
      </tags>
  </entry>
  <entry>
    <title>susctf(DigitalCircuits+hello_word)</title>
    <url>/2022/03/04/susctf-DigitalCircuits-hello-word/</url>
    <content><![CDATA[<h1 id="SUSCTF-DigitalCircuits-hello-word"><a href="#SUSCTF-DigitalCircuits-hello-word" class="headerlink" title="SUSCTF(DigitalCircuits+hello_word)"></a>SUSCTF(DigitalCircuits+hello_word)</h1><p><a href="https://github.com/susers/SUSCTF2022_official_wp/tree/main/reverse">官方的WP</a></p>
<h2 id="DigitalCircuits"><a href="#DigitalCircuits" class="headerlink" title="DigitalCircuits"></a>DigitalCircuits</h2><p>这是一个pyc反编译的题目</p>
<h3 id="pyc文件转换成py文件"><a href="#pyc文件转换成py文件" class="headerlink" title="pyc文件转换成py文件"></a>pyc文件转换成py文件</h3><p>这是一个将pyc打包成地exe文件，首先使用软件解包，这个软件反编译出来地主程序并不是一个pyc文件，需要自己通过instruct这个文件修改这个文件地格式</p>
<p>将pyc文件用unemployed6 编译为py文件，然后得到源代码，分析代码，发现这是一个tea加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># uncompyle6 version 3.8.1.dev0</span><br><span class="line"># Python bytecode 3.7.0 (3394)</span><br><span class="line"># Decompiled from: Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)]</span><br><span class="line"># Embedded file name: DigitalCircuits.py</span><br><span class="line"># Compiled at: 1995-09-28 00:18:56</span><br><span class="line"># Size of source mod 2**32: 257 bytes</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def f1(a, b):   # 只有当两个字符都是1的时候才输出为1 与运算&amp;</span><br><span class="line">    if a == &#x27;1&#x27;:</span><br><span class="line">        if b == &#x27;1&#x27;:</span><br><span class="line">            return &#x27;1&#x27;</span><br><span class="line">    return &#x27;0&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f2(a, b):     # 有1则1    或运算|</span><br><span class="line">    if a == &#x27;0&#x27;:</span><br><span class="line">        if b == &#x27;0&#x27;:</span><br><span class="line">            return &#x27;0&#x27;</span><br><span class="line">    return &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f3(a):    # 取反运算~</span><br><span class="line">    if a == &#x27;1&#x27;:</span><br><span class="line">        return &#x27;0&#x27;</span><br><span class="line">    if a == &#x27;0&#x27;:</span><br><span class="line">        return &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f4(a, b):    # 当一个字符相同的时候返回0 当两个字符不同的时候返回1 异或运算</span><br><span class="line">    # f1(a, f3(b) ： a&amp;(~b)</span><br><span class="line">    # f1(f3(a), b) : (~a)&amp;b</span><br><span class="line">    # f2(f1(a, f3(b)), f1(f3(a), b)) : (a&amp;(~b))|((~a)&amp;b)</span><br><span class="line">    return f2(f1(a, f3(b)), f1(f3(a), b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f5(x, y, z):</span><br><span class="line">    # f4(x, y) ： d = (x&amp;(~y))|((~x)&amp;y) = x^y</span><br><span class="line">    # f4(d, z) :  ((x^y)&amp;(~z))|((~(x^y))&amp;z) 若z是0时 x和y要不同才返回1 若z是1时 x和y要相同 才返回1</span><br><span class="line">    s = f4(f4(x, y), z)</span><br><span class="line">    # f1(x, y) ： x&amp;y</span><br><span class="line">    # f2(x, y) : x|y</span><br><span class="line">    # f1(z, f2(x, y)) : z&amp;(x|y)</span><br><span class="line">    # f2(f1(x, y), f1(z, f2(x, y))) : (x&amp;y)|(z&amp;(x|y)) 当x和y都是1时 或者 z是1 x和y其中一个是1时 返回1</span><br><span class="line">    c = f2(f1(x, y), f1(z, f2(x, y)))</span><br><span class="line">    return (s, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f6(a, b):</span><br><span class="line">    ans = &#x27;&#x27;</span><br><span class="line">    z = &#x27;0&#x27;</span><br><span class="line">    a = a[::-1]   # 将其倒过来</span><br><span class="line">    b = b[::-1]   # 将其倒过来</span><br><span class="line">    for i in range(32):   # 循环32次</span><br><span class="line">        ans += f5(a[i], b[i], z)[0]   # 单个字符</span><br><span class="line">        z = f5(a[i], b[i], z)[1]      # 单个字符</span><br><span class="line"></span><br><span class="line">def f6(a, b):</span><br><span class="line">    ans = &#x27;&#x27;</span><br><span class="line">    z = &#x27;0&#x27;</span><br><span class="line">    a = a[::-1]  # 将其倒过来</span><br><span class="line">    b = b[::-1]  # 将其倒过来</span><br><span class="line">    for i in range(32):  # 循环32次</span><br><span class="line">        ans += ((a[i]^b[i])&amp;(~z))|((~(a[i]^b[i]))&amp;z)  # 单个字符 ((x^y)&amp;(~z))|((~(x^y))&amp;z)</span><br><span class="line">        z = (a[i]&amp;b[i])|(z&amp;(a[i]|b[i]))  # 单个字符</span><br><span class="line">    return ans[::-1]</span><br><span class="line"></span><br><span class="line"># 向左移4位</span><br><span class="line">def f7(a, n):</span><br><span class="line">    return a[n:] + &#x27;0&#x27; * n</span><br><span class="line"></span><br><span class="line"># 向右移5位</span><br><span class="line">def f8(a, n):</span><br><span class="line">    return n * &#x27;0&#x27; + a[:-n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f9(a, b):</span><br><span class="line">    ans = &#x27;&#x27;</span><br><span class="line">    for i in range(32):</span><br><span class="line">        ans += f4(a[i], b[i])   # 逐项比较每一位数，如果相同则加0 如果不同则加1</span><br><span class="line"></span><br><span class="line">    return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f10(v0, v1, k0, k1, k2, k3):</span><br><span class="line">    s = &#x27;00000000000000000000000000000000&#x27;</span><br><span class="line">    d = &#x27;10011110001101110111100110111001&#x27;</span><br><span class="line">    for i in range(32):</span><br><span class="line">        s = f6(s, d)</span><br><span class="line">        # f7(v1, 4) v1&lt;&lt;4    f8(v1, 5) v1&gt;&gt;5</span><br><span class="line">        # f6(v0, f9(f9(f6(v1&lt;&lt;4, k0), f6(v1, s)), f6(v1&gt;&gt;5, k1)))</span><br><span class="line">        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))</span><br><span class="line">        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return v0 + v1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k0 = &#x27;0100010001000101&#x27;.zfill(32)   # 0x4445</span><br><span class="line">k1 = &#x27;0100000101000100&#x27;.zfill(32)   # 0x4144</span><br><span class="line">k2 = &#x27;0100001001000101&#x27;.zfill(32)   # 0x4245</span><br><span class="line">k3 = &#x27;0100010101000110&#x27;.zfill(32)   # 0x4546</span><br><span class="line">flag = input(&#x27;please input flag:&#x27;)</span><br><span class="line">if flag[0:7] != &#x27;SUSCTF&#123;&#x27; or flag[(-1)] != &#x27;&#125;&#x27;:</span><br><span class="line">    print(&#x27;Error!!!The formate of flag is SUSCTF&#123;XXX&#125;&#x27;)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    exit(0)</span><br><span class="line">flagstr = flag[7:-1]</span><br><span class="line">if len(flagstr) != 24:</span><br><span class="line">    print(&#x27;Error!!!The length of flag 24&#x27;)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    exit(0)</span><br><span class="line">else:</span><br><span class="line">    res = &#x27;&#x27;</span><br><span class="line">    # 将这里面的字符串每8个分为一组</span><br><span class="line">    for i in range(0, len(flagstr), 8):</span><br><span class="line">        v0 = flagstr[i:i + 4]</span><br><span class="line">        v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[(i + 1)]))[2:].zfill(8) + bin(ord(flagstr[(i + 2)]))[2:].zfill(8) + bin(ord(flagstr[(i + 3)]))[2:].zfill(8)</span><br><span class="line">        v1 = bin(ord(flagstr[(i + 4)]))[2:].zfill(8) + bin(ord(flagstr[(i + 5)]))[2:].zfill(8) + bin(ord(flagstr[(i + 6)]))[2:].zfill(8) + bin(ord(flagstr[(i + 7)]))[2:].zfill(8)</span><br><span class="line">        res += f10(v0, v1, k0, k1, k2, k3)</span><br><span class="line"></span><br><span class="line">    if res == &#x27;001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111&#x27;:</span><br><span class="line">        print(&#x27;True&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;False&#x27;)</span><br><span class="line">time.sleep(5)</span><br></pre></td></tr></table></figure>

<h3 id="tea算法"><a href="#tea算法" class="headerlink" title="tea算法"></a>tea算法</h3><p>tea 的密钥是：0x4445,0x4144,0x4245,0x4546</p>
<p>最后的加密结果：[0x3e8947cb,0xcc944639,0x31358388,0x3b0b6893,0xda627361,0x3b2e6427]</p>
<p>dalt：0x9e3779b9</p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */</span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v1[3]=&#123;0x3e8947cb,0xcc944639,0x0&#125;,k[4]=&#123;0x4445,0x4144,0x4245,0x4546&#125;;</span><br><span class="line">    uint32_t v2[3]=&#123;0x31358388,0x3b0b6893,0x0&#125;;</span><br><span class="line">    uint32_t v3[3]=&#123;0xda627361,0x3b2e6427&#125;;</span><br><span class="line">    decrypt(v1, k);</span><br><span class="line">    decrypt(v2, k);</span><br><span class="line">    decrypt(v3, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s %s %s\n&quot;,(char*)v1,(char*)v2,(char*)v3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">fvBXQdEa rcbvhBPx cOA8Ag6J</span><br></pre></td></tr></table></figure>

<p>在输入数据的时候：从图中我们可以看到每组字符串中（每4个字符为一组）它将低位的字符放到二进制的高位，所以最后的结果还需要调整字符串的顺序，逆序取出每组数据</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220226130532348.png" alt="image-20220226130532348"></p>
<p>最后的flag是 SUSCTF{XBvfaEdQvbcrxPBh8AOcJ6gA}</p>
<h2 id="hello-word"><a href="#hello-word" class="headerlink" title="hello_word"></a>hello_word</h2><p>这个题目考察vhdl </p>
<h3 id="定位代码"><a href="#定位代码" class="headerlink" title="定位代码"></a>定位代码</h3><p>通过字符串找到一个含有inputflag页面的函数，在里面出现了有vhdl</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220226224203141.png" alt="image-20220226224203141"></p>
<h3 id="VHDL介绍"><a href="#VHDL介绍" class="headerlink" title="VHDL介绍"></a>VHDL介绍</h3><blockquote>
<p>GHDL是一个基于GCC的VHDL语言编译/模拟命令行工具</p>
<p>通过使用代码生成器（<a href="https://llvm.org/">LLVM</a>、<a href="https://gcc.gnu.org/">GCC</a>或仅<a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> / <a href="https://en.wikipedia.org/wiki/Intel_80386">i386</a>，内置的），它比任何解释模拟器都要快得多。它可以处理非常大的设计，例如<a href="https://www.gaisler.com/index.php/downloads/leongrlib">leon3/grlib</a>。</p>
<p>可将波形写入<a href="https://ghdl.github.io/ghdl/using/Simulation.html?highlight=GHW#cmdoption-wave">GHW</a>、<a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD</a>或 FST 文件。结合基于<a href="https://en.wikipedia.org/wiki/Graphical_user_interface">GUI的</a><a href="https://en.wikipedia.org/wiki/Waveform_viewer">波形查看器</a>和良好的文本编辑器，GHDL 是用于<strong>编写、测试和模拟代码</strong>的非常强大的工具。</p>
</blockquote>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220303190451907.png" alt="image-20220303190451907"></p>
<h3 id="状态机介绍"><a href="#状态机介绍" class="headerlink" title="状态机介绍"></a>状态机介绍</h3><p>分析代码这是一个状态机</p>
<blockquote>
<p><strong>有限状态机</strong>（Finite-state machine,FSM）：又称有限状态自动机，简称状态机，是表示有限个状态以及在<strong>这些状态之间的转移和动作等行为的数学模型</strong>。</p>
<p><strong>FSM</strong>：是一种算法思想，简单而言，有限状态机<strong>由一组状态、一个初始状态、输入和根据输入及现有状态转换为下一个状态的转换函数</strong>组成。</p>
<p><strong>六种元素</strong>：起始、终止、现态、次态（目标状态）、动作、条件，我们就可以完成一个状态机图</p>
<p>状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学<a href="https://so.csdn.net/so/search?q=%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">模型</a>。说白了，一般就是指一张状态转换图。</p>
<p>例如：自动门有两个状态，open 和 closed ，closed 状态下，如果读取开门信号，那么状态就会切换为 open 。open 状态下如果读取关门信号，状态就会切换为 closed 。</p>
</blockquote>
<p>能够抽象出来的图：</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304122921881.png" alt="image-20220304122921881">、</p>
<p>状态机的四大概念：</p>
<ul>
<li>第一个是 <strong>State</strong> ，状态。一个状态机至少要<strong>包含两个状态</strong>。例如上面自动门的例子，有 open 和 closed 两个状态。</li>
<li>第二个是 <strong>Event</strong> ，事件。事件就是执行某个操作的触发<strong>条件或者口令</strong>。对于自动门，“按下开门按钮”就是一个事件。</li>
<li>第三个是 <strong>Action</strong> ，动作。事件发生以后要<strong>执行动作</strong>。例如事件是“按开门按钮”，动作是“开门”。编程的时候，一个 Action一般就对应一个函数。</li>
<li>第四个是 <strong>Transition</strong> ，变换。也就是从一个状态<strong>变化</strong>为另一个状态。例如“开门过程”就是一个变换。</li>
</ul>
<h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><p>这道题是被strip了的，下面是对strip概念的解释</p>
<p><strong>strip的作用</strong>：</p>
<p>so文件组成：一个完整的 so 由C代码加一些 debug 信息组成，这些debug信息会记录 so 中所有方法的对照表，就是方法名和其偏移地址的对应表，也叫做符号表。</p>
<p>未strip的so文件：这种既有c代码和debug信息的 so文件就是未 strip 的so文件，通常体积会比较大</p>
<p>strip操作：so 中的debug信息会被剥离，整个 so 的体积也会缩小。</p>
<p>strip操作解说：</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304124408410.png" alt="image-20220304124408410"></p>
<h3 id="逻辑电路"><a href="#逻辑电路" class="headerlink" title="逻辑电路"></a>逻辑电路</h3><p>逻辑电路一般是状态机</p>
<blockquote>
<p>逻辑电路：是指完成逻辑运算的电路。这种电路，一般有<strong>若干个输入端</strong>和<strong>一个 或几个输出端</strong>，当输入信号之间满足某一特定逻辑关系时，电路就开通，有输 出;否则，电路就关闭，无输出。所以，这种电路又叫逻辑门电路，简称门电路。</p>
</blockquote>
<p>这里的case语句展示了这样的逻辑电路的构成</p>
<p>这里考察的是VHDL这个程序</p>
<h3 id="case语句的代码的算法分析"><a href="#case语句的代码的算法分析" class="headerlink" title="case语句的代码的算法分析"></a>case语句的代码的算法分析</h3><h4 id="定位代码-1"><a href="#定位代码-1" class="headerlink" title="定位代码"></a>定位代码</h4><p>首先通过字符串inputflag定位到对应的函数，这是一个switch的循环语句</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304130403296.png" alt="image-20220304130403296"></p>
<p>分析这个switch语句</p>
<h4 id="case1-4"><a href="#case1-4" class="headerlink" title="case1-4"></a>case1-4</h4><p>case1-4不断地跳转，这个地方地代码是对输入地flag的长度赋值</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304130605519.png" alt="image-20220304130605519"></p>
<p>向下跳转到case9的地方</p>
<h4 id="case9模块"><a href="#case9模块" class="headerlink" title="case9模块"></a>case9模块</h4><p>这个地方把输入的值给到vhdl中进行xor模块，然后跳到case10模块</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304132901912.png" alt="image-20220304132901912"></p>
<h4 id="case10模块"><a href="#case10模块" class="headerlink" title="case10模块"></a>case10模块</h4><p>调用vhdl的异或的方法，并且在这里可以知道一个用于异或运算的数组</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133058776.png" alt="image-20220304133058776"></p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133113178.png" alt="image-20220304133113178"></p>
<p>数组是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x56,0xda,0xcd,0x3a,0x7e,0x86,0x13,0xb5,0x1d,0x9d,0xfc,0x97,0x8c,0x31,0x6b,0xc9,0xfb,0x1a,0xe2,0x2d,0xdc,0xd3,0xf1,0xf4,0x36,0x09,0x20,0x42,0x04,0x6a,0x71,0x53,0x78,0xa4,0x97,0x8f,0x7a,0x72,0x39,0xe8,0x3d,0xfa,0x40,0x3d,0x98,0x01]</span><br></pre></td></tr></table></figure>

<h4 id="case11"><a href="#case11" class="headerlink" title="case11"></a>case11</h4><p>将异或的结果和最后的答案对比</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133511919.png" alt="image-20220304133511919"></p>
<p>对比使用的数组：</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133538057.png" alt="image-20220304133538057"></p>
<p>数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x05,0x8f,0x9e,0x79,0x2a,0xc0,0x68,0x81,0x2d,0xfc,0xcf,0xa4,0xb5,0x55,0x5f,0xe4,0x9d,0x23,0xd6,0x1d,0xf1,0xe7,0x97,0x91,0x06,0x24,0x42,0x71,0x3c,0x58,0x5c,0x30,0x19,0xc6,0xf5,0xbc,0x4b,0x42,0x5d,0xda,0x58,0x9b,0x24,0x40]</span><br></pre></td></tr></table></figure>

<h4 id="case-5模块"><a href="#case-5模块" class="headerlink" title="case 5模块"></a>case 5模块</h4><p>通过表示正确字符个数的correct判断最后的结果，错误就跳转到wrong的case5这个模块</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304134147758.png" alt="image-20220304134147758"></p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj1 = [0x05,0x8f,0x9e,0x79,0x2a,0xc0,0x68,0x81,0x2d,0xfc,0xcf,0xa4,0xb5,0x55,0x5f,0xe4,0x9d,0x23,0xd6,0x1d,0xf1,0xe7,0x97,0x91,0x06,0x24,0x42,0x71,0x3c,0x58,0x5c,0x30,0x19,0xc6,0xf5,0xbc,0x4b,0x42,0x5d,0xda,0x58,0x9b,0x24,0x40]</span><br><span class="line">obj2=[0x56,0xda,0xcd,0x3a,0x7e,0x86,0x13,0xb5,0x1d,0x9d,0xfc,0x97,0x8c,0x31,0x6b,0xc9,0xfb,0x1a,0xe2,0x2d,0xdc,0xd3,0xf1,0xf4,0x36,0x09,0x20,0x42,0x04,0x6a,0x71,0x53,0x78,0xa4,0x97,0x8f,0x7a,0x72,0x39,0xe8,0x3d,0xfa,0x40,0x3d,0x98,0x01]</span><br><span class="line">for i in range(len(obj1)):</span><br><span class="line">  print(chr(obj1[i]^obj2[i]),end=&#x27;&#x27;)</span><br><span class="line">  SUSCTF&#123;40a339d4-f940-4fe0-b382-cabb310d2ead&#125;</span><br></pre></td></tr></table></figure>

<p>所以最后的flag是 SUSCTF{40a339d4-f940-4fe0-b382-cabb310d2ead}</p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>susctf</tag>
      </tags>
  </entry>
  <entry>
    <title>frida+d3mug复现</title>
    <url>/2022/03/17/frida-d3mug%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="FRIDA-API使用篇"><a href="#FRIDA-API使用篇" class="headerlink" title="FRIDA-API使用篇"></a>FRIDA-API使用篇</h1><p>frida中有五种对象，分别是Java、Interceptor、NativePointer、NativeFunction、NativeCallback对象</p>
<p>这些都是在编写frida脚本的时候会用到的对象以及对应的函数。</p>
<p>frida知识更多的学习，可以查看<a href="https://www.anquanke.com/member.html?memberId=131652">这些文章</a></p>
<h2 id="Java对象"><a href="#Java对象" class="headerlink" title="Java对象"></a>Java对象</h2><p>无论是想对<code>so</code>层亦或java层进行拦截，都必须编写<code>Java.perform</code>，java对象是很重要的</p>
<h3 id="附加调用Java-perform"><a href="#附加调用Java-perform" class="headerlink" title="附加调用Java.perform"></a>附加调用Java.perform</h3><p><code>Java.perform（fn）</code>主要用于<strong>当前线程附加到<code>Java VM</code><strong>并且</strong>调用<code>fn</code>方法</strong>。该API是非常重要的</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unction frida_Java() &#123;</span><br><span class="line">    //运行当前js脚本时会对当前线程附加到Java VM虚拟机，并且执行function方法</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        //判断是否Java VM正常运行</span><br><span class="line">        if(Java.available)</span><br><span class="line">        &#123;</span><br><span class="line">            //如不意外会直接输出 hello</span><br><span class="line">            console.log(&quot;hello&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;       </span><br><span class="line">setImmediate(frida_Java,0);</span><br><span class="line"></span><br><span class="line">输出如下。</span><br><span class="line">[Google Pixel::com.roysue.roysueapplication]-&gt; hello</span><br></pre></td></tr></table></figure>

<h3 id="判断加载Java-available"><a href="#判断加载Java-available" class="headerlink" title="判断加载Java.available"></a>判断加载Java.available</h3><p>该函数一般用来<strong>判断</strong>当前进程是否加载了**<code>JavaVM，Dalvik</code>或<code>ART</code>虚拟机**</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function frida_Java() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        //作为判断用</span><br><span class="line">        if(Java.available)</span><br><span class="line">        &#123;</span><br><span class="line">            //注入的逻辑代码</span><br><span class="line">            console.log(&quot;hello java vm&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //未能正常加载JAVA VM</span><br><span class="line">            console.log(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;       </span><br><span class="line">setImmediate(frida_Java,0);</span><br><span class="line"></span><br><span class="line">输出如下。</span><br><span class="line">hello java vm</span><br></pre></td></tr></table></figure>

<h3 id="版本号Java-androidVersion"><a href="#版本号Java-androidVersion" class="headerlink" title="版本号Java.androidVersion"></a>版本号Java.androidVersion</h3><p>显示<strong>android系统版本号</strong></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function frida_Java() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        //作为判断用</span><br><span class="line">        if(Java.available)</span><br><span class="line">        &#123;</span><br><span class="line">            //注入的逻辑代码</span><br><span class="line">            console.log(&quot;&quot;,Java.androidVersion);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //未能正常加载JAVA VM</span><br><span class="line">            console.log(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;       </span><br><span class="line">setImmediate(frida_Java,0);</span><br></pre></td></tr></table></figure>

<h3 id="获取类Java-use"><a href="#获取类Java-use" class="headerlink" title="获取类Java.use"></a>获取类Java.use</h3><p><code>Java.use(className)，</code>动态获取<code>className</code>的类定义，通过对其调用<code>$new()</code>来调用构造函数，可以从中<strong>实例化对象</strong>。当想要<strong>回收类</strong>时可以调用<code>$Dispose()</code>方法显式释放，当然也可以等待<code>JavaScript</code>的垃圾回收机制，当实例化一个对象之后，可以通过其<strong>实例对象调用类中的静态或非静态的方法</strong></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">  //获取android.app.Activity类</span><br><span class="line">  var Activity = Java.use(&#x27;android.app.Activity&#x27;);</span><br><span class="line">  //获取java.lang.Exception类</span><br><span class="line">  var Exception = Java.use(&#x27;java.lang.Exception&#x27;);</span><br><span class="line">  //拦截Activity类的onResume方法</span><br><span class="line">  Activity.onResume.implementation = function () &#123;</span><br><span class="line">    //调用onResume方法的时候，会在此处被拦截并且调用以下代码抛出异常！</span><br><span class="line">    throw Exception.$new(&#x27;Oh noes!&#x27;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="枚举类Java-enumerateLoadedClasses"><a href="#枚举类Java-enumerateLoadedClasses" class="headerlink" title="枚举类Java.enumerateLoadedClasses"></a>枚举类Java.enumerateLoadedClasses</h3><p>该API枚举当前<strong>加载的所有类信息</strong>，它有一个<strong>回调函数</strong>分别是<code>onMatch、onComplete</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function frida_Java() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        if(Java.available)</span><br><span class="line">        &#123;</span><br><span class="line">            //console.log(&quot;&quot;,Java.androidVersion);</span><br><span class="line">            //枚举当前加载的所有类</span><br><span class="line">            Java.enumerateLoadedClasses(&#123;</span><br><span class="line">                //每一次回调此函数时其参数className就是类的信息</span><br><span class="line">                onMatch: function (className)</span><br><span class="line">                &#123;</span><br><span class="line">                    //输出类字符串</span><br><span class="line">                    console.log(&quot;&quot;,className);</span><br><span class="line">                &#125;,</span><br><span class="line">                //枚举完毕所有类之后的回调函数</span><br><span class="line">                onComplete: function ()</span><br><span class="line">                &#123;</span><br><span class="line">                    //输出类字符串</span><br><span class="line">                    console.log(&quot;输出完毕&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;       </span><br><span class="line">setImmediate(frida_Java,0);</span><br></pre></td></tr></table></figure>

<h3 id="扫描实例类Java-choose"><a href="#扫描实例类Java-choose" class="headerlink" title="扫描实例类Java.choose"></a>扫描实例类Java.choose</h3><p>在堆上查找实例化的对象，实例化对象的意思就是用这个类创建的一个对象（如同人这个类中的叫小明的这个人）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">    //查找android.view.View类在堆上的实例化对象</span><br><span class="line">    Java.choose(&quot;android.view.View&quot;, &#123;</span><br><span class="line">        //枚举时调用</span><br><span class="line">        onMatch:function(instance)&#123;</span><br><span class="line">            //打印实例</span><br><span class="line">            console.log(instance);</span><br><span class="line">        &#125;,</span><br><span class="line">        //枚举完成后调用</span><br><span class="line">        onComplete:function() &#123;</span><br><span class="line">            console.log(&quot;end&quot;)</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">android.view.View&#123;2292774 V.ED..... ......ID 0,1794-1080,1920 #1020030 android:id/navigationBarBackground&#125;</span><br><span class="line">android.view.View&#123;d43549d V.ED..... ......ID 0,0-1080,63 #102002f android:id/statusBarBackground&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="类型转换器Java-cast"><a href="#类型转换器Java-cast" class="headerlink" title="类型转换器Java.cast"></a>类型转换器Java.cast</h3><p>使用 <code>Java.cast(object,Class)</code> 可以转换一个对象的类型。通常在拦截<code>so</code>层时会使用此函数将<code>jstring、jarray</code>等等转换之后查看其值。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">performNow</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Student</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.example.myapplication.Student&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> student = <span class="title class_">Student</span>.$new(<span class="string">&#x27;田所浩二&#x27;</span>,<span class="number">24</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">class</span>);</span><br><span class="line">  <span class="comment">//将Student类对象强制转化成Object类对象</span></span><br><span class="line">  student = <span class="title class_">Java</span>.<span class="title function_">cast</span>(student,<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">class</span>);</span><br><span class="line">  <span class="comment">//将上面强制转换成的Object类对象转换成Student类对象</span></span><br><span class="line">  student = <span class="title class_">Java</span>.<span class="title function_">cast</span>(student,<span class="title class_">Student</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">class</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="定义任意数组类型Java-array"><a href="#定义任意数组类型Java-array" class="headerlink" title="定义任意数组类型Java.array"></a>定义任意数组类型Java.array</h3><p>frida提供了<strong>在js代码</strong>中定义<strong>java数组</strong>的api，该数组可以用于传递给java API。定义格式为<code>Java.array(&#39;type&#39;,[value1,value2,....]);</code></p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//定义一个int数组、值是1003, 1005, 1007</span></span><br><span class="line">        <span class="keyword">var</span> intarr = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&#x27;int&#x27;</span>, [ <span class="number">1003</span>, <span class="number">1005</span>, <span class="number">1007</span> ]);</span><br><span class="line">        <span class="comment">//定义一个byte数组、值是0x48, 0x65, 0x69</span></span><br><span class="line">        <span class="keyword">var</span> bytearr = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&#x27;byte&#x27;</span>, [ <span class="number">0x48</span>, <span class="number">0x65</span>, <span class="number">0x69</span> ]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;bytearr.<span class="property">length</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出每个byte元素</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(bytearr[i])</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Java-vm对象"><a href="#Java-vm对象" class="headerlink" title="Java.vm对象"></a>Java.vm对象</h3><p>Java.vm对象十分常用，比如想要拿到<strong>JNI层的JNIEnv对象</strong>，可以使用**getEnv()**。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function frida_Java() &#123;     </span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">         //拦截getStr函数</span><br><span class="line">         Interceptor.attach(Module.findExportByName(&quot;libhello.so&quot; , &quot;Java_com_roysue_roysueapplication_hellojni_getStr&quot;), &#123;</span><br><span class="line">            onEnter: function(args) &#123;</span><br><span class="line">                console.log(&quot;getStr&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave:function(retval)&#123;</span><br><span class="line">                //它的返回值的是retval 在jni层getStr的返回值的jstring </span><br><span class="line">                //我们在这里做的事情就是替换掉结果</span><br><span class="line">                //先获取一个Env对象</span><br><span class="line">                var env = Java.vm.getEnv();</span><br><span class="line">                //通过newStringUtf方法构建一个jstirng字符串</span><br><span class="line">                var jstring = env.newStringUtf(&#x27;roysue&#x27;);</span><br><span class="line">                //replace替换掉结果</span><br><span class="line">                retval.replace(jstring);</span><br><span class="line">                console.log(&quot;getSum方法返回值为:roysue&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(frida_Java,0);</span><br></pre></td></tr></table></figure>

<h2 id="Interceptor对象"><a href="#Interceptor对象" class="headerlink" title="Interceptor对象"></a>Interceptor对象</h2><p>函数原型是**Interceptor.attach(target, callbacks)**：</p>
<p><strong>target参数</strong>：是需要拦截的位置的<strong>函数地址</strong>，也就是填某个**<code>so</code>层函数的地址<strong>即可对其拦截，<code>target</code>是一个</strong><code>NativePointer</code>参数**，用来指定你想要拦截的函数的地址，<code>NativePointer</code>是一个指针（下面有对NativePointer的说明）；对于<code>Thumb</code>函数需要对函数地址<code>+1</code></p>
<p><strong>callbacks参数</strong>：它的回调函数，有两个onEnter: function (args) 和 onLeave: function (retval)函数</p>
<h3 id="Interceptor-attach"><a href="#Interceptor-attach" class="headerlink" title="Interceptor.attach"></a>Interceptor.attach</h3><p><strong>两个回调函数</strong>：</p>
<ul>
<li><p><code>onEnter：</code>函数（<code>args</code>）：回调函数，给定一个参数<code>args</code>，可用于读取或写入参数作为 <code>NativePointer</code> 对象的数组。</p>
</li>
<li><p><code>onLeave：</code>函数（<code>retval</code>）：回调函数给定一个参数 <code>retval</code>，该参数是包含原始返回值的 <code>NativePointer</code> 派生对象。可以调用 <code>retval.replace（1337）</code> 以整数 <code>1337</code> 替换返回值，或者调用 <code>retval.replace（ptr（&quot;0x1234&quot;））</code>以替换为指针。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用Module对象getExportByNameAPI直接获取libc.so中的导出函数read的地址，对read函数进行附加拦截</span><br><span class="line">Interceptor.attach(Module.getExportByName(&#x27;libc.so&#x27;, &#x27;read&#x27;), &#123;</span><br><span class="line">  //每次read函数调用的时候会执行onEnter回调函数</span><br><span class="line">  onEnter: function (args) &#123;</span><br><span class="line">    this.fileDescriptor = args[0].toInt32();</span><br><span class="line">  &#125;,</span><br><span class="line">  //read函数执行完成之后会执行onLeave回调函数</span><br><span class="line">  onLeave: function (retval) &#123;</span><br><span class="line">    if (retval.toInt32() &gt; 0) &#123;</span><br><span class="line">      /* do something with this.fileDescriptor */</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Interceptor.attach函数的一些属性</strong>：</p>
<ul>
<li><table>
<thead>
<tr>
<th>returnAddress</th>
<th>返回地址，类型是<code>NativePointer</code></th>
</tr>
</thead>
<tbody><tr>
<td>threadId</td>
<td>操作系统线程ID</td>
</tr>
<tr>
<td>context</td>
<td>上下文：具有键<code>pc</code>和<code>sp</code>的对象，它们是分别为<code>ia32/x64/arm</code>指定<code>EIP/RIP/PC</code>和<code>ESP/RSP/SP的NativePointer</code>对象。其他处理器特定的键也可用，例如<code>eax、rax、r0、x0</code>等。也可以通过分配给这些键来更新寄存器值。</td>
</tr>
<tr>
<td>errno</td>
<td>当前<code>errno</code>值</td>
</tr>
<tr>
<td>lastError</td>
<td>当前操作系统错误值</td>
</tr>
<tr>
<td>depth</td>
<td>相对于其他调用的调用深度</td>
</tr>
</tbody></table>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Interceptor.attach(Module.findExportByName(&quot;libhello.so&quot; , &quot;Java_com_roysue_roysueapplication_hellojni_getSum&quot;), &#123;</span><br><span class="line">            onEnter: function(args) &#123;</span><br><span class="line">                //输出</span><br><span class="line">                console.log(&#x27;Context information:&#x27;);</span><br><span class="line">                //输出上下文因其是一个Objection对象，需要它进行接送、转换才能正常看到值</span><br><span class="line">                console.log(&#x27;Context  : &#x27; + JSON.stringify(this.context));</span><br><span class="line">                //输出返回地址</span><br><span class="line">                console.log(&#x27;Return   : &#x27; + this.returnAddress);</span><br><span class="line">                //输出线程id</span><br><span class="line">                console.log(&#x27;ThreadId : &#x27; + this.threadId);</span><br><span class="line">                console.log(&#x27;Depth    : &#x27; + this.depth);</span><br><span class="line">                console.log(&#x27;Errornr  : &#x27; + this.err);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave:function(retval)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Interceptor-detachAll"><a href="#Interceptor-detachAll" class="headerlink" title="Interceptor.detachAll"></a>Interceptor.detachAll</h3><p>简单来说这个的函数的作用就是让之前所有的<code>Interceptor.attach</code>附加拦截的回调函数失效</p>
<h3 id="Interceptor-replace"><a href="#Interceptor-replace" class="headerlink" title="Interceptor.replace"></a>Interceptor.replace</h3><p>相当于<strong>替换掉原本的函数</strong>，用替换时的实现替换目标处的函数。如果想要完全或部分替换现有函数的实现，则通常使用此函数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function frida_Interceptor() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">       //这个c_getSum方法有两个int参数、返回结果为两个参数相加</span><br><span class="line">       //这里用NativeFunction函数自己定义了一个c_getSum函数</span><br><span class="line">       var add_method = new NativeFunction(Module.findExportByName(&#x27;libhello.so&#x27;, &#x27;c_getSum&#x27;), </span><br><span class="line">       &#x27;int&#x27;,[&#x27;int&#x27;,&#x27;int&#x27;]);</span><br><span class="line">       //输出结果 那结果肯定就是 3</span><br><span class="line">       console.log(&quot;result:&quot;,add_method(1,2));</span><br><span class="line">       //这里对原函数的功能进行替换实现</span><br><span class="line">       Interceptor.replace(add_method, new NativeCallback(function (a, b) &#123;</span><br><span class="line">           //h不论是什么参数都返回123</span><br><span class="line">            return 123;</span><br><span class="line">       &#125;, &#x27;int&#x27;, [&#x27;int&#x27;, &#x27;int&#x27;]));</span><br><span class="line">       //再次调用 则返回123</span><br><span class="line">       console.log(&quot;result:&quot;,add_method(1,2));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NativePointer对象"><a href="#NativePointer对象" class="headerlink" title="NativePointer对象"></a>NativePointer对象</h2><p>同等与C语言中的指针</p>
<h3 id="new-NativePointer-s"><a href="#new-NativePointer-s" class="headerlink" title="new NativePointer(s)"></a>new NativePointer(s)</h3><p>声明定义NativePointer类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ptr1 = new NativePointer(&quot;100&quot;);</span><br><span class="line">console.log(&quot;ptr1:&quot;,ptr1);</span><br></pre></td></tr></table></figure>

<h3 id="运算符以及指针读写API"><a href="#运算符以及指针读写API" class="headerlink" title="运算符以及指针读写API"></a>运算符以及指针读写API</h3><p>这里有个表，可以用这个指针对这些API进行调用</p>
<p><img src="https://p3.ssl.qhimg.com/t0135a7319c873d8d52.png" alt="img"></p>
<p><img src="https://p3.ssl.qhimg.com/t01821e14d1331f0aef.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用readByteArray函数来读取libc.so文件在内存中的数据</span><br><span class="line">var pointer = Process.findModuleByName(&quot;libc.so&quot;).base;</span><br><span class="line">//读取从pointer地址开始的16个字节 (从libc文件读取0x10个字节的长度)</span><br><span class="line">console.log(pointer.readByteArray(0x10));</span><br></pre></td></tr></table></figure>

<p>上面这些API的调用的部分示例可以查看<a href="https://www.anquanke.com/post/id/195869#h2-13">这篇文章</a>中的NativePointer对象这个部分</p>
<h2 id="NativeFunction对象"><a href="#NativeFunction对象" class="headerlink" title="NativeFunction对象"></a>NativeFunction对象</h2><p>作用：调用<code>address</code>处的函数(用<code>NativePointer</code>指定)</p>
<p>函数定义格式：new NativeFunction(address, returnType, argTypes[, options])</p>
<ul>
<li><strong>returnType和argTypes[，]中能够填写的数据类型</strong>：void、pointer、int、uint、long、ulong、char、uchar、float、double、int8、uint8、int16、uint16、int32、uint32、int64、uint64这些类型。假设有<strong>三个参数</strong>都是<code>int</code>，则<strong>new NativeFunction(address, returnType, [‘int’, ‘int’, ‘int’])</strong></li>
<li>定义的时候必须要将<strong>参数类型个数</strong>和<strong>参数类型</strong>以及<strong>返回值</strong>完全匹配。</li>
<li>并且第一个参数一定要是<strong>函数地址指针</strong></li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// LargeObject HandyClass::friendlyFunctionName();</span><br><span class="line">//创建friendlyFunctionPtr地址的函数</span><br><span class="line">var friendlyFunctionName = new NativeFunction(friendlyFunctionPtr,</span><br><span class="line">    &#x27;void&#x27;, [&#x27;pointer&#x27;, &#x27;pointer&#x27;]);</span><br><span class="line">//申请内存空间    </span><br><span class="line">var returnValue = Memory.alloc(sizeOfLargeObject);</span><br><span class="line">//调用friendlyFunctionName函数</span><br><span class="line">friendlyFunctionName(returnValue, thisPtr);</span><br></pre></td></tr></table></figure>

<h2 id="NativeCallback对象"><a href="#NativeCallback对象" class="headerlink" title="NativeCallback对象"></a>NativeCallback对象</h2><p>作用：创建一个回调函数</p>
<p>函数定义格式：new NativeCallback(func，rereturn Type，argTypes[，ABI])</p>
<ul>
<li>func参数：由JavaScript函数实现的函数</li>
<li><code>rereturn Type</code>指定返回类型，<code>argTypes</code>数组指定参数类型</li>
</ul>
<p>当将产生的回调与<code>Interceptor.replace()</code>一起使用时，将调用func，并将其绑定到具有一些有用属性的对象，就像<code>Interceptor.Attach()</code>中的那样</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//替换对象的函数指针</span></span><br><span class="line">   <span class="keyword">var</span> add_method = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(<span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&#x27;libhello.so&#x27;</span>, <span class="string">&#x27;c_getSum&#x27;</span>), </span><br><span class="line">   <span class="string">&#x27;int&#x27;</span>,[<span class="string">&#x27;int&#x27;</span>,<span class="string">&#x27;int&#x27;</span>]);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;result:&quot;</span>,<span class="title function_">add_method</span>(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">   <span class="comment">//在这里new一个新的函数，但是参数的个数和返回值必须对应</span></span><br><span class="line">   <span class="title class_">Interceptor</span>.<span class="title function_">replace</span>(add_method, <span class="keyword">new</span> <span class="title class_">NativeCallback</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">   &#125;, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>]));</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;result:&quot;</span>,<span class="title function_">add_method</span>(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用java.perform()中写入js脚本</p>
<p>使用Module对象获得一些so文件的地址信息</p>
<p>利用so文件的地址信息使用NativeFunction 得到so文件之中的对象，再使用Interceptor对象的API，对相应的函数进行一定的操作</p>
<p>运行这个函数，设置这个函数的输入的参数，设置这个函数的返回的参数</p>
<h1 id="FRIDA-API使用篇：rpc、Process、Module、Memory"><a href="#FRIDA-API使用篇：rpc、Process、Module、Memory" class="headerlink" title="FRIDA-API使用篇：rpc、Process、Module、Memory"></a>FRIDA-API使用篇：rpc、Process、Module、Memory</h1><p>这里对frida官方的一些非常常用的<code>API</code>进行介绍</p>
<h2 id="FRIDA输出打印"><a href="#FRIDA输出打印" class="headerlink" title="FRIDA输出打印"></a>FRIDA输出打印</h2><p>在官方API有两种打印的方式，分别是<code>console</code>、<code>send</code></p>
<h3 id="console输出"><a href="#console输出" class="headerlink" title="console输出"></a>console输出</h3><p>在<code>FRIDA</code>的<code>console</code>中有三个级别分别是<code>log、warn、error</code>。一般在使用中我们只会使用<code>log</code>来输出想看的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello_printf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello-log&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;hello-warn&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;hello-error&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(hello_printf,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="console之hexdump"><a href="#console之hexdump" class="headerlink" title="console之hexdump"></a>console之hexdump</h4><p>hexdump的含义:<strong>打印内存中的地址</strong>，target参数可以是<strong>ArrayBuffer</strong>或者<strong>NativePointer</strong>,而<strong>options参数</strong>则是自定义输出格式可以填这几个参数offset、lengt、header、ansi</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> libc = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&#x27;libc.so&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(libc, &#123;</span><br><span class="line">  <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">64</span>,</span><br><span class="line">  <span class="attr">header</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">ansi</span>: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>执行效果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">00000000  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............</span><br><span class="line">00000010  03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00  ..(.........4...</span><br><span class="line">00000020  34 a8 04 00 00 00 00 05 34 00 20 00 08 00 28 00  4.......4. ...(.</span><br><span class="line">00000030  1e 00 1d 00 06 00 00 00 34 00 00 00 34 00 00 00  ........4...4...</span><br></pre></td></tr></table></figure>

<h3 id="send"><a href="#send" class="headerlink" title="send"></a><strong>send</strong></h3><p>原理：send是在<strong>python层</strong>定义的<strong>on_message回调函数</strong>，jscode内所有的信息都被监控<strong>script.on(‘message’, on_message)<strong>，当</strong>输出信息</strong>的时候on_message函数会拿到其数据再通过format转换、</p>
<p>输出效果：能够直接将数据以**<code>json</code>格式**输出，当然数据是二进制的时候也依然是可以使用<code>send</code></p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">def <span class="title function_">on_message</span>(message, data):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="title function_">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="attr">else</span>:</span><br><span class="line">        <span class="title function_">print</span>(message)</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    Java.perform(function () </span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        var jni_env = Java.vm.getEnv();</span></span><br><span class="line"><span class="string">        console.log(jni_env);</span></span><br><span class="line"><span class="string">        send(jni_env);</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string"> &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">process = frida.<span class="title function_">get_usb_device</span>().<span class="title function_">attach</span>(<span class="string">&#x27;com.roysue.roysueapplication&#x27;</span>)</span><br><span class="line">script = process.<span class="title function_">create_script</span>(jscode)</span><br><span class="line">script.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">script.<span class="title function_">load</span>()</span><br><span class="line">sys.<span class="property">stdin</span>.<span class="title function_">read</span>()</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roysue@ubuntu:~/Desktop/Chap09$ python Chap03.py </span><br><span class="line">[object Object]</span><br><span class="line">[*] &#123;&#x27;handle&#x27;: &#x27;0xdf4f8000&#x27;, &#x27;vm&#x27;: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FRIDA变量类型"><a href="#FRIDA变量类型" class="headerlink" title="FRIDA变量类型"></a>FRIDA变量类型</h2><p>在脚本之中如何声明变量类型。以及<code>frida</code>为<code>Int64(v)</code>提供了一些相关的API的使用</p>
<h3 id="声明变量类型"><a href="#声明变量类型" class="headerlink" title="声明变量类型"></a>声明变量类型</h3><table>
<thead>
<tr>
<th>索引</th>
<th>API</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>new Int64(v)</td>
<td>定义一个有符号Int64类型的变量值为v，参数v可以是字符串或者以0x开头的的十六进制值</td>
</tr>
<tr>
<td>2</td>
<td>new UInt64(v)</td>
<td>定义一个无符号Int64类型的变量值为v，参数v可以是字符串或者以0x开头的的十六进制值</td>
</tr>
<tr>
<td>3</td>
<td>new NativePointer(s)</td>
<td>定义一个指针，指针地址为s</td>
</tr>
<tr>
<td>4</td>
<td>ptr(“0”)</td>
<td>同上</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new Int64(1):&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new UInt64(1):&quot;</span>+<span class="keyword">new</span> <span class="title class_">UInt64</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new NativePointer(0xEC644071):&quot;</span>+<span class="keyword">new</span> <span class="title class_">NativePointer</span>(<span class="number">0xEC644071</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new ptr(&#x27;0xEC644071&#x27;):&quot;</span>+<span class="keyword">new</span> <span class="title function_">ptr</span>(<span class="number">0xEC644071</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Int64-v-使用的API"><a href="#Int64-v-使用的API" class="headerlink" title="Int64(v)使用的API"></a>Int64(v)使用的API</h3><table>
<thead>
<tr>
<th>索引</th>
<th>API</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>add(rhs)、sub(rhs)、and(rhs)、or(rhs)、xor(rhs)</td>
<td>加、减、逻辑运算</td>
</tr>
<tr>
<td>2</td>
<td>shr(N)、shl(n)</td>
<td>向右/向左移位n位生成新的Int64</td>
</tr>
<tr>
<td>3</td>
<td>Compare(Rhs)</td>
<td>返回整数比较结果</td>
</tr>
<tr>
<td>4</td>
<td>toNumber()</td>
<td>转换为数字</td>
</tr>
<tr>
<td>5</td>
<td>toString([radix=10])</td>
<td>转换为可选基数的字符串(默认为10)</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello_type</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//8888 + 1 = 8889</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8888 + 1:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="string">&quot;8888&quot;</span>).<span class="title function_">add</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//8888 - 1 = 8887</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8888 - 1:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="string">&quot;8888&quot;</span>).<span class="title function_">sub</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//8888 &lt;&lt; 1 = 4444</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8888 &lt;&lt; 1:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="string">&quot;8888&quot;</span>).<span class="title function_">shr</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//8888 == 22 = 1 1是false</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8888 == 22:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="string">&quot;8888&quot;</span>).<span class="title function_">compare</span>(<span class="number">22</span>));</span><br><span class="line">        <span class="comment">//转string</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8888 toString:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="string">&quot;8888&quot;</span>).<span class="title function_">toString</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Process对象"><a href="#Process对象" class="headerlink" title="Process对象"></a>Process对象</h2><p>介绍以及使用一些<code>Process</code>对象中比较常用的<code>api</code></p>
<h3 id="Process-id"><a href="#Process-id" class="headerlink" title="Process.id"></a>Process.id</h3><p>Process.id：返回附加<strong>目标进程的PID</strong></p>
<h3 id="Process-isDebuggerAttached"><a href="#Process-isDebuggerAttached" class="headerlink" title="Process.isDebuggerAttached()"></a>Process.isDebuggerAttached()</h3><p><strong>检测</strong>当前是否对目标程序已经附加</p>
<h3 id="Process-enumerateModules"><a href="#Process-enumerateModules" class="headerlink" title="Process.enumerateModules()"></a>Process.enumerateModules()</h3><p><strong>枚举</strong>当前加载的<strong>模块</strong>，返回模块对象的数组。会枚举当前所有已加载的<code>so</code>模块，并且返回了数组<code>Module</code>对象。</p>
<p>枚举得到的每个module对象，再使用每个module对象进行操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">frida_Process</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> process_Obj_Module_Arr = <span class="title class_">Process</span>.<span class="title function_">enumerateModules</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; process_Obj_Module_Arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span>,process_Obj_Module_Arr[i].<span class="property">name</span>);<span class="comment">//这里使用了module的name属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(frida_Process,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Process-enumerateThreads"><a href="#Process-enumerateThreads" class="headerlink" title="Process.enumerateThreads()"></a>Process.enumerateThreads()</h3><p>枚举当前所有的线程，返回包含以下属性的对象数组：</p>
<table>
<thead>
<tr>
<th align="left">索引</th>
<th align="left">属性</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">id</td>
<td align="left">线程id</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">state</td>
<td align="left">当前运行状态有running, stopped, waiting, uninterruptible or halted</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">context</td>
<td align="left">带有键pc和sp的对象，它们是分别为ia32/x64/arm指定EIP/RIP/PC和ESP/RSP/SP的NativePointer对象。也可以使用其他处理器特定的密钥，例如eax、rax、r0、x0等。</td>
</tr>
</tbody></table>
<h3 id="Process-getCurrentThreadId"><a href="#Process-getCurrentThreadId" class="headerlink" title="Process.getCurrentThreadId()"></a>Process.getCurrentThreadId()</h3><p>获取此线程的操作系统特定 <code>ID</code> 作为数字</p>
<h2 id="Module对象"><a href="#Module对象" class="headerlink" title="Module对象"></a>Module对象</h2><p>获得程序中函数 类等的一些信息的时候（基地址，偏移地址等）就会用到这个对象</p>
<h3 id="Module对象的属性"><a href="#Module对象的属性" class="headerlink" title="Module对象的属性"></a>Module对象的属性</h3><table>
<thead>
<tr>
<th>索引</th>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>name</td>
<td>模块名称</td>
</tr>
<tr>
<td>2</td>
<td>base</td>
<td>模块地址，其变量类型为NativePointer</td>
</tr>
<tr>
<td>3</td>
<td>size</td>
<td>大小</td>
</tr>
<tr>
<td>4</td>
<td>path</td>
<td>完整文件系统路径</td>
</tr>
</tbody></table>
<h3 id="Module对象的API"><a href="#Module对象的API" class="headerlink" title="Module对象的API"></a>Module对象的API</h3><table>
<thead>
<tr>
<th>索引</th>
<th>API</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Module.load()</td>
<td>加载指定so文件，返回一个Module对象</td>
</tr>
<tr>
<td>2</td>
<td>enumerateImports()</td>
<td>枚举所有Import库函数，返回Module数组对象</td>
</tr>
<tr>
<td>3</td>
<td>enumerateExports()</td>
<td>枚举所有Export库函数，返回Module数组对象</td>
</tr>
<tr>
<td>4</td>
<td>enumerateSymbols()</td>
<td>枚举所有Symbol库函数，返回Module数组对象</td>
</tr>
<tr>
<td>5</td>
<td>Module.findExportByName(exportName)、Module.getExportByName(exportName)</td>
<td>寻找指定so中export库中的函数地址</td>
</tr>
<tr>
<td>6</td>
<td>Module.findBaseAddress(name)、Module.getBaseAddress(name)</td>
<td>返回so的基地址</td>
</tr>
</tbody></table>
<h3 id="enumerateImports"><a href="#enumerateImports" class="headerlink" title="enumerateImports()"></a>enumerateImports()</h3><p>该API会枚举模块中所有中的所有Import函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hooks = Module.load(&#x27;libhello.so&#x27;);</span><br><span class="line">var Imports = hooks.enumerateImports();//再遍历这个得到的枚举数组</span><br></pre></td></tr></table></figure>

<h3 id="enumerateExports"><a href="#enumerateExports" class="headerlink" title="enumerateExports()"></a>enumerateExports()</h3><p>该API会枚举模块中所有中的所有<code>Export</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hooks = Module.load(&#x27;libhello.so&#x27;);</span><br><span class="line">var Exports = hooks.enumerateExports();</span><br></pre></td></tr></table></figure>

<h3 id="enumerateSymbols"><a href="#enumerateSymbols" class="headerlink" title="enumerateSymbols()"></a>enumerateSymbols()</h3><p>该API会枚举模块中所有中的所有symbols 符号，使用symbols 符号可以定位native方法。返回的是一个数组对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hooks = Module.load(&#x27;libc.so&#x27;);</span><br><span class="line">var Symbol = hooks.enumerateSymbols();</span><br></pre></td></tr></table></figure>

<h3 id="Module-findExportByName-exportName-Module-getExportByName-exportName"><a href="#Module-findExportByName-exportName-Module-getExportByName-exportName" class="headerlink" title="Module.findExportByName(exportName), Module.getExportByName(exportName)"></a>Module.findExportByName(exportName), Module.getExportByName(exportName)</h3><p>返回<code>so</code>文件中<code>Export</code>函数库中函数名称为**<code>exportName</code>函数<strong>的</strong>绝对地址**</p>
<p>这个方法只适用于Export函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&#x27;libhello.so&#x27;</span>, <span class="string">&#x27;c_getStr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Java_com_roysue_roysueapplication_hellojni_getStraddress:&quot;</span>,<span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&#x27;libhello.so&#x27;</span>, <span class="string">&#x27;Java_com_roysue_roysueapplication_hellojni_getStr&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Java_com_roysue_roysueapplication_hellojni_getStraddress:&quot;</span>,<span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&#x27;libhello.so&#x27;</span>, <span class="string">&#x27;Java_com_roysue_roysueapplication_hellojni_getStr&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Module-findBaseAddress-name-、Module-getBaseAddress-name"><a href="#Module-findBaseAddress-name-、Module-getBaseAddress-name" class="headerlink" title="Module.findBaseAddress(name)、Module.getBaseAddress(name)"></a>Module.findBaseAddress(name)、Module.getBaseAddress(name)</h3><p>返回<code>name</code>模块的基地址</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;libhello.so&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;so address:&quot;</span>,<span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(name));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;so address:&quot;</span>,<span class="title class_">Module</span>.<span class="title function_">getBaseAddress</span>(name));</span><br></pre></td></tr></table></figure>

<h2 id="Memory对象"><a href="#Memory对象" class="headerlink" title="Memory对象"></a>Memory对象</h2><p><code>Memory</code>的一些<code>API</code>的作用：通常是对内存处理，譬如<code>Memory.copy()</code>复制内存</p>
<h3 id="Memory-scan搜索内存数据"><a href="#Memory-scan搜索内存数据" class="headerlink" title="Memory.scan搜索内存数据"></a>Memory.scan搜索内存数据</h3><p>功能：搜索内存中以<code>address</code>地址开始，搜索长度为<code>size</code>，需要搜是条件是<code>pattern，callbacks</code>搜索之后的回调函数</p>
<p>格式：Memory.scan(module.base, module.size, pattern，callbacks）</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">        //先获取so的module对象</span><br><span class="line">        var module = Process.findModuleByName(&quot;libhello.so&quot;); </span><br><span class="line">        //??是通配符</span><br><span class="line">        var pattern = &quot;03 49 ?? 50 20 44&quot;;</span><br><span class="line">        //基址</span><br><span class="line">        console.log(&quot;base:&quot;+module.base)</span><br><span class="line">        //从so的基址开始搜索，搜索大小为so文件的大小，搜指定条件03 49 ?? 50 20 44的数据</span><br><span class="line">        var res = Memory.scan(module.base, module.size, pattern, &#123;</span><br><span class="line">            onMatch: function(address, size)&#123;</span><br><span class="line">                //搜索成功</span><br><span class="line">                console.log(&#x27;搜索到 &#x27; +pattern +&quot; 地址是:&quot;+ address.toString());  </span><br><span class="line">            &#125;, </span><br><span class="line">            onError: function(reason)&#123;</span><br><span class="line">                //搜索失败</span><br><span class="line">                console.log(&#x27;搜索失败&#x27;);</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: function()</span><br><span class="line">            &#123;</span><br><span class="line">                //搜索完毕</span><br><span class="line">                console.log(&quot;搜索完毕&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="内存分配Memory-alloc"><a href="#内存分配Memory-alloc" class="headerlink" title="内存分配Memory.alloc"></a>内存分配Memory.alloc</h3><p>作用：在目标进程中的堆上<strong>申请<code>size</code>大小的内存</strong>，并且会按照<code>Process.pageSize</code>对齐，返回一个<code>NativePointer</code>，并且申请的内存如果在<code>JavaScript</code>里面没有对这个内存的使用的时候会自动释放的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> r = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(r, &#123;</span><br><span class="line">            <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">length</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">header</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">ansi</span>: <span class="literal">false</span></span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure>

<h3 id="内存复制Memory-copy"><a href="#内存复制Memory-copy" class="headerlink" title="内存复制Memory.copy"></a>内存复制Memory.copy</h3><p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申请一个内存空间大小为10个字节</span></span><br><span class="line"><span class="keyword">const</span> r = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//复制以module.base地址开始的10个字节 那肯定会是7F 45 4C 46...因为一个ELF文件的Magic属性如此。</span></span><br><span class="line"><span class="title class_">Memory</span>.<span class="title function_">copy</span>(r,<span class="variable language_">module</span>.<span class="property">base</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="写入内存Memory-writeByteArray’"><a href="#写入内存Memory-writeByteArray’" class="headerlink" title="写入内存Memory.writeByteArray’"></a>写入内存Memory.writeByteArray’</h3><p>将字节数组<strong>写入一个指定内存</strong></p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义需要写入的字节数组 这个字节数组是字符串&quot;roysue&quot;的十六进制</span></span><br><span class="line"><span class="keyword">var</span> arr = [ <span class="number">0x72</span>, <span class="number">0x6F</span>, <span class="number">0x79</span>, <span class="number">0x73</span>, <span class="number">0x75</span>, <span class="number">0x65</span>];</span><br><span class="line"><span class="comment">//申请一个新的内存空间 返回指针 大小是arr.length</span></span><br><span class="line"><span class="keyword">const</span> r = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(arr.<span class="property">length</span>);</span><br><span class="line"><span class="comment">//将arr数组写入R地址中</span></span><br><span class="line"><span class="title class_">Memory</span>.<span class="title function_">writeByteArray</span>(r,arr);</span><br></pre></td></tr></table></figure>

<h3 id="读取内存Memory-readByteArray"><a href="#读取内存Memory-readByteArray" class="headerlink" title="读取内存Memory.readByteArray"></a>读取内存Memory.readByteArray</h3><p>这个函数的第一个参数传入的是 NativePointer 类型的地址指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//读取r指针，长度是arr.length 也就是会打印上面一样的值</span><br><span class="line">var buffer = Memory.readByteArray(r, arr.length);</span><br></pre></td></tr></table></figure>

<p>参考文章：<a href="https://www.anquanke.com/post/id/195215#h2-1">FRIDA-API使用篇：rpc、Process、Module、Memory使用方法及示例 - 安全客</a></p>
<h1 id="frida的so函数hook"><a href="#frida的so函数hook" class="headerlink" title="frida的so函数hook"></a>frida的so函数hook</h1><p>so文件之中的函数有导出函数和非导出函数,导出函数打开IDA后能够在导出表中找到的函数就是导出函数，未导出函数则在导出表中寻找不到。一般来说<strong>静态编写的native函数都能在导出表中寻找到，而动态加载的则无法在导出表中发现</strong></p>
<p>在IDA的Exports页面之中查看导出函数窗口</p>
<p>示例：</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220315233226275.png" alt="image-20220315233226275"></p>
<p><strong>导出函数hook</strong>：导出函数窗口可以看到导出函数的函数名，偏移量 。导出函数的hook可以通过<strong>函数名</strong>或者<strong>偏移量</strong>。</p>
<p><strong>非导出函数hook</strong>：只能通过<strong>地址hook</strong>。定位到函数的位置，直接看它的偏移量即可</p>
<h2 id="通过函数地址获取指定-so-文件的函数"><a href="#通过函数地址获取指定-so-文件的函数" class="headerlink" title="通过函数地址获取指定 so 文件的函数"></a>通过函数地址获取指定 so 文件的函数</h2><p><strong>函数地址 = so基地址 + 函数偏移</strong>(如果Thumb 指令， hook 的偏移地址需要进行 <strong>+1 操作</strong>)</p>
<p><strong>IDA 判断 Thumb 指令集和 Arm指令集</strong></p>
<ul>
<li><strong>IDA - Options - General - number of opcode bytes</strong> - 设置为 4</li>
<li>此时查看 IDA VIew 中 opcode 的长度, 如果出现 <strong>2 个字节</strong>和 <strong>4 个字节</strong>的, 说明为 <strong>thumb 指令集</strong></li>
<li>如果都是 <strong>4 个字节</strong>的, 说明是 <strong>arm 指令集</strong>;</li>
<li>在 Thumb 指令集下, inline hook 的偏移地址需要进行 +1 操作;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str_name_so = &quot;libjnitest.so&quot;;    //需要hook的so名</span><br><span class="line">var n_addr_func_offset = 0x00000680;         //需要hook的函数的偏移</span><br><span class="line">var n_addr_so = Module.findBaseAddress(str_name_so); //加载到内存后 函数地址 = so地址 + 函数偏移</span><br><span class="line">var n_addr_func = parseInt(n_addr_so, 16) + n_addr_func_offset;</span><br><span class="line">var ptr_func = new NativePointer(n_addr_func);</span><br></pre></td></tr></table></figure>

<h2 id="通过函数名获取指定-so-文件的函数"><a href="#通过函数名获取指定-so-文件的函数" class="headerlink" title="通过函数名获取指定 so 文件的函数"></a><strong>通过函数名获取指定 so 文件的函数</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var ptr_func = Module.findExportByName(&quot;libjnitest.so&quot;,&quot;test_add&quot;) //对函数名hook</span><br></pre></td></tr></table></figure>

<h2 id="通过-symbols-符号定位-native-方法"><a href="#通过-symbols-符号定位-native-方法" class="headerlink" title="通过 symbols 符号定位 native 方法"></a><strong>通过 symbols 符号定位 native 方法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    var NewStringUTF_addr = null;</span><br><span class="line">    var symbols = Process.findModuleByName(&quot;libart.so&quot;).enumerateSymbols(); //使用enumerateSymbols()函数得到所有的symbols 然后对symbols中所有的对象进行遍历，然后判断语句获得目标函数的地址</span><br><span class="line">    for (var i in symbols) &#123;</span><br><span class="line">        var symbol = symbols[i];</span><br><span class="line">        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;</span><br><span class="line">            symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;</span><br><span class="line">            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0</span><br><span class="line">        )&#123;</span><br><span class="line">            if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;= 0) &#123;</span><br><span class="line">                console.log(&quot;find target symbols&quot;, symbol.name, &quot;address is &quot;, symbol.address);</span><br><span class="line">                NewStringUTF_addr = symbol.address;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;NewStringUTF_addr is &quot;, NewStringUTF_addr);</span><br><span class="line">//得到函数地址之后 使用这个函数地址attach</span><br><span class="line">Interceptor.attach(NewStringUTF_addr, &#123;</span><br><span class="line">        onEnter: function (args) &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave: function (returnResult) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="通过-Intercept-拦截器打印-native-方法参数和返回值-并修改返回值"><a href="#通过-Intercept-拦截器打印-native-方法参数和返回值-并修改返回值" class="headerlink" title="通过 Intercept 拦截器打印 native 方法参数和返回值, 并修改返回值"></a><strong>通过 Intercept 拦截器打印 native 方法参数和返回值, 并修改返回值</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var add_c_addr = Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;add_c&quot;);</span><br><span class="line">    console.log(&quot;add_c_addr is :&quot;,add_c_addr);</span><br><span class="line">    // 添加拦截器</span><br><span class="line">    Interceptor.attach(add_c_addr,&#123;</span><br><span class="line">        // 打印入参</span><br><span class="line">        onEnter: function (args) &#123;</span><br><span class="line">            console.log(&quot;add_c called&quot;);</span><br><span class="line">            console.log(&quot;arg1:&quot;,args[0].toInt32());</span><br><span class="line">            console.log(&quot;arg2&quot;, args[1].toInt32());</span><br><span class="line">        &#125;,</span><br><span class="line">        // 打印返回值</span><br><span class="line">        onLeave: function (returnValue) &#123;</span><br><span class="line">            console.log(&quot;add_c result is :&quot;, returnValue.toInt32());</span><br><span class="line">            // 修改返回值</span><br><span class="line">            returnValue.replace(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>



<h2 id="获取指定-so-文件的基地址"><a href="#获取指定-so-文件的基地址" class="headerlink" title="获取指定 so 文件的基地址"></a><strong>获取指定 so 文件的基地址</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var baseAddr = Module.findBaseAddress(&quot;libnative-lib.so&quot;);</span><br><span class="line">console.log(&quot;baseAddr&quot;, baseAddr);</span><br></pre></td></tr></table></figure>

<h2 id="Hook修改native层函数返回值为int类型的情况"><a href="#Hook修改native层函数返回值为int类型的情况" class="headerlink" title="Hook修改native层函数返回值为int类型的情况"></a><strong>Hook修改native层函数返回值为int类型的情况</strong></h2><p>使用<code>replace()</code>函数直接修改即可</p>
<p>frida脚本示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import frida</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">jscode = &quot;&quot;&quot;</span><br><span class="line">Java.perform(function()&#123;</span><br><span class="line">    var str_name_so = &quot;libjnitest.so&quot;;    //需要hook的so名</span><br><span class="line">    var n_addr_func_offset = 0x00000680;         //需要hook的函数的偏移</span><br><span class="line">    var n_addr_so = Module.findBaseAddress(str_name_so); //加载到内存后 函数地址 = so地址 + 函数偏移</span><br><span class="line">    var n_addr_func = parseInt(n_addr_so, 16) + n_addr_func_offset;</span><br><span class="line">    var ptr_func = new NativePointer(n_addr_func);</span><br><span class="line">    //var ptr_func = Module.findExportByName(&quot;libjnitest.so&quot;,&quot;test_add&quot;) //对函数名hook</span><br><span class="line"></span><br><span class="line">    Interceptor.attach(ptr_func,&#123; </span><br><span class="line">        //onEnter: 进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始是我们java层传入的参数</span><br><span class="line">        onEnter: function(args) &#123;</span><br><span class="line">            send(&quot;Hook start&quot;);</span><br><span class="line">            send(&quot;args[2]=&quot; + args[2]); //第一个传入的参数</span><br><span class="line">            send(&quot;args[3]=&quot; + args[3]); //第二个参数</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave: function(retval)&#123; //onLeave: 该函数执行结束要执行的代码，其中retval参数即是返回值</span><br><span class="line">            send(&quot;return:&quot;+retval); //返回值</span><br><span class="line">            retval.replace(100); //替换返回值为100</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def printMessage(message,data):</span><br><span class="line">    if message[&#x27;type&#x27;] == &#x27;send&#x27;:</span><br><span class="line">        print(&#x27;[*] &#123;0&#125;&#x27;.format(message[&#x27;payload&#x27;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(&#x27;com.example.testso&#x27;) #进程名</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(&#x27;message&#x27;,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>

<h2 id="Hook修改native层函数返回值为string类型"><a href="#Hook修改native层函数返回值为string类型" class="headerlink" title="Hook修改native层函数返回值为string类型"></a><strong>Hook修改native层函数返回值为string类型</strong></h2><p>返回值为字符串其实是返回了一个<code>char \*</code>（字符串指针），所以简单的替换是无法取效果的</p>
<p>关键代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数</span><br><span class="line">var jstrings = env.newStringUtf(&quot;tamper&quot;); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针</span><br><span class="line">retval.replace(jstrings); //替换返回值</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import frida</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">jscode = &quot;&quot;&quot;</span><br><span class="line">Java.perform(function()&#123;</span><br><span class="line">    Interceptor.attach(Module.findExportByName(&quot;libfridaso.so&quot;,&quot;Java_com_example_fridasostring_fridaSoString_FridaSo&quot;),&#123;</span><br><span class="line">        onEnter: function(args) &#123;</span><br><span class="line">            send(&quot;Hook start&quot;);</span><br><span class="line">            send(&quot;args[2]=&quot; + args[2]);</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave: function(retval)&#123;</span><br><span class="line">            send(&quot;return:&quot;+retval);</span><br><span class="line">            var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数</span><br><span class="line">            var jstrings = env.newStringUtf(&quot;tamper&quot;); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针</span><br><span class="line">            retval.replace(jstrings); //替换返回值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def printMessage(message,data):</span><br><span class="line">    if message[&#x27;type&#x27;] == &#x27;send&#x27;:</span><br><span class="line">        print(&#x27;[*] &#123;0&#125;&#x27;.format(message[&#x27;payload&#x27;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(&#x27;com.example.fridasostring&#x27;)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(&#x27;message&#x27;,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>

<h2 id="Frida命令"><a href="#Frida命令" class="headerlink" title="Frida命令"></a>Frida命令</h2><p>基础命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动frida-server(模拟器)</span><br><span class="line">./data/local/tmp/frida-server-12.8.0-android-x86</span><br><span class="line"></span><br><span class="line"># 启动frida-server(Pixel真机)</span><br><span class="line">./data/local/tmp/frida-server-12.8.0-android-arm64</span><br><span class="line"></span><br><span class="line"># 在我的电脑之中模拟器运行frida-server(因为将这个文件导入的时候进行了重命名为frida-server)</span><br><span class="line">./data/local/tmp/frida-server</span><br><span class="line"></span><br><span class="line"># 转发端口</span><br><span class="line">adb forward tcp:27042 tcp:27042</span><br><span class="line">adb forward tcp:27043 tcp:27043</span><br><span class="line"></span><br><span class="line"># 列举出来所有连接到电脑上的设备</span><br><span class="line">frida-ls-devices</span><br><span class="line"></span><br><span class="line"># 连接到指定设备</span><br><span class="line">frida-ps -D tcp</span><br><span class="line"></span><br><span class="line"># 列举出来设备上的所有进程</span><br><span class="line">frida-ps -U</span><br><span class="line"></span><br><span class="line"># 列举出来设备上的所有应用程序</span><br><span class="line">frida-ps -Ua</span><br><span class="line"></span><br><span class="line"># 列举出来设备上的所有已安装应用程序和对应的名字</span><br><span class="line">frida-ps -Uai</span><br><span class="line"></span><br><span class="line"># 跟踪某个函数</span><br><span class="line">frida-trace -U -f Name -i &quot;函数名&quot;</span><br><span class="line"># frida-trace -U -f com.autonavi.minimap -i &quot;getRequestParams&quot;</span><br><span class="line"></span><br><span class="line"># 跟踪某个方法</span><br><span class="line">frida-trace -U -f Name -m &quot;方法名&quot;</span><br><span class="line"># frida-trace -U -f com.autonavi.minimap -m &quot;MapLoader&quot;</span><br></pre></td></tr></table></figure>



<h1 id="d3mug"><a href="#d3mug" class="headerlink" title="d3mug"></a>d3mug</h1><p>ctf之中的游戏逆向（unity3D逆向分析）</p>
<p>unity逆向的文章（里面有各种各样的有关unity的题目，可以学习一下）：<a href="https://forum.butian.net/share/1294">https://forum.butian.net/share/1294</a></p>
<p><strong>unity游戏IL2CPP类型</strong></p>
<p>这道题是 ：IL2CPP类型相对来说，题目难度有一个质的提升。对unity的理解程度需要更深。IL2CPP的Unity3D游戏的逆向，只需要根据global-metadata.dat和libil2cpp.so来进行就可以了。</p>
<p><strong>il2cpp的内部实现文档</strong>：<a href="https://blogs.unity3d.com/2015/05/06/an-introduction-to-ilcpp-internals/">https://blogs.unity3d.com/2015/05/06/an-introduction-to-ilcpp-internals/</a></p>
<p>il2cpp（主要分析metadata的一篇文章）</p>
<p>游戏的主页面</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305085623123.png" alt="image-20220305085623123"></p>
<p>游戏的运行界面：需要在白线的上面不停的点击这些蓝色的模块，如果能在白线的位置上点击到，那么GOOD就会增加一</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305085823662.png" alt="image-20220305085823662"></p>
<h2 id="IL2CPPDumper"><a href="#IL2CPPDumper" class="headerlink" title="IL2CPPDumper"></a>IL2CPPDumper</h2><p>使用<strong>IL2CPPDumper这个工具</strong>将apk解包之后的<strong>global-metadata.dat</strong>和<strong>libil2cpp.so</strong>这两个文件，<strong>dump出</strong>该DLL里的所有类以及类里的方法和成员，</p>
<p>使用<a href="https://blog.csdn.net/linxinfa/article/details/116572369">IL2CPPDumper</a>这个工具dump的方法以及dump出来的文件说明</p>
<p>dump（input文件）</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305092747884.png" alt="image-20220305092747884"></p>
<p>dump（output文件）</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305092816043.png" alt="image-20220305092816043"></p>
<p><strong>dump.cs</strong>:</p>
<p>这个文件会把<code>C#</code>的<code>dll</code>代码的类、方法、字段列出来。这里面有非常多的数据</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305093238515.png" alt="image-20220305093238515"></p>
<p><strong>il2cpp.h</strong>：</p>
<p>生成的<code>cpp</code>的头文件，从头文件里我们也可以看到相关的数据结构</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305093516208.png" alt="image-20220305093516208"></p>
<p><strong>script.json</strong>：</p>
<p>以<code>json</code>格式显示类的方法信息</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305093703245.png" alt="image-20220305093703245"></p>
<p><strong>stringliteral.json</strong>：</p>
<p>以json的格式显示所有的字符串信息</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305094319654.png" alt="image-20220305094319654"></p>
<p><strong>DummyDll/Assembly-CSharp.dll</strong></p>
<p>进入DummyDll目录，可以看到很多dll，其中就有Assembly-CSharp.dll，使用dnspy打开这个文件</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305095103745.png" alt="image-20220305095103745"></p>
<p>文件列表：可以看到这里是游戏页面的初始化，组件（线），音乐等等</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305095653171.png" alt="image-20220305095653171"></p>
<p>从上面<strong>IL2CppDumper</strong>我们可以发现，逆向得到的函数体都是空的，看不了内部逻辑。内部的逻辑结构就需要使用IDA查看libil2cpp.so这个文件，在这个文件中使用上面得到的cs文件的偏移量找到目标的函数</p>
<h2 id="关键函数定位"><a href="#关键函数定位" class="headerlink" title="关键函数定位"></a>关键函数定位</h2><p>将Il2CppDumper 处理之后得到的Assembly-CSharp.dll文件放入到dnspy之中，这个文件里面存放了这个游戏里面函数的偏移地址</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314175022511.png" alt="image-20220314175022511"></p>
<p>根据需要查看相应的类，再查看相应的类中的函数的偏移地址</p>
<p>这里我们需要查看 GameManager和 ScoreScene类中的函数</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314175327440.png" alt="image-20220314175327440"></p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314175404995.png" alt="image-20220314175404995"></p>
<h2 id="游戏逻辑分析"><a href="#游戏逻辑分析" class="headerlink" title="游戏逻辑分析"></a>游戏逻辑分析</h2><p>使用上面得到的Assembly-CSharp.dll文件定位到函数的关键地址</p>
<h3 id="NoteObject类中的OnClicked-函数"><a href="#NoteObject类中的OnClicked-函数" class="headerlink" title="NoteObject类中的OnClicked()函数"></a>NoteObject类中的OnClicked()函数</h3><p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314180743397.png" alt="image-20220314180743397"></p>
<p>再跟进这个判断时间的函数之中 它的rva是RVA = “0x62B64C” ，查看Assembly-CSharp.dll这个文件我们可以知道它就是NoteHit()函数</p>
<h3 id="GameManager类的NoteHit-函数"><a href="#GameManager类的NoteHit-函数" class="headerlink" title="GameManager类的NoteHit()函数"></a>GameManager类的NoteHit()函数</h3><p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314180815068.png" alt="image-20220314180815068"></p>
<h3 id="GameManager类中的update-函数"><a href="#GameManager类中的update-函数" class="headerlink" title="GameManager类中的update()函数"></a>GameManager类中的update()函数</h3><p>从上面那张图中可以得到在NoteHit()函数的结尾的地方调用了update()函数</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314182013914.png" alt="image-20220314182013914"></p>
<p>上面这个update()函数调用了libd3mug.so的update()函数，这个函数的最后调用了server.run</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220315210534201.png" alt="image-20220315210534201"></p>
<p>逻辑分析：点击了NodeObject是表示音游之中的方块的类，NoteObject类中的OnClicked()函数表示点击方块，之后会触发GameManager类的NoteHit()函数分析点击的时间，从而确定是否点击成功与否，该函数之后会调用GameManager类中的update()函数</p>
<p>然后查看分数的模块ScoreScene类</p>
<h3 id="ScoreScene类的get-函数"><a href="#ScoreScene类的get-函数" class="headerlink" title="ScoreScene类的get()函数"></a>ScoreScene类的get()函数</h3><p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314183330050.png" alt="image-20220314183330050"></p>
<p>上面这个get()函数里面调用了libd3mug.so中的get()函数</p>
<h3 id="libd3mug-so中的get-函数"><a href="#libd3mug-so中的get-函数" class="headerlink" title="libd3mug.so中的get()函数"></a>libd3mug.so中的get()函数</h3><p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220315210430564.png" alt="image-20220315210430564"></p>
<p>通过这个函数交叉查询一下，找到引用该函数的函数sub_62EE40() 它便是ScoreScene类的Start()函数</p>
<h3 id="ScoreScene类的Start-函数"><a href="#ScoreScene类的Start-函数" class="headerlink" title="ScoreScene类的Start()函数"></a>ScoreScene类的Start()函数</h3><p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314183807139.png" alt="image-20220314183807139"></p>
<p>逻辑分析：游戏结束之后会转到的类是ScoreScene类，其中最后显示分数的函数中，调用了get()函数，这样获得了一个字符串</p>
<h2 id="AssertStudio获得谱面"><a href="#AssertStudio获得谱面" class="headerlink" title="AssertStudio获得谱面"></a>AssertStudio获得谱面</h2><p>这是一个音游的游戏，由于需要我们踩点正确，所以就要我们找到这个游戏中的谱面（音乐的谱子），使用<a href="%5B(6%E6%9D%A1%E6%B6%88%E6%81%AF">AssertStudio</a> Unity解包提取资源/AssetStudio的简单使用_咲奈的平行时空-CSDN博客_unity解包](<a href="https://blog.csdn.net/qq_21567385/article/details/107015800))%E5%8A%A0%E8%BD%BD%E8%BF%99%E4%B8%AAunity%E6%B8%B8%E6%88%8F%E7%9A%84assets%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%9C%A8%E5%AE%83%E7%9A%84Asset">https://blog.csdn.net/qq_21567385/article/details/107015800))加载这个unity游戏的assets目录，在它的Asset</a> List下面我们能够看到很多资源文件，其中的hitpoints的文件就是它的谱面</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314193510893.png" alt="image-20220314193510893"></p>
<p>在这个游戏页面的首页之中我们就能够看到这个游戏的音乐是 Chromevox</p>
<p>这里有三个音乐的hitpoints 我们选择其中是Chromevox的</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314194026586.png" alt="image-20220314194026586"></p>
<p>将这个文件导出出来,这个文件之中前面表示的是轨道数，后面表示的是时间</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314194629112.png" alt="image-20220314194629112"></p>
<p>按照之前的方法找到GameManager类的NoteMissed()函数</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314195819635.png" alt="image-20220314195819635"></p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314195836835.png" alt="image-20220314195836835"></p>
<p>从图中我们可以知道update()中的参数就是msecs，所以我们需要将得到的hitpoints中的msecs作为 参数传入其中，这个过程就需要frida来hook函数</p>
<h2 id="frida"><a href="#frida" class="headerlink" title="frida"></a>frida</h2><p>查看frida-server是否成功开启，-U表示USB，允许Frida检查USB设备，这时将看到一个进程列表。</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314205710639.png" alt="image-20220314205710639"></p>
<p>通过该命令可以得到frida脚本中所需要的文件信息(pid 和 应用名和包名)</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import frida, sys</span><br><span class="line"></span><br><span class="line">jscode = &quot;&quot;&quot;</span><br><span class="line">console.log(&#x27;12345&#x27;)</span><br><span class="line">let hitpoints = [0, 0, 0, 146, 292, 292, 439, 512, 585, 585, 658, 731, 804, 878, 1024, 1170, 1170, 1317, 1463, 1463, 1609, 1682, 1756, 1756, 1902, 2048, 2195, 2341, 2341, 2487, 2634, 2634, 2780, 2853, 2926, 2926, 3073, 3146, 3219, 3219, 3365, 3439, 3512, 3512, 3658, 3804, 3878, 3951, 4024, 4097, 4097, 4243, 4390, 4682, 4682, 4682, 4829, 4975, 4975, 5121, 5195, 5268, 5341, 5414, 5487, 5560, 5560, 5853, 5853, 5999, 6146, 6146, 6292, 6365, 6439, 6439, 6585, 6731, 6731, 6731, 7024, 7024, 7170, 7317, 7317, 7463, 7536, 7609, 7609, 7682, 7756, 7829, 7902, 7902, 7975, 8048, 8121, 8195, 8341, 8487, 8634, 8780, 9073, 9073, 9073, 9219, 9365, 9365, 9512, 9658, 9658, 9804, 9878, 9951, 9951, 10097, 10243, 10243, 10243, 10390, 10463, 10536, 10536, 10682, 10829, 10829, 10975, 11121, 11121, 11268, 11414, 11414, 11560, 11707, 11707, 11853, 11999, 11999, 11999, 12146, 12292, 12292, 12439, 12439, 12585, 12585, 12585, 12731, 12878, 12951, 13024, 13097, 13170, 13170, 13317, 13463, 13463, 13463, 13609, 13756, 13756, 13756, 13902, 14048, 14048, 14195, 14341, 14487, 14634, 14634, 14926, 14926, 14926, 15219, 15219, 15219, 15365, 15365, 15512, 15512, 15658, 15804, 15804, 15951, 16024, 16097, 16097, 16170, 16243, 16317, 16390, 16390, 16536, 16682, 16682, 16829, 16902, 16975, 16975, 17121, 17268, 17268, 17268, 17414, 17560, 17634, 17707, 17780, 17853, 17926, 17999, 18073, 18146, 18146, 18292, 18439, 18439, 18731, 18731, 18731, 18878, 19024, 19024, 19024, 19170, 19243, 19317, 19463, 19609, 19609, 19609, 19756, 19829, 19902, 20048, 20195, 20195, 20341, 20487, 20487, 20634, 20780, 20780, 20926, 21073, 21073, 21219, 21365, 21365, 21365, 21512, 21585, 21658, 21658, 21804, 21951, 21951, 21951, 22097, 22243, 22317, 22390, 22463, 22536, 22536, 22609, 22682, 22756, 22829, 22829, 22975, 23121, 23121, 23268, 23414, 23560, 23707, 23780, 23853, 23926, 23999, 23999, 24073, 24146, 24219, 24292, 24365, 24439, 24512, 24585, 24585, 24731, 24731, 24878, 24878, 24878, 25024, 25170, 25170, 25317, 25390, 25463, 25463, 25609, 25756, 25756, 25756, 25902, 25902, 26048, 26048, 26195, 26195, 26341, 26341, 26414, 26487, 26487, 26560, 26634, 26634, 26780, 26780, 26926, 27219, 27512, 27585, 27658, 27731, 27804, 27804, 28097, 28097, 28390, 28682, 28682, 28975, 29268, 29268, 29560, 29560, 29853, 29853, 30146, 30439, 30439, 30731, 31024, 31024, 31317, 31609, 31609, 31902, 32195, 32195, 32487, 32780, 32780, 32780, 33365, 33365, 33365, 33951, 33951, 34243, 34536, 34536, 34829, 35121, 35121, 35414, 35707, 35707, 35707, 35999, 36292, 36585, 36878, 36878, 37024, 37024, 37170, 37170, 37463, 37463, 37463, 37609, 37756, 37756, 37902, 38048, 38048, 38195, 38341, 38341, 38487, 38634, 38634, 38780, 38926, 39073, 39219, 39365, 39512, 39658, 39804, 39804, 39951, 40097, 40097, 40243, 40390, 40390, 40536, 40682, 40829, 40975, 40975, 41121, 41268, 41414, 41560, 41707, 41853, 41999, 42146, 42146, 42292, 42292, 42439, 42585, 42731, 42731, 42878, 42878, 43024, 43170, 43317, 43317, 43463, 43463, 43609, 43609, 43682, 43756, 43756, 43829, 43902, 43902, 44048, 44048, 44195, 44195, 44341, 44341, 44487, 44560, 44634, 44707, 44780, 44853, 44926, 44999, 45073, 45146, 45219, 45292, 45365, 45439, 45512, 45585, 45658, 45658, 45804, 45951, 45951, 46097, 46243, 46243, 46536, 46536, 46536, 46829, 46829, 46902, 46975, 47121, 47121, 47268, 47414, 47414, 47560, 47634, 47707, 47707, 47853, 47926, 47999, 47999, 48146, 48292, 48292, 48439, 48585, 48585, 48731, 48878, 48878, 49024, 49170, 49170, 49243, 49317, 49463, 49463, 49609, 49756, 49756, 49902, 49975, 50048, 50048, 50121, 50195, 50268, 50341, 50341, 50487, 50487, 50707, 50707, 50926, 50926, 51073, 51219, 51365, 51512, 51512, 51585, 51658, 51804, 51804, 51951, 52097, 52097, 52170, 52243, 52317, 52390, 52390, 52536, 52609, 52682, 52682, 52829, 52975, 52975, 53121, 53268, 53268, 53414, 53560, 53560, 53707, 53853, 53853, 53926, 53999, 54073, 54146, 54146, 54219, 54292, 54365, 54439, 54439, 54512, 54585, 54658, 54731, 54731, 54878, 54878, 55024, 55024, 55024, 55317, 55317, 55317, 55609, 55609, 55609, 55902, 55902, 55902, 56195, 56268, 56341, 56487, 56487, 56634, 56780, 56780, 56926, 56999, 57073, 57073, 57219, 57292, 57365, 57365, 57512, 57658, 57658, 57804, 57951, 57951, 58097, 58243, 58243, 58390, 58536, 58536, 58609, 58682, 58829, 58829, 58975, 59121, 59121, 59268, 59341, 59414, 59414, 59560, 59634, 59707, 59707, 59853, 59926, 59999, 59999, 60073, 60292, 60292, 60439, 60585, 60585, 60731, 60878, 60878, 60951, 61024, 61024, 61170, 61170, 61317, 61317, 61463, 61463, 61463, 61536, 61609, 61609, 61756, 61756, 61902, 61902, 62048, 62048, 62048, 62121, 62195, 62195, 62341, 62341, 62414, 62487, 62560, 62634, 62634, 62780, 62780, 62926, 62926, 63073, 63073, 63219, 63219, 63292, 63365, 63439, 63512, 63512, 63585, 63658, 63731, 63804, 63804, 63878, 63951, 64024, 64097, 64097, 64170, 64243, 64317, 64390, 64390, 64536, 64536, 64609, 64682, 64829, 64975, 65121, 65268, 65414, 65560, 65560, 65707, 65853, 65999, 66146, 66146, 66439, 66585, 66878, 67170, 67317, 67317, 67609, 67902, 68048, 68195, 68341, 68487, 68487, 68780, 68926, 69073, 69219, 69365, 69512, 69658, 69658, 69804, 69951, 70243, 70390, 70536, 70682, 70829, 70829, 71121, 71268, 71560, 71853, 71999, 71999, 72292, 72585, 72731, 72878, 73024, 73170, 73317, 73463, 73609, 73609, 73756, 73975, 74195, 74341, 74341, 74634, 74707, 74780, 74926, 74926, 75073, 75073, 75219, 75219, 75219, 75365, 75512, 75512, 75658, 75658, 75804, 75804, 75804, 75951, 76097, 76097, 76390, 76390, 76390, 76536, 76682, 76682, 76829, 76829, 76975, 76975, 76975, 77268, 77268, 77414, 77560, 77560, 77561, 77707, 77853, 77853, 77999, 77999, 78146, 78146, 78146, 78292, 78439, 78439, 78731, 78732, 78732, 78878, 79024, 79024, 79170, 79171, 79317, 79317, 79463, 79609, 79609, 79756, 79902, 79902, 80048, 80195, 80341, 80341, 80487, 80487, 80634, 80780, 80780, 80926, 80926, 81073, 81073, 81073, 81219, 81365, 81512, 81512, 81658, 81658, 81658, 81951, 81951, 81951, 82097, 82243, 82243, 82390, 82536, 82682, 82682, 82829, 82829, 82829, 82975, 83121, 83121, 83268, 83414, 83414, 83560, 83707, 83853, 83853, 83999, 83999, 83999, 84292, 84292, 84365, 84439, 84512, 84585, 84585, 84731, 84804, 84878, 84878, 84951, 85024, 85097, 85170, 85170, 85317, 85390, 85463, 85463, 85536, 85609, 85682, 85756, 85756, 85829, 85902, 85975, 86048, 86048, 86121, 86195, 86268, 86341, 86341, 86487, 86634, 86634, 86707, 86780, 86853, 86926, 86926, 87073, 87146, 87219, 87219, 87292, 87365, 87439, 87512, 87512, 87658, 87804, 87804, 87878, 87951, 88024, 88097, 88097, 88170, 88243, 88317, 88390, 88390, 88536, 88609, 88682, 88682, 88829, 88975, 88975, 89121, 89121, 89268, 89268, 89414, 89414, 89560, 89560, 89707, 89707, 89853, 89853, 89999, 89999, 90146, 90146, 90292, 90292, 90439, 90439, 90585, 90585, 90731, 90731, 90878, 90878, 91024, 91024, 91170, 91170, 91317, 91317, 91390, 91463, 91536, 91609, 91682, 91756, 91829, 91902, 91975, 92048, 92121, 92195, 92268, 92341, 92634, 92780, 92926, 93219, 93365, 93365, 93365, 93365, 93658, 93658, 93804, 93878, 93951, 93951, 94097, 94243, 94317, 94390, 94463, 94536, 94536, 94682, 94829, 94829, 94975, 95121, 95121, 95268, 95414, 95487, 95560, 95634, 95707, 95707, 95853, 95853, 95999, 95999, 96146, 96292, 96292, 96292, 96439, 96585, 96585, 96658, 96731, 96804, 96878, 96878, 97024, 97170, 97170, 97317, 97390, 97463, 97463, 97609, 97756, 97756, 97829, 97902, 98048, 98048, 98048, 98195, 98341, 98341, 98487, 98560, 98634, 98634, 98780, 98926, 98926, 99073, 99219, 99219, 99365, 99512, 99512, 99658, 99804, 99804, 99951, 100097, 100170, 100243, 100317, 100390, 100390, 100536, 100682, 100682, 100829, 100975, 100975, 100975, 101121, 101268, 101268, 101341, 101414, 101487, 101560, 101560, 101707, 101853, 101853, 101926, 101999, 102073, 102146, 102146, 102292, 102439, 102439, 102439, 102585, 102658, 102731, 102731, 102878, 103024, 103024, 103024, 103170, 103243, 103317, 103317, 103317, 103463, 103609, 103682, 103756, 103829, 103902, 103902, 104048, 104195, 104195, 104341, 104487, 104487, 104487, 104634, 104780, 104853, 104926, 104999, 105073, 105073, 105219, 105365, 105365, 105512, 105658, 105658, 105658, 105804, 105951, 105951, 106097, 106170, 106243, 106243, 106317, 106390, 106536, 106536, 106682, 106756, 106829, 106829, 106829, 106975, 107121, 107121, 107268, 107268, 107414, 107414, 107414, 107560, 107707, 107707, 107707, 107853, 107999, 107999, 107999, 108146, 108292, 108292, 108439, 108585, 108585, 108731, 108878, 108878, 108878, 109024, 109170, 109170, 109317, 109463, 109463, 109536, 109609, 109682, 109756, 109756, 109902, 110048, 110048, 110048, 110195, 110195, 110341, 110341, 110341, 110487, 110487, 110634, 110634, 110634, 110780, 110780, 110926, 110926, 110926, 111073, 111073, 111219, 111219, 111219, 111365, 111512, 111658, 111731, 111804, 111878, 111951, 112024, 112097, 112097, 112097, 112390, 112390, 112536, 112682, 112682, 112682, 112829, 112975, 112975, 113121, 113268, 113268, 113414, 113560, 113560, 113707, 113853, 113853, 113999, 114146, 114219, 114292, 114365, 114439, 114439, 114585, 114731, 114731, 114878, 115024, 115024, 115024, 115170, 115317, 115317, 115463, 115536, 115609, 115609, 115756, 115902, 115902, 115975, 116048, 116121, 116195, 116195, 116268, 116341, 116414, 116487, 116487, 116560, 116634, 116707, 116780, 116780, 116926, 117073, 117073, 117219, 117365, 117365, 117512, 117658, 117658, 117804, 117878, 117951, 117951, 118097, 118243, 118243, 118390, 118536, 118536, 118682, 118829, 118902, 118975, 119048, 119121, 119121, 119268, 119414, 119414, 119560, 119707, 119707, 119853, 119999, 119999, 120146, 120292, 120292, 120439, 120439, 120731, 121024, 121170, 121463, 121536, 121609, 121682, 121756, 121756, 121756, 121902, 122048, 122048, 122048, 122195, 122341, 122341, 122341, 122487, 122560, 122634, 122634, 122634, 122780, 122926, 122926, 122926, 123073, 123219, 123219, 123219, 123365, 123512, 123512, 123512, 123585, 123658, 123731, 123804, 123804, 123804, 123951, 124097, 124097, 124097, 124243, 124390, 124390, 124390, 124536, 124682, 124682, 124682, 124829, 124975, 124975, 124975, 125121, 125268, 125268, 125268, 125414, 125487, 125560, 125560, 125560, 125707, 125853, 125853, 125853, 125999, 126146, 126146, 126146, 126292, 126439, 126439, 126439, 126585, 126585, 126731, 126731, 126878, 126878, 127024, 127024, 127024, 127170, 127170, 127317, 127317, 127463, 127463, 127609, 127609, 127609, 127756, 127756, 127902, 127902, 128048, 128048, 128195, 128195, 128268, 128341, 128341, 128414, 128487, 128487, 128560, 128634, 128707, 128780, 128780, 128853, 128926, 128999, 129073, 129146, 129219, 129292, 129365, 129365, 129439, 129512, 129585, 129658, 129731, 129804, 129878, 129951, 129951, 130024, 130097, 130170, 130243, 130243, 130317, 130390, 130463, 130536, 130536, 130682, 130756, 130829, 130829, 130829, 130975, 130975, 131121, 131195, 131268, 131341, 131560, 131707, 131707, 131780, 131853, 131926, 132146, 132292, 132365, 132439, 132512, 132731, 132878, 132878, 132951, 133024, 133097, 133463, 133463, 133756, 134048, 134048, 134048, 134341, 134634, 134634, 134926, 134926, 135219, 135219, 135219, 135512, 135512, 135658, 135658, 135804, 135804, 135951, 135951, 136097, 136097, 136243, 136243, 136390, 136390, 136536, 136536, 136609, 136682, 136682, 136829, 136829, 136902, 136975, 136975, 137121, 137121, 137268, 137268, 137414, 137414, 137560, 137560, 137707, 137707, 137780, 137853, 137926, 137999, 137999, 138073, 138146, 138146, 138219, 138292, 138365, 138439, 138439, 138512, 138585, 138658, 138731, 138731, 138804, 138878, 138951, 139024, 139024, 139097, 139170, 139243, 139317, 139317, 139463, 139463, 139609, 139609, 139756, 139756, 139902, 139902, 140195, 140195, 140195, 140195]</span><br><span class="line">let UpdateFunc = new NativeFunction(Module.findExportByName(&quot;libd3mug.so&quot;,&quot;update&quot;),&quot;void&quot;,[&#x27;int&#x27;])</span><br><span class="line">for(let i=0;i&lt;hitpoints.length;i++)&#123;</span><br><span class="line">UpdateFunc(hitpoints[i]);</span><br><span class="line">&#125;</span><br><span class="line">let GetFunc = new NativeFunction(Module.findExportByName(&quot;libd3mug.so&quot;,&quot;get&quot;),&quot;pointer&quot;,[]);</span><br><span class="line">var result = GetFunc();</span><br><span class="line">console.log(ptr(result));</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#x27;type&#x27;] == &#x27;send&#x27;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line"># 查找USB设备并附加到目标进程</span><br><span class="line">#session = frida.get_remote_device(timeout=1000).attach(4103) # 通过命令查到的pid</span><br><span class="line"># 使用进程名称attach</span><br><span class="line"># session = frida.get_remote_device(timeout=1000).attach(&quot;LostBits&quot;)</span><br><span class="line"># 在我的电脑上能够attach的方法</span><br><span class="line">device = frida.get_remote_device()</span><br><span class="line">pid = device.spawn([&#x27;com.DefaultCompany.com.unity.template.mobile2D&#x27;])</span><br><span class="line">print(pid)</span><br><span class="line">session = device.attach(pid)</span><br><span class="line"># 在目标进程里创建脚本</span><br><span class="line">script = session.create_script(jscode)</span><br><span class="line"># 注册消息回调</span><br><span class="line">script.on(&#x27;message&#x27;, on_message)</span><br><span class="line">print(&#x27;[*] Start attach&#x27;)</span><br><span class="line"># 加载创建好的javascript脚本</span><br><span class="line">script.load()</span><br><span class="line"># 读取系统输入</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>

<p>D3CTF{Gb78e-7b04-4364-82d2-7f44}</p>
<p>如果用解密的方法从libd3mug.so函数分析加密的结果得到flag的脚本</p>
<p>官方的解释：libd3mug.so中的算法是一个类似于feistel的东西，通过一个静态的种子初始化</p>
<p>mt19937随机数生成器，然后先生成随机数判定是否要进入下一步解密，在解密中重新生成随机数作为key，然后选取</p>
<p>一个偏移在数据中取出32字节，加密其中的16字节并将左右位置互换，将每个note的击打时间都录入update函数，即</p>
<p>可解出正确答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;random&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const DWORD hitp[] = &#123; 0,0,0,146,292,292,439,512,585,585,658,731,804,878,1024,1170,1170,1317,1463,1463,1609,1682,1756,1756,1902,2048,2195,2341,2341,2487,2634,2634,2780,2853,2926,2926,3073,3146,3219,3219,3365,3439,3512,3512,3658,3804,3878,3951,4024,4097,4097,4243,4390,4682,4682,4682,4829,4975,4975,5121,5195,5268,5341,5414,5487,5560,5560,5853,5853,5999,6146,6146,6292,6365,6439,6439,6585,6731,6731,6731,7024,7024,7170,7317,7317,7463,7536,7609,7609,7682,7756,7829,7902,7902,7975,8048,8121,8195,8341,8487,8634,8780,9073,9073,9073,9219,9365,9365,9512,9658,9658,9804,9878,9951,9951,10097,10243,10243,10243,10390,10463,10536,10536,10682,10829,10829,10975,11121,11121,11268,11414,11414,11560,11707,11707,11853,11999,11999,11999,12146,12292,12292,12439,12439,12585,12585,12585,12731,12878,12951,13024,13097,13170,13170,13317,13463,13463,13463,13609,13756,13756,13756,13902,14048,14048,14195,14341,14487,14634,14634,14926,14926,14926,15219,15219,15219,15365,15365,15512,15512,15658,15804,15804,15951,16024,16097,16097,16170,16243,16317,16390,16390,16536,16682,16682,16829,16902,16975,16975,17121,17268,17268,17268,17414,17560,17634,17707,17780,17853,17926,17999,18073,18146,18146,18292,18439,18439,18731,18731,18731,18878,19024,19024,19024,19170,19243,19317,19463,19609,19609,19609,19756,19829,19902,20048,20195,20195,20341,20487,20487,20634,20780,20780,20926,21073,21073,21219,21365,21365,21365,21512,21585,21658,21658,21804,21951,21951,21951,22097,22243,22317,22390,22463,22536,22536,22609,22682,22756,22829,22829,22975,23121,23121,23268,23414,23560,23707,23780,23853,23926,23999,23999,24073,24146,24219,24292,24365,24439,24512,24585,24585,24731,24731,24878,24878,24878,25024,25170,25170,25317,25390,25463,25463,25609,25756,25756,25756,25902,25902,26048,26048,26195,26195,26341,26341,26414,26487,26487,26560,26634,26634,26780,26780,26926,27219,27512,27585,27658,27731,27804,27804,28097,28097,28390,28682,28682,28975,29268,29268,29560,29560,29853,29853,30146,30439,30439,30731,31024,31024,31317,31609,31609,31902,32195,32195,32487,32780,32780,32780,33365,33365,33365,33951,33951,34243,34536,34536,34829,35121,35121,35414,35707,35707,35707,35999,36292,36585,36878,36878,37024,37024,37170,37170,37463,37463,37463,37609,37756,37756,37902,38048,38048,38195,38341,38341,38487,38634,38634,38780,38926,39073,39219,39365,39512,39658,39804,39804,39951,40097,40097,40243,40390,40390,40536,40682,40829,40975,40975,41121,41268,41414,41560,41707,41853,41999,42146,42146,42292,42292,42439,42585,42731,42731,42878,42878,43024,43170,43317,43317,43463,43463,43609,43609,43682,43756,43756,43829,43902,43902,44048,44048,44195,44195,44341,44341,44487,44560,44634,44707,44780,44853,44926,44999,45073,45146,45219,45292,45365,45439,45512,45585,45658,45658,45804,45951,45951,46097,46243,46243,46536,46536,46536,46829,46829,46902,46975,47121,47121,47268,47414,47414,47560,47634,47707,47707,47853,47926,47999,47999,48146,48292,48292,48439,48585,48585,48731,48878,48878,49024,49170,49170,49243,49317,49463,49463,49609,49756,49756,49902,49975,50048,50048,50121,50195,50268,50341,50341,50487,50487,50707,50707,50926,50926,51073,51219,51365,51512,51512,51585,51658,51804,51804,51951,52097,52097,52170,52243,52317,52390,52390,52536,52609,52682,52682,52829,52975,52975,53121,53268,53268,53414,53560,53560,53707,53853,53853,53926,53999,54073,54146,54146,54219,54292,54365,54439,54439,54512,54585,54658,54731,54731,54878,54878,55024,55024,55024,55317,55317,55317,55609,55609,55609,55902,55902,55902,56195,56268,56341,56487,56487,56634,56780,56780,56926,56999,57073,57073,57219,57292,57365,57365,57512,57658,57658,57804,57951,57951,58097,58243,58243,58390,58536,58536,58609,58682,58829,58829,58975,59121,59121,59268,59341,59414,59414,59560,59634,59707,59707,59853,59926,59999,59999,60073,60292,60292,60439,60585,60585,60731,60878,60878,60951,61024,61024,61170,61170,61317,61317,61463,61463,61463,61536,61609,61609,61756,61756,61902,61902,62048,62048,62048,62121,62195,62195,62341,62341,62414,62487,62560,62634,62634,62780,62780,62926,62926,63073,63073,63219,63219,63292,63365,63439,63512,63512,63585,63658,63731,63804,63804,63878,63951,64024,64097,64097,64170,64243,64317,64390,64390,64536,64536,64609,64682,64829,64975,65121,65268,65414,65560,65560,65707,65853,65999,66146,66146,66439,66585,66878,67170,67317,67317,67609,67902,68048,68195,68341,68487,68487,68780,68926,69073,69219,69365,69512,69658,69658,69804,69951,70243,70390,70536,70682,70829,70829,71121,71268,71560,71853,71999,71999,72292,72585,72731,72878,73024,73170,73317,73463,73609,73609,73756,73975,74195,74341,74341,74634,74707,74780,74926,74926,75073,75073,75219,75219,75219,75365,75512,75512,75658,75658,75804,75804,75804,75951,76097,76097,76390,76390,76390,76536,76682,76682,76829,76829,76975,76975,76975,77268,77268,77414,77560,77560,77561,77707,77853,77853,77999,77999,78146,78146,78146,78292,78439,78439,78731,78732,78732,78878,79024,79024,79170,79171,79317,79317,79463,79609,79609,79756,79902,79902,80048,80195,80341,80341,80487,80487,80634,80780,80780,80926,80926,81073,81073,81073,81219,81365,81512,81512,81658,81658,81658,81951,81951,81951,82097,82243,82243,82390,82536,82682,82682,82829,82829,82829,82975,83121,83121,83268,83414,83414,83560,83707,83853,83853,83999,83999,83999,84292,84292,84365,84439,84512,84585,84585,84731,84804,84878,84878,84951,85024,85097,85170,85170,85317,85390,85463,85463,85536,85609,85682,85756,85756,85829,85902,85975,86048,86048,86121,86195,86268,86341,86341,86487,86634,86634,86707,86780,86853,86926,86926,87073,87146,87219,87219,87292,87365,87439,87512,87512,87658,87804,87804,87878,87951,88024,88097,88097,88170,88243,88317,88390,88390,88536,88609,88682,88682,88829,88975,88975,89121,89121,89268,89268,89414,89414,89560,89560,89707,89707,89853,89853,89999,89999,90146,90146,90292,90292,90439,90439,90585,90585,90731,90731,90878,90878,91024,91024,91170,91170,91317,91317,91390,91463,91536,91609,91682,91756,91829,91902,91975,92048,92121,92195,92268,92341,92634,92780,92926,93219,93365,93365,93365,93365,93658,93658,93804,93878,93951,93951,94097,94243,94317,94390,94463,94536,94536,94682,94829,94829,94975,95121,95121,95268,95414,95487,95560,95634,95707,95707,95853,95853,95999,95999,96146,96292,96292,96292,96439,96585,96585,96658,96731,96804,96878,96878,97024,97170,97170,97317,97390,97463,97463,97609,97756,97756,97829,97902,98048,98048,98048,98195,98341,98341,98487,98560,98634,98634,98780,98926,98926,99073,99219,99219,99365,99512,99512,99658,99804,99804,99951,100097,100170,100243,100317,100390,100390,100536,100682,100682,100829,100975,100975,100975,101121,101268,101268,101341,101414,101487,101560,101560,101707,101853,101853,101926,101999,102073,102146,102146,102292,102439,102439,102439,102585,102658,102731,102731,102878,103024,103024,103024,103170,103243,103317,103317,103317,103463,103609,103682,103756,103829,103902,103902,104048,104195,104195,104341,104487,104487,104487,104634,104780,104853,104926,104999,105073,105073,105219,105365,105365,105512,105658,105658,105658,105804,105951,105951,106097,106170,106243,106243,106317,106390,106536,106536,106682,106756,106829,106829,106829,106975,107121,107121,107268,107268,107414,107414,107414,107560,107707,107707,107707,107853,107999,107999,107999,108146,108292,108292,108439,108585,108585,108731,108878,108878,108878,109024,109170,109170,109317,109463,109463,109536,109609,109682,109756,109756,109902,110048,110048,110048,110195,110195,110341,110341,110341,110487,110487,110634,110634,110634,110780,110780,110926,110926,110926,111073,111073,111219,111219,111219,111365,111512,111658,111731,111804,111878,111951,112024,112097,112097,112097,112390,112390,112536,112682,112682,112682,112829,112975,112975,113121,113268,113268,113414,113560,113560,113707,113853,113853,113999,114146,114219,114292,114365,114439,114439,114585,114731,114731,114878,115024,115024,115024,115170,115317,115317,115463,115536,115609,115609,115756,115902,115902,115975,116048,116121,116195,116195,116268,116341,116414,116487,116487,116560,116634,116707,116780,116780,116926,117073,117073,117219,117365,117365,117512,117658,117658,117804,117878,117951,117951,118097,118243,118243,118390,118536,118536,118682,118829,118902,118975,119048,119121,119121,119268,119414,119414,119560,119707,119707,119853,119999,119999,120146,120292,120292,120439,120439,120731,121024,121170,121463,121536,121609,121682,121756,121756,121756,121902,122048,122048,122048,122195,122341,122341,122341,122487,122560,122634,122634,122634,122780,122926,122926,122926,123073,123219,123219,123219,123365,123512,123512,123512,123585,123658,123731,123804,123804,123804,123951,124097,124097,124097,124243,124390,124390,124390,124536,124682,124682,124682,124829,124975,124975,124975,125121,125268,125268,125268,125414,125487,125560,125560,125560,125707,125853,125853,125853,125999,126146,126146,126146,126292,126439,126439,126439,126585,126585,126731,126731,126878,126878,127024,127024,127024,127170,127170,127317,127317,127463,127463,127609,127609,127609,127756,127756,127902,127902,128048,128048,128195,128195,128268,128341,128341,128414,128487,128487,128560,128634,128707,128780,128780,128853,128926,128999,129073,129146,129219,129292,129365,129365,129439,129512,129585,129658,129731,129804,129878,129951,129951,130024,130097,130170,130243,130243,130317,130390,130463,130536,130536,130682,130756,130829,130829,130829,130975,130975,131121,131195,131268,131341,131560,131707,131707,131780,131853,131926,132146,132292,132365,132439,132512,132731,132878,132878,132951,133024,133097,133463,133463,133756,134048,134048,134048,134341,134634,134634,134926,134926,135219,135219,135219,135512,135512,135658,135658,135804,135804,135951,135951,136097,136097,136243,136243,136390,136390,136536,136536,136609,136682,136682,136829,136829,136902,136975,136975,137121,137121,137268,137268,137414,137414,137560,137560,137707,137707,137780,137853,137926,137999,137999,138073,138146,138146,138219,138292,138365,138439,138439,138512,138585,138658,138731,138731,138804,138878,138951,139024,139024,139097,139170,139243,139317,139317,139463,139463,139609,139609,139756,139756,139902,139902,140195,140195,140195,140195 &#125;;</span><br><span class="line"></span><br><span class="line">DWORD __ROR4__(DWORD a1, char a2)</span><br><span class="line">&#123;</span><br><span class="line">  return (a1 &gt;&gt; a2) | (a1 &lt;&lt; (32 - a2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int rounds(uint8_t* bytes, unsigned int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  DWORD* v3; // r4</span><br><span class="line">  DWORD v4; // r12</span><br><span class="line">  DWORD v5[2]; // r5</span><br><span class="line">  DWORD v6; // r3</span><br><span class="line">  DWORD result; // r0</span><br><span class="line"></span><br><span class="line">  v3 = (DWORD*)((char*)bytes + a3);</span><br><span class="line">  v4 = *(DWORD*)((char*)bytes + a3);</span><br><span class="line">  *(DWORD64*)&amp;v5[0] = *(DWORD64*)((char*)bytes + a3 + 4);</span><br><span class="line">  v6 = *(DWORD*)((char*)bytes + a3 + 12);</span><br><span class="line">  *(DWORD*)((char*)bytes + a3) = *(&amp;v5[0] + 1);</span><br><span class="line">  result = v4 ^ __ROR4__(*(&amp;v5[0] + 1) ^ a2, 19);</span><br><span class="line">  v3[3] = v5[0] ^ __ROR4__(v6, 18) ^ __ROR4__(*(&amp;v5[0] + 1) ^ a2, 19);</span><br><span class="line">  v3[1] = v6;</span><br><span class="line">  v3[2] = result;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char enc_bytes[] =</span><br><span class="line">  &#123;</span><br><span class="line">    0x3C, 0xAC, 0x92, 0x6F, 0x44, 0xA1, 0xC1, 0x17, 0xFD, 0x62,</span><br><span class="line">    0x60, 0xDD, 0x63, 0xF8, 0xE3, 0x2A, 0x5E, 0x75, 0x78, 0xBE,</span><br><span class="line">    0x59, 0x46, 0x33, 0xF6, 0x2E, 0x64, 0x61, 0x8A, 0x27, 0x93,</span><br><span class="line">    0x21, 0x7D, 0x00</span><br><span class="line">  &#125;;</span><br><span class="line">  mt19937 rng(-196167794);</span><br><span class="line">  for (int i = 0; i &lt; 1608; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    if (rng() % 7 &gt;= 3)</span><br><span class="line">    &#123;</span><br><span class="line">      rounds(enc_bytes, rng(), hitp[i] &amp; 0xF);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%s\n&quot;, enc_bytes);</span><br><span class="line">  getchar();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">D3CTF&#123;Gb78e-7b04-4364-82d2-7f44&#125;</span><br></pre></td></tr></table></figure>

<p>最后得到flag：D3CTF{Gb78e-7b04-4364-82d2-7f44}</p>
]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>复现</tag>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫_逆向</title>
    <url>/2022/03/02/%E8%BF%B7%E5%AE%AB-%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<h1 id="迷宫-逆向"><a href="#迷宫-逆向" class="headerlink" title="迷宫_逆向"></a>迷宫_逆向</h1><h2 id="深度优先算法介绍"><a href="#深度优先算法介绍" class="headerlink" title="深度优先算法介绍"></a>深度优先算法介绍</h2><blockquote>
<p>深度优先搜索算法（Depth-First-Search），是搜索算法的一种。是沿着树的深度遍历树的节点，<strong>尽可能深</strong>的搜索树的分支。当节点v的所有边都己被探寻过，搜索将<strong>回溯</strong>到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于<strong>盲目搜索</strong>。</p>
</blockquote>
<h2 id="深度优先算法在迷宫中的使用"><a href="#深度优先算法在迷宫中的使用" class="headerlink" title="深度优先算法在迷宫中的使用"></a>深度优先算法在迷宫中的使用</h2><p>二维的迷宫：</p>
<ul>
<li>使用递归的方法，用栈的思想放入和取出路径，用数组的方式存放迷宫图</li>
<li>使用for循环遍历四个方向，在每个节点选择走的方向，如果按这个方向向下走一步能够满足条件（不是墙并且没有到达过），就可以将这一步的目标地址进行标记（已经走过），并且将走的方向放入路径之中</li>
<li>当死路的时候就会向上返回。如果四个方向都遍历，没有一个方向能够满足条件，那么就会返回上一轮，并且将这步错误的方向在路径之中去除，并且将这个地址再次标记为未可达</li>
<li>递归的结束条件。已经到达了目标地址的坐标，就可以返回这个路径了</li>
</ul>
<h2 id="二维迷宫题算法实现"><a href="#二维迷宫题算法实现" class="headerlink" title="二维迷宫题算法实现"></a>二维迷宫题算法实现</h2><h3 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h3><p>map：迷宫地图，数组需要在声明的时候进行初始化</p>
<p>stages：上下左右的表示方法</p>
<p>n,m：一共有多少排多少列</p>
<p>stx,sty：迷宫起始的位置，需要对应数组的下标</p>
<p>endx,endy：迷宫终点的位置，需要对应数组相应的下标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> tmap[<span class="number">32</span>][<span class="number">32</span>]=&#123;<span class="string">&quot;00000&quot;</span>,<span class="string">&quot;01100&quot;</span>,<span class="string">&quot;00100&quot;</span>,<span class="string">&quot;00110&quot;</span>,<span class="string">&quot;00000&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> sign[<span class="number">50</span>][<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 右左下上</span></span><br><span class="line"><span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> stages[] = <span class="string">&quot;dasw&quot;</span>;</span><br><span class="line"><span class="comment">//这个迷宫有几排几列，用于判断有没有超出边界</span></span><br><span class="line"><span class="type">int</span> n=<span class="number">5</span>,m=<span class="number">5</span>;</span><br><span class="line"><span class="comment">// 标记起始位置</span></span><br><span class="line"><span class="type">int</span> stx=<span class="number">1</span>,sty=<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 标记终点位置</span></span><br><span class="line"><span class="type">int</span> endx=<span class="number">3</span>,endy=<span class="number">3</span>;</span><br><span class="line"><span class="comment">// road 路径</span></span><br><span class="line"><span class="type">char</span> road[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//已经走了多少步了</span></span><br><span class="line"><span class="type">int</span> steps=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addSteps</span><span class="params">(<span class="type">char</span> stage)</span>&#123;</span><br><span class="line">    road[steps] = stage;</span><br><span class="line">    steps++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">subSteps</span><span class="params">()</span>&#123;</span><br><span class="line">    steps--;</span><br><span class="line">    road[steps] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先算法 提供的参数是走迷宫的起始位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tx,ty;</span><br><span class="line">    <span class="keyword">if</span>(x == endx&amp;&amp;y == endy)&#123;</span><br><span class="line">        <span class="comment">//到达了最后的地方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;走的路径是：%s&quot;</span>,(<span class="type">char</span>*)road);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//tx 和 ty标记到达地址</span></span><br><span class="line">            tx = x+next[i][<span class="number">0</span>];</span><br><span class="line">            ty = y+next[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 当沿着这个方向的下一步不是墙 不是已经走过的地方 并且到达的这个地址在范围之内</span></span><br><span class="line">        <span class="keyword">if</span>(tx&gt;=<span class="number">0</span>&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=<span class="number">0</span>&amp;&amp;ty&lt;m&amp;&amp;tmap[ty][tx]!=<span class="string">&#x27;0&#x27;</span>&amp;&amp;sign[ty][tx]==<span class="number">0</span>)&#123;</span><br><span class="line">            sign[ty][tx]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将之前长度的字符串放入到其中 并且再添加一个字符（表示这一步的方向）</span></span><br><span class="line">            addSteps(stages[i]);</span><br><span class="line">            dfs(tx,ty);</span><br><span class="line">            sign[ty][tx]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//除去最后一步</span></span><br><span class="line">            subSteps();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当四个方向都不满足的时候跳出循环</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    dfs(stx,sty);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：dssd</span><br></pre></td></tr></table></figure>



<h3 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h3><p>使用脚本的时候根据题目的不同需要进行修改的脚本之中的参数有</p>
<p>map：map使用数字类型的数字表示，还是用char类型的数组表示，map的声明以及每一步的是否正确的判断条件都是不一样的</p>
<p>stx和sty：迷宫的起点，数组的起点是从0开始标识的</p>
<p>endx和endy：迷宫的终点，注意数组的下标</p>
<p>signdirect：题目之中这四个方向所代表的字符都是不一样的，需要根据题目的要求具体的表示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># map是迷宫</span></span><br><span class="line"><span class="built_in">map</span> = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line"><span class="comment"># 标记该路径是否走过 5*5的数组的表示方法</span></span><br><span class="line">sign = [[<span class="number">0</span>]*<span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 起始的位置</span></span><br><span class="line">stx = <span class="number">1</span></span><br><span class="line">sty = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记下一步的地址</span></span><br><span class="line">endx = <span class="number">0</span></span><br><span class="line">endy = <span class="number">0</span></span><br><span class="line"><span class="comment"># 每次走的方向 路径</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 标记走的四个方向</span></span><br><span class="line">direct = [[<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 这四个方向的表示方法</span></span><br><span class="line">signdirect=<span class="string">&#x27;dasw&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度遍历方法的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y</span>):</span><br><span class="line">  <span class="keyword">global</span> flag   <span class="comment">#注意在函数里面要当全局变量使用的变量一定要在函数之中进行声明！！！！！！</span></span><br><span class="line">  endx = <span class="number">0</span></span><br><span class="line">  endy = <span class="number">0</span></span><br><span class="line">  <span class="comment"># 到达终点</span></span><br><span class="line">  <span class="keyword">if</span> x==finalx <span class="keyword">and</span> y==finaly:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment"># 未到达终点之前遍历四个方向</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(direct)):</span><br><span class="line">    endx = x+direct[i][<span class="number">0</span>]</span><br><span class="line">    endy = y+direct[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> endy&gt;=<span class="number">0</span> <span class="keyword">and</span> endy&lt;<span class="built_in">len</span>(<span class="built_in">map</span>) <span class="keyword">and</span> endx&gt;=<span class="number">0</span> <span class="keyword">and</span> endx&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>]) <span class="keyword">and</span> <span class="built_in">map</span>[endy][endx] == <span class="number">1</span> <span class="keyword">and</span> sign[endy][endx] !=<span class="number">1</span>:</span><br><span class="line">      sign[endy][endx] = <span class="number">1</span></span><br><span class="line">      flag=flag+signdirect[i]</span><br><span class="line">      dfs(endx,endy)</span><br><span class="line">      sign[endy][endx] = <span class="number">0</span></span><br><span class="line">      flag = flag[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dfs(stx,sty)</span><br><span class="line">运行结果： dssd</span><br></pre></td></tr></table></figure>

<p>如果是用字符串的形式声明迷宫时，map的表示方式，及脚本之中需要改变的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map = [&quot;00000&quot;,&quot;01100&quot;,&quot;00100&quot;,&quot;00110&quot;,&quot;00000&quot;]</span><br><span class="line"># 每一步判断条件的 map[endy][endx] == &#x27;1&#x27; 要修改成满足要求的对应字符而不是数字了</span><br><span class="line">if endy&gt;=0 and endy&lt;len(map) and endx&gt;=0 and endx&lt;len(map[0]) and map[endy][endx] == &#x27;1&#x27; and sign[endy][endx] !=1:    </span><br></pre></td></tr></table></figure>

<h2 id="三维迷宫题的算法实现"><a href="#三维迷宫题的算法实现" class="headerlink" title="三维迷宫题的算法实现"></a>三维迷宫题的算法实现</h2><h3 id="python版本-1"><a href="#python版本-1" class="headerlink" title="python版本"></a>python版本</h3><p>这里需要输入的参数和二维的脚本差不多，只是要多一个z轴上的坐标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">map</span> = [[ <span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaeee&quot;</span>],[<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>],[<span class="string">&quot;aeeaa&quot;</span>,<span class="string">&quot;aeeaa&quot;</span>,<span class="string">&quot;eeeae&quot;</span>,<span class="string">&quot;eaaae&quot;</span>,<span class="string">&quot;eaaae&quot;</span>],[<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;eaaee&quot;</span>],[ <span class="string">&quot;aaeea&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aeeea&quot;</span>,<span class="string">&quot;eeaea&quot;</span>,<span class="string">&quot;eaaea&quot;</span>]]</span><br><span class="line"></span><br><span class="line">sign = [[[<span class="number">0</span>]*<span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 标记起始位置</span></span><br><span class="line">stx = <span class="number">2</span></span><br><span class="line">sty = <span class="number">4</span></span><br><span class="line">stz = <span class="number">0</span></span><br><span class="line"><span class="comment"># 标识终点位置</span></span><br><span class="line">finalx = <span class="number">2</span></span><br><span class="line">finaly = <span class="number">2</span></span><br><span class="line">finalz = <span class="number">2</span></span><br><span class="line"><span class="comment"># 标记下一步的地址</span></span><br><span class="line">endx = <span class="number">0</span></span><br><span class="line">endy = <span class="number">0</span></span><br><span class="line">endz = <span class="number">0</span></span><br><span class="line"><span class="comment"># 每次走的方向 路径</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 标记走的四个方向</span></span><br><span class="line">direct = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line">signdirect=<span class="string">&#x27;daswxy&#x27;</span></span><br><span class="line"><span class="comment"># 深度遍历方法的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y,z</span>):</span><br><span class="line">  <span class="keyword">global</span> flag   <span class="comment">#注意在函数里面要当全局变量使用的变量一定要在函数之中进行声明！！！！！！</span></span><br><span class="line">  endx = <span class="number">0</span></span><br><span class="line">  endy = <span class="number">0</span></span><br><span class="line">  endz = <span class="number">0</span></span><br><span class="line">  <span class="comment"># 到达终点</span></span><br><span class="line">  <span class="keyword">if</span> x==finalx <span class="keyword">and</span> y==finaly <span class="keyword">and</span> z==finalz:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment"># 未到达终点之前遍历6个</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(direct)):</span><br><span class="line">    endx = x+direct[i][<span class="number">0</span>]</span><br><span class="line">    endy = y+direct[i][<span class="number">1</span>]</span><br><span class="line">    endz = z+direct[i][<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> endy&gt;=<span class="number">0</span> <span class="keyword">and</span> endy&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>]) <span class="keyword">and</span> endx&gt;=<span class="number">0</span> <span class="keyword">and</span> endx&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>][<span class="number">0</span>]) <span class="keyword">and</span> endz&gt;=<span class="number">0</span> <span class="keyword">and</span> endz&lt;<span class="built_in">len</span>(<span class="built_in">map</span>) <span class="keyword">and</span> <span class="built_in">map</span>[endz][endy][endx] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">and</span> sign[endz][endy][endx] !=<span class="number">1</span>:</span><br><span class="line">      sign[endz][endy][endx] = <span class="number">1</span></span><br><span class="line">      flag=flag+signdirect[i]</span><br><span class="line">      dfs(endx,endy,endz)</span><br><span class="line">      sign[endz][endy][endx] = <span class="number">0</span></span><br><span class="line">      flag = flag[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dfs(stx,sty,stz)</span><br><span class="line"><span class="comment"># 这里返回的结果有多个，选取其中最短的那个即为正确答案   ddwwxxssxaxwwaasasyywwdd</span></span><br><span class="line">ddwwxxssxaxwwaasasyywwdd</span><br><span class="line">ddwwxxssxaxwwaasasyywwdwds</span><br><span class="line">ddwwxxssxaxwwaasasyywwdwwdss</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdd</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdwds</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdwwdss</span><br></pre></td></tr></table></figure>

<p>有时候迷宫的走法不止一个，就取走的路程最小的那个就可以了</p>
]]></content>
      <categories>
        <category>题型</category>
      </categories>
      <tags>
        <tag>迷宫</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向之native层的so文件格式</title>
    <url>/2022/03/03/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="安卓逆向之native层的so文件格式"><a href="#安卓逆向之native层的so文件格式" class="headerlink" title="安卓逆向之native层的so文件格式"></a>安卓逆向之native层的so文件格式</h1><h2 id="安卓逆向的相关工具介绍"><a href="#安卓逆向的相关工具介绍" class="headerlink" title="安卓逆向的相关工具介绍"></a>安卓逆向的相关工具介绍</h2><p>反编译代码的工具：</p>
<ul>
<li><a href="https://sourceforge.net/projects/dex2jar/files/">dex2jar</a>:把dex文件转成jar文件</li>
<li><a href="http://java-decompiler.github.io/">jd-gui</a>: 这个工具用于将jar文件转换成java代码</li>
</ul>
<p>反编译资源的工具：</p>
<ul>
<li><a href="https://ibotpeaches.github.io/Apktool/install/">APKTool</a>: 本文重要工具，APK逆向工具。它可以将资源解码，并在修改后可以重新构建它们。它还可以执行一些自动化任务，例如构建apk。解码就是将其恢复成未打包的资源文件（包括resources.arsc，class.dex，9.png和xml）；解码的资源可以重新打包成apk/jar文件；组织和处理依赖于框架资源的APK；Smali调试；执行自动化任务</li>
<li><strong>JEB</strong>:JEB是一个功能强大为安全专业人士设计的安卓应用程序反编译工具，用于逆向工程或者审计apk文件。它是可以直接反编译apk文件的。</li>
<li><a href="https://github.com/skylot/jadx">jadx</a>：jadx是一款反编译利器，同时支持命令行和图形界面，能以最简便的方式完成apk的反编译操作。工具支持<strong>apk、dex、jar、aar</strong>等格式的文件</li>
</ul>
<h2 id="so文件介绍"><a href="#so文件介绍" class="headerlink" title="so文件介绍"></a>so文件介绍</h2><p><strong>概念</strong>：.so 文件是ELF对象文件中可被共享的对象文件(Shared object file)，这些就是所谓的动态库文件。</p>
<p><strong>动态文件的作用</strong>：如果用静态库来生成可执行程序，那每个生成的可执行程序中都会有一份库代码的拷贝。如果在磁盘中存储这些可执行程序，那就会占用额外的磁盘空 间；另外如果拿它们放到Linux系统上一起运行，也会浪费掉宝贵的物理内存。如果将静态库换成动态库，那么这些问题都不会出现。</p>
<p>Android中的so文件就是elf文件，所以需要了解so文件，必须先来了解一下elf文件的格式。</p>
<h3 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h3><p>为了让大家对elf文件格式有一个整体的了解，首先先看一张非虫先生总结好的图片讲解：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/20140918103240781.png" alt="20140918103240781.png"></p>
<p>ELF文件的两种视图，分别是<strong>链接视图</strong>和<strong>执行视图</strong>。</p>
<p><strong>链接视图</strong>：是在<strong>链接时</strong>用到的视图， 以<strong>节</strong>（section）为单位，下图<strong>左侧</strong>的视角是从链接来看的。从图中我们得到，在链接阶段，我们可以忽略<strong>program header table</strong>来处理此文件，因为它是按照<strong>section header table</strong>来处理此文件的。</p>
<p><strong>执行视图</strong>：在<strong>执行时</strong>用到的视图，是以<strong>段</strong>（segment）为单位，下图<strong>右侧</strong>的视角是执行来看的。从图中我们可以得到，在运行阶段可以忽略<strong>section header table</strong>来处理此程序，因为它是按照<strong>program header table</strong>来处理此文件的。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220302143454066.png" alt="image-20220302143454066"></p>
<p><strong>文件的组成</strong>：</p>
<ul>
<li><strong>ELF heade</strong>r： 描述整个文件的组织。</li>
<li><strong>Program Header Table</strong>: 描述文件中的各种segments，用来告诉系统如何创建进程映像的。 </li>
<li><strong>sections</strong> 或者 <strong>segments</strong>：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。</li>
<li><strong>Section Header Table</strong>: 包含了文件各个segction的属性信息</li>
</ul>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220302144111413.png" alt="image-20220302144111413"></p>
<p><strong>区分两种视图的原因</strong>：</p>
<p>在内存之中，多个具有<strong>相同权限</strong>（flg值）section<strong>合并</strong>一个segment。操作系统往往以<strong>页</strong>为基本单位来<strong>管理内存分配</strong>，以及<strong>内存的权限</strong>管理的粒度也是以页为单位。每个section在映射时的长度都是系统<strong>页长度的整数倍</strong>，如果section的长度不是其整数倍，则导致多余部分也将占用一个页，因为一个ELF文件具有很多的section，那么这样将会导致内存浪费严重。为了减少页面内部的碎片，节省了空间，显著提高内存利用率，就将相同权限（flg值）section合并一个segment。</p>
<h4 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h4><p>32位ELF文件中常用的<strong>数据格式</strong>：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303170256836.png" alt="image-20220303170256836"></p>
<p>ELF Header的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define EI_NIDENT 16</span><br><span class="line">typedef struct &#123;</span><br><span class="line">       unsigned char e_ident[EI_NIDENT];  // ELF的一些标识信息，前四位为.ELF,其他的信息比如大小端等</span><br><span class="line">       ELF32_Half e_type;                 // 标识了文件类型</span><br><span class="line">       ELF32_Half e_machine;              // 文件的目标体系架构，比如ARM</span><br><span class="line">       ELF32_Word e_version;              // 0为非法版本，1为当前版本</span><br><span class="line">       ELF32__Addr e_entry;               // 程序入口的虚拟地址</span><br><span class="line">       ELF32_Off e_phoff;                 // 程序头部表偏移地址</span><br><span class="line">       ELF32_Off e_shoff;                 // 节区头部表偏移地址</span><br><span class="line">       ELF32_Word e_flags;                // 保存与文件相关的，特定于处理器的标志</span><br><span class="line">       ELF32_Half e_ehsize;               // ELF头的大小</span><br><span class="line">       ELF32_Half e_phentsize;            // 每个程序头部表的大小</span><br><span class="line">       ELF32_Half e_phnum;                // 程序头部表的数量</span><br><span class="line">       ELF32_Half e_shentsize;            // 每个节区头部表的大小</span><br><span class="line">       ELF32_Half e_shnum;                // 节区头部表的数量</span><br><span class="line">       ELF32_Half e_shstrndx;             // 节区字符串表位置</span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<p>查看ELF Header结构的内容命令： readelf -h android_server</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303171118246.png" alt="image-20220303171118246"></p>
<h5 id="e-entry"><a href="#e-entry" class="headerlink" title="e_entry"></a>e_entry</h5><p>e_entry表示程序入口地址。谓<strong>程序进入点</strong>是指当程序真正执行起来的时候，要运行的指令的运行时地址。其第一条可执行文件test和动态库.so都存在所谓的进入点，且可执行文件的<strong>e_entry</strong>指向C库中的**_start<strong>，而</strong>动态库.so**中的进入点指向 <strong>call_gmon_start</strong>。</p>
<h5 id="重点关注的字段"><a href="#重点关注的字段" class="headerlink" title="重点关注的字段"></a>重点关注的字段</h5><p>在ELF Header中我们需要重点关注以下几个字段：</p>
<ul>
<li><strong>e_entry</strong>：表示程序<strong>入口地址</strong></li>
<li><strong>e_ehsize</strong>：ELF Header<strong>结构大小</strong></li>
<li><strong>e_phoff、e_phentsize、e_phnum</strong>：描述<strong>Program Header Table</strong>的偏移、大小、结构。</li>
<li><strong>e_shoff、e_shentsize、e_shnum</strong>：描述<strong>Section Header Table</strong>的偏移、大小、结构。</li>
<li><strong>e_shstrndx</strong>：这一项描述的是<strong>字符串表</strong>在<strong>Section Header Tabl</strong>e中的索引，值25表示的是Section Header Table中第25项是字符串表（String Table）</li>
</ul>
<h4 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h4><p>section head table(SHT)包含了用来描述每一个<strong>section的条目（entry）</strong>，每一个entry的内容主要包括该 section 的<strong>名称、类型、大小以及在整个ELF文件中的字节偏移位置</strong>等等。</p>
<p>每个条目结构定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    Elf32_Word sh_name;   //节区名，是节区头部字符串表节区（Section Header String Table Section）的索引。名字是一个 NULL 结尾的字符串。</span><br><span class="line">    Elf32_Word sh_type;    //为节区类型</span><br><span class="line">    Elf32_Word sh_flags;    //节区标志</span><br><span class="line">    Elf32_Addr sh_addr;    //如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应处的位置。否则，此字段为 0。</span><br><span class="line">    Elf32_Off sh_offset;    //此成员的取值给出节区的第一个字节与文件头之间的偏移。</span><br><span class="line">    Elf32_Word sh_size;   //此 成 员 给 出 节 区 的 长 度 （ 字 节 数 ）。</span><br><span class="line">    Elf32_Word sh_link;   //此成员给出节区头部表索引链接。其具体的解释依赖于节区类型。</span><br><span class="line">    Elf32_Word sh_info;       //此成员给出附加信息，其解释依赖于节区类型。</span><br><span class="line">    Elf32_Word sh_addralign;    //某些节区带有地址对齐约束.</span><br><span class="line">    Elf32_Word sh_entsize;    //某些节区中包含固定大小的项目，如符号表。对于这类节区，此成员给出每个表项的长度字节数。</span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<h4 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h4><p>有些节区是系统预订的，一般以点开头号,</p>
<h5 id="常用的系统节区"><a href="#常用的系统节区" class="headerlink" title="常用的系统节区"></a>常用的系统节区</h5><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>.bss</td>
<td>SHT_NOBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>包含将出现在程序的内存映像中的为初始化数据。根据定义，当程序开始执行，系统将把这些数据初始化为 0。此节区不占用文件空间。</td>
</tr>
<tr>
<td>.comment</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>包含版本控制信息。</td>
</tr>
<tr>
<td>.data</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td>
</tr>
<tr>
<td>.data1</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td>
</tr>
<tr>
<td>.debug</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>此节区包含用于符号调试的信息。</td>
</tr>
<tr>
<td>.dynamic</td>
<td>SHT_DYNAMIC</td>
<td></td>
<td>此节区包含动态链接信息。节区的属性将包含 SHF_ALLOC 位。是否 SHF_WRITE 位被设置取决于处理器。</td>
</tr>
<tr>
<td>.dynstr</td>
<td>SHT_STRTAB</td>
<td>SHF_ALLOC</td>
<td>此节区包含用于动态链接的字符串，大多数情况下这些字符串代表了与符号表项相关的名称。</td>
</tr>
<tr>
<td>.dynsym</td>
<td>SHT_DYNSYM</td>
<td>SHF_ALLOC</td>
<td>此节区包含了动态链接符号表。</td>
</tr>
<tr>
<td>.fini</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含了可执行的指令，是进程终止代码的一部分。程序正常退出时，系统将安排执行这里的代码。</td>
</tr>
<tr>
<td>.got</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含全局偏移表。</td>
</tr>
<tr>
<td>.hash</td>
<td>SHT_HASH</td>
<td>SHF_ALLOC</td>
<td>此节区包含了一个符号哈希表。</td>
</tr>
<tr>
<td>.init</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含了可执行指令，是进程初始化代码的一部分。当程序开始执行时，系统要在开始调用主程序入口之前（通常指 C 语言的 main 函数）执行这些代码。</td>
</tr>
<tr>
<td>.interp</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含程序解释器的路径名。如果程序包含一个可加载的段，段中包含此节区，那么节区的属性将包含 SHF_ALLOC 位，否则该位为 0。</td>
</tr>
<tr>
<td>.line</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>此节区包含符号调试的行号信息，其中描述了源程序与机器指令之间的对应关系。其内容是未定义的。</td>
</tr>
<tr>
<td>.note</td>
<td>SHT_NOTE</td>
<td>(无)</td>
<td>此节区中包含注释信息，有独立的格式。</td>
</tr>
<tr>
<td>.plt</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含过程链接表（procedure linkage table）。</td>
</tr>
<tr>
<td>.relname .relaname</td>
<td>SHT_REL SHT_RELA</td>
<td></td>
<td>这些节区中包含了重定位信息。如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含 SHF_ALLOC 位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。例如 .text 节区的重定位节区名字将是：.rel.text 或者 .rela.text。</td>
</tr>
<tr>
<td>.rodata .rodata1</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC</td>
<td>这些节区包含只读数据，这些数据通常参与进程映像的不可写段。</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含节区名称。</td>
</tr>
<tr>
<td>.strtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含字符串，通常是代表与符号表项相关的名称。如果文件拥有一个可加载的段，段中包含符号串表，节区的属性将包含SHF_ALLOC 位，否则该位为 0。</td>
</tr>
<tr>
<td>.symtab</td>
<td>SHT_SYMTAB</td>
<td></td>
<td>此节区包含一个符号表。如果文件中包含一个可加载的段，并且该段中包含符号表，那么节区的属性中包含SHF_ALLOC 位，否则该位置为 0。</td>
</tr>
<tr>
<td>.text</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含程序的可执行指令。</td>
</tr>
</tbody></table>
<h5 id="so文件中重要的Section"><a href="#so文件中重要的Section" class="headerlink" title="so文件中重要的Section"></a>so文件中重要的Section</h5><h6 id="符号表-dynsym"><a href="#符号表-dynsym" class="headerlink" title="-符号表(.dynsym)"></a><strong>-符号表(.dynsym)</strong></h6><p>符号表包含用来<strong>定位、重定位程序中符号定义和引用的信息</strong>，简单的理解就是符号表记录了该文件中的所有符号，所谓的符号就是经过<strong>修饰了的函数名或者变量名</strong>，不同的编译器有不同的修饰规则。<strong>例如</strong>符号_ZL15global_static_a，就是由global_static_a变量名经过修饰而来。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">     Elf32_Word st_name;      //符号表项名称。如果该值非0，则表示符号名的字符串表索引(offset)，否则符号表项没有名称。</span><br><span class="line">     Elf32_Addr st_value;       //符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。</span><br><span class="line">     Elf32_Word st_size;         //符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。</span><br><span class="line">     unsigned char st_info;    //符号的类型和绑定属性。</span><br><span class="line">     unsigned char st_other;  //该成员当前包含 0，其含义没有定义。</span><br><span class="line">     Elf32_Half st_shndx;        //每个符号表项都以和其他节区的关系的方式给出定义。此成员给出相关的节区头部表索引。</span><br><span class="line">&#125; Elf32_sym;</span><br></pre></td></tr></table></figure>

<p>符号表的内容</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303175513396.png" alt="image-20220303175513396"></p>
<h6 id="字符串表（-dynstr）"><a href="#字符串表（-dynstr）" class="headerlink" title="-字符串表（.dynstr）"></a><strong>-字符串表（.dynstr）</strong></h6><p>字符串表中存放着<strong>所有符号的名称字符串</strong>。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303175720635.png" alt="image-20220303175720635"></p>
<h6 id="重定位表"><a href="#重定位表" class="headerlink" title="-重定位表"></a><strong>-重定位表</strong></h6><p>重定位就是为程序不同部分<strong>分配加载地址</strong>，<strong>调整</strong>程序中的数据和代码以反映<strong>所分配地址</strong>的过程。简单的言之，则是将程序中的各个部分<strong>映射到合理的地址</strong>上来。例如，当程序调用了一个函数时，相关的调用指令必须把控制传输到适当的目标执行地址。</p>
<p>重定位文件必须包含<strong>如何修改其节区内容的信息</strong>，从而允许可执行文件和共享目标文件保存进程的程序映象的正确信息。</p>
<p>重定位表项的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Addr r_offset;     //重定位动作所适用的位置（受影响的存储单位的第一个字节的偏移或者虚拟地址）</span><br><span class="line">    Elf32_Word r_info;       //要进行重定位的符号表索引，以及将实施的重定位类型（哪些位需要修改，以及如何计算它们的取值）</span><br><span class="line">                                         //其中 .rel.dyn 重定位类型一般为R_386_GLOB_DAT和R_386_COPY；.rel.plt为R_386_JUMP_SLOT</span><br><span class="line">&#125; Elf32_Rel; </span><br></pre></td></tr></table></figure>

<p>r_info 成员使用 <strong>ELF32_R_TYPE 宏运算</strong>可得到<strong>重定位类型</strong>，使用 <strong>ELF32_R_SYM 宏运算</strong>可得到符号在符号表里的<strong>索引值</strong>。</p>
<p>三种宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ELF32_R_SYM(i) ((i)&gt;&gt;8)</span><br><span class="line">#define ELF32_R_TYPE(i) ((unsigned char)(i))</span><br><span class="line">#define ELF32_R_INFO(s, t) (((s)&lt;&lt;8) + (unsigned char)(t))</span><br></pre></td></tr></table></figure>

<p>重定位表中的内容</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303180343936.png" alt="image-20220303180343936"></p>
<h4 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h4><p>程序头部（Program Header）用来在文件中定位各个段的映像,同时包含其他一些用来为程序创建映像所必须的信息。</p>
<p>文件头部的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Word p_type;           //此数组元素描述的段的类型，或者如何解释此数组元素的信息。 </span><br><span class="line">    Elf32_Off  p_offset;           //此成员给出从文件头到该段第一个字节的偏移</span><br><span class="line">    Elf32_Addr p_vaddr;         //此成员给出段的第一个字节将被放到内存中的虚拟地址</span><br><span class="line">    Elf32_Addr p_paddr;        //此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息。</span><br><span class="line">    Elf32_Word p_filesz;         //此成员给出段在文件映像中所占的字节数。可以为0。</span><br><span class="line">    Elf32_Word p_memsz;     //此成员给出段在内存映像中占用的字节数。可以为0。</span><br><span class="line">    Elf32_Word p_flags;         //此成员给出与段相关的标志。</span><br><span class="line">    Elf32_Word p_align;        //此成员给出段在文件中和内存中如何对齐。</span><br><span class="line">&#125; Elf32_phdr;</span><br></pre></td></tr></table></figure>

<p>程序头部表中的内容：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303181440086.png" alt="image-20220303181440086"></p>
<p>so文件格式中结构体的某些参数未详细说明，可以去查看下面的这个参考文章。</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/mergerly/article/details/94585901">https://blog.csdn.net/mergerly/article/details/94585901</a></p>
]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>so文件</tag>
      </tags>
  </entry>
  <entry>
    <title>陇原战疫2021网络安全大赛</title>
    <url>/2022/03/29/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="陇原战”疫”2021网络安全大赛"><a href="#陇原战”疫”2021网络安全大赛" class="headerlink" title="陇原战”疫”2021网络安全大赛"></a>陇原战”疫”2021网络安全大赛</h1><p>最后还加了一道周末打的DASCTF比赛的re题目</p>
<h2 id="findme"><a href="#findme" class="headerlink" title="findme"></a>findme</h2><p>RC4加密</p>
<h3 id="定位加密函数"><a href="#定位加密函数" class="headerlink" title="定位加密函数"></a>定位加密函数</h3><p>在main函数之中是主逻辑</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193151182.png" alt="image-20220324193151182"></p>
<p>通过里面比较的函数定位到对应的位置，发现是引用了strcmp这个函数</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193140351.png" alt="image-20220324193140351"></p>
<p>可以看到这个函数可能被另外一个函数改动了，定位到这个函数，这一看到这个函数把strcmp指引到了另外一个函数</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193117669.png" alt="image-20220324193117669"></p>
<h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><p>S盒的生成</p>
<p>它的S盒是利用用户输入的密钥生成S盒</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193044135.png" alt="image-20220324193044135"></p>
<p>利用密钥流进行加密的操作</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193028708.png" alt="image-20220324193028708"></p>
<h4 id="RC4加密的函数"><a href="#RC4加密的函数" class="headerlink" title="RC4加密的函数"></a>RC4加密的函数</h4><p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193322692.png" alt="image-20220324193322692"></p>
<h4 id="S盒的生成"><a href="#S盒的生成" class="headerlink" title="S盒的生成"></a>S盒的生成</h4><p>S盒的生成的函数：sub_40164C((int)v9, (int)v7, v4);</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193416009.png" alt="image-20220324193416009"></p>
<p>对输入进行加密的函数：sub_401767((int)v8, (int)v6, v10); </p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193543255.png" alt="image-20220324193543255"></p>
<p>所以将内存之中需要解密的数据dump出来</p>
<h3 id="密文"><a href="#密文" class="headerlink" title="密文"></a>密文</h3><p>需要解密的对象是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0xb7,0x52,0x85,0xc1,0x90,0xe9,0x07,0xb8,0xe4,0x1a,0xc3,0xbd,0x1d,0x8e,0x85,0x46,0x00,0x21,0x44,0xaf,0xef,0x70,0x32,0xb5,0x11,0xc6]</span><br></pre></td></tr></table></figure>

<h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥是引用该函数输入的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SETCTF2021</span><br></pre></td></tr></table></figure>

<h3 id="和密文进行异或的数组"><a href="#和密文进行异或的数组" class="headerlink" title="和密文进行异或的数组"></a>和密文进行异或的数组</h3><p>输入的字符串和图中的数进行异或运算就得到加密的结果，所以我们可以输入26个字符(这里输入的是flag{11111111111111111111})，得到加密的结果</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324205255817.png" alt="image-20220324205255817"></p>
<p>利用这个加密的结果和输入的字符串对应进行异或运算，再和最后对比结果进行异或运算，就能够得到正确的flag</p>
<p>假flag异或运算得到的结果</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324205611680.png" alt="image-20220324205611680"></p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [  0x82, 0x7B, 0xB0, 0xE5, 0xBF, 0x9E, 0x4D, 0xDD, 0xBD, 0x1A,</span><br><span class="line">  0x81, 0xD3, 0x45, 0x8A, 0xEB, 0x32, 0x03, 0x4F, 0x40, 0xEA,</span><br><span class="line">  0x8C, 0x22, 0x6E, 0xBD, 0x01, 0xC6]</span><br><span class="line">obj2 = [0xb7,0x52,0x85,0xc1,0x90,0xe9,0x07,0xb8,0xe4,0x1a,0xc3,0xbd,0x1d,0x8e,0x85,0x46,0x00,0x21,0x44,0xaf,0xef,0x70,0x32,0xb5,0x11,0xc6]</span><br><span class="line">str = &#x27;flag&#123;11111111111111111111&#125;&#x27;</span><br><span class="line">for i in range(len(obj)):</span><br><span class="line">    print(chr(obj[i]^obj2[i]^ord(str[i])),end=&#x27;&#x27;)</span><br><span class="line">SETCTF&#123;Th1s_i5_E2_5tRcm9!&#125;</span><br></pre></td></tr></table></figure>

<p>所以最后的flag是 SETCTF{Th1s_i5_E2_5tRcm9!}</p>
<p>这里如果使用RC4解密的问题是，最后对比的加密结果不能转换成char类型</p>
<h2 id="power"><a href="#power" class="headerlink" title="power"></a>power</h2><p>这是一个arm汇编源文件</p>
<h3 id="arm文件的编译"><a href="#arm文件的编译" class="headerlink" title="arm文件的编译"></a>arm文件的编译</h3><p>在linux之中使用 arm-linux-gnueabi-as power -o power.o 将其编译为elf文件，然后拖入ida32之中即可找到下面这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-as power -o power.o</span><br></pre></td></tr></table></figure>



<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324220844188.png" alt="image-20220324220844188"></p>
<h3 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h3><p>得到的代码我们能够看出这里使用的是AES加密 ，从图中标记的地方知道，虽然这个地方用的函数是cbc加密模式，但是从循环语句，每次加密16个字符（128位），把32个字符的输入分成了前16个和后16个字符各为一组数据，这样的加密模式显示是ECB模式</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324214742877.png" alt="image-20220324214742877"></p>
<p>从上面我们能够知道加密的结果 hex类型的数据：1030a9254d44937bed312da03d2db9adbec5762c2eca7b5853e489d2a140427b</p>
<p>密钥是16字节的字符串：this_is_a_key!!!</p>
<p>偏移量是：this_is_a_key!!!</p>
<h3 id="AES解密"><a href="#AES解密" class="headerlink" title="AES解密"></a>AES解密</h3><p>故用在线解密软件得到解密的结果是：</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324215149254.png" alt="image-20220324215149254"></p>
<p>最后的flag是 flag{y0u_found_the_aes_12113112}</p>
<h2 id="EasyRE-Revenge"><a href="#EasyRE-Revenge" class="headerlink" title="EasyRE_Revenge"></a>EasyRE_Revenge</h2><p>通过字符串定位到关键代码</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220325122807647.png" alt="image-20220325122807647"></p>
<p>先对输入的长度进行判断（32），再对输入进行变换</p>
<p>将跳转到另外一个函数，但是发现这个函数要去花指令之后才能反编译</p>
<p>加密输入，和加密结果进行对比的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x42, 0xB0, 0xE8, 0xEE, 0x6C, 0xEE, 0xD0, 0x57, 0x32, 0x4B, </span><br><span class="line">0xF5, 0xF3, 0xD6, 0xB7, 0xF0, 0xD3, 0x89, 0xC3, 0x61, 0x0A, </span><br><span class="line">0x40, 0xBA, 0xC7, 0x38, 0x2C, 0x9E, 0x3D, 0x0C, 0x84, 0x92, </span><br><span class="line">0x4A, 0xD6</span><br></pre></td></tr></table></figure>

<h3 id="Eat-something"><a href="#Eat-something" class="headerlink" title="Eat_something"></a>Eat_something</h3><p>得到了一个页面，这里关键代码再wasm文件之中</p>
<p>wasm文件：</p>
<blockquote>
<p>wasm 是 <strong>WebAssembly 的二进制文件</strong>，包含二进制字节码。 写网站基本上是用 JavaScript, 当 JavaScript 速度不够快时，某个模块就可以用 C/C++ 编写，再编译成 wasm，供 JS 调用</p>
</blockquote>
<p>页面网络之中得到wasm文件，感觉源文件是类似于字节码的东西</p>
<img src="/images/陇原战疫2021网络安全大赛/image-20220326082218639.png" alt="image-20220326082218639" style="zoom: 67%;" />

<h3 id="wasm文件的编译"><a href="#wasm文件的编译" class="headerlink" title="wasm文件的编译"></a>wasm文件的编译</h3><p>将wasm文件转换成.o文件</p>
<p>使用[该文章](<a href="https://www.52pojie.cn/thread-1438499-1-1.html">wasm一键转c - 『原创发布区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a>)之中提供的软件将wasm的文件转换成.o格式的文件</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220328124110199.png" alt="image-20220328124110199"></p>
<h3 id="定位关键函数"><a href="#定位关键函数" class="headerlink" title="定位关键函数"></a>定位关键函数</h3><p>将文件放入到ida之中，关注它反编译得到的函数名称</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220328124259347.png" alt="image-20220328124259347"></p>
<p>定位到有特别含义的函数名称，定位到_w2c_checkright这个函数</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220328130246604.png" alt="image-20220328130246604"></p>
<h3 id="密文-1"><a href="#密文-1" class="headerlink" title="密文"></a>密文</h3><p>定位到w2c_memory 偏移为1024赋值的函数</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220328130406773.png" alt="image-20220328130406773"></p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220328130634714.png" alt="image-20220328130634714"></p>
<p>提取出其中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc =   [0x86, 0x8B, 0xAA, 0x85, 0xAC, 0x89, 0xF0, 0xAF, 0xD8, 0x69, </span><br><span class="line">  0xD6, 0xDD, 0xB2, 0xBF, 0x6E, 0xE5, 0xAE, 0x99, 0xCC, 0xD5, </span><br><span class="line">  0xBC, 0x8B, 0xF2, 0x7D, 0x7A, 0xE3, 0x59, 0x6F, 0x75, 0x20, </span><br><span class="line">  0x61, 0x72, 0x65, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x21, </span><br><span class="line">  0x00, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77, </span><br><span class="line">  0x72, 0x6F, 0x6E, 0x67, 0x21, 0x00]</span><br></pre></td></tr></table></figure>

<h3 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc =   [0x86, 0x8B, 0xAA, 0x85, 0xAC, 0x89, 0xF0, 0xAF, 0xD8, 0x69,</span><br><span class="line">  0xD6, 0xDD, 0xB2, 0xBF, 0x6E, 0xE5, 0xAE, 0x99, 0xCC, 0xD5,</span><br><span class="line">  0xBC, 0x8B, 0xF2, 0x7D, 0x7A, 0xE3, 0x59, 0x6F, 0x75, 0x20,</span><br><span class="line">  0x61, 0x72, 0x65, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x21,</span><br><span class="line">  0x00, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77,</span><br><span class="line">  0x72, 0x6F, 0x6E, 0x67, 0x21, 0x00]</span><br><span class="line">for i in range(len(enc)):</span><br><span class="line">    print(chr((enc[i]^i)//2),end=&#x27;&#x27;)</span><br><span class="line">CETCTF&#123;Th0nk_Y0u_DocTOr51&#125;</span><br></pre></td></tr></table></figure>

<p>最后的flag是CETCTF{Th0nk_Y0u_DocTOr51}</p>
<h2 id="easyre-DACTF2022"><a href="#easyre-DACTF2022" class="headerlink" title="easyre-DACTF2022"></a>easyre-DACTF2022</h2><p>用PE打开发现是ASpack的壳，使用Stripper脱壳(工具在 看雪论坛的工具之中搜ASpack，其中有脱该壳的工具，也有手动脱壳的方法)</p>
<p>将脱壳得到的文件放入到ida32之中</p>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>首先判断了长度 和 前六个字符</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125348507.png" alt="image-20220329125348507"></p>
<h3 id="判断的输入的主逻辑函数"><a href="#判断的输入的主逻辑函数" class="headerlink" title="判断的输入的主逻辑函数"></a>判断的输入的主逻辑函数</h3><p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125735359.png" alt="image-20220329125735359"></p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125737500.png" alt="image-20220329125737500"></p>
<h3 id="动态提取dword-492940数组的过程"><a href="#动态提取dword-492940数组的过程" class="headerlink" title="动态提取dword_492940数组的过程"></a>动态提取dword_492940数组的过程</h3><p>下断点</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125814919.png" alt="image-20220329125814919"></p>
<p>按照基本的要求，字符串的长度是42，前六个字符是DASCTF，构造输入</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125913628.png" alt="image-20220329125913628"></p>
<p>然后提取数据：</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125940909.png" alt="image-20220329125940909"></p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125950987.png" alt="image-20220329125950987"></p>
<p>dword_492940:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x38,0x78,0xdd,0xe8,0x00,0xaf,0xbf,0x3a,0x6b,0xfb,0xb8,0x0c,0x85,0x35,0x5c,0xad,0xe6,0x00,0xe0,0x8a,0x1d,0xbd,0x46,0xd2,0x2b,0x00,0x15,0x24,0xc6,0xad,0xa1,0xc9,0x7b,0x12,0x28,0x00,0x05,0x00,0x72,0x3e,0x10,0xa1,0x00,0x00]</span><br></pre></td></tr></table></figure>

<p>最后对比的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0xC3,0x80,0xD5,0xF2,0x9B,0x30,0x0B,0xB4,0x55,0xDE,0x22,0x83,0x2f,0x97,0xB8,0x20,0x1D,0x74,0xd1,1,0x73,0x1A,0xB2,0xc8,0xc5,0x74,0xc0,0x5B,0xf7,0xF,0xD3,1,0x55,0xB2,0xA4,0xAE,0x7B,0xAC,0x5c,0x56,0xbc,0x23]</span><br></pre></td></tr></table></figure>

<h3 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">para = [0x38,0x78,0xdd,0xe8,0x00,0xaf,0xbf,0x3a,0x6b,0xfb,0xb8,0x0c,0x85,0x35,0x5c,0xad,0xe6,0x00,0xe0,0x8a,0x1d,0xbd,0x46,0xd2,0x2b,0x00,0x15,0x24,0xc6,0xad,0xa1,0xc9,0x7b,0x12,0x28,0x00,0x05,0x00,0x72,0x3e,0x10,0xa1,0x00,0x00]</span><br><span class="line">para2 = [0xC3,0x80,0xD5,0xF2,0x9B,0x30,0x0B,0xB4,0x55,0xDE,0x22,0x83,0x2f,0x97,0xB8,0x20,0x1D,0x74,0xd1,1,0x73,0x1A,0xB2,0xc8,0xc5,0x74,0xc0,0x5B,0xf7,0xF,0xD3,1,0x55,0xB2,0xA4,0xAE,0x7B,0xAC,0x5c,0x56,0xbc,0x23]</span><br><span class="line">for i in range(len(para2)):</span><br><span class="line">    if para2[i] &gt;71:</span><br><span class="line">        print(chr((para2[i] - 71) ^ para[i]), end=&quot;&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(chr((para2[i] +256 - 71) ^ para[i]), end=&quot;&quot;)</span><br><span class="line">DASCTF&#123;Welc0me-t0-j01n-SU-l0ve-suyug1eg1e&#125;</span><br></pre></td></tr></table></figure>

<p>最后的flag：DASCTF{Welc0me-t0-j01n-SU-l0ve-suyug1eg1e}</p>
<p>参考文章：</p>
<p><a href="https://zzzzsky.com/2021/11/11/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021_RE_WP/">陇原战”疫”2021网络安全大赛_RE_WP | zsky’s Blog (zzzzsky.com)</a></p>
<p><a href="https://blog.shi1011.cn/ctf/1808">陇原战”疫”2021网络安全大赛 - 翻车鱼 (shi1011.cn)</a></p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>复现</tag>
        <tag>wasm</tag>
        <tag>AES</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理实验</title>
    <url>/2022/08/05/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h3 id="数字图像处理的基础"><a href="#数字图像处理的基础" class="headerlink" title="数字图像处理的基础"></a>数字图像处理的基础</h3><h4 id="将彩色图转换为灰度图"><a href="#将彩色图转换为灰度图" class="headerlink" title="将彩色图转换为灰度图"></a>将彩色图转换为灰度图</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;)</span><br><span class="line">subplot(121),imshow(RGB)</span><br><span class="line">gray = rgb2gray(RGB)</span><br><span class="line">subplot(122),imshow(gray)</span><br></pre></td></tr></table></figure>

<p>转换的结果是：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731101025493.png" alt="image-20220731101025493"></p>
<h4 id="将灰度图转为为索引图"><a href="#将灰度图转为为索引图" class="headerlink" title="将灰度图转为为索引图"></a>将灰度图转为为索引图</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;)</span><br><span class="line">subplot(221),imshow(RGB)</span><br><span class="line">gray = rgb2gray(RGB)</span><br><span class="line">subplot(222),imshow(gray)</span><br><span class="line">[X,map] = gray2ind(gray,8)</span><br><span class="line">subplot(223),imshow(X,map)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731101632758.png" alt="image-20220731101632758"></p>
<p>结论：变为索引值之后图像变得非常的不自然了，图中的显色有分块的现象，特别是在水中的那部分，这是为什么呢？将函数中索引值8增大，这个值越大发现图像之中的颜色表示就更加的自然（最后那幅图的索引值是64的）</p>
<p>索引值：图像颜色映射的个数，也表示图像的灰度级数</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731102131472.png" alt="image-20220731102131472"></p>
<h4 id="将索引图转化为真彩色的图"><a href="#将索引图转化为真彩色的图" class="headerlink" title="将索引图转化为真彩色的图"></a>将索引图转化为真彩色的图</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;)</span><br><span class="line">subplot(221),imshow(RGB)</span><br><span class="line">gray = rgb2gray(RGB)</span><br><span class="line">subplot(222),imshow(gray)</span><br><span class="line">[X,map] = gray2ind(gray,64)</span><br><span class="line">subplot(223),imshow(X,map)，</span><br><span class="line">color = ind2rgb(X,map)</span><br><span class="line">subplot(224),imshow(color)</span><br></pre></td></tr></table></figure>

<p>这样子得到的rgb和原来的二值图是一样的，也不知道为什么，并且按照网上的方式读取tif文件，一直不能够读取成功，使用bmp格式的图像得到的结果仍然是一样的，所以二值图转换的原理是什么需要考究一下</p>
<h4 id="将灰度图像转化为二值化图"><a href="#将灰度图像转化为二值化图" class="headerlink" title="将灰度图像转化为二值化图"></a>将灰度图像转化为二值化图</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color = imread(&#x27;D:\reports\test.jpg&#x27;)</span><br><span class="line">subplot(221),imshow(color)</span><br><span class="line">gray = rgb2gray(color)</span><br><span class="line">subplot(222),imshow(gray)</span><br><span class="line">BW1 = im2bw(gray,0.3)</span><br><span class="line">subplot(223),imshow(BW1)</span><br><span class="line">BW2 = im2bw(gray,0.7)</span><br><span class="line">subplot(224),imshow(BW2)</span><br></pre></td></tr></table></figure>

<p>运行的结果：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731105415590.png" alt="image-20220731105415590"></p>
<p>思考：灰度转二值图的函数是im2bw，后面的阈值的意思是，判断哪些该转换成1，哪些该转换成0，阈值设置得越小，得到的二值图像的白色面积越多。也就是进行阈值处理。</p>
<h3 id="图像的几何变换"><a href="#图像的几何变换" class="headerlink" title="图像的几何变换"></a>图像的几何变换</h3><h4 id="图像的平移"><a href="#图像的平移" class="headerlink" title="图像的平移"></a>图像的平移</h4><p>原理说明：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731145937610.png" alt="image-20220731145937610"></p>
<p>代码：</p>
<p>mymove.m(脚本文件，在这里面定义了一个用于移动的函数，在同一文件夹目录下可以直接调用该函数)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function OUT = mymove(Image,move_X,move_Y)</span><br><span class="line">J = double(Image); % 将图像中的数据转换成双精度的形式</span><br><span class="line">HW=size(J);% 获取原图像的大小</span><br><span class="line">OUT = zeros(HW); % 新建新图像的矩阵</span><br><span class="line">OUT(1:HW(1),1:HW(2)) = inf; % inf在matlab中表现的是无限大的形式，即这里将图像的内容初始化为全白的背景</span><br><span class="line">if((move_X&gt;=0)&amp;&amp;(move_Y&gt;=0))</span><br><span class="line">    OUT(move_X+1:HW(1),move_Y+1:HW(2)) = J(1:HW(1)-move_X,1:HW(2)-move_Y);</span><br><span class="line">elseif((move_X&gt;0)&amp;&amp;(move_Y&lt;0))</span><br><span class="line">    OUT(move_X+1:HW(1),1:HW(2)+move_Y) = J(1:HW(1)-move_X,1-move_Y:HW(2));</span><br><span class="line">elseif((move_X&lt;0)&amp;&amp;(move_Y&gt;0))</span><br><span class="line">    OUT(1:HW(1)+move_X,1+move_Y:HW(2)) = J(1-move_X:HW(1),1:HW(2)-move_Y);</span><br><span class="line">elseif((move_X&lt;0)&amp;&amp;(move_Y&lt;0))</span><br><span class="line">    OUT(1:HW(1)+move_X,1:HW(2)+move_Y) = J(1-move_X:HW(1),1-move_Y:HW(2));</span><br><span class="line">end % 判断性语句结束的标志</span><br><span class="line">OUT = uint8(OUT);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>主程序代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = mymove(image,60,100);</span><br><span class="line">subplot(232),imshow(image_1);</span><br><span class="line">image_2 = mymove(image,-60,100);</span><br><span class="line">subplot(234),imshow(image_2);</span><br><span class="line">image_3 = mymove(image,60,-100);</span><br><span class="line">subplot(235),imshow(image_3);</span><br><span class="line">image_4 = mymove(image,-60,-100);</span><br><span class="line">subplot(236),imshow(image_4);</span><br></pre></td></tr></table></figure>



<p>代码运行的结果：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731145831362.png" alt="image-20220731145831362"></p>
<h4 id="图像的缩放"><a href="#图像的缩放" class="headerlink" title="图像的缩放"></a>图像的缩放</h4><p>原理:</p>
<p>使用的双线性插值算法，遍历变换之后的每个像素点，并且定位和该像素点相关的四个像素点，利用这四个像素点的像素根据公式推导出该像素点的像素。计算的公式如下图所示</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731162031267.png" alt="image-20220731162031267"></p>
<p>代码：</p>
<p>脚本函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function OUT = changeSize(Image,zoom_X,zoom_Y)</span><br><span class="line">J = double(Image); % 将图像中的数据转换成双精度的形式</span><br><span class="line">HW = size(J);% 获取原图像的大小 返回的第一个参数是行数 第二个参数是列数</span><br><span class="line">OUT = zeros(HW); % 新建新图像的矩阵</span><br><span class="line">OUT(1:HW(1),1:HW(2)) = inf; % inf在matlab中表现的是无限大的形式，即这里将图像的内容初始化为全白的背景</span><br><span class="line">changeHW = [floor(HW(1)*zoom_Y),floor(HW(2)*zoom_X)];%放大缩小后的图像的大小 </span><br><span class="line">%便利放大缩小之后的图像的每一个像素点</span><br><span class="line">for i = 1:changeHW(1)</span><br><span class="line">    for j = 1:changeHW(2)</span><br><span class="line">        % 变化之后的图像中的像素点定位到原图像中的对应的位置</span><br><span class="line">        X = i/zoom_Y;</span><br><span class="line">        Y = j/zoom_X;</span><br><span class="line">        % 获得数值的小数部分</span><br><span class="line">        u = X-floor(X);</span><br><span class="line">        v = Y-floor(Y);</span><br><span class="line">        if X&lt; 1</span><br><span class="line">            X =1;</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        if Y&lt; 1</span><br><span class="line">            Y = 1;</span><br><span class="line">        end</span><br><span class="line">        OUT(i,j) = J(floor(X),floor(Y))*u*v + J(ceil(X),floor(Y))*u*(1-v) + J(floor(X),ceil(Y))*(1-u)*v + J(ceil(X),ceil(Y))*(1-u)*(1-v);</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">OUT = uint8(OUT(1:HW(1),1:HW(2)));</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>主函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = changeSize(image,0.5,0.5);</span><br><span class="line">subplot(232),imshow(image_1),axis on;</span><br><span class="line">image_2 = changeSize(image,1.5,1.5);</span><br><span class="line">subplot(233),imshow(image_2),axis on;</span><br><span class="line">image_3 = changeSize(image,0.5,0.8);</span><br><span class="line">subplot(234),imshow(image_3),axis on;</span><br><span class="line">image_4 = changeSize(image,1.0,1.5);</span><br><span class="line">subplot(235),imshow(image_4),axis on;</span><br></pre></td></tr></table></figure>

<p>代码运行的结果：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731161451618.png" alt="image-20220731161451618"></p>
<h4 id="图像旋转"><a href="#图像旋转" class="headerlink" title="图像旋转"></a>图像旋转</h4><p>新图像的高和宽的公式：</p>
<p>**nHW(1)=ceil(HW(1)*abs(cos(abs(alpha)))+HW(2)*abs(sin(abs(alpha)))); nHW(2)=ceil(HW(1)<em>abs(sin(abs(alpha)))+HW(2)<em>abs(cos(abs(alpha))));</em></em></p>
<p>换算到逆时针旋转之后的坐标公式：<br><em><strong>x1=x0cos(β)-y0sin(β)<br>y1=x0sin(β)+y0cos(β)</strong></em></p>
<p>图像：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731163223386.png" alt="image-20220731163223386"></p>
<p>则由新图像中的坐标换算到原图像中的坐标公式：<br><em><strong>x=icos(β)+jsin(β)<br>y=-isin(β)+jcos(β)</strong></em></p>
<p>变换之后的图像中的每个坐标不只是有角度上的转变，还有一定的平移，因为要确保图像在中央</p>
<p>旋转函数代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function OUT = myrotate(image,alpha) % alpha是旋转的角度</span><br><span class="line">J = double(image);% 将图像中的值转换成双精度形式</span><br><span class="line">HW = size(J);% 获得图像的大小 size</span><br><span class="line">alpha = mod(alpha,360);% 将角度转变到0~360</span><br><span class="line">alpha = (alpha*pi)/180;% 将角度转变成弧度制</span><br><span class="line">nHW(1) = ceil(HW(1)*abs(cos(abs(alpha)))+HW(2)*abs(sin(abs(alpha))));% 旋转之后的图像的大小（长和宽都要重新定义）</span><br><span class="line">nHW(2) = ceil(HW(1)*abs(sin(abs(alpha)))+HW(2)*abs(cos(abs(alpha))));</span><br><span class="line">OUT = zeros(nHW);% 利用新的长和宽定义图像的矩阵</span><br><span class="line">OUT(1:nHW(1),1:nHW(2)) = inf;% 对这个矩阵进行初始化（inf 初始化成白色的）</span><br><span class="line">u0 = HW(2)*abs(sin(alpha));u2 = HW(1)*abs(cos(alpha));% 竖直方向的平移量</span><br><span class="line">u1 = HW(1)*abs(sin(alpha));u3 = HW(2)*abs(cos(alpha)); % 水平方向的平移量</span><br><span class="line">T = [cos(alpha),sin(alpha);-sin(alpha),cos(alpha)];% 对坐标进行换算的矩阵</span><br><span class="line">% 遍历这个新的图像</span><br><span class="line">for i = 1:nHW(1)</span><br><span class="line">    for j = 1:nHW(2)</span><br><span class="line">        if(alpha&gt;=0 &amp;&amp; alpha&lt;pi/2)</span><br><span class="line">            XY = T * ([i;j]-[u0;0]);% 此时整个图像需要向上移动 </span><br><span class="line">        elseif(alpha&gt;=pi/2 &amp;&amp; alpha&lt;pi)</span><br><span class="line">            XY = T *([i;j]-[u0+u2;u3]);</span><br><span class="line">        elseif(alpha&gt;=pi &amp;&amp; alpha&lt;3*pi/2)</span><br><span class="line">            XY = T *([i;j]-[u2;u1+u3]);</span><br><span class="line">        elseif(alpha&gt;=3*pi/2 &amp;&amp; alpha&lt;2*pi)</span><br><span class="line">            XY = T * ([i;j]-[0;u1]);</span><br><span class="line">        end</span><br><span class="line">        X = XY(1);</span><br><span class="line">        Y = XY(2);</span><br><span class="line">        if X&gt;=1 &amp;&amp; X&lt;=HW(1) &amp;&amp; Y&gt;=1 &amp;&amp; Y&lt;=HW(2)</span><br><span class="line">            u = X - floor(X);</span><br><span class="line">            v = Y - floor(Y);</span><br><span class="line">         OUT(i,j) = J(floor(X),floor(Y))*u*v + J(ceil(X),floor(Y))*u*(1-v) + J(floor(X),ceil(Y))*(1-u)*v + J(ceil(X),ceil(Y))*(1-u)*(1-v);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    end</span><br><span class="line">OUT = uint8(OUT(1:nHW(1),1:nHW(2)));</span><br><span class="line">% 根据旋转的角度平移坐标值 并且 乘以换算的矩阵 得到在原图像中的坐标点</span><br><span class="line">% 得到小数的部分</span><br><span class="line">% 使用双线插入法获得对应的像素值</span><br><span class="line">% 将OUT的值转变成uint8的形式</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>主函数代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image1 = myrotate(image,30);</span><br><span class="line">subplot(232),imshow(image1),axis on;</span><br><span class="line">image1 = myrotate(image,120);</span><br><span class="line">subplot(233),imshow(image1),axis on;</span><br><span class="line">image1 = myrotate(image,210);</span><br><span class="line">subplot(234),imshow(image1),axis on;</span><br><span class="line">image1 = myrotate(image,310);</span><br><span class="line">subplot(235),imshow(image1),axis on;</span><br></pre></td></tr></table></figure>

<p>运行的效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731175016882.png" alt="image-20220731175016882"></p>
<h4 id="图像镜像"><a href="#图像镜像" class="headerlink" title="图像镜像"></a>图像镜像</h4><p>水平镜像的公式：（水平镜像操作是以原图像的垂直中轴线为中心，将图像分为左右两部分进行对称变换）<br><em><strong>x1=x0<br>y1=width+1-y0</strong></em></p>
<p>垂直镜像的公式：（垂直镜像操作是以原图像的水平中轴线为中心，将图像分为上下两部分进行对称变换）</p>
<p><em><strong>x1=height+1-x0<br>y1=y0</strong></em></p>
<p>width =》 第二个得到的数据</p>
<p>height =》第一个得到的数据</p>
<p>镜像函数的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function OUT = mymirror(Image,choice)</span><br><span class="line">    J= double(Image);% 将图像的数据进行双精度</span><br><span class="line">    HW = size(J);% 获得图像的大小 size</span><br><span class="line">    OUT = zeros(HW(1),HW(2));% 利用图像的大小创建对应的数组</span><br><span class="line">    OUT(1:HW(1),1:HW(2)) = inf;% 初始化矩阵 inf</span><br><span class="line">    % 遍历矩阵</span><br><span class="line">    for i = 1:HW(1)</span><br><span class="line">        for j = 1:HW(2)</span><br><span class="line">            if strcmp(choice,&#x27;level&#x27;) % 水平镜像</span><br><span class="line">                OUT(i,j) = J(i,HW(2)+1-j);</span><br><span class="line">            elseif strcmp(choice,&#x27;vertical&#x27;) % 垂直镜像</span><br><span class="line">                OUT(i,j) = J(HW(1)+1-i,j);</span><br><span class="line">            end </span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    % 针对不同的选择进行设置</span><br><span class="line">    % 对相应位置图像的像素进行设置</span><br><span class="line">    OUT = uint8(OUT);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>主函数的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = mymirror(image,&#x27;level&#x27;)</span><br><span class="line">subplot(232),imshow(image_1),axis on,title(&#x27;水平镜像&#x27;)</span><br><span class="line">image_2 = mymirror(image,&#x27;vertical&#x27;)</span><br><span class="line">subplot(233),imshow(image_2),axis on,title(&#x27;垂直镜像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731235124610.png" alt="image-20220731235124610"></p>
<h4 id="图像的转置"><a href="#图像的转置" class="headerlink" title="图像的转置"></a>图像的转置</h4><p>转置就是像素点的x坐标和y坐标进行交换，注意这样使得它的长和宽的大小也进行了交换</p>
<p>转置函数代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function OUT = myTranspose(Image)</span><br><span class="line">    J= double(Image);% 将图像的数据进行双精度</span><br><span class="line">    HW = size(J);% 获得图像的大小 size</span><br><span class="line">    OUT = zeros(HW(2),HW(1));% 因为是转置所以它的行宽的大小进行了交换</span><br><span class="line">    OUT(1:HW(2),1:HW(1)) = inf;% 初始化矩阵 inf</span><br><span class="line">    % 遍历矩阵</span><br><span class="line">    for i = 1:HW(2)</span><br><span class="line">        for j = 1:HW(1)</span><br><span class="line">            OUT(i,j) = J(j,i); % 转置像素赋值的公式</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    OUT = uint8(OUT);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>主函数代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = myTranspose(image);</span><br><span class="line">subplot(232),imshow(image_1),axis on,title(&#x27;转置的图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：<br><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220731235832423.png" alt="image-20220731235832423"></p>
<h4 id="图像的剪切"><a href="#图像的剪切" class="headerlink" title="图像的剪切"></a>图像的剪切</h4><p>剪切函数代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function OUT = myCut(Image,strat_X,strat_Y)</span><br><span class="line">    J= double(Image);% 将图像的数据进行双精度</span><br><span class="line">    HW = size(J);</span><br><span class="line">    OUT = J(strat_X:HW(1),strat_Y:HW(2));% 因为是转置所以它的行宽的大小进行了交换</span><br><span class="line">    OUT = uint8(OUT);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>主函数代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = myCut(image,50,70);</span><br><span class="line">subplot(232),imshow(image_1),axis on,title(&#x27;剪切的图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801000929925.png" alt="image-20220801000929925"></p>
<h3 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h3><h4 id="函数映射"><a href="#函数映射" class="headerlink" title="函数映射"></a><strong>函数映射</strong></h4><p>使用<strong>imadjust</strong>这个灰度值映射函数</p>
<blockquote>
<p>语法：<em>g=imadjust(f,[low-in,hign-in],[low-out,high-out],gamma);</em></p>
<p>将输入图像<strong>指定灰度范围</strong>映射到想要得到的<strong>输出图像的灰度范围</strong></p>
<p><strong>gamma</strong>为映射函数曲线的特征参数，gamma小于1，则映射被<strong>加权至高的输出值</strong>，大于1，则被<strong>加权至较低的输出值</strong>，等于1为<strong>线性映射</strong>。gamma默认为1。</p>
</blockquote>
<p>运行代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">image_1 = imadjust(image,[0,1],[1,0]);</span><br><span class="line">subplot(232),imshow(image_1)</span><br><span class="line">image_2 = imadjust(image,[0.3,0.8],[0,1]);</span><br><span class="line">subplot(233),imshow(image_2)</span><br><span class="line">image_3 = imadjust(image,[0.3,0.8],[0,1],0.5);</span><br><span class="line">subplot(234),imshow(image_3)</span><br><span class="line">image_4 = imadjust(image,[0.3,0.8],[0,1],1.5);</span><br><span class="line">subplot(235),imshow(image_4)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801002104962.png" alt="image-20220801002104962"></p>
<p>分析：第二张图是将[0,1]的像素值投影到[1,0]的像素值区域，这样得到的图片的效果就是颜色取反，越黑的像素点转变之后就越白。第三张图使得图像黑色区域更黑，白色区域更白，容易使得图像整体的感觉变得更暗，所以有第四张图，将grammer设置为0.5（数值小于1了），能够提高图像的亮度，第五张图，将grammer设置为1.5，降低了图像的亮度。</p>
<h4 id="直方图处理"><a href="#直方图处理" class="headerlink" title="直方图处理"></a>直方图处理</h4><p>绘制图像直方图</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">subplot(232),imshow(image)</span><br><span class="line">imhist(image,16)</span><br><span class="line">subplot(233),imshow(image)</span><br><span class="line">plot(imhist(image))</span><br></pre></td></tr></table></figure>

<p>代码的运行结果：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801004113238.png" alt="image-20220801004113238"></p>
<p>均衡化调用的函数hiseq()</p>
<p>运行的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">subplot(232),imshow(image)</span><br><span class="line">imhist(image,16)</span><br><span class="line">subplot(233),imshow(image)</span><br><span class="line">plot(imhist(image))</span><br><span class="line">g = histeq(image,256)</span><br><span class="line">subplot(234),imshow(g)</span><br><span class="line">subplot(235),imshow(g)</span><br><span class="line">imhist(g,16)</span><br><span class="line">subplot(236),imshow(g)</span><br><span class="line">plot(imhist(g))</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801004646948.png" alt="image-20220801004646948"></p>
<p>分析：通过图我们可以看到均衡化之后的直方图中每部分像素值（每个分类部分）中的点的数量近似相同，图像显示也有了明显的差异</p>
<p>使用直方图图匹配</p>
<p>参考的文章：<a href="https://www.programminghunter.com/article/37032194016/">https://www.programminghunter.com/article/37032194016/</a></p>
<p>自己写的代码：(代码里面找最近的点的那个地方,使用了index()函数自己没有看懂)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image)</span><br><span class="line">% 双峰高斯函数</span><br><span class="line">r = 127;</span><br><span class="line">x = -r:r+1;</span><br><span class="line">sigma = 20;</span><br><span class="line">y1=exp(-((x-80).^2)/(2*sigma^2));</span><br><span class="line">y2=exp(-((x+80).^2)/(2*sigma^2));</span><br><span class="line">y=y1+y2; </span><br><span class="line">y = y /sum(y);% 归一化 概率</span><br><span class="line">subplot(232),imshow(y)</span><br><span class="line">plot(y)</span><br><span class="line">% 该函数的累计直方图</span><br><span class="line">G = [];</span><br><span class="line">for i=1:256</span><br><span class="line">    G = [G sum(y(1:i))];</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subplot(233),imshow(image)</span><br><span class="line">imhist(image)</span><br><span class="line">% 获得原图像的累计直方图</span><br><span class="line">hist = imhist(image);% 获得原图像的直方图</span><br><span class="line">imageP = hist/(HW(1)*HW(2));% 每一中像素的概率</span><br><span class="line">% 对概率再累计求和</span><br><span class="line">s=[];</span><br><span class="line">for i=1:256</span><br><span class="line">    s=[s sum(imageP(1:i))];</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 找到两个概率累计图中最近的点</span><br><span class="line">for i = 1:256</span><br><span class="line">    tem&#123;i&#125; = G-s(i);</span><br><span class="line">    tem&#123;i&#125; = abs(tem&#123;i&#125;); % 这里看的是距离，所以取绝对值进行比较就可以了</span><br><span class="line">    [a index(i)] = min(tem&#123;i&#125;); % 获得距离最小的点</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">newimage=zeros(HW(1),HW(2));</span><br><span class="line">for i = 1:HW(1)</span><br><span class="line">    for j = 1:HW(2)</span><br><span class="line">        newimage(i,j) = index(image(i,j)+1)-1;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">newimage = uint8(newimage);</span><br><span class="line">subplot(234),imshow(newimage)</span><br><span class="line">subplot(234),imshow(newimage)</span><br><span class="line">imhist(newimage)</span><br></pre></td></tr></table></figure>

<p>运行的结果是：<br><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801104042622.png" alt="image-20220801104042622"></p>
<p>分析：看这个曲线就能知道匹配了上面的图像了，这里面要使用累积概率进行计算才可以</p>
<h3 id="图像的平滑处理"><a href="#图像的平滑处理" class="headerlink" title="图像的平滑处理"></a>图像的平滑处理</h3><h4 id="采用均值和高斯滤波器进行平滑处理"><a href="#采用均值和高斯滤波器进行平滑处理" class="headerlink" title="采用均值和高斯滤波器进行平滑处理"></a>采用均值和高斯滤波器进行平滑处理</h4><p>用来生成滤波器的函数</p>
<p>h = fspecial(type)<br>h = fspecial(type，para)</p>
<p>type参数来指定滤波器的种类，para来对具体的滤波器种类添加额外的参数信息</p>
<p><strong>高斯滤波器</strong></p>
<p>H = fspecial(‘gaussian’,hsize,sigma) ：type = ‘gaussian’时就是高斯滤波器了，size指定滤波器的大小,默认值是3×3，sigma指定滤波器的标准差，默认值是0.5（决定了高斯模糊核的模糊程度），使用sigma的值很大的时候，然后运用此模糊核对图像处理，会使图像更加模糊。</p>
<p>例： h1 = fspecial(‘gaussian’,5,1)</p>
<p><strong>均值滤波器</strong></p>
<p>H =fspecial(‘average’,hsize) ：hsize指定滤波器的尺寸</p>
<p>例：h1 = fspecial(‘average’,5) %5x5的核</p>
<p><strong>圆形均值滤波器</strong></p>
<p>H = fspecialL(‘disk’,RADIUS)，radius代表区域半径。</p>
<p>例：h1 = fspecial(‘disk’,3)</p>
<p><strong>拉普拉斯滤波器</strong></p>
<p>H = fspecial（’laplacian’,ALPHA)：alpha用于控制算子形状，取值范围为【0，1】，默认值为0.2，尺寸一定是3×3</p>
<p>例：h1 =fspecial(‘laplacian’)</p>
<p><strong>拉普拉斯高斯滤波器</strong></p>
<p>H = fspecial(‘log’,hsize,sigma) :hsize表示模板尺寸，默认值为3x3,sigma为滤波器的标准差</p>
<p>例：h1 =fspecial(‘log’,3,0.2)</p>
<p><strong>prewitt</strong></p>
<p>H = fspecial(‘prewitt’) ：用于边缘增强，这个函数是没有参数的，默认的大小就是3x3，</p>
<p><strong>sobel</strong></p>
<p>H = fspecial(‘sobel’)：这个函数是无参数的，用于边缘的提取。</p>
<p>例：h1 = fspecial(‘sobel’)</p>
<p>高斯和均值滤波器的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title(&#x27;原图&#x27;)</span><br><span class="line">average3image = filter2(fspecial(&#x27;average&#x27;,3),image)/255;% 采用均值滤波器进行平滑处理 3x3</span><br><span class="line">subplot(232),imshow(average3image),title(&#x27;3x3的均值滤波器&#x27;)</span><br><span class="line">average5image = filter2(fspecial(&#x27;average&#x27;,5),image)/255;% 5x5</span><br><span class="line">subplot(233),imshow(average5image),title(&#x27;5x5的均值滤波器&#x27;)</span><br><span class="line">average7image = filter2(fspecial(&#x27;average&#x27;,7),image)/255;% 7X7</span><br><span class="line">subplot(234),imshow(average7image),title(&#x27;7x7的均值滤波器&#x27;)</span><br><span class="line">gaussianImage1 = filter2(fspecial(&#x27;gaussian&#x27;),image)/255;</span><br><span class="line">subplot(235),imshow(gaussianImage1),title(&#x27;0.5的高斯滤波器&#x27;)</span><br><span class="line">gaussianImage2 = filter2(fspecial(&#x27;gaussian&#x27;,5,10),image)/255;</span><br><span class="line">subplot(236),imshow(gaussianImage2),title(&#x27;10的高斯滤波器&#x27;);</span><br></pre></td></tr></table></figure>

<p>效果图：<br><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801110943637.png" alt="image-20220801110943637"></p>
<p>分析：可以看到越大的模板，处理之后的图像就会越模糊，sigma越大就会使得页面更加的模糊</p>
<p>边缘增强的两个滤波器prewitt和sobel：</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title(&#x27;原图&#x27;)</span><br><span class="line">prewittImage = filter2(fspecial(&#x27;prewitt&#x27;),image)/255</span><br><span class="line">subplot(232),imshow(prewittImage),title(&#x27;prewitt边缘增强&#x27;)</span><br><span class="line">sobelImage = filter2(fspecial(&#x27;sobel&#x27;),image)/255</span><br><span class="line">subplot(233),imshow(sobelImage),title(&#x27;sobel边缘增强&#x27;)</span><br></pre></td></tr></table></figure>



<p>锐化处理的公式（把边缘部分进行突出）</p>
<ul>
<li>原图*2-平滑图像</li>
<li>原图+边缘处理图像</li>
</ul>
<p>锐化处理代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title(&#x27;原图&#x27;)</span><br><span class="line">average5image = filter2(fspecial(&#x27;average&#x27;,5),image)/255;% 5x5</span><br><span class="line">subplot(234),imshow(average5image),title(&#x27;5x5的均值滤波器&#x27;)</span><br><span class="line">prewittImage = filter2(fspecial(&#x27;prewitt&#x27;),image)/255;</span><br><span class="line">subplot(232),imshow(prewittImage),title(&#x27;prewitt边缘增强&#x27;)</span><br><span class="line">sobelImage = filter2(fspecial(&#x27;sobel&#x27;),image)/255;</span><br><span class="line">subplot(233),imshow(sobelImage),title(&#x27;sobel边缘增强&#x27;)</span><br><span class="line">subImage1 = image*2-uint8(average5image);</span><br><span class="line">subplot(235),imshow(subImage1),title(&#x27;原图*2-平滑图像锐化&#x27;)</span><br><span class="line">subImage2 = image+uint8(prewittImage);</span><br><span class="line">subplot(236),imshow(subImage2),title(&#x27;原图+边缘处理图像锐化&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：<br><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801112456585.png" alt="image-20220801112456585"></p>
<p>分析：因为我用的是模糊程度偏大的图像，所以使得使用第一种方法锐化之后的结果，图像的整体的亮度会偏大，第二种方式锐化之后的，仔细看能够感觉细节上面增强了，但是直观上来看，我认为是不明显的。</p>
<h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><p>边缘的两个性质：</p>
<ul>
<li>强度的一阶导数的模大于某个阈值的位置（在边缘处像素几句变化）</li>
<li>强度的二阶导数有过零点的位置</li>
</ul>
<p>使用edge()函数检测 <a href="https://ww2.mathworks.cn/help/images/ref/edge.html">edge()函数的各种用法</a></p>
<p>sobel和canny边缘检测的对比</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title(&#x27;原图&#x27;)</span><br><span class="line">BW1 = edge(image,&#x27;sobel&#x27;);</span><br><span class="line">subplot(232),imshow(BW1),title(&#x27;sobel边缘检测&#x27;)</span><br><span class="line">BW2 = edge(image,&#x27;canny&#x27;);</span><br><span class="line">subplot(233),imshow(BW2),title(&#x27;canny边缘检测&#x27;)</span><br><span class="line">figure</span><br><span class="line">imshowpair(BW1,BW2,&#x27;montage&#x27;)</span><br><span class="line">title(&#x27;sobel边缘检测                canny边缘检测 &#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801114928541.png" alt="image-20220801114928541"></p>
<p>分析：canny边缘的提取能力高于其它的</p>
<p>边缘检测的方法：<br>robert：边缘<strong>定位精度较高</strong>，对于陡峭边缘且噪声低的图像效果较好，但没有进行平滑处理，没有抑制噪声的能力</p>
<p>sobel prewitt：进行了平滑处理，对噪声具有一定<strong>抑制能力</strong>，但容易出现多像素宽度</p>
<p>laplacian：对噪声较为敏感，使噪声能力成分得到加强，容易丢失部分边缘方向信息，造成一些不连续的检测边缘，同时抗噪声能力较差。</p>
<p>log：抗噪声能力较强，但会造成一些尖锐的边缘无法检测到。</p>
<p>canny：最优化思想的边缘检测算子，同时采用高斯函数对图像进行平滑处理，但会造成将高频边缘平滑掉，造成边缘丢失，采用双阈值算法检测和连接边缘。</p>
<p>上面几种边缘检测方法的对比：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801120104487.png" alt="image-20220801120104487"></p>
<p>分析：对比上面的几个图，我们能够看到canny的边缘检测的效果是最好的。</p>
<h3 id="图像的分割"><a href="#图像的分割" class="headerlink" title="图像的分割"></a>图像的分割</h3><p>这里采用的方法都是阈值分割，上面用于边缘检测也是可以用于图像分割的</p>
<h4 id="全局分割"><a href="#全局分割" class="headerlink" title="全局分割"></a>全局分割</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title(&#x27;原图&#x27;)</span><br><span class="line">subplot(232),imshow(image),title(&#x27;原图直方图&#x27;)</span><br><span class="line">imhist(image,200)</span><br><span class="line">% 采用全局阈值分割</span><br><span class="line">grobeCutImage1 = image&gt;100;</span><br><span class="line">subplot(234),imshow(grobeCutImage1),title(&#x27;分割图像一&#x27;)</span><br><span class="line">grobeCutImage2 = image&gt;180;</span><br><span class="line">subplot(235),imshow(grobeCutImage2),title(&#x27;分割图像二&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：<br><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801151058135.png" alt="image-20220801151058135"></p>
<h4 id="Otsu阈值分割"><a href="#Otsu阈值分割" class="headerlink" title="Otsu阈值分割"></a>Otsu阈值分割</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title(&#x27;原图&#x27;)</span><br><span class="line">subplot(232),imshow(image),title(&#x27;原图直方图&#x27;)</span><br><span class="line">imhist(image,200)</span><br><span class="line">% 采用Otsu阈值分割</span><br><span class="line">doubleImage = im2double(image);</span><br><span class="line">T = graythresh(doubleImage) ;</span><br><span class="line">J = im2bw(doubleImage,T);</span><br><span class="line">subplot(234),imshow(J),title(&#x27;Otsu阈值处理&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801151842037.png" alt="image-20220801151842037"></p>
<h4 id="迭代式阈值分割法"><a href="#迭代式阈值分割法" class="headerlink" title="迭代式阈值分割法"></a>迭代式阈值分割法</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title(&#x27;原图&#x27;)</span><br><span class="line">subplot(232),imshow(image),title(&#x27;原图直方图&#x27;)</span><br><span class="line">imhist(image,200)</span><br><span class="line">% 采用迭代式阈值分割法</span><br><span class="line">doubleImage = im2double(image);</span><br><span class="line">thred = 0.01 ;% 精度</span><br><span class="line">T1 = (min(doubleImage)+max(doubleImage));% 得到第一个分界点 最大值和最小值取二分之一的位置（T1）</span><br><span class="line">sumRight = find(doubleImage&lt;T1);% 找出小于这个分界点的值</span><br><span class="line">sumLeft = find(doubleImage&gt;=T1);% 找出大于这个分界点的值</span><br><span class="line">T2 = (mean(doubleImage(sumRight))+mean(doubleImage(sumLeft)))/2;% 分别求这两边数字的平均值</span><br><span class="line">% 对这两边的平均值求和再*1/2</span><br><span class="line">while abs(T1-T2)&lt;=thred</span><br><span class="line">    T1 = T2;</span><br><span class="line">    sumRight = find(doubleImage&lt;T1);</span><br><span class="line">    sumLeft = find(doubleImage&gt;=T1);</span><br><span class="line">    T2 = (mean(doubleImage(sumRight))+mean(doubleImage(sumLeft)))/2;</span><br><span class="line">end    % whiel循环，T1和T2之间的差在0.01之上时不断进行迭代</span><br><span class="line">% T1 =T2 再继续用相同的方法求得T2（这样保证左右两边的像素总值近似相等时结束）</span><br><span class="line">% 使用im2bw()进行阈值的划分</span><br><span class="line">result = im2bw(doubleImage,T2);</span><br><span class="line">subplot(232),imshow(result),title(&#x27;迭代式阈值分割&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801154509823.png" alt="image-20220801154509823"></p>
<p>分析：这里的这个阈值点的确定的要求，要使得这个阈值以下的所有点像素相加的结果等于这个阈值以上的所有点像素相加的结果，但我觉得分割效果并不是很优秀</p>
<h4 id="区域分割的分水岭分割"><a href="#区域分割的分水岭分割" class="headerlink" title="区域分割的分水岭分割"></a>区域分割的分水岭分割</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">RGB = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image = rgb2gray(RGB);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231),imshow(image),title(&#x27;原图&#x27;)</span><br><span class="line">subplot(232),imshow(image),title(&#x27;原图直方图&#x27;)</span><br><span class="line">imhist(image,200)</span><br><span class="line">% 采用分水岭分割</span><br><span class="line">newimage = watershed(image,1); % 这个地方能输入的参数值是 1, 4, 6, 8, 18, or 26 默认是8 指的是连通区的个数</span><br><span class="line">subplot(234),imshow(newimage),title(&#x27;分水岭分割&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220801155205365.png" alt="image-20220801155205365"></p>
<p>感觉不到任何的效果，不知道这种分割方法的效果和意义所在</p>
<h3 id="图像的形态学处理"><a href="#图像的形态学处理" class="headerlink" title="图像的形态学处理"></a>图像的形态学处理</h3><h3 id="图像腐蚀"><a href="#图像腐蚀" class="headerlink" title="图像腐蚀"></a>图像腐蚀</h3><p>运行的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">bw = zeros(9,9);</span><br><span class="line">bw(2:6,3:7) = 1;% 给2到6排和3到7列的数据赋值为1</span><br><span class="line">se = strel(&#x27;square&#x27;,5);% 创立5*5的结构体</span><br><span class="line">se2 = strel(&#x27;square&#x27;,1);% 创立1*1的结构体</span><br><span class="line">se3 = strel(&#x27;square&#x27;,3);% 创立3*3的结构体</span><br><span class="line">bw2 = imerode(bw,se);% 用se模板对bw进行腐蚀的操作</span><br><span class="line">bw3 = imerode(bw,se2);% 用se模板对bw进行腐蚀的操作</span><br><span class="line">bw4 = imerode(bw,se3);% 用se模板对bw进行腐蚀的操作</span><br><span class="line">subplot(221); imshow(bw);title(&#x27;输入的图像&#x27;)</span><br><span class="line">subplot(222); imshow(bw3);title(&#x27;1*1 腐蚀后的图像&#x27;)</span><br><span class="line">subplot(223); imshow(bw4);title(&#x27;3*3 腐蚀后的图像&#x27;)</span><br><span class="line">subplot(224); imshow(bw2);title(&#x27;5*5 腐蚀后的图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804110512155.png" alt="image-20220804110512155"></p>
<p>3*3的腐蚀模板：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804110649716.png" alt="image-20220804110649716"></p>
<p>原图像的模板：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804110723961.png" alt="image-20220804110723961"></p>
<p>3*3腐蚀之后的结果：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804110756214.png" alt="image-20220804110756214"></p>
<h4 id="图像膨胀"><a href="#图像膨胀" class="headerlink" title="图像膨胀"></a>图像膨胀</h4><p>运行的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">bw = zeros(9,9);</span><br><span class="line">bw(4:5,4:6) = 1;% 给4到5排和4到6列的数据赋值为1</span><br><span class="line">se = strel(&#x27;square&#x27;,5);% 创立5*5的结构体</span><br><span class="line">se2 = strel(&#x27;square&#x27;,1);% 创立1*1的结构体</span><br><span class="line">se3 = strel(&#x27;square&#x27;,3);% 创立3*3的结构体</span><br><span class="line">bw2 = imdilate(bw,se);% 用se模板对bw进行膨胀的操作</span><br><span class="line">bw3 = imdilate(bw,se2);% 用se模板对bw进行膨胀的操作</span><br><span class="line">bw4 = imdilate(bw,se3);% 用se模板对bw进行膨胀的操作</span><br><span class="line">subplot(221); imshow(bw);title(&#x27;输入的图像&#x27;)</span><br><span class="line">subplot(222); imshow(bw3);title(&#x27;1*1 膨胀后的图像&#x27;)</span><br><span class="line">subplot(223); imshow(bw4);title(&#x27;3*3 膨胀后的图像&#x27;)</span><br><span class="line">subplot(224); imshow(bw2);title(&#x27;5*5 膨胀后的图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>图像运行结果的截图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804111645824.png" alt="image-20220804111645824"></p>
<p><strong>线性膨胀图像</strong></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread(&#x27;D:\reports\label.jpg&#x27;);</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title(&#x27;原图像&#x27;)</span><br><span class="line">se = strel(&#x27;line&#x27;,11,90);% 制定一个线性的结构，长度是11，角度是90度</span><br><span class="line">bw1 = imdilate(image,se);</span><br><span class="line">subplot(232);imshow(bw1);title(&#x27;垂直线性膨胀图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：<br><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804112706637.png" alt="image-20220804112706637"></p>
<p>用于膨胀的模板</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804112819360.png" alt="image-20220804112819360"></p>
<p><strong>球形膨胀</strong></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread(&#x27;D:\reports\label.jpg&#x27;);</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title(&#x27;原图像&#x27;)</span><br><span class="line">se = strel(&#x27;ball&#x27;,5,5);% 制定一个球形膨胀的结构</span><br><span class="line">bw1 = imdilate(image,se);</span><br><span class="line">subplot(232);imshow(bw1);title(&#x27;球形膨胀图像&#x27;)</span><br></pre></td></tr></table></figure>



<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804113013278.png" alt="image-20220804113013278"></p>
<p>球形模板图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804113314104.png" alt="image-20220804113314104"></p>
<h4 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h4><p>腐蚀运算，然后再做膨胀运算</p>
<p>运算代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread(&#x27;D:\reports\label.jpg&#x27;);</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title(&#x27;原图像&#x27;)</span><br><span class="line">se = strel(&#x27;disk&#x27;,3);% 制定一个棋盘膨胀的结构</span><br><span class="line">bw1 = imopen(image,se); % 进行开运算</span><br><span class="line">subplot(232);imshow(bw1);title(&#x27;开运算图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804113806790.png" alt="image-20220804113806790"></p>
<p>分析：</p>
<p>我们能够看到的是右边的图相比于左边的图已经不连贯而变得模糊了，是因为开运算的第一次腐蚀，就会将很多细节的地方去除掉。</p>
<h4 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h4><p>先做膨胀运算，然后再做腐蚀运算</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread(&#x27;D:\reports\label.jpg&#x27;);</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title(&#x27;原图像&#x27;)</span><br><span class="line">se = strel(&#x27;disk&#x27;,3);% 制定一个棋盘膨胀的结构</span><br><span class="line">bw1 = imclose(image,se); % 进行闭运算</span><br><span class="line">subplot(232);imshow(bw1);title(&#x27;闭运算图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804114257142.png" alt="image-20220804114257142"></p>
<h4 id="形态学的高帽滤波"><a href="#形态学的高帽滤波" class="headerlink" title="形态学的高帽滤波"></a>形态学的高帽滤波</h4><p>高帽滤波定义</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804114443334.png" alt="image-20220804114443334"></p>
<p><strong>A</strong>输入的图像，<strong>B</strong>为采用的结构元素，即从图像中减去形态学开操作后的图像，通过<strong>高帽滤波可以增强图像的对比度</strong>。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread(&#x27;D:\reports\label.jpg&#x27;);</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title(&#x27;原图像&#x27;)</span><br><span class="line">se = strel(&#x27;disk&#x27;,3);% 制定一个棋盘膨胀的结构</span><br><span class="line">bw1 = imtophat(image,se); % 高帽滤波</span><br><span class="line">adjustBw1 = imadjust(bw1);% 进行图像增强的操作 </span><br><span class="line">subplot(232);imshow(bw1);title(&#x27;高帽滤波后的图像&#x27;)</span><br><span class="line">subplot(233);imshow(adjustBw1);title(&#x27;图像增强后图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804115244654.png" alt="image-20220804115244654"></p>
<p>分析：因为高帽滤波的减法运算，所以图像的背景色就是0了</p>
<h4 id="低帽滤波"><a href="#低帽滤波" class="headerlink" title="低帽滤波"></a>低帽滤波</h4><p>定义：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804115641941.png" alt="image-20220804115641941"></p>
<p><strong>A</strong>输入的图像，<strong>B</strong>为采用的结构元素，即从图像中减去形态学闭操作后的图像。通过<strong>低帽滤波可以获取图像的边缘</strong></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread(&#x27;D:\reports\label.jpg&#x27;);</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">HW = size(image);</span><br><span class="line">subplot(231);imshow(image);title(&#x27;原图像&#x27;)</span><br><span class="line">se = strel(&#x27;disk&#x27;,3);% 制定一个棋盘膨胀的结构</span><br><span class="line">bw1 = imtophat(image,se); % 高帽滤波</span><br><span class="line">bw2 = imbothat(image,se); % 低帽滤波</span><br><span class="line">dealBw2 = imsubtract(imadd(image,bw1),bw2);% 进行图像处理的操作 </span><br><span class="line">subplot(232);imshow(bw1);title(&#x27;高帽滤波后的图像&#x27;)</span><br><span class="line">subplot(233);imshow(bw2);title(&#x27;低帽滤波后的图像&#x27;)</span><br><span class="line">subplot(234);imshow(dealBw2);title(&#x27;处理后的图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804120236113.png" alt="image-20220804120236113"></p>
<p>imsubtract(imadd(image,bw1),bw2)：其中bw1进行的是高帽滤波，bw2进行的是低帽滤波，这样处理的结果使得图像的对比度增强</p>
<h4 id="填充操作"><a href="#填充操作" class="headerlink" title="填充操作"></a>填充操作</h4><p>对灰度图像进行填充</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread(&#x27;D:\reports\label.jpg&#x27;);</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">% bw = im2bw(image);</span><br><span class="line">fillBw = imfill(image,&#x27;holes&#x27;);</span><br><span class="line">subplot(121),imshow(image),title(&#x27;二值化图像&#x27;)</span><br><span class="line">subplot(122),imshow(fillBw),title(&#x27;填充操作之后的图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804142511067.png" alt="image-20220804142511067"></p>
<p>分析：右边的图相比于左边哦我们能看到a和e这种中间有镂空的空洞部分都被进行了填充</p>
<h4 id="灰度图像中设定阈值的局部极大值"><a href="#灰度图像中设定阈值的局部极大值" class="headerlink" title="灰度图像中设定阈值的局部极大值"></a>灰度图像中设定阈值的局部极大值</h4><p>[输入像素值-周围值(10)]&gt;X(设定阈值)时,这个像素点就会被特别标记</p>
<p>通过imhmax()对极大值进行抑制</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread(&#x27;D:\reports\label.jpg&#x27;);</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">R = imextendedmax(image,100); % 带阈值的局部区域最大</span><br><span class="line">R2 = imextendedmax(image,150);</span><br><span class="line">subplot(131),imshow(image),title(&#x27;原图像&#x27;)</span><br><span class="line">subplot(132),imshow(R),title(&#x27;设定阈值(100)&#x27;);</span><br><span class="line">subplot(133),imshow(R2),title(&#x27;设定阈值(150)&#x27;);</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804143530355.png" alt="image-20220804143530355"></p>
<h4 id="灰度图像边缘测定"><a href="#灰度图像边缘测定" class="headerlink" title="灰度图像边缘测定"></a>灰度图像边缘测定</h4><p>使用膨胀腐蚀</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread(&#x27;D:\reports\label.jpg&#x27;);</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">se = strel(&#x27;disk&#x27;,3);% 创模板</span><br><span class="line">erodeImage = imerode(image,se);% 腐蚀操作</span><br><span class="line">dilateImage = imdilate(image,se);% 膨胀操作</span><br><span class="line">dealImage1 = dilateImage - erodeImage;</span><br><span class="line">dealImage2 = image - erodeImage;</span><br><span class="line">subplot(221),imshow(image),title(&#x27;原图像&#x27;)</span><br><span class="line">subplot(222),imshow(dealImage1),title(&#x27;膨胀-腐蚀&#x27;)</span><br><span class="line">subplot(223),imshow(dealImage2),title(&#x27;原图-腐蚀&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804144738253.png" alt="image-20220804144738253"></p>
<h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><h4 id="图像的频谱图展示"><a href="#图像的频谱图展示" class="headerlink" title="图像的频谱图展示"></a>图像的频谱图展示</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all;close all;</span><br><span class="line">rgb = imread(&#x27;D:\reports\label.jpg&#x27;);</span><br><span class="line">image = rgb2gray(rgb);</span><br><span class="line">F = fft2(im2double(image)); % FFT傅里叶变换</span><br><span class="line">F = fftshift(F); % FFT频谱平移</span><br><span class="line">F = real(F); </span><br><span class="line">T = log(F+1); %频谱对数变换</span><br><span class="line">subplot(231),imshow(image),title(&#x27;原图像&#x27;)</span><br><span class="line">subplot(234),imshow(T,[]),title(&#x27;原图像的频率图&#x27;)</span><br><span class="line">noisyImage = imnoise(image ,&#x27;salt &amp; pepper&#x27;,0.04); % 向图像之中添加椒盐噪声</span><br><span class="line">noisyF = fft2(im2double(noisyImage));</span><br><span class="line">noisyF = fftshift(noisyF);</span><br><span class="line">noisyF = real(noisyF);</span><br><span class="line">noisyT = log(noisyF+1); % 频谱对数变换</span><br><span class="line">subplot(232),imshow(noisyImage),title(&#x27;椒盐噪声&#x27;)</span><br><span class="line">subplot(235),imshow(noisyT,[]),title(&#x27;椒盐噪声的频率图&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：<br><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804153219688.png" alt="image-20220804153219688"></p>
<h4 id="高斯低通-高通-频域滤波"><a href="#高斯低通-高通-频域滤波" class="headerlink" title="高斯低通(高通)频域滤波"></a>高斯低通(高通)频域滤波</h4><p>低通滤波：对频谱图做高斯低通滤波，使低频通过而使高频衰减，滤波之后的图像会变得模糊，比原始图像减少尖锐的细节部分而突出平滑过渡部分，</p>
<p>高通滤波：使高频通过而使低频衰减，结果发现滤波后的图像变锐化，比原始图像减少平滑过渡而突出边缘等细节部分。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">image = imread(&#x27;D:\reports\blackAndWhite.jpg&#x27;)</span><br><span class="line">I = rgb2gray(image)</span><br><span class="line">P = double(I);</span><br><span class="line">M = im2double(I); % 转化为归一化二维矩阵</span><br><span class="line">Q = fft2(P); % 转化为二维矩阵</span><br><span class="line">N = fft2(M); </span><br><span class="line">move1 = fftshift(N); % 转换到频谱的中心</span><br><span class="line">move2 = fftshift(Q);</span><br><span class="line">subplot(231),imshow(I),title(&#x27;原图像&#x27;)</span><br><span class="line">HW = size(move2);</span><br><span class="line">d0 = 50 ;% 截至频率，数值越小越平滑</span><br><span class="line">row1 = fix(HW(1)/2)</span><br><span class="line">col1 = fix(HW(2)/2)</span><br><span class="line">for i = 1:HW(1)</span><br><span class="line">    for j = 1:HW(2)</span><br><span class="line">        d = sqrt((i-row1)^2+(j-col1)^2);</span><br><span class="line">        hl(i,j) = exp(-d^2 /(2*d0^2));% 高斯低通滤波器</span><br><span class="line">        hh(i,j) = 1-hl(i,j); % 高斯高通滤波器</span><br><span class="line">        gl(i,j) = hl(i,j) * move2(i,j); % 高斯低通滤波</span><br><span class="line">        gh(i,j) = hh(i,j) * move2(i,j); % 高斯高通滤波</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">% 对图像进行傅里叶的反变换</span><br><span class="line">gl = ifftshift(gl);</span><br><span class="line">g1 = ifft2(gl); </span><br><span class="line">k1 = uint8(real(gl));</span><br><span class="line">gh = ifftshift(ifft(gh));</span><br><span class="line">k2 = uint8(real(gh));</span><br><span class="line">subplot(232),imshow(k1),title(&#x27;原图像低通滤波&#x27;)</span><br><span class="line">subplot(233),imshow(k2),title(&#x27;原图像高通滤波&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：<br><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804165900350.png" alt="image-20220804165900350"></p>
<p>总结：不知道为什么达不到平滑图像的效果，对比网上的代码，感觉也没有错</p>
<p><a href="https://blog.csdn.net/wulafly/article/details/53225255">参考文章</a></p>
<p><a href="http://www.dwenzhao.cn/profession/language/matlabimgtrans.html">频率域波的运用处理</a></p>
<h3 id="图像的合成处理"><a href="#图像的合成处理" class="headerlink" title="图像的合成处理"></a>图像的合成处理</h3><p>对图像数据进行加减异或运算从而对图像进行处理，这里就简单的展示了一下加运算</p>
<h4 id="加运算"><a href="#加运算" class="headerlink" title="加运算"></a>加运算</h4><p>数据信息：<em>uint8</em> 类型的数据容易溢出，饱和截取操作；或者预先转化为<em>uint16</em>数据类型。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">image = imread(&#x27;D:\reports\blackAndWhite.jpg&#x27;);</span><br><span class="line">image = rgb2gray(image);</span><br><span class="line">image2 = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image2 = rgb2gray(image2);</span><br><span class="line">newImage = imadd(image,image2,&#x27;uint8&#x27;);</span><br><span class="line">newImage2 = imadd(image,image2,&#x27;uint16&#x27;);</span><br><span class="line">subplot(231),imshow(image),title(&#x27;图像1&#x27;)</span><br><span class="line">subplot(232),imshow(image2),title(&#x27;图像2&#x27;)</span><br><span class="line">subplot(234),imshow(newImage,[]),title(&#x27;相加(饱和截取)&#x27;)</span><br><span class="line">subplot(235),imshow(newImage2,[]),title(&#x27;uint16数据类型&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804172555954.png" alt="image-20220804172555954"></p>
<h3 id="彩色图像的处理"><a href="#彩色图像的处理" class="headerlink" title="彩色图像的处理"></a>彩色图像的处理</h3><p>cat运算符可以堆叠出RGB图像</p>
<p>rgb2ind()函数生成8色的抖动和非抖动图像</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">image = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image2 = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">[f1,map] = rgb2ind(image,8,&#x27;nodither&#x27;);% 将rgb图像转化为索引图像，且索引图像是8种颜色(不抖动)</span><br><span class="line">subplot(121),imshow(f1,map),title(&#x27;rgb2ind无抖动图像&#x27;);</span><br><span class="line">[f2,map2] = rgb2ind(image,8,&#x27;dither&#x27;);</span><br><span class="line">subplot(122),imshow(f2,map2),title(&#x27;rgb2ind抖动图像&#x27;);</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804234124105.png" alt="image-20220804234124105"></p>
<p>‘replicate’:图像大小通过复制外边界的值来扩展</p>
<p>平滑rgb图像</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">image = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">image2 = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">mode = fspecial(&#x27;motion&#x27;,50,40); % 创建一个滤波</span><br><span class="line">filteredImage = imfilter(image,mode);</span><br><span class="line">subplot(121),imshow(image),title(&#x27;原图像&#x27;)</span><br><span class="line">subplot(122),imshow(filteredImage),title(&#x27;平滑图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804235002633.png" alt="image-20220804235002633"></p>
<p>锐化rgb图像</p>
<p>这里是用原图像减去拉普拉斯算子处理之后的图像得到锐化图像</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">image = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">mode = [1 1 1 1 1;1 1 1 1 1;1 1 -24 1 1;1 1 1 1 1;1 1 1 1 1];% 拉普拉斯算子</span><br><span class="line">filteredImage = image - imfilter(image,mode,&#x27;replicate&#x27;);</span><br><span class="line">subplot(121),imshow(image),title(&#x27;原图像&#x27;)</span><br><span class="line">subplot(122),imshow(filteredImage),title(&#x27;锐化图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220804235923711.png" alt="image-20220804235923711"></p>
<p>将图像转化为hsi（色调，饱和度，亮度），再对其中一个分量进行处理得到的图像</p>
<p>rgb2hsi()函数代码（同目录之下创建rgb2hsi文件）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function hsi = rgb2hsi(rgb)</span><br><span class="line">%hsi = rgb2hsi( rgb )将rgb转化为hsi</span><br><span class="line">%输出hsi是double型的</span><br><span class="line"> </span><br><span class="line">% rgb =imread(rgb);%没有这句会报错</span><br><span class="line">%提取图像RGB分量</span><br><span class="line">rgb = im2double(rgb);</span><br><span class="line">r = rgb(:,:,1);</span><br><span class="line">g = rgb(:,:,2);</span><br><span class="line">b = rgb(:,:,3);</span><br><span class="line"> </span><br><span class="line">%执行转化</span><br><span class="line">num = 0.5*((r-g)+(r-b));</span><br><span class="line">den = sqrt((r-g).^2 +(r-b).*(g-b));</span><br><span class="line">theta = acos(num./(den + eps)); %eps极小值标示，防止除以0出错</span><br><span class="line"> </span><br><span class="line">H = theta;</span><br><span class="line">H( b&gt;g ) = 2*pi - H( b&gt;g );</span><br><span class="line">H = H/(2*pi);</span><br><span class="line"> </span><br><span class="line">num = min(min(r,g),b);</span><br><span class="line">den = r + g + b;</span><br><span class="line">den(den == 0) = eps;%eps极小值标示，防止除以0出错</span><br><span class="line">S = 1 - 3.* num./den;</span><br><span class="line">H( S==0 ) = 0;</span><br><span class="line">I = ( r + g + b )/3;</span><br><span class="line"> </span><br><span class="line">%组合hsi图像，H、S、I是矩阵</span><br><span class="line">hsi = cat(3,H,S,I);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>hsi2rgb()函数脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%hsi2rgb源程序</span><br><span class="line">function rgb=hsi2rgb(hsi)</span><br><span class="line">%rgb=hsi2rgb(hsi)把一幅HSI图像转换为RGB图像</span><br><span class="line">%其中HSI是double型</span><br><span class="line">%hsi(:,:,1)是色度分量，它的范围是除以2*pi后在[0,1]内</span><br><span class="line">%hsi(:,:,2)是饱和度分量，它的范围是在[0,1]内</span><br><span class="line">%hsi(:,:,3)是亮度分量，它的范围是在[0,1]内</span><br><span class="line"></span><br><span class="line">%输出图像的分量是</span><br><span class="line">%rgb(:,:,1)为红</span><br><span class="line">%rgb(:,:,2)为绿</span><br><span class="line">%rgb(:,:,3)为蓝</span><br><span class="line"></span><br><span class="line">%提取HSI的各个分量</span><br><span class="line">hsi=im2double(hsi);%把hsi转化为双精度浮点类型</span><br><span class="line">H=hsi(:,:,1)*2*pi;</span><br><span class="line">S=hsi(:,:,2);</span><br><span class="line">I=hsi(:,:,3);</span><br><span class="line"></span><br><span class="line">%执行变换方程</span><br><span class="line">R=zeros(size(hsi,1),size(hsi,2));</span><br><span class="line">G=zeros(size(hsi,1),size(hsi,2));</span><br><span class="line">B=zeros(size(hsi,1),size(hsi,2));</span><br><span class="line"></span><br><span class="line">%RG区(0&lt;=H&lt;2*pi/3)</span><br><span class="line">idx=find((0&lt;=H) &amp; (H&lt;2*pi/3));%寻找0&lt;=H&lt;2*pi/3</span><br><span class="line">B(idx)=I(idx).*(1-S(idx));</span><br><span class="line">R(idx)=I(idx).*(1+S(idx).*cos(H(idx))./cos(pi/3-H(idx)));</span><br><span class="line">G(idx)=3*I(idx)-(R(idx)+B(idx));</span><br><span class="line"></span><br><span class="line">%BG区(2*pi/3&lt;=H&lt;4*pi/3)</span><br><span class="line">idx=find((2*pi/3&lt;=H) &amp; (H&lt;4*pi/3));%寻找2*pi/3&lt;=H&lt;4*pi/3</span><br><span class="line">R(idx)=I(idx).*(1-S(idx));</span><br><span class="line">G(idx)=I(idx).*(1+S(idx).*cos(H(idx)-2*pi/3)./cos(pi-H(idx)));</span><br><span class="line">B(idx)=3*I(idx)-(R(idx)+G(idx));</span><br><span class="line"></span><br><span class="line">%BR区(4*pi/3&lt;=H&lt;=2*pi)</span><br><span class="line">idx=find((4*pi/3&lt;=H) &amp; (H&lt;=2*pi));%寻找4*pi/3&lt;=H&lt;=2*pi</span><br><span class="line">G(idx)=I(idx).*(1-S(idx));</span><br><span class="line">B(idx)=I(idx).*(1+S(idx).*cos(H(idx)-4*pi/3)./cos(5*pi/3-H(idx)));</span><br><span class="line">R(idx)=3*I(idx)-(G(idx)+B(idx));</span><br><span class="line"></span><br><span class="line">%将3个分量联合成为一个RGB图像</span><br><span class="line">rgb=cat(3,R,G,B);</span><br><span class="line">rgb=max(min(rgb,1),0);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>主函数（这里是对亮度分量进行平滑处理的结果）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">image = imread(&#x27;D:\reports\test.jpg&#x27;);</span><br><span class="line">hsiImage = rgb2hsi(image)% 将原图像转化为hsi图像</span><br><span class="line">% 分别得到hsi的三个分量</span><br><span class="line">h = hsiImage(:,:,1);</span><br><span class="line">s = hsiImage(:,:,2);</span><br><span class="line">i = hsiImage(:,:,3);</span><br><span class="line">mode = ones(25)./(25*25);</span><br><span class="line">filterI = imfilter(i,mode,&#x27;replicate&#x27;);% 对其中的i分量，亮度分量使用filter进行平滑处理</span><br><span class="line">hsiImage = cat(3,h,s,filterI);% 将这三个方向的值组合在一起</span><br><span class="line">image2 = hsi2rgb(hsiImage)% 将hsi图像转化成rgb图像</span><br><span class="line">subplot(121),imshow(image),title(&#x27;原图像&#x27;)</span><br><span class="line">subplot(122),imshow(image2),title(&#x27;亮度分量平滑图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805002223940.png" alt="image-20220805002223940"></p>
<p><a href="https://juejin.cn/post/7001840048278601758">参考文章</a></p>
<h3 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h3><p>小波变换有着窗口自适应的特点，即高频信号分辨率高（但是频率分辨率差），低频信号频率分辨率高（但是时间分辨率差）</p>
<p>wavemngr(‘read’,1):进行小波的查看</p>
<p>waveinfo():查看小波的相关信息</p>
<p>小波在时间上的移动,逐一比较不同位置的窗口信号,小波系数，<strong>小波系数越大</strong>，则证明小波与该段信号的<strong>拟合程度越好</strong>,</p>
<p>小波的信息查询：waveinfo函数，例如waveinfo(‘wname’)</p>
<p>wname代表的小波有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;haar&#x27; : Haar wavelet.</span><br><span class="line">&#x27;db&#x27; : Daubechies wavelets.</span><br><span class="line">&#x27;sym&#x27; : Symlets.</span><br><span class="line">&#x27;coif&#x27; : Coiflets.</span><br><span class="line">&#x27;bior&#x27; : Biorthogonal wavelets.</span><br><span class="line">&#x27;rbio&#x27; : Reverse biorthogonal wavelets.</span><br><span class="line">&#x27;meyr&#x27; : Meyer wavelet.</span><br><span class="line">&#x27;dmey&#x27; : Discrete Meyer wavelet.</span><br><span class="line">&#x27;gaus&#x27; : Gaussian wavelets.</span><br><span class="line">&#x27;mexh&#x27; : Mexican hat wavelet.</span><br><span class="line">&#x27;morl&#x27; : Morlet wavelet.</span><br><span class="line">&#x27;cgau&#x27; : Complex Gaussian wavelets.</span><br><span class="line">&#x27;cmor&#x27; : Complex Morlet wavelets.</span><br><span class="line">&#x27;shan&#x27; : Complex Shannon wavelets.</span><br><span class="line">&#x27;fbsp&#x27; : Complex Frequency B-spline wavelets.</span><br><span class="line">&#x27;fk&#x27; : Fejer-Korovkin orthogonal wavelets</span><br></pre></td></tr></table></figure>



<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805103058654.png" alt="image-20220805103058654"></p>
<p><strong>wfilters函数</strong></p>
<blockquote>
<p>[LO<em>D,HI</em>D,LO<em>R,HI</em>R] = wfilters(‘wname’):计算正交小波或双正交小波（wname）有关联的四个滤波器</p>
<p>LO_D，分解低通滤波器;HI_D，分解高通滤波器;LO_R，重构低通滤波器;HI_R，重构高通滤波器</p>
</blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">[LOD,HID,LOR,HIR] = wfilters(&#x27;db45&#x27;);% 得到该小波关联的四个滤波器</span><br><span class="line">% 将这四个滤波器显示出来</span><br><span class="line">subplot(221),stem(LOD),xlim([0,100]),title(&#x27;分解低通滤波器&#x27;)</span><br><span class="line">xlabel(&#x27;x&#x27;),ylabel(&#x27;y&#x27;)</span><br><span class="line">subplot(222),stem(HID),xlim([0,100]),title(&#x27;分解高通滤波器&#x27;)</span><br><span class="line">xlabel(&#x27;x&#x27;),ylabel(&#x27;y&#x27;)</span><br><span class="line">subplot(223),stem(LOR),xlim([0,100]),title(&#x27;重构低通滤波器&#x27;)</span><br><span class="line">xlabel(&#x27;x&#x27;),ylabel(&#x27;y&#x27;)</span><br><span class="line">subplot(224),stem(HIR),xlim([0,100]),title(&#x27;重构低通滤波器&#x27;)</span><br><span class="line">xlabel(&#x27;x&#x27;),ylabel(&#x27;y&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805105124689.png" alt="image-20220805105124689"></p>
<h4 id="二维离散小波变换图像单层小波分解"><a href="#二维离散小波变换图像单层小波分解" class="headerlink" title="二维离散小波变换图像单层小波分解"></a>二维离散小波变换图像单层小波分解</h4><p>使用dwt2()函数</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">image = imread(&#x27;D:\reports\test.jpg&#x27;);% 获取照片</span><br><span class="line">T = rgb2gray(image);% 将照片转化成灰度模式</span><br><span class="line">[sm1,deHo,deVe,deDi] = dwt2(T,&#x27;bior3.7&#x27;);% 将灰度照片单层分解成四个层面</span><br><span class="line">% 将四个层面的图像分别输出</span><br><span class="line">figure</span><br><span class="line">subplot(141),imshow(uint8(sm1),title(&#x27;近似分量&#x27;)% 近似分量</span><br><span class="line">subplot(142),imshow(deHo),title(&#x27;细节水平分量&#x27;)% 细节水平分量</span><br><span class="line">subplot(143),imshow(deVe),title(&#x27;细节垂直分量&#x27;)% 细节垂直分量</span><br><span class="line">subplot(144),imshow(deDi),title(&#x27;细节对角分量&#x27;)% 细节对角分量&#x27;</span><br><span class="line">figure</span><br><span class="line">subplot(121),imshow(image),title(&#x27;原图&#x27;)% 原图</span><br><span class="line">subplot(122),imshow([sm1,deHo;deVe,deDi]),title(&#x27;小波变换分量组合&#x27;)% 小波变换分量组合图像</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805131621875.png" alt="image-20220805131621875"></p>
<h4 id="小波实现图像的重构"><a href="#小波实现图像的重构" class="headerlink" title="小波实现图像的重构"></a>小波实现图像的重构</h4><p>idwt2()函数</p>
<p>这里使用db1小波函数对图像进行分解，然后再用db4的小波函数对图像进行重构，做差之后就能直观的看到前后图像的差别</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">image = imread(&#x27;D:\reports\test.jpg&#x27;);% 获取照片</span><br><span class="line">T = rgb2gray(image);% 将照片转化成灰度模式</span><br><span class="line">[sm1,deHo,deVe,deDi] = dwt2(T,&#x27;db1&#x27;);% 将灰度照片单层分解成四个层面</span><br><span class="line">imageS = size(T);%获得原图像的尺度</span><br><span class="line">T0 = idwt2(sm1,deHo,deVe,deDi,&#x27;db4&#x27;,imageS);% 利用小波分解的第一层系数去重构</span><br><span class="line">T1 = double(T)-T0;</span><br><span class="line">figure</span><br><span class="line">subplot(131),imshow(uint8(T)),title(&#x27;原图像&#x27;)</span><br><span class="line">subplot(132),imshow(uint8(T0)),title(&#x27;重构图像&#x27;)</span><br><span class="line">subplot(133),imshow(uint8(T1)),title(&#x27;差异图像&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805132501969.png" alt="image-20220805132501969"></p>
<h4 id="多层小波重构"><a href="#多层小波重构" class="headerlink" title="多层小波重构"></a>多层小波重构</h4><p>使用函数upcoef2()完成重构</p>
<p>appcoef2()：获取小波分解的近似系数</p>
<p>[<a href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&s_tid=srchtitle_detcoef2_1#mw_09cf57bc-3330-4b93-a910-445cde51c817"><code>h</code></a>,<a href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&s_tid=srchtitle_detcoef2_1#mw_e81701d6-fe13-4c82-8ca5-291a4f343e89"><code>v</code></a>,<a href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&s_tid=srchtitle_detcoef2_1#mw_3804afb4-f6e9-4671-9dda-14dae7e60694"><code>d</code></a>] = detcoef2(‘all’,<a href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&s_tid=srchtitle_detcoef2_1#mw_0f3a673f-2992-4843-ae0f-b9e10ec8712d"><code>c</code></a>,<a href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&s_tid=srchtitle_detcoef2_1#mw_63157831-b6ac-4121-95b6-d9fd171a3585"><code>s</code></a>,<a href="https://ww2.mathworks.cn/help/wavelet/ref/detcoef2.html?searchHighlight=detcoef2&s_tid=srchtitle_detcoef2_1#mw_91710198-9837-410b-bfdc-c2728c302aef"><code>n</code></a>):返回级别n处的水平h、垂直v和对角线d细节系数。’all‘这个参数也可以相应的修改而获得三个方向对应的细节系数</p>
<p>二层的分解需要将用小波函数分解出两层，然后再对每一层再进行小波变换的分解，重构的时候分方向重构。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">image = imread(&#x27;D:\reports\test.jpg&#x27;);% 获取照片</span><br><span class="line">T = rgb2gray(image);% 将照片转化成灰度模式</span><br><span class="line">[c,s] = wavedec2(T,2,&#x27;db4&#x27;); % 对图像进行小波的二层分解 wavedec2 小波函数使用db4</span><br><span class="line">siz = s(size(s,1),:);% 获得第二层小波分解的系数矩阵</span><br><span class="line">ca1 = appcoef2(c,s,&#x27;db4&#x27;,2); % 小波分解的近似系数 appcoef()</span><br><span class="line">a1 = upcoef2(&#x27;a&#x27;,ca1,&#x27;db4&#x27;,2,siz); % upcoef2()函数进行重构</span><br><span class="line"></span><br><span class="line">chd1 = detcoef2(&#x27;h&#x27;,c,s,2); % 小波分解的细节系数水平分量detcoef2()&#x27;h</span><br><span class="line">hd1 = upcoef2(&#x27;h&#x27;,chd1,&#x27;db4&#x27;,2,siz);</span><br><span class="line"></span><br><span class="line">cvd1 = detcoef2(&#x27;v&#x27;,c,s,2); % 细节系数垂直分量&#x27;v&#x27;</span><br><span class="line">vd1 = upcoef2(&#x27;v&#x27;,cvd1,&#x27;db4&#x27;,2,siz);</span><br><span class="line"></span><br><span class="line">cdd1 = detcoef2(&#x27;d&#x27;,c,s,2); % 细节系数对角分量&#x27;d&#x27;</span><br><span class="line">dd1 = upcoef2(&#x27;d&#x27;,cdd1,&#x27;db4&#x27;,2,siz);</span><br><span class="line"></span><br><span class="line">result1 = a1+hd1+vd1+dd1;  % 将四个重构的分量相加得到图像的重构结果</span><br><span class="line">figure</span><br><span class="line">subplot(221),imshow(uint8(a1)),title(&#x27;小波分解的近似系数&#x27;)</span><br><span class="line">subplot(222),imshow(hd1),title(&#x27;小波分解的近似系数水平分量&#x27;)</span><br><span class="line">subplot(223),imshow(vd1),title(&#x27;小波分解的细节系数垂直分量&#x27;)</span><br><span class="line">subplot(224),imshow(dd1),title(&#x27;小波分解的细节系数对角分量&#x27;)</span><br><span class="line">figure</span><br><span class="line">subplot(121),imshow(uint8(T)),title(&#x27;原图像&#x27;)</span><br><span class="line">subplot(122),imshow(uint8(result1)),title(&#x27;二层分解重构图像&#x27;)</span><br></pre></td></tr></table></figure>



<p>效果图:</p>
<p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805141517643.png" alt="image-20220805141517643"></p>
<h4 id="小波去噪去噪"><a href="#小波去噪去噪" class="headerlink" title="小波去噪去噪"></a>小波去噪去噪</h4><p>wrcoef2():使用wname指定的小波返回基于图像的小波分解结构[c,s]的type重构系数矩阵</p>
<p>例:<a href="https://ww2.mathworks.cn/help/wavelet/ref/wrcoef2.html?searchHighlight=wrcoef2&s_tid=srchtitle_wrcoef2_1#mw_9150039f-ca62-418b-8ca4-60dd701e1d07"><code>x</code></a> = wrcoef2(<a href="https://ww2.mathworks.cn/help/wavelet/ref/wrcoef2.html?searchHighlight=wrcoef2&s_tid=srchtitle_wrcoef2_1#mw_e8ef2513-e0bd-4cb0-8627-0cd7725f54bc"><code>type</code></a>,<a href="https://ww2.mathworks.cn/help/wavelet/ref/wrcoef2.html?searchHighlight=wrcoef2&s_tid=srchtitle_wrcoef2_1#mw_177fae65-edf4-44c3-aecd-9b55acdb796c"><code>c</code></a>,<a href="https://ww2.mathworks.cn/help/wavelet/ref/wrcoef2.html?searchHighlight=wrcoef2&s_tid=srchtitle_wrcoef2_1#mw_34affb98-fb55-4113-8dd1-8faf2f83de0a"><code>s</code></a>,<a href="https://ww2.mathworks.cn/help/wavelet/ref/wrcoef2.html?searchHighlight=wrcoef2&s_tid=srchtitle_wrcoef2_1#mw_6d9d77b8-5a90-459f-9f09-0edd798f673a"><code>wname</code></a>) ;a2 = wrcoef2(“a”,c,s,”sym5”,2);</p>
<p>NC = wthcoef2(‘type’,C,S,N,T,SORH) ：向量N和T中定义阈值，再从小波分解结构[C,S]中获得的水平、垂直或对角系数</p>
<p><a href="https://chowdera.com/2022/03/202203110547374632.html">参考文章</a></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">image = imread(&#x27;D:\reports\test.jpg&#x27;);% 获取照片</span><br><span class="line">T = rgb2gray(image);% 将照片转化成灰度模式</span><br><span class="line">T = imnoise(T,&#x27;speckle&#x27;,0.1);</span><br><span class="line">subplot(131),imshow(uint8(T)),title(&#x27;加噪图像&#x27;)</span><br><span class="line">% init=2055615866;</span><br><span class="line">% randn(&#x27;seed&#x27;,init);</span><br><span class="line">% T = double(T) + 2*randn(size(T));</span><br><span class="line">[c,s] = wavedec2(T,2,&#x27;sym4&#x27;); % 对图像进行小波的二层分解 wavedec2 小波函数使用db4</span><br><span class="line">result1 = wrcoef2(&#x27;a&#x27;,c,s,&#x27;sym4&#x27;,2);% 重构第二层的近似系数，小波分解去噪的操作</span><br><span class="line">subplot(132),imshow(result1),title(&#x27;小波分解去噪&#x27;)</span><br><span class="line">n = [1,2];% 设置阈值N 尺度向量</span><br><span class="line">r = [10.28, 24.08];% 设置阈值T 阈值向量</span><br><span class="line">dealData0 = wthcoef2(&#x27;t&#x27;,c,s,n,r,&#x27;s&#x27;);% 对高频小波进行阈值处理 wthcoef2</span><br><span class="line">dealData1 = wthcoef2(&#x27;t&#x27;,dealData0,s,n,r,&#x27;s&#x27;);% 对高频小波进行第二次阈值处理</span><br><span class="line">result2 = waverec2(dealData1,s,&#x27;sym4&#x27;);% 对阈值处理之后的小波进行重构 waverec2（）</span><br><span class="line">subplot(133),imshow(result1),title(&#x27;小波阈值去噪&#x27;)</span><br></pre></td></tr></table></figure>

<p>实验结果：<br><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/image-20220805154151408.png" alt="image-20220805154151408"></p>
<p>总结：能够看到噪声明显减弱了，但是图像也更模糊了，去噪的过程就是过滤高频小波，高频小波之中表现的是细节</p>
]]></content>
      <categories>
        <category>数字图像处理基础</category>
      </categories>
      <tags>
        <tag>数字图像处理基础实验</tag>
      </tags>
  </entry>
</search>
