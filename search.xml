<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUUCTF的Dig the way - 栈溢出</title>
    <url>/2022/02/27/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h2 id="BUUCTF的Dig-the-way-栈溢出"><a href="#BUUCTF的Dig-the-way-栈溢出" class="headerlink" title="BUUCTF的Dig the way - 栈溢出"></a>BUUCTF的Dig the way - 栈溢出</h2><p>这是一道栈溢出的题目</p>
<p>进入到主函数里面</p>
<p>首先就是读取data之中数据的代码</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227123156345.png" alt="image-20220227123156345"></p>
<p>通过代码我们可以知道这个地方并没有对数据的写入长度进行限制</p>
<h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><p>fseek()函数可以移动文件的读写指针到指定的位置，即移动当前文件的位置指针，其原型为：<br>  int fseek(FILE * stream, long offset, int fromwhere);</p>
<p>【参数】stream为文件指针，offset为偏移量，fromwhere为指针的起始位置。</p>
<p>参数 offset 为根据参数 fromwhere 来移动读写位置的位移数。参数 fromwhere 为下列其中一种：</p>
<ul>
<li>SEEK_SET：从距文件开头 offset 位移量为新的读写位置；</li>
<li>SEEK_CUR：以目前的读写位置往后增加 offset 个位移量；</li>
<li>SEEK_END：将读写位置指向文件尾后再增加 offset 个位移量。</li>
</ul>
<p>例子：</p>
<ul>
<li>将读写位置移动到文件开头：fseek(fp, 0, SEEK_SET);</li>
<li>将读写位置移动到文件尾时：fseek(fp, 0, SEEK_END);</li>
<li>将读写位置动到离文件开头100字节处：fseek(fp,100L, SEEK_SET);</li>
<li>将读写指针移动到离文件当前位置100字节处：fseek(fp,100L, SEEK_CUR);</li>
<li>将读写指针退回到离文件结尾100字节处：fseek(fp, -100L, SEEK_END);</li>
</ul>
<h4 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h4><p>用 法: <code>long ftell(FILE *fp);</code><br>描 述: 返回当前文件指针位置。这个位置是当前文件指针相对于文件开头的位移量。<br>返回值:返回文件指针的位置，若出错则返回-1L。<br>参数：文件指针。</p>
<h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><p>用 法: size_t fread( void *buffer, size_t size, size_t count, FILE *stream ) ;<br>描 述: fread()用来从文件流中读取数据。参数stream为已打开的文件指针，参数buffer指向欲存放读取进来的数据空间，读取的字节数以参数size * count来决定。<br>返回值: 返回实际读取到的count数目，如果此值比参数count来得小，则代表可能读到了文件尾了或者有错误发生(前者几率大)，这时必须用feof()或ferror()来决定发生什么情况。<br>参数：</p>
<p>buffer ：读取的数据存放的内存的指针（可以是数组，也可以是新开辟的空间，buffer就是一个索引）；<br>size ： 每次读取的字节数 ；<br>count ：读取次数 ；<br>strean：要读取的文件的指针；</p>
<h4 id="三个函数的解析"><a href="#三个函数的解析" class="headerlink" title="三个函数的解析"></a>三个函数的解析</h4><h5 id="func0"><a href="#func0" class="headerlink" title="func0"></a>func0</h5><p>交换栈中的两个数据</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113310818.png" alt="image-20220227113300364"></p>
<h5 id="func1"><a href="#func1" class="headerlink" title="func1"></a>func1</h5><p>这个函数的返回值小于等于2</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113437073.png" alt="image-20220227113437073"></p>
<h5 id="func2"><a href="#func2" class="headerlink" title="func2"></a>func2</h5><p>这个函数的返回值大于等于2</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113508616.png" alt="image-20220227113508616"></p>
<p>现在我们需要使v11等于0 ，程序之中给v11赋值的是func2函数，但是该函数的返回值一定是大于等于2的，显示不可能实现v11= 0</p>
<p>但是在上面的三个函数之中我们可以看到func1的返回值能够等于0 ，所以需要使用func0这个函数调换栈中func1和func2这两个函数的位置</p>
<h4 id="交换func1函数和func0函数位置"><a href="#交换func1函数和func0函数位置" class="headerlink" title="交换func1函数和func0函数位置"></a>交换func1函数和func0函数位置</h4><p>运行func0函数时，传入的参数v12和v13是初始值，我们只需将表示func1地址的v15 和 表示func2地址的v16交换</p>
<p>v15的地址是 v8+4*7    v16的地址是v8+4*8 所以需要将v12 和 v13的值设为7 和 8 ；</p>
<p>按道理来说7和8的顺序没有关系，但是实际操作发现7和8的赋值顺序不一样，得到的flag是不一样的，只有把v12 = 7和 v13 = 8才可以得到正确的flag</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227122635003.png" alt="image-20220227122635003"></p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227122638492.png" alt="image-20220227122638492"></p>
<h4 id="使得func1的返回值为0"><a href="#使得func1的返回值为0" class="headerlink" title="使得func1的返回值为0"></a>使得func1的返回值为0</h4><p>运行func2时 v12=2  v13=3 ，所以函数之中进行运算的两个数字是v10和v11，v10的值是2 ，若想要这个函数的返回值是0，需要将v10置为-1 即0xffffffff</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227123021830.png" alt="image-20220227123021830"></p>
<h4 id="data文件的构造"><a href="#data文件的构造" class="headerlink" title="data文件的构造"></a>data文件的构造</h4><p>data数据传入的首地址是v7，因为没有设置传入数据的长度，所以可以传入无限制大小的数据，多出来的部分会对后面的数据进行覆盖，v7的长度是20 ，v10的位置是 20+2*4 = 28  v11的位置是 20+3*4=32  v12的位置是 20+4*4=36 v13的位置是 20+5*4=40 总的数据长度是44</p>
<p>用010构造数据，并且保存为data，和exe文件放到同一目录之下，运行程序</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227130028183.png" alt="image-20220227130028183"></p>
<p>运行的结果：</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227130059588.png" alt="image-20220227130059588"></p>
<p>所以得到的flag是</p>
<p>flag{8cda1bdb68a72a392a3968a71bdb8cda}</p>
<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。</p>
<p>实现栈溢出，要满足两个条件。第一，程序要有向栈内写入数据的行为；第二，程序并不限制写入数据的长度。如果想用栈溢出来执行攻击指令，就要在溢出数据内包含攻击指令的内容或地址，并且要将程序控制权交给该指令。攻击指令可以是自定义的指令片段，也可以利用系统内已有的函数及指令。</p>
</blockquote>
<h3 id="函数状态主要涉及三个寄存器-–-esp，ebp，eip"><a href="#函数状态主要涉及三个寄存器-–-esp，ebp，eip" class="headerlink" title="函数状态主要涉及三个寄存器 – esp，ebp，eip"></a>函数状态主要涉及三个寄存器 – esp，ebp，eip</h3><ul>
<li><p><code>esp</code>用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化</p>
</li>
<li><p><code>ebp</code>用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p>
</li>
<li><p><code>eip</code> 用来存储即将执行的程序指令的地址，cpu依照 eip的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p>
<p>使用这三个寄存器实现 将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。</p>
</li>
</ul>
<h3 id="栈溢出攻击"><a href="#栈溢出攻击" class="headerlink" title="栈溢出攻击"></a>栈溢出攻击</h3><blockquote>
<p>当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是<br>eip。所以我们的目标就是让 eip 载入攻击指令的地址。 首先，在退栈过程中，返回地址会被传给<br>eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。</p>
</blockquote>
<p>四种方法归类：</p>
<p>1.修改返回地址，让其指向溢出数据中的一段指令（shellcode） </p>
<p>2.修改返回地址，让其指向内存中已有的某个函数（return2libc）</p>
<p> 3.修改返回地址，让其指向内存中已有的一段指令（ROP） </p>
<p>4.修改某个被调用函数的地址，让其指向另一个函数（hijack GOT）</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227134449755.png" alt="image-20220227134449755"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>32位x86架构下的通用寄存器包括一般寄存器（eax、ebx、ecx、edx），索引寄存器（esi、edi），以及堆栈指针寄存器（esp、ebp）</p>
<ul>
<li><p>eax被称为累加寄存器（Accumulator），用以进行算数运算和返回函数结果等。</p>
</li>
<li><p>ebx被称为基址寄存器（Base），在内存寻址时（比如数组运算）用以存放基地址。</p>
</li>
<li><p>ecx被称为记数寄存器（Counter），用以在循环过程中记数。</p>
</li>
<li><p>edx 被称为数据寄存器（Data），常配合 eax 一起存放运算结果等数据。</p>
</li>
<li><p>esi 指向要处理的数据地址（Source Index）</p>
</li>
<li><p>edi指向存放处理结果的数据地址（Destination Index）</p>
</li>
</ul>
<p>参考文章： <a href="https://blog.csdn.net/weixin_43092232/article/details/96902468">https://blog.csdn.net/weixin_43092232/article/details/96902468</a></p>
]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向之native层的so文件格式</title>
    <url>/2022/03/03/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="安卓逆向之native层的so文件格式"><a href="#安卓逆向之native层的so文件格式" class="headerlink" title="安卓逆向之native层的so文件格式"></a>安卓逆向之native层的so文件格式</h1><h2 id="安卓逆向的相关工具介绍"><a href="#安卓逆向的相关工具介绍" class="headerlink" title="安卓逆向的相关工具介绍"></a>安卓逆向的相关工具介绍</h2><p>反编译代码的工具：</p>
<ul>
<li><a href="https://sourceforge.net/projects/dex2jar/files/">dex2jar</a>:把dex文件转成jar文件</li>
<li><a href="http://java-decompiler.github.io/">jd-gui</a>: 这个工具用于将jar文件转换成java代码</li>
</ul>
<p>反编译资源的工具：</p>
<ul>
<li><a href="https://ibotpeaches.github.io/Apktool/install/">APKTool</a>: 本文重要工具，APK逆向工具。它可以将资源解码，并在修改后可以重新构建它们。它还可以执行一些自动化任务，例如构建apk。解码就是将其恢复成未打包的资源文件（包括resources.arsc，class.dex，9.png和xml）；解码的资源可以重新打包成apk/jar文件；组织和处理依赖于框架资源的APK；Smali调试；执行自动化任务</li>
<li><strong>JEB</strong>:JEB是一个功能强大为安全专业人士设计的安卓应用程序反编译工具，用于逆向工程或者审计apk文件。它是可以直接反编译apk文件的。</li>
<li><a href="https://github.com/skylot/jadx">jadx</a>：jadx是一款反编译利器，同时支持命令行和图形界面，能以最简便的方式完成apk的反编译操作。工具支持<strong>apk、dex、jar、aar</strong>等格式的文件</li>
</ul>
<h2 id="so文件介绍"><a href="#so文件介绍" class="headerlink" title="so文件介绍"></a>so文件介绍</h2><p><strong>概念</strong>：.so 文件是ELF对象文件中可被共享的对象文件(Shared object file)，这些就是所谓的动态库文件。</p>
<p><strong>动态文件的作用</strong>：如果用静态库来生成可执行程序，那每个生成的可执行程序中都会有一份库代码的拷贝。如果在磁盘中存储这些可执行程序，那就会占用额外的磁盘空 间；另外如果拿它们放到Linux系统上一起运行，也会浪费掉宝贵的物理内存。如果将静态库换成动态库，那么这些问题都不会出现。</p>
<p>Android中的so文件就是elf文件，所以需要了解so文件，必须先来了解一下elf文件的格式。</p>
<h3 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h3><p>为了让大家对elf文件格式有一个整体的了解，首先先看一张非虫先生总结好的图片讲解：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/20140918103240781.png" alt="20140918103240781.png"></p>
<p>ELF文件的两种视图，分别是<strong>链接视图</strong>和<strong>执行视图</strong>。</p>
<p><strong>链接视图</strong>：是在<strong>链接时</strong>用到的视图， 以<strong>节</strong>（section）为单位，下图<strong>左侧</strong>的视角是从链接来看的。从图中我们得到，在链接阶段，我们可以忽略<strong>program header table</strong>来处理此文件，因为它是按照<strong>section header table</strong>来处理此文件的。</p>
<p><strong>执行视图</strong>：在<strong>执行时</strong>用到的视图，是以<strong>段</strong>（segment）为单位，下图<strong>右侧</strong>的视角是执行来看的。从图中我们可以得到，在运行阶段可以忽略<strong>section header table</strong>来处理此程序，因为它是按照<strong>program header table</strong>来处理此文件的。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220302143454066.png" alt="image-20220302143454066"></p>
<p><strong>文件的组成</strong>：</p>
<ul>
<li><strong>ELF heade</strong>r： 描述整个文件的组织。</li>
<li><strong>Program Header Table</strong>: 描述文件中的各种segments，用来告诉系统如何创建进程映像的。 </li>
<li><strong>sections</strong> 或者 <strong>segments</strong>：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。</li>
<li><strong>Section Header Table</strong>: 包含了文件各个segction的属性信息</li>
</ul>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220302144111413.png" alt="image-20220302144111413"></p>
<p><strong>区分两种视图的原因</strong>：</p>
<p>在内存之中，多个具有<strong>相同权限</strong>（flg值）section<strong>合并</strong>一个segment。操作系统往往以<strong>页</strong>为基本单位来<strong>管理内存分配</strong>，以及<strong>内存的权限</strong>管理的粒度也是以页为单位。每个section在映射时的长度都是系统<strong>页长度的整数倍</strong>，如果section的长度不是其整数倍，则导致多余部分也将占用一个页，因为一个ELF文件具有很多的section，那么这样将会导致内存浪费严重。为了减少页面内部的碎片，节省了空间，显著提高内存利用率，就将相同权限（flg值）section合并一个segment。</p>
<h4 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h4><p>32位ELF文件中常用的<strong>数据格式</strong>：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303170256836.png" alt="image-20220303170256836"></p>
<p>ELF Header的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define EI_NIDENT 16</span><br><span class="line">typedef struct &#123;</span><br><span class="line">       unsigned char e_ident[EI_NIDENT];  // ELF的一些标识信息，前四位为.ELF,其他的信息比如大小端等</span><br><span class="line">       ELF32_Half e_type;                 // 标识了文件类型</span><br><span class="line">       ELF32_Half e_machine;              // 文件的目标体系架构，比如ARM</span><br><span class="line">       ELF32_Word e_version;              // 0为非法版本，1为当前版本</span><br><span class="line">       ELF32__Addr e_entry;               // 程序入口的虚拟地址</span><br><span class="line">       ELF32_Off e_phoff;                 // 程序头部表偏移地址</span><br><span class="line">       ELF32_Off e_shoff;                 // 节区头部表偏移地址</span><br><span class="line">       ELF32_Word e_flags;                // 保存与文件相关的，特定于处理器的标志</span><br><span class="line">       ELF32_Half e_ehsize;               // ELF头的大小</span><br><span class="line">       ELF32_Half e_phentsize;            // 每个程序头部表的大小</span><br><span class="line">       ELF32_Half e_phnum;                // 程序头部表的数量</span><br><span class="line">       ELF32_Half e_shentsize;            // 每个节区头部表的大小</span><br><span class="line">       ELF32_Half e_shnum;                // 节区头部表的数量</span><br><span class="line">       ELF32_Half e_shstrndx;             // 节区字符串表位置</span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<p>查看ELF Header结构的内容命令： readelf -h android_server</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303171118246.png" alt="image-20220303171118246"></p>
<h5 id="e-entry"><a href="#e-entry" class="headerlink" title="e_entry"></a>e_entry</h5><p>e_entry表示程序入口地址。谓<strong>程序进入点</strong>是指当程序真正执行起来的时候，要运行的指令的运行时地址。其第一条可执行文件test和动态库.so都存在所谓的进入点，且可执行文件的<strong>e_entry</strong>指向C库中的**_start<strong>，而</strong>动态库.so**中的进入点指向 <strong>call_gmon_start</strong>。</p>
<h5 id="重点关注的字段"><a href="#重点关注的字段" class="headerlink" title="重点关注的字段"></a>重点关注的字段</h5><p>在ELF Header中我们需要重点关注以下几个字段：</p>
<ul>
<li><strong>e_entry</strong>：表示程序<strong>入口地址</strong></li>
<li><strong>e_ehsize</strong>：ELF Header<strong>结构大小</strong></li>
<li><strong>e_phoff、e_phentsize、e_phnum</strong>：描述<strong>Program Header Table</strong>的偏移、大小、结构。</li>
<li><strong>e_shoff、e_shentsize、e_shnum</strong>：描述<strong>Section Header Table</strong>的偏移、大小、结构。</li>
<li><strong>e_shstrndx</strong>：这一项描述的是<strong>字符串表</strong>在<strong>Section Header Tabl</strong>e中的索引，值25表示的是Section Header Table中第25项是字符串表（String Table）</li>
</ul>
<h4 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h4><p>section head table(SHT)包含了用来描述每一个<strong>section的条目（entry）</strong>，每一个entry的内容主要包括该 section 的<strong>名称、类型、大小以及在整个ELF文件中的字节偏移位置</strong>等等。</p>
<p>每个条目结构定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    Elf32_Word sh_name;   //节区名，是节区头部字符串表节区（Section Header String Table Section）的索引。名字是一个 NULL 结尾的字符串。</span><br><span class="line">    Elf32_Word sh_type;    //为节区类型</span><br><span class="line">    Elf32_Word sh_flags;    //节区标志</span><br><span class="line">    Elf32_Addr sh_addr;    //如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应处的位置。否则，此字段为 0。</span><br><span class="line">    Elf32_Off sh_offset;    //此成员的取值给出节区的第一个字节与文件头之间的偏移。</span><br><span class="line">    Elf32_Word sh_size;   //此 成 员 给 出 节 区 的 长 度 （ 字 节 数 ）。</span><br><span class="line">    Elf32_Word sh_link;   //此成员给出节区头部表索引链接。其具体的解释依赖于节区类型。</span><br><span class="line">    Elf32_Word sh_info;       //此成员给出附加信息，其解释依赖于节区类型。</span><br><span class="line">    Elf32_Word sh_addralign;    //某些节区带有地址对齐约束.</span><br><span class="line">    Elf32_Word sh_entsize;    //某些节区中包含固定大小的项目，如符号表。对于这类节区，此成员给出每个表项的长度字节数。</span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<h4 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h4><p>有些节区是系统预订的，一般以点开头号,</p>
<h5 id="常用的系统节区"><a href="#常用的系统节区" class="headerlink" title="常用的系统节区"></a>常用的系统节区</h5><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>.bss</td>
<td>SHT_NOBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>包含将出现在程序的内存映像中的为初始化数据。根据定义，当程序开始执行，系统将把这些数据初始化为 0。此节区不占用文件空间。</td>
</tr>
<tr>
<td>.comment</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>包含版本控制信息。</td>
</tr>
<tr>
<td>.data</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td>
</tr>
<tr>
<td>.data1</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td>
</tr>
<tr>
<td>.debug</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>此节区包含用于符号调试的信息。</td>
</tr>
<tr>
<td>.dynamic</td>
<td>SHT_DYNAMIC</td>
<td></td>
<td>此节区包含动态链接信息。节区的属性将包含 SHF_ALLOC 位。是否 SHF_WRITE 位被设置取决于处理器。</td>
</tr>
<tr>
<td>.dynstr</td>
<td>SHT_STRTAB</td>
<td>SHF_ALLOC</td>
<td>此节区包含用于动态链接的字符串，大多数情况下这些字符串代表了与符号表项相关的名称。</td>
</tr>
<tr>
<td>.dynsym</td>
<td>SHT_DYNSYM</td>
<td>SHF_ALLOC</td>
<td>此节区包含了动态链接符号表。</td>
</tr>
<tr>
<td>.fini</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含了可执行的指令，是进程终止代码的一部分。程序正常退出时，系统将安排执行这里的代码。</td>
</tr>
<tr>
<td>.got</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含全局偏移表。</td>
</tr>
<tr>
<td>.hash</td>
<td>SHT_HASH</td>
<td>SHF_ALLOC</td>
<td>此节区包含了一个符号哈希表。</td>
</tr>
<tr>
<td>.init</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含了可执行指令，是进程初始化代码的一部分。当程序开始执行时，系统要在开始调用主程序入口之前（通常指 C 语言的 main 函数）执行这些代码。</td>
</tr>
<tr>
<td>.interp</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含程序解释器的路径名。如果程序包含一个可加载的段，段中包含此节区，那么节区的属性将包含 SHF_ALLOC 位，否则该位为 0。</td>
</tr>
<tr>
<td>.line</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>此节区包含符号调试的行号信息，其中描述了源程序与机器指令之间的对应关系。其内容是未定义的。</td>
</tr>
<tr>
<td>.note</td>
<td>SHT_NOTE</td>
<td>(无)</td>
<td>此节区中包含注释信息，有独立的格式。</td>
</tr>
<tr>
<td>.plt</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含过程链接表（procedure linkage table）。</td>
</tr>
<tr>
<td>.relname .relaname</td>
<td>SHT_REL SHT_RELA</td>
<td></td>
<td>这些节区中包含了重定位信息。如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含 SHF_ALLOC 位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。例如 .text 节区的重定位节区名字将是：.rel.text 或者 .rela.text。</td>
</tr>
<tr>
<td>.rodata .rodata1</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC</td>
<td>这些节区包含只读数据，这些数据通常参与进程映像的不可写段。</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含节区名称。</td>
</tr>
<tr>
<td>.strtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含字符串，通常是代表与符号表项相关的名称。如果文件拥有一个可加载的段，段中包含符号串表，节区的属性将包含SHF_ALLOC 位，否则该位为 0。</td>
</tr>
<tr>
<td>.symtab</td>
<td>SHT_SYMTAB</td>
<td></td>
<td>此节区包含一个符号表。如果文件中包含一个可加载的段，并且该段中包含符号表，那么节区的属性中包含SHF_ALLOC 位，否则该位置为 0。</td>
</tr>
<tr>
<td>.text</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含程序的可执行指令。</td>
</tr>
</tbody></table>
<h5 id="so文件中重要的Section"><a href="#so文件中重要的Section" class="headerlink" title="so文件中重要的Section"></a>so文件中重要的Section</h5><h6 id="符号表-dynsym"><a href="#符号表-dynsym" class="headerlink" title="-符号表(.dynsym)"></a><strong>-符号表(.dynsym)</strong></h6><p>符号表包含用来<strong>定位、重定位程序中符号定义和引用的信息</strong>，简单的理解就是符号表记录了该文件中的所有符号，所谓的符号就是经过<strong>修饰了的函数名或者变量名</strong>，不同的编译器有不同的修饰规则。<strong>例如</strong>符号_ZL15global_static_a，就是由global_static_a变量名经过修饰而来。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">     Elf32_Word st_name;      //符号表项名称。如果该值非0，则表示符号名的字符串表索引(offset)，否则符号表项没有名称。</span><br><span class="line">     Elf32_Addr st_value;       //符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。</span><br><span class="line">     Elf32_Word st_size;         //符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。</span><br><span class="line">     unsigned char st_info;    //符号的类型和绑定属性。</span><br><span class="line">     unsigned char st_other;  //该成员当前包含 0，其含义没有定义。</span><br><span class="line">     Elf32_Half st_shndx;        //每个符号表项都以和其他节区的关系的方式给出定义。此成员给出相关的节区头部表索引。</span><br><span class="line">&#125; Elf32_sym;</span><br></pre></td></tr></table></figure>

<p>符号表的内容</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303175513396.png" alt="image-20220303175513396"></p>
<h6 id="字符串表（-dynstr）"><a href="#字符串表（-dynstr）" class="headerlink" title="-字符串表（.dynstr）"></a><strong>-字符串表（.dynstr）</strong></h6><p>字符串表中存放着<strong>所有符号的名称字符串</strong>。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303175720635.png" alt="image-20220303175720635"></p>
<h6 id="重定位表"><a href="#重定位表" class="headerlink" title="-重定位表"></a><strong>-重定位表</strong></h6><p>重定位就是为程序不同部分<strong>分配加载地址</strong>，<strong>调整</strong>程序中的数据和代码以反映<strong>所分配地址</strong>的过程。简单的言之，则是将程序中的各个部分<strong>映射到合理的地址</strong>上来。例如，当程序调用了一个函数时，相关的调用指令必须把控制传输到适当的目标执行地址。</p>
<p>重定位文件必须包含<strong>如何修改其节区内容的信息</strong>，从而允许可执行文件和共享目标文件保存进程的程序映象的正确信息。</p>
<p>重定位表项的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Addr r_offset;     //重定位动作所适用的位置（受影响的存储单位的第一个字节的偏移或者虚拟地址）</span><br><span class="line">    Elf32_Word r_info;       //要进行重定位的符号表索引，以及将实施的重定位类型（哪些位需要修改，以及如何计算它们的取值）</span><br><span class="line">                                         //其中 .rel.dyn 重定位类型一般为R_386_GLOB_DAT和R_386_COPY；.rel.plt为R_386_JUMP_SLOT</span><br><span class="line">&#125; Elf32_Rel; </span><br></pre></td></tr></table></figure>

<p>r_info 成员使用 <strong>ELF32_R_TYPE 宏运算</strong>可得到<strong>重定位类型</strong>，使用 <strong>ELF32_R_SYM 宏运算</strong>可得到符号在符号表里的<strong>索引值</strong>。</p>
<p>三种宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ELF32_R_SYM(i) ((i)&gt;&gt;8)</span><br><span class="line">#define ELF32_R_TYPE(i) ((unsigned char)(i))</span><br><span class="line">#define ELF32_R_INFO(s, t) (((s)&lt;&lt;8) + (unsigned char)(t))</span><br></pre></td></tr></table></figure>

<p>重定位表中的内容</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303180343936.png" alt="image-20220303180343936"></p>
<h4 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h4><p>程序头部（Program Header）用来在文件中定位各个段的映像,同时包含其他一些用来为程序创建映像所必须的信息。</p>
<p>文件头部的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Word p_type;           //此数组元素描述的段的类型，或者如何解释此数组元素的信息。 </span><br><span class="line">    Elf32_Off  p_offset;           //此成员给出从文件头到该段第一个字节的偏移</span><br><span class="line">    Elf32_Addr p_vaddr;         //此成员给出段的第一个字节将被放到内存中的虚拟地址</span><br><span class="line">    Elf32_Addr p_paddr;        //此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息。</span><br><span class="line">    Elf32_Word p_filesz;         //此成员给出段在文件映像中所占的字节数。可以为0。</span><br><span class="line">    Elf32_Word p_memsz;     //此成员给出段在内存映像中占用的字节数。可以为0。</span><br><span class="line">    Elf32_Word p_flags;         //此成员给出与段相关的标志。</span><br><span class="line">    Elf32_Word p_align;        //此成员给出段在文件中和内存中如何对齐。</span><br><span class="line">&#125; Elf32_phdr;</span><br></pre></td></tr></table></figure>

<p>程序头部表中的内容：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303181440086.png" alt="image-20220303181440086"></p>
<p>so文件格式中结构体的某些参数未详细说明，可以去查看下面的这个参考文章。</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/mergerly/article/details/94585901">https://blog.csdn.net/mergerly/article/details/94585901</a></p>
]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>so文件</tag>
      </tags>
  </entry>
  <entry>
    <title>TEA系列加密解密</title>
    <url>/2022/02/28/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h1 id="TEA系列加密解密"><a href="#TEA系列加密解密" class="headerlink" title="TEA系列加密解密"></a>TEA系列加密解密</h1><h2 id="TEA加密解密"><a href="#TEA加密解密" class="headerlink" title="TEA加密解密"></a>TEA加密解密</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>在密码学中，微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。</p>
<p>代码的特点： </p>
<ul>
<li>加密使用的数据为2个32位无符号整数，密钥为4个32位无符号整数即密钥长度为128位（当加密解密的对象是一串数组的时候，需要将这个32位无符号整数的数组<strong>每两个32位无符号整数划分为一组</strong>，对每一组数据单独加密解密得到结果）</li>
<li>该算法使用了一个常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 <strong>0×9E3779B9</strong>）作为魔数</li>
</ul>
</blockquote>
<h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>拥有一个叫做<a href="https://en.wikipedia.org/wiki/Feistel_cipher">Feistel 结构</a>的密码学结构。这种密码学结构通俗的来讲就是会将加密的plaintext分成L、R两部分，并且满足 <code>L_&#123;i+1&#125; = R_i, R_&#123;i+1&#125; = F(K_i,R_i) \oplus L_i</code> 这种交换式的加密方式的一种结构。</p>
<p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228191440573.png" alt="image-20220228191440573"></p>
<h3 id="TEA加密算法的实现"><a href="#TEA加密算法的实现" class="headerlink" title="TEA加密算法的实现"></a>TEA加密算法的实现</h3><p>参数要求：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组）</p>
<p>加密特征：存在一个<strong>delta值</strong>，这个值会不停的增加到<strong>sum</strong>之中，形成一种循环的效果；会有一个<strong>位移-&gt;与密钥相加-&gt;异或</strong>的过程；计算delta的sum状态值也会参与</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TEA解密算法的实现"><a href="#TEA解密算法的实现" class="headerlink" title="TEA解密算法的实现"></a>TEA解密算法的实现</h3><p>参数要求：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//解密函数  </span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */  </span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */  </span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */  </span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */  </span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);  </span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">    &#125;                                              /* end cycle */  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>解密数组：{0x3e8947cb,0xcc944639,0x31358388,0x3b0b6893,0xda627361,0x3b2e6427}</p>
<p>key数组：{0x4445,0x4144,0x4245,0x4546}</p>
<p>因为在解密的过程之中会产生移位的运算，这个过程会产生溢出，所以每组解密的对象声明成 <strong>v1[3]={0x3e8947cb,0xcc944639,0x0}</strong> 这样的形式</p>
<p>解密的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */</span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v1[3]=&#123;0x3e8947cb,0xcc944639,0x0&#125;,k[4]=&#123;0x4445,0x4144,0x4245,0x4546&#125;;</span><br><span class="line">    uint32_t v2[3]=&#123;0x31358388,0x3b0b6893,0x0&#125;;</span><br><span class="line">    uint32_t v3[3]=&#123;0xda627361,0x3b2e6427&#125;;</span><br><span class="line">    decrypt(v1, k);</span><br><span class="line">    decrypt(v2, k);</span><br><span class="line">    decrypt(v3, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s %s %s\n&quot;,(char*)v1,(char*)v2,(char*)v3);   // 注意如何将一串数组以字符串的形式输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出的结果：fvBXQdEa rcbvhBPx cOA8Ag6J</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p>printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p>
<p>参数的格式</p>
<p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228193403698.png" alt="image-20220228193403698"></p>
<h2 id="XTEA加密解密"><a href="#XTEA加密解密" class="headerlink" title="XTEA加密解密"></a>XTEA加密解密</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作</p>
</blockquote>
<h3 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228193746682.png" alt="image-20220228193746682"></p>
<h3 id="XTEA加密算法的实现"><a href="#XTEA加密算法的实现" class="headerlink" title="XTEA加密算法的实现"></a>XTEA加密算法的实现</h3><p>相较于TEA的变化：</p>
<ul>
<li>由之前的**<code>((v1&lt;&lt;4) + k0) ^ ((v1&gt;&gt;5) + k1)</code>** 变化成了 **<code>((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1)</code>**，此时v1内部数据的加密变化不再受到密钥的影响。</li>
<li>原先的<code>v1 + sum</code>变成了<code>(sum + key[sum &amp; 3])</code>以及<code>sum + key[(sum&gt;&gt;11) &amp; 3]</code>，密钥变成了<strong>轮转</strong>使用，而不是固定只针对某种数据进行加密（解密）。并且此时密钥的选取<strong>受到sum的影响</strong></li>
<li><code>sum += delta</code>的时机由每次加密开头就发生变化到v0，v1<strong>两个block加密的中间</strong>。</li>
</ul>
<p>输入的参数：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组），注意这里循环的次数不是固定的了，是需要传入的参数<strong>num_rounds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  </span><br><span class="line">    unsigned int i;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;  </span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  </span><br><span class="line">        sum += delta;  </span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="XTEA解密算法的实现"><a href="#XTEA解密算法的实现" class="headerlink" title="XTEA解密算法的实现"></a>XTEA解密算法的实现</h3><p>输入的参数：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组），注意这里循环的次数不是固定的了，是需要传入的参数<strong>num_rounds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  </span><br><span class="line">    unsigned int i;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;  </span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */</span><br><span class="line"></span><br><span class="line">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[3]=&#123;0x73647979,0x726b6f5f,0x0&#125;;</span><br><span class="line">    uint32_t v1[2]=&#123;0x646f675f,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]=&#123;0X95C4C,0X871D,0X1A7B7,0X12C7C7&#125;;</span><br><span class="line">    unsigned int r=32;//num_rounds建议取值为32</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line">    printf(&quot;加密前原始数据：%s%s\n&quot;,(char*)v,(char*)v1);</span><br><span class="line">    encipher(r, v, k);</span><br><span class="line">    encipher(r, v1, k);</span><br><span class="line">    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v1[0]);</span><br><span class="line">    decipher(r, v, k);</span><br><span class="line">    decipher(r, v1, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s%s\n&quot;,(char*)v,(char*)v1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">加密前原始数据：yyds_okr_god</span><br><span class="line">加密后的数据：3461349474 1314311102 3609197830</span><br><span class="line">解密后的数据：yyds_okr_god</span><br></pre></td></tr></table></figure>

<h2 id="XXTEA加密解密"><a href="#XXTEA加密解密" class="headerlink" title="XXTEA加密解密"></a>XXTEA加密解密</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>XTEA再度进化， 变成了支持块加密<code>XXTEA</code></p>
</blockquote>
<h3 id="加密过程-2"><a href="#加密过程-2" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228200301853.png" alt="image-20220228200301853"></p>
<h3 id="XXTEA加密解密算法的实现"><a href="#XXTEA加密解密算法的实现" class="headerlink" title="XXTEA加密解密算法的实现"></a>XXTEA加密解密算法的实现</h3><p>特点：在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥, 是目前TEA系列中最安全的算法，但性能较上两种有所降低。</p>
<p>参数：输入的是<strong>至少拥有两个元素的32bit的数组</strong>，密钥的长度仍然是<strong>128位</strong>，即拥有<strong>4个元素32位</strong>长度的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdint.h&gt;  </span><br><span class="line">#define DELTA 0x9e3779b9  </span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))  </span><br><span class="line">  </span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])  </span><br><span class="line">&#123;  </span><br><span class="line">    uint32_t y, z, sum;  </span><br><span class="line">    unsigned p, rounds, e;  </span><br><span class="line">    if (n &gt; 1)            /* Coding Part */  </span><br><span class="line">    &#123;  </span><br><span class="line">        rounds = 6 + 52/n;  </span><br><span class="line">        sum = 0;  </span><br><span class="line">        z = v[n-1];  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            sum += DELTA;  </span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;  </span><br><span class="line">            for (p=0; p&lt;n-1; p++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                y = v[p+1];  </span><br><span class="line">                z = v[p] += MX;  </span><br><span class="line">            &#125;  </span><br><span class="line">            y = v[0];  </span><br><span class="line">            z = v[n-1] += MX;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (--rounds);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */  </span><br><span class="line">    &#123;  </span><br><span class="line">        n = -n;  </span><br><span class="line">        rounds = 6 + 52/n;  </span><br><span class="line">        sum = rounds*DELTA;  </span><br><span class="line">        y = v[0];  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;  </span><br><span class="line">            for (p=n-1; p&gt;0; p--)  </span><br><span class="line">            &#123;  </span><br><span class="line">                z = v[p-1];  </span><br><span class="line">                y = v[p] -= MX;  </span><br><span class="line">            &#125;  </span><br><span class="line">            z = v[n-1];  </span><br><span class="line">            y = v[0] -= MX;  </span><br><span class="line">            sum -= DELTA;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (--rounds);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span><br><span class="line"></span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t y, z, sum;</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n-1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=0; p&lt;n-1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+1];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n-1] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=n-1; p&gt;0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p-1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n-1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[4]= &#123;0x73647979,0x726b6f5f,0x646f675f,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]= &#123;0X95C4C,0X871D,0X1A7B7,0X12C7C7&#125;;</span><br><span class="line">    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line">    printf(&quot;加密前原始数据：%s\n&quot;,(char*)v);</span><br><span class="line">    btea(v, n, k);</span><br><span class="line">    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v[3]);</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s\n&quot;,(char*)v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">加密前原始数据：yyds_okr_god</span><br><span class="line">加密后的数据：609835868 2980644312 0</span><br><span class="line">解密后的数据：yyds_okr_god</span><br></pre></td></tr></table></figure>

<h2 id="逆向中TEA系列加密的识别"><a href="#逆向中TEA系列加密的识别" class="headerlink" title="逆向中TEA系列加密的识别"></a>逆向中TEA系列加密的识别</h2><p>解决逆向题大部分出现TEA的场合都是【识别算法-&gt;编写对应解密程序】</p>
<p>分析二进制文件中的算法的时候有几个识别的特征</p>
<ul>
<li>可能存在针对<strong>64bit</strong>以及<strong>128bit</strong>数字的操作（输入的<strong>msg和key</strong>） ，一般会用<strong>无符号的32位的数组</strong>表示</li>
<li>存在<strong>先进行位移，然后异或</strong>的类似操作（<code>(z&gt;&gt;5^y&lt;&lt;2) </code>这类混合变换）**<code>(z&gt;&gt;5^y&lt;&lt;2)</code><strong>就是xxtea加密了，存在</strong>(v0 &lt;&lt; 4)** 和 **(v0 &gt;&gt; 5)**移位就是tea和xtea加密了</li>
<li>前面一个复杂的混合变换的结果可能会<strong>叠加</strong>到另一个值上，两者相互叠加（Feistel 结构）</li>
<li><strong>获取密钥</strong>的时候，会使用某一个常量值作为下标（<code>key[(sum&gt;&gt;11) &amp; 3]</code>）存在轮换的方式获得密钥 就是xtea或者xxtea了</li>
<li>会在算法开始定义一个<strong>delta</strong>，并且这个值不断的参与算法，但是<strong>从来不会受到输入的影响</strong>（delta数值如果没有魔改就是0x9e3779b9）如果出现了<strong>0x9e3779b9</strong>这个数字一般就能确定是TEA加密系列</li>
</ul>
<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/4272e0805da3">https://www.jianshu.com/p/4272e0805da3</a></p>
<p><a href="https://www.anquanke.com/post/id/224198#h3-2">https://www.anquanke.com/post/id/224198#h3-2</a></p>
]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>TEA</tag>
      </tags>
  </entry>
  <entry>
    <title>VNCTF_2022</title>
    <url>/2022/02/25/VNCTF-2022/</url>
    <content><![CDATA[<h2 id="VN2022"><a href="#VN2022" class="headerlink" title="VN2022"></a>VN2022</h2><h4 id="cm狗"><a href="#cm狗" class="headerlink" title="cm狗"></a>cm狗</h4><p>用jadx软件载入这个apk文件</p>
<p>判断flag的函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141557259.png" alt="image-20220215141557259"></p>
<p>判断的函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141619535.png" alt="image-20220215141619535"></p>
<p>loadDexClass()的这个函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141712322.png" alt="image-20220215141712322"></p>
<p>这里copyfile了一个dex的文件，这里copyFile()函数里面应该还有一系列的操作，一系列操作的结果最后写入了创建的一个文件里面</p>
<p>找到这个文件，并且找到这个函数</p>
<p><img src="/images/VNCTF-2022/image-20220219205934006.png" alt="image-20220219205934006"></p>
<p>该函数的详情</p>
<p><img src="/images/VNCTF-2022/image-20220219210128389.png" alt="image-20220219210128389"></p>
<p>主要的代码</p>
<p><img src="/images/VNCTF-2022/image-20220219210151167.png" alt="image-20220219210151167"></p>
<p><img src="/images/VNCTF-2022/image-20220219210531948.png" alt="image-20220219210531948"></p>
<p>注意这个地方是每次取1024出来，外层有个while(true)的循环的操作</p>
<p>得到的这个文件名称是 classes.dex</p>
<p><img src="/images/VNCTF-2022/image-20220219213108277.png" alt="image-20220219213108277"></p>
<p>对文件进行操作的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v0 = &#x27;vn2022&#x27;</span><br><span class="line">with open(&quot;D:\\re\\buuctf\\VN\\3\\ooo&quot;,&#x27;rb&#x27;) as f1:</span><br><span class="line">    c = f1.read()</span><br><span class="line">with open(&quot;D:\\re\\buuctf\\VN\\3\\out&quot;,&#x27;wb&#x27;) as f2:</span><br><span class="line">    for i in range(len(c)):</span><br><span class="line">        f2.write((c[i]^ord(v0[i %1024 % len(v0)])).to_bytes(1,byteorder=&quot;little&quot;,signed=False))</span><br><span class="line">print(&quot;OK&quot;)</span><br></pre></td></tr></table></figure>

<p>将得到的这个文件命名为class.dex，这是一个dex文件，首先使用dex2jar 将 dex文件转变成jar文件，然后使用jd-gui打开这个得到的jar文件，注意使用dex2jar得到jar文件的时候，需要将dex文件放入到dex2jar的文件夹目录之下</p>
<p>得到的这个文件之中 </p>
<p>加密函数 （xxtea加密）</p>
<p><img src="/images/VNCTF-2022/image-20220219223231506.png" alt="image-20220219223231506"></p>
<p>在hcheck这个函数之中，首先给了一堆数字，然后将输入的flag以及xxtea的密钥输入，对输入进行加密，加密的结果就是上面定义的一系列数值</p>
<p><img src="/images/VNCTF-2022/image-20220219223525059.png" alt="image-20220219223525059"></p>
<p><img src="/images/VNCTF-2022/image-20220219223528938.png" alt="image-20220219223528938"></p>
<p>去网上找一个xxtea解密的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9            //固定的一个常量</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   //固定的运算</span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])   //v是要加密的两个元素的数组</span><br><span class="line">&#123;                                                      //n为数组的长度</span><br><span class="line">    uint32_t y, z, sum;                                //无符号整型</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52/n;               //固定的得出轮数</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n-1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;                //每次进行叠加</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;          //固定运算</span><br><span class="line">            for (p=0; p&lt;n-1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+1];</span><br><span class="line">                v[p] += MX;</span><br><span class="line">                      z = v[p];</span><br><span class="line">                        &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n-1] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=n-1; p&gt;0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p-1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n-1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int8_t a[]= &#123;68, 39, -92, 108, -82, -18, 72, -55, 74, -56, 38, 11, 60, 84, 97, -40, 87, 71, 99, -82, 120, 104, 47, -71, -58, -57, 0, 33, 42, 38, -44, -39, -60, 113, -2, 92, -75, 118, -77, 50, -121, 43, 32, -106 &#125;;</span><br><span class="line">    uint32_t *v = (uint32_t *)a;</span><br><span class="line">    uint32_t *k= (uint32_t *)&quot;H4pPY_VNCTF!!OvO&quot;;</span><br><span class="line">    int n= 11;</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    printf(&quot;decrypto result:%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n&quot;,v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10]);</span><br><span class="line">    printf(&quot;result:%s&quot;,v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">VNCTF&#123;93ee7688-f216-42cb-a5c2-191ff4e412ba&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220219230318245.png" alt="image-20220219230318245"></p>
<p>所以最后的flag 是 VNCTF{93ee7688-f216-42cb-a5c2-191ff4e412ba}</p>
<h4 id="BabyMaze"><a href="#BabyMaze" class="headerlink" title="BabyMaze"></a>BabyMaze</h4><p>这道题如果直接使用employee6 解pyc得到代码是不行的，因为在这个代码里面有花指令，</p>
<p>方法一：直接使用pycda中的得到bytecode的底层的代码</p>
<p>看见迷宫，拼一下迷宫，按照w代表向上走，s代表向下走，a代表向左走，d代表向右走的方式走迷宫</p>
<p>python的pyc文件的反编译pycdc和pycdas这两个文件，pycdc反编译为python的代码，pycdas这个文件会将pyc文件编译成字节码的形式 <a href="http://www.syjblog.com/?p=470">pyc反编译</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/89935120">pyc的结构体</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Bytecode object */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">   PyObject_HEAD</span><br><span class="line">   int co_argcount;            /* Code Block的位置参数个数，比如说一个函数的位置参数个数*/</span><br><span class="line">   int co_nlocals;             /* Code Block中局部变量的个数，包括其中位置参数的个数 */</span><br><span class="line">   int co_stacksize;           /* 执行该段Code Block需要的栈空间 */</span><br><span class="line">   int co_flags;               /* CO_..., see below */</span><br><span class="line">   PyObject *co_code;          /* Code Block编译所得的字节码指令序列。以PyStingObjet的形式存在 */</span><br><span class="line">   PyObject *co_consts;        /* PyTupleObject对象，保存CodeBlock中的所常量 */</span><br><span class="line">   PyObject *co_names;         /* PyTupleObject对象，保存CodeBlock中的所有符号 */</span><br><span class="line">   PyObject *co_varnames;      /* Code Block中的局部变量名集合 */</span><br><span class="line">   PyObject *co_freevars;      /* Python实现闭包需要用的东西 */</span><br><span class="line">   PyObject *co_cellvars;      /* Code Block中内部嵌套函数所引用的局部变量名集合 */</span><br><span class="line">   /* The rest doesn&#x27;t count for hash/cmp */</span><br><span class="line">   PyObject *co_filename;      /* Code Block所对应的.py文件的完整路径 */</span><br><span class="line">   PyObject *co_name;          /* Code Block的名字，通常是函数名或类名 */</span><br><span class="line">   int co_firstlineno;         /* Code Block在对应的.py文件中起始行 */</span><br><span class="line">   PyObject *co_lnotab;        /* 字节码指令与.py文件中source code行号的对应关系，以PyStringObject的形式存在 */</span><br><span class="line">   void *co_zombieframe;     /* for optimization only (see frameobject.c) */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>

<p>得到：走出的迷宫的结果</p>
<p>ssssddssaassddddwwwwddwwddddddwwddddddssddwwddddddddssssaawwaassaassaassddssaassaawwwwwwaaaaaaaassaassddddwwddssddssssaassddssssaaaaaawwddwwaawwwwaassssssssssssddddssddssddddddddwwaaaaaawwwwddssddwwwwwwwwddssddssssssssddddss</p>
<p>将上面的解md5(32小写)得到最后的结果  VNCTF{801f190737434100e7d2790bd5b0732e}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                   1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">68      BUILD_LIST              31 1 5 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">132     BUILD_LIST              31 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1</span><br><span class="line">196     BUILD_LIST              31 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1</span><br><span class="line">260     BUILD_LIST              31 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1</span><br><span class="line">324     BUILD_LIST              31 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">388     BUILD_LIST              31 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1</span><br><span class="line">452     BUILD_LIST              31 1 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1</span><br><span class="line">516     BUILD_LIST              31 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1</span><br><span class="line">580     BUILD_LIST              31 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">644     BUILD_LIST              31 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1</span><br><span class="line">708     BUILD_LIST              31 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">772     BUILD_LIST              31 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1</span><br><span class="line">836     BUILD_LIST              31 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">900     BUILD_LIST              31 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1</span><br><span class="line">964     BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">1028    BUILD_LIST              31 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 0 1</span><br><span class="line">1092    BUILD_LIST              31 1 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">1156    BUILD_LIST              31 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1</span><br><span class="line">1220    BUILD_LIST              31 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">1284    BUILD_LIST              31 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 0 1</span><br><span class="line">1348    BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1412    BUILD_LIST              31 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1476    BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1540    BUILD_LIST              31 1 0 1 1 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1604    BUILD_LIST              31 1 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1</span><br><span class="line">1668    BUILD_LIST              31 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1</span><br><span class="line">1732    BUILD_LIST              31 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1</span><br><span class="line">1796    BUILD_LIST              31 1 0 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1</span><br><span class="line">1860    BUILD_LIST              31 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 7 1</span><br><span class="line">1924    BUILD_LIST              31 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>VNCTF{801f190737434100e7d2790bd5b0732e}</p>
<h4 id="时空飞行"><a href="#时空飞行" class="headerlink" title="时空飞行"></a>时空飞行</h4><p>运行一下这个程序，因为不能直接运行，所以使用IDA调试运行，所以现在我们需要找到日期和符来歌（根据运行之中的提示语句得到）</p>
<p><img src="/images/VNCTF-2022/image-20220221120512364.png" alt="image-20220221120512364"></p>
<p>变化之后的日期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0FD07C452h, 0EC90A488h, 68D33CD1h, 96F64587h</span><br></pre></td></tr></table></figure>

<p>对输入的日期进行加密的过程</p>
<p><img src="/images/VNCTF-2022/image-20220221122556035.png" alt="image-20220221122556035"></p>
<p>v5[v3] = sub_401A3B(v5[i + 3] ^ v5[i + 2] ^ (unsigned int)v5[i + 1] ^ dword_405040[i]) ^ v4;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v5[4] = sub_401A3B(v5[3] ^ v5[2] ^ (unsigned int)v5[1] ^ dword_405040[0]) ^ v5[0];</span><br><span class="line">v5[5] = sub_401A3B(v5[4] ^ v5[3] ^ (unsigned int)v5[2] ^ dword_405040[1]) ^ v5[1];</span><br><span class="line">... ...</span><br><span class="line">v5[34] = sub_401A3B(v5[33] ^ v5[32] ^ (unsigned int)v5[31] ^ dword_405040[2]) ^ v5[30];</span><br><span class="line">v5[35] = sub_401A3B(v5[34] ^ v5[33] ^ (unsigned int)v5[32] ^ dword_405040[3]) ^ v5[31];</span><br></pre></td></tr></table></figure>

<p>sub_401A3B()这个函数的作用</p>
<p><img src="/images/VNCTF-2022/image-20220221123230352.png" alt="image-20220221123230352"></p>
<p>a1和a1向左移13位的结果和a1向右移9位的结果做异或运算，</p>
<p>逆向分析的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">unsigned int CalcRound(unsigned int key)&#123;</span><br><span class="line">    return key ^((((key&amp;0xffffffff)&lt;&lt;13)|((key&amp;0xffffffff)&gt;&gt;(32-13)))^(((key&amp;0xffffffff)&lt;&lt;(32-9))|((key&amp;0xffffffff)&gt;&gt;9)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long CK[32] = &#123;</span><br><span class="line">0x00070e15,0x1c232a31,0x383f464d,0x545b6269,</span><br><span class="line">0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,</span><br><span class="line">0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,</span><br><span class="line">0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,</span><br><span class="line">0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,</span><br><span class="line">0x30373e45,0x4c535a61,0x686f767d,0x848b9299,</span><br><span class="line">0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,</span><br><span class="line">0x10171e25,0x2c333a41,0x484f565d,0x646b7279</span><br><span class="line">&#125;;</span><br><span class="line">    unsigned int result[] = &#123;0x0FD07C452, 0x0EC90A488, 0x68D33CD1, 0x96F64587&#125;;</span><br><span class="line">    unsigned int re_result[36];</span><br><span class="line">    for(int i=32;i&lt;36;i++)&#123;</span><br><span class="line">        re_result[i] =result[i-32];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=31;i&gt;=0;i--)&#123;</span><br><span class="line">        re_result[i] = CalcRound(re_result[i+1]^re_result[i+2]^re_result[i+3]^CK[i])^re_result[i+4];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned long tem[4] = &#123;0xA3B1BAC6,0x56AA3350,0x677D9197,0xB27022DC&#125;;</span><br><span class="line">    for(int i=0;i&lt;=3;i++)&#123;</span><br><span class="line">        re_result[i]=re_result[i]^tem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char *data = (unsigned char *)re_result;   //因为日期的表示是8个数字，每个数字是用8位来代表</span><br><span class="line">    for(int i=1;i&lt;=2;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=4;j++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;,data[i*4 - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">20211205</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221133215573.png" alt="image-20220221133215573"></p>
<p>将得到的日期放入之后，就要进行符来歌的输入</p>
<p><img src="/images/VNCTF-2022/image-20220221133557404.png" alt="image-20220221133557404"></p>
<p>最后需要对比的元素是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1ebe,0x1e8e,0x1e44,0x1e39,0x1e5b,0x1e8,0x1e36,0x1e8f,0x1edd,0x1e5e,0x1e94,0x1eb5,0x1e1,0x1e70,0x1eab,0x1e63,0x1ebb,0x1e72,0x1e50,0x1e13,0x1e5d,0x1e25,0x1e16,0x1e78</span><br></pre></td></tr></table></figure>

<p>在上面函数 之中对这个数组中的元素做了一定的运算，下面得到的就是运算加密之后的数组</p>
<p><img src="/images/VNCTF-2022/image-20220221170531828.png" alt="image-20220221170531828"></p>
<p>所以需要比较的数组是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221183335046.png" alt="image-20220221183335046"></p>
<p>用爆破的方式得到上面的解，发现这里某些会有多个解所以需要使用递归的方式，深度优先算法解得所有的解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [ 0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3]</span><br><span class="line">i=0</span><br><span class="line">flags=[]</span><br><span class="line">flag = [0]*24</span><br><span class="line">flag[23] = 0xe3</span><br><span class="line">def DFS(deep):</span><br><span class="line">  global flags</span><br><span class="line">  global flag</span><br><span class="line">  if deep ==0:</span><br><span class="line">    flags.append(flag.copy())</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">    for j in range(1,0xff):</span><br><span class="line">      tem = j^((j % 0x12+ flag[deep] + 0x05) ^ 0x41)</span><br><span class="line">      if tem == obj[deep-1]:</span><br><span class="line">        flag[deep-1]=j</span><br><span class="line">        DFS(deep-1)</span><br><span class="line">              </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  DFS(23)</span><br><span class="line">  for i in range(len(flags)):</span><br><span class="line">    print(flags[i])</span><br><span class="line">[20, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[21, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[22, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[23, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[28, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[29, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[30, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[31, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[128, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[129, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[130, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[131, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[136, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[137, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[138, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[139, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[72, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[73, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[74, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[75, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[80, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[81, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[82, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[83, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[88, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[89, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[184, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[185, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[186, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[187, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221183354391.png" alt="image-20220221183354391"></p>
<p>通过这个我们可以获得 a1[60] a1[61] a1[62] a1[63] a1[64] a1[65] 5个数</p>
<p>对输入的每32个字节的操作：将32位数 F1F1 F2F2 F3F3 F4F4 排列为 F4F4 F3F3 F2F2 F1F1 </p>
<p><img src="/images/VNCTF-2022/image-20220221184405201.png" alt="image-20220221184405201"></p>
<p>将所有输入的字符进行上面的运算，然后重新赋值给a1 则可以知道数组之中有6个元素</p>
<p><img src="/images/VNCTF-2022/image-20220221184743758.png" alt="image-20220221184743758"></p>
<p>然后就需要进行一系列的运算，</p>
<p><img src="/images/VNCTF-2022/image-20220221185657924.png" alt="image-20220221185657924"></p>
<p>当v5不是6的倍数的时候 </p>
<p>当i不是6的倍数的时候：v5[7] = v5[1]^v5[6]   v5[i] = v5[i-6] ^ v5[i-1] </p>
<p>当i是6的倍数的时候：v5[i] = v5[i-6] ^ T(v5[i-1],v3)  v3代表的是第几个6的倍数</p>
<p><strong>T函数的讲解</strong>：</p>
<p><img src="/images/VNCTF-2022/image-20220221190435689.png" alt="image-20220221190435689"></p>
<p>其中的第一个函数：将a1分解成了4个元素的数组0x  F0F0 F1F1 F2F2 F3F3</p>
<p><img src="/images/VNCTF-2022/image-20220221190819733.png" alt="image-20220221190819733"></p>
<p>其中的第二个函数：将数组中的元素循环右移一位 ；例如 a=[a0,a1,a2,a3] 转化成 a=[a1,a2,a3,a0] </p>
<p>[F3F3,F2F2,F1F1,F0F0] [F2F2,F1F1,F0F0,F3F3]</p>
<p><img src="/images/VNCTF-2022/image-20220221191008054.png" alt="image-20220221191008054"></p>
<p>其中第三个函数：整合上面的数组之中的元素  0x F3F3 F0F0 F1F1 F2F2</p>
<p><img src="/images/VNCTF-2022/image-20220221191329845.png" alt="image-20220221191329845"></p>
<p>所以这个函数的作用是 将 0x  F0F0 F1F1 F2F2 F3F3 转化成 0x F3F3 F0F0 F1F1 F2F2 循环左移动了8位 然后再和对应那个6的倍数作为脚标找到数组对应的元素</p>
<p>作为索引对象的数组是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000,</span><br><span class="line">           0x36000000]</span><br></pre></td></tr></table></figure>

<p>每组得到了6个数字，将这六个元素作为66个元素之中的后六位元素</p>
<p>逆向：</p>
<p>当i不是6的倍数时： v5[i-6] = v5[i]^v5[i-1]</p>
<p>当i是6的倍数时： v5[i-6] = v5[i]^ T(v5[i-1],v3) # v3 = i%6 T是将数循环左移动了8位，再和对应的数字进行异或运算</p>
<p>逆向得到的66个元素的前6个元素，将前6个元素转化为字符输出</p>
<p>所有运算的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [ 0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3]</span><br><span class="line">inner_index = [0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000,</span><br><span class="line">           0x36000000]</span><br><span class="line">i=0</span><br><span class="line">flags=[]</span><br><span class="line">flag = [0]*24</span><br><span class="line">flag[23] = 0xe3</span><br><span class="line"># 用递归 ，深度遍历的方法得到所有的解</span><br><span class="line">def DFS(deep):</span><br><span class="line">  global flags</span><br><span class="line">  global flag</span><br><span class="line">  if deep ==0:</span><br><span class="line">    flags.append(flag.copy())</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">    for j in range(1,0xff):</span><br><span class="line">      tem = j^((j % 0x12+ flag[deep] + 0x05) ^ 0x41)</span><br><span class="line">      if tem == obj[deep-1]:</span><br><span class="line">        flag[deep-1]=j</span><br><span class="line">        DFS(deep-1)</span><br><span class="line"></span><br><span class="line"># 位移运算</span><br><span class="line">def rol8(num):</span><br><span class="line">  return ((num&amp;0xffffff)&lt;&lt;8) |((num&amp;0xff000000)&gt;&gt;(32-8))</span><br><span class="line"></span><br><span class="line"># 位移加上 异或运算</span><br><span class="line">def T(num,i):</span><br><span class="line">  num = rol8(num)</span><br><span class="line">  return num^inner_index[i-1]</span><br><span class="line"></span><br><span class="line"># 根据是否是6的倍数进行的不同的异或运算</span><br><span class="line">def multiple(final_flag):</span><br><span class="line">  for i in range(65,5,-1):</span><br><span class="line">    if i%6 !=0:</span><br><span class="line">      final_flag[i-6] = final_flag[i]^final_flag[i-1]</span><br><span class="line">    else:</span><br><span class="line">      final_flag[i - 6] = final_flag[i] ^ T(final_flag[i - 1], i//6)</span><br><span class="line">  return final_flag</span><br><span class="line"></span><br><span class="line"># 将得到的数组进行输出</span><br><span class="line">def print_flag(final_flag):</span><br><span class="line">  for i in range(len(final_flag)):</span><br><span class="line">    for j in range(4):</span><br><span class="line">      print(chr((final_flag[i] &amp; 0xff000000)&gt;&gt;(32-8)),end=&quot;&quot;)</span><br><span class="line">      final_flag[i] = final_flag[i] &lt;&lt; 8</span><br><span class="line">  print()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  DFS(23)</span><br><span class="line">  re_flags = []</span><br><span class="line">  for j in range(len(flags)):</span><br><span class="line">    flag = flags[j]</span><br><span class="line">    tem = []</span><br><span class="line">    # 将每4个8位数组合成 一个16进制的32位数</span><br><span class="line">    for i in range(0, len(flag), 4):</span><br><span class="line">      tem.append(int(</span><br><span class="line">        &quot;0x&quot; + hex(flag[i + 3])[2:].zfill(2) + hex(flag[i + 2])[2:].zfill(2) + hex(flag[i + 1])[2:].zfill(2) + hex(</span><br><span class="line">          flag[i])[2:].zfill(2),16))</span><br><span class="line">    re_flags.append(tem.copy())   # re_flags 里面将24个元素每4个一组转化为一个数</span><br><span class="line"></span><br><span class="line">  # 异或运算的逆向</span><br><span class="line">  final_flag = [0]*66</span><br><span class="line">  re_flags2 = []</span><br><span class="line">  for i in range(len(re_flags)):</span><br><span class="line">    final_flag = [0]*66</span><br><span class="line">    for j in range(6):  #将已知的5个值放入其中</span><br><span class="line">      final_flag[60+j] = re_flags[i][j]</span><br><span class="line">      </span><br><span class="line">    # 利用这5个元素推理出所有的数字</span><br><span class="line">    final_flag = multiple(final_flag)</span><br><span class="line">    tem = []</span><br><span class="line">    for j in range(6):</span><br><span class="line">      tem.append(final_flag[j])</span><br><span class="line">    print(tem)</span><br><span class="line">    re_flags2.append(tem.copy())</span><br><span class="line">  for i in range(len(re_flags2)):</span><br><span class="line">    print_flag(re_flags2[i])</span><br></pre></td></tr></table></figure>

<p>在所有的输出之中找到flag  VNCTF{TimeFlightMachine}</p>
<h4 id="cmgo！"><a href="#cmgo！" class="headerlink" title="cmgo！"></a>cmgo！</h4><p>将这个exe文件拖入ida之中，从函数名称的窗口之中就可以看到这里进行了程序的无符号化，使得函数的名称不能够直观的得到，所以函数的入口难以找到，无符号golang逆向技巧，使用IDAGolangHelper这一脚本，打开脚本文件（文件-脚本文件）找到这个脚本文件夹，选中rename function之后选择go版本,所以将这个exe拖进IDA7.6之中，找到程序入口main.main</p>
<p><img src="/images/VNCTF-2022/image-20220221232254810.png" alt="image-20220221232254810"></p>
<p>找到初始化虚拟机的地方和opcode</p>
<p><img src="/images/VNCTF-2022/image-20220222081345526.png" alt="image-20220222081345526"></p>
<p>第二个函数 mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084558720.png" alt="image-20220222084558720"></p>
<p>第三个函数  mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084616048.png" alt="image-20220222084616048"></p>
<p><img src="/images/VNCTF-2022/image-20220222084743697.png" alt="image-20220222084743697"></p>
<p>第四个函数 mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084926787.png" alt="image-20220222084926787"></p>
<p>第五个函数 push</p>
<p><img src="/images/VNCTF-2022/image-20220222085210002.png" alt="image-20220222085210002"></p>
<p>第六个函数 和push类似的样子</p>
<p><img src="/images/VNCTF-2022/image-20220222085400565.png" alt="image-20220222085400565"></p>
<p>第七个函数 pop</p>
<p><img src="/images/VNCTF-2022/image-20220222085437971.png" alt="image-20220222085437971"></p>
<p>第八个函数 add</p>
<p><img src="/images/VNCTF-2022/image-20220222085652595.png" alt="image-20220222085652595"></p>
<p>第九个函数 sub</p>
<p><img src="/images/VNCTF-2022/image-20220222085733426.png" alt="image-20220222085733426"></p>
<p>第十个函数 div</p>
<p><img src="/images/VNCTF-2022/image-20220222085838161.png" alt="image-20220222085838161"></p>
<p>第十一个函数 mul</p>
<p><img src="/images/VNCTF-2022/image-20220222085928057.png" alt="image-20220222085928057"></p>
<p>第十二个函数 xor</p>
<p><img src="/images/VNCTF-2022/image-20220222090005356.png" alt="image-20220222090005356"></p>
<p>第十三个函数  jmp</p>
<p><img src="/images/VNCTF-2022/image-20220222090054005.png" alt="image-20220222090054005"></p>
<p>第十四个函数 jmp（多了一个判断条件）当等于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090501248.png" alt="image-20220222090501248"></p>
<p>第十五个函数 jnp</p>
<p><img src="/images/VNCTF-2022/image-20220222090557647.png" alt="image-20220222090557647"></p>
<p>第十六个函数 jlp 当小于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090652596.png" alt="image-20220222090652596"></p>
<p>第十七个函数 jhp 当大于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090801331.png" alt="image-20220222090801331"></p>
<p>第十八个函数 scanf</p>
<p><img src="/images/VNCTF-2022/image-20220222091046004.png" alt="image-20220222091046004"></p>
<p>第十九个函数 print</p>
<p><img src="/images/VNCTF-2022/image-20220222091135371.png" alt="image-20220222091135371"></p>
<p>第二十个函数 quit</p>
<p><img src="/images/VNCTF-2022/image-20220222091303160.png" alt="image-20220222091303160"></p>
<p>初始化虚拟机并且载入opcode之后，要运行这个虚拟机，所以查看虚拟机的运行的函数，用流程图的方式查看函数的逻辑，找到逻辑之中的循环，找到其中的关键代码</p>
<p><img src="/images/VNCTF-2022/image-20220222120534330.png" alt="image-20220222120534330"></p>
<p>进行动调得到函数的对应关系，动态调试得到的对应关系,</p>
<p><img src="/images/VNCTF-2022/image-20220223001010055.png" alt="image-20220223001010055"></p>
<p>跟踪到[rbx+rdi*8+1008h]这个里面，通过按D将db的数据转化成dq</p>
<p><img src="/images/VNCTF-2022/image-20220223001105287.png" alt="image-20220223001105287"></p>
<p>通过他们的顺序，就能知道code 和 函数的对应关系</p>
<p>opcode的 0-16对应函数1-17</p>
<p>97 98 99对应函数18 19 20</p>
<p>将opcode得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov r0 0X57</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6C</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X63</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6D</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X74</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X56</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X4E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X43</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X54</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X46</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X30</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X21</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0XA</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X69</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X70</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X75</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X74</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X66</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6C</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X61</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X67</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X3A</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0XA</span><br><span class="line">pushchar(r0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov r19 0X49</span><br><span class="line">mov r3 0X0</span><br><span class="line">mov r1 0X2B</span><br><span class="line">mov r2 0X1</span><br><span class="line">scanf(r0)</span><br><span class="line">push r0</span><br><span class="line">sub r1 r2</span><br><span class="line">if r1 != r3:quit </span><br><span class="line">mov r0 0X0</span><br><span class="line">push r0</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">mov r0 r6</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">mov r0 r6</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">mov r0 r7</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">mov r0 r7</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">mov r0 r8</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">mov r0 r8</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">mov r0 r9</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">mov r0 r9</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">mov r0 r10</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">mov r0 r10</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">mov r0 r11</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">mov r0 r11</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">mov r0 r12</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">mov r0 r12</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100  //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">mov r0 r13</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">mov r0 r13</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">mov r0 r15</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">mov r0 r15</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">mov r0 r16</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">mov r0 r16</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">push r6</span><br><span class="line">push r7</span><br><span class="line">push r8</span><br><span class="line">push r9</span><br><span class="line">push r10</span><br><span class="line">push r11</span><br><span class="line">push r12</span><br><span class="line">push r13</span><br><span class="line">push r14</span><br><span class="line">push r15</span><br><span class="line">push r16</span><br><span class="line">//第一次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X11C</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0XE8D1D5DF</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   // 0XE8D1D5DF 数据的比较</span><br><span class="line">mov r0 0XF5E3C114</span><br><span class="line">if r2 != r0:quit   //  0XF5E3C114</span><br><span class="line">// 第二次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X127</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X228EC216</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit  //  0X228EC216 数据的比较</span><br><span class="line">mov r0 0X89D45A61</span><br><span class="line">if r2 != r0:quit   //  0X89D45A61</span><br><span class="line">// 第三次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X132</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X655B8F69</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit    //  0X655B8F69 数据的比较</span><br><span class="line">mov r0 0X2484A07A</span><br><span class="line">if r2 != r0:quit    //  0X2484A07A</span><br><span class="line">// 第四次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X13D</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0XD9E5E7F8</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   //  0XD9E5E7F8 数据的比较</span><br><span class="line">mov r0 0X3A441532</span><br><span class="line">if r2 != r0:quit   //   0X3A441532</span><br><span class="line">// 第五次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X148</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X91AB7E88</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   // 0X91AB7E88</span><br><span class="line">mov r0 0X69FC64BC</span><br><span class="line">if r2 != r0:quit   //  0X69FC64BC</span><br><span class="line">pop r1</span><br><span class="line">mov r0 0X7D3765</span><br><span class="line">if r1 != r0:quit   //  0X7D3765</span><br><span class="line">mov r0 0X189</span><br><span class="line">jmp r0</span><br><span class="line">quit!</span><br><span class="line"></span><br><span class="line">mov r3 0X9E3779B9  //tea函数开始的地方 delta</span><br><span class="line">mov r4 0X95C4C     //k0</span><br><span class="line">mov r5 0X871D      //k1</span><br><span class="line">mov r6 0X1A7B7     //k2</span><br><span class="line">mov r7 0X12C7C7    //k3</span><br><span class="line">mov r8 0X0</span><br><span class="line">mov r17 0X10  //用于位移的一堆数字</span><br><span class="line">mov r18 0X20</span><br><span class="line">mov r19 0X160</span><br><span class="line">mov r10 0X0</span><br><span class="line">mov r11 0X20</span><br><span class="line">mov r12 0X1</span><br><span class="line">add r8 r3</span><br><span class="line">mov r0 r2</span><br><span class="line">mul r0 r17</span><br><span class="line">add r0 r4</span><br><span class="line">mov r14 r0</span><br><span class="line">mov r0 r2</span><br><span class="line">add r0 r8</span><br><span class="line">mov r15 r0</span><br><span class="line">mov r0 r2</span><br><span class="line">div r0 r18</span><br><span class="line">add r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">xor r0 r15</span><br><span class="line">xor r0 r16</span><br><span class="line">add r1 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">mul r0 r17</span><br><span class="line">add r0 r6</span><br><span class="line">mov r14 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">add r0 r8</span><br><span class="line">mov r15 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">div r0 r18</span><br><span class="line">add r0 r7</span><br><span class="line">mov r16 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">xor r0 r15</span><br><span class="line">xor r0 r16</span><br><span class="line">add r2 r0</span><br><span class="line">sub r11 r12</span><br><span class="line">if r11 != r10:quit </span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">mov r0 0X6E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">mov r0 0X79</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X73</span><br><span class="line">pushchar(r0)</span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">v[2]=&#123;0XE8D1D5DF,0XF5E3C114,0X228EC216,0X89D45A61,0X655B8F69,0X2484A07A,0XD9E5E7F8,0X3A441532,0X91AB7E88,0X69FC64BC,0X7D3765&#125;</span><br></pre></td></tr></table></figure>

<p>网上的TEA的加密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上的TEA的解密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void decrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up; sum is 32*delta */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目之中的TEA解密的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Decrypt(unsigned long* EntryData,unsigned long* Key) &#123;</span><br><span class="line">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br><span class="line">unsigned long x = EntryData[0];</span><br><span class="line">unsigned long y = EntryData[1];</span><br><span class="line"></span><br><span class="line">unsigned long sum = 0xC6EF3720;</span><br><span class="line">unsigned long delta = 0x9E3779B9;</span><br><span class="line">sum = delta &lt;&lt; 5;   //注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.</span><br><span class="line">//总共加密32轮 那么反序也解密32轮</span><br><span class="line">for (int i = 0; i &lt; 32; i++) &#123;</span><br><span class="line">// 先将y解开 然后参与运算在解x</span><br><span class="line">y -= ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);</span><br><span class="line">x -= ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);</span><br><span class="line">sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">//最后加密的结果重新写入到数组中</span><br><span class="line">EntryData[0] = x;</span><br><span class="line">EntryData[1] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">//通过对比元素的代码处将其分为6组，每两个是一组，只有前10个进行了加密的操作</span><br><span class="line">   unsigned long t1[3] = &#123;0XE8D1D5DF,0XF5E3C114,0x0&#125;;</span><br><span class="line">   unsigned long t2[3] = &#123;0X228EC216,0X89D45A61,0x0&#125;;</span><br><span class="line">   unsigned long t3[3] = &#123;0X655B8F69,0X2484A07A,0x0&#125;;</span><br><span class="line">   unsigned long t4[3] = &#123;0XD9E5E7F8,0X3A441532,0x0&#125;;</span><br><span class="line">   unsigned long t5[3] = &#123;0X91AB7E88,0X69FC64BC,0x0&#125;;</span><br><span class="line">   unsigned long t6[2] = &#123;0X7D3765,0x0&#125;;</span><br><span class="line">//printf(&quot;待加密的数值 = %s\r\n&quot;, (char*)Data);</span><br><span class="line"></span><br><span class="line">unsigned long key[4] = &#123; 0X95C4C,0X871D,0X1A7B7,0X12C7C7 &#125;;</span><br><span class="line"></span><br><span class="line">// 分析代码我们可以得到一共加密了5次，所以数组之中只有10个分组进行了加密的操作</span><br><span class="line">Decrypt(t1, key);</span><br><span class="line">Decrypt(t2, key);</span><br><span class="line">Decrypt(t3, key);</span><br><span class="line">Decrypt(t4, key);</span><br><span class="line">Decrypt(t5, key);</span><br><span class="line"></span><br><span class="line">printf(&quot;解密后的数值 = %s%s%s%s%s%s\r\n&quot;, (char*)t1,(char*)t2,(char*)t3,(char*)t4,(char*)t5,(char *)t6);</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">VNCTF&#123;ecd63ae5-8945-4ac4-b5a5-34fc3ade81e7&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫_逆向</title>
    <url>/2022/03/02/%E8%BF%B7%E5%AE%AB-%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<h1 id="迷宫-逆向"><a href="#迷宫-逆向" class="headerlink" title="迷宫_逆向"></a>迷宫_逆向</h1><h2 id="深度优先算法介绍"><a href="#深度优先算法介绍" class="headerlink" title="深度优先算法介绍"></a>深度优先算法介绍</h2><blockquote>
<p>深度优先搜索算法（Depth-First-Search），是搜索算法的一种。是沿着树的深度遍历树的节点，<strong>尽可能深</strong>的搜索树的分支。当节点v的所有边都己被探寻过，搜索将<strong>回溯</strong>到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于<strong>盲目搜索</strong>。</p>
</blockquote>
<h2 id="深度优先算法在迷宫中的使用"><a href="#深度优先算法在迷宫中的使用" class="headerlink" title="深度优先算法在迷宫中的使用"></a>深度优先算法在迷宫中的使用</h2><p>二维的迷宫：</p>
<ul>
<li>使用递归的方法，用栈的思想放入和取出路径，用数组的方式存放迷宫图</li>
<li>使用for循环遍历四个方向，在每个节点选择走的方向，如果按这个方向向下走一步能够满足条件（不是墙并且没有到达过），就可以将这一步的目标地址进行标记（已经走过），并且将走的方向放入路径之中</li>
<li>当死路的时候就会向上返回。如果四个方向都遍历，没有一个方向能够满足条件，那么就会返回上一轮，并且将这步错误的方向在路径之中去除，并且将这个地址再次标记为未可达</li>
<li>递归的结束条件。已经到达了目标地址的坐标，就可以返回这个路径了</li>
</ul>
<h2 id="二维迷宫题算法实现"><a href="#二维迷宫题算法实现" class="headerlink" title="二维迷宫题算法实现"></a>二维迷宫题算法实现</h2><h3 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h3><p>map：迷宫地图，数组需要在声明的时候进行初始化</p>
<p>stages：上下左右的表示方法</p>
<p>n,m：一共有多少排多少列</p>
<p>stx,sty：迷宫起始的位置，需要对应数组的下标</p>
<p>endx,endy：迷宫终点的位置，需要对应数组相应的下标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> tmap[<span class="number">32</span>][<span class="number">32</span>]=&#123;<span class="string">&quot;00000&quot;</span>,<span class="string">&quot;01100&quot;</span>,<span class="string">&quot;00100&quot;</span>,<span class="string">&quot;00110&quot;</span>,<span class="string">&quot;00000&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> sign[<span class="number">50</span>][<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 右左下上</span></span><br><span class="line"><span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> stages[] = <span class="string">&quot;dasw&quot;</span>;</span><br><span class="line"><span class="comment">//这个迷宫有几排几列，用于判断有没有超出边界</span></span><br><span class="line"><span class="type">int</span> n=<span class="number">5</span>,m=<span class="number">5</span>;</span><br><span class="line"><span class="comment">// 标记起始位置</span></span><br><span class="line"><span class="type">int</span> stx=<span class="number">1</span>,sty=<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 标记终点位置</span></span><br><span class="line"><span class="type">int</span> endx=<span class="number">3</span>,endy=<span class="number">3</span>;</span><br><span class="line"><span class="comment">// road 路径</span></span><br><span class="line"><span class="type">char</span> road[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//已经走了多少步了</span></span><br><span class="line"><span class="type">int</span> steps=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addSteps</span><span class="params">(<span class="type">char</span> stage)</span>&#123;</span><br><span class="line">    road[steps] = stage;</span><br><span class="line">    steps++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">subSteps</span><span class="params">()</span>&#123;</span><br><span class="line">    steps--;</span><br><span class="line">    road[steps] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先算法 提供的参数是走迷宫的起始位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tx,ty;</span><br><span class="line">    <span class="keyword">if</span>(x == endx&amp;&amp;y == endy)&#123;</span><br><span class="line">        <span class="comment">//到达了最后的地方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;走的路径是：%s&quot;</span>,(<span class="type">char</span>*)road);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//tx 和 ty标记到达地址</span></span><br><span class="line">            tx = x+next[i][<span class="number">0</span>];</span><br><span class="line">            ty = y+next[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 当沿着这个方向的下一步不是墙 不是已经走过的地方 并且到达的这个地址在范围之内</span></span><br><span class="line">        <span class="keyword">if</span>(tx&gt;=<span class="number">0</span>&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=<span class="number">0</span>&amp;&amp;ty&lt;m&amp;&amp;tmap[ty][tx]!=<span class="string">&#x27;0&#x27;</span>&amp;&amp;sign[ty][tx]==<span class="number">0</span>)&#123;</span><br><span class="line">            sign[ty][tx]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将之前长度的字符串放入到其中 并且再添加一个字符（表示这一步的方向）</span></span><br><span class="line">            addSteps(stages[i]);</span><br><span class="line">            dfs(tx,ty);</span><br><span class="line">            sign[ty][tx]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//除去最后一步</span></span><br><span class="line">            subSteps();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当四个方向都不满足的时候跳出循环</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    dfs(stx,sty);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：dssd</span><br></pre></td></tr></table></figure>



<h3 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h3><p>使用脚本的时候根据题目的不同需要进行修改的脚本之中的参数有</p>
<p>map：map使用数字类型的数字表示，还是用char类型的数组表示，map的声明以及每一步的是否正确的判断条件都是不一样的</p>
<p>stx和sty：迷宫的起点，数组的起点是从0开始标识的</p>
<p>endx和endy：迷宫的终点，注意数组的下标</p>
<p>signdirect：题目之中这四个方向所代表的字符都是不一样的，需要根据题目的要求具体的表示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># map是迷宫</span></span><br><span class="line"><span class="built_in">map</span> = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line"><span class="comment"># 标记该路径是否走过 5*5的数组的表示方法</span></span><br><span class="line">sign = [[<span class="number">0</span>]*<span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 起始的位置</span></span><br><span class="line">stx = <span class="number">1</span></span><br><span class="line">sty = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记下一步的地址</span></span><br><span class="line">endx = <span class="number">0</span></span><br><span class="line">endy = <span class="number">0</span></span><br><span class="line"><span class="comment"># 每次走的方向 路径</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 标记走的四个方向</span></span><br><span class="line">direct = [[<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 这四个方向的表示方法</span></span><br><span class="line">signdirect=<span class="string">&#x27;dasw&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度遍历方法的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y</span>):</span><br><span class="line">  <span class="keyword">global</span> flag   <span class="comment">#注意在函数里面要当全局变量使用的变量一定要在函数之中进行声明！！！！！！</span></span><br><span class="line">  endx = <span class="number">0</span></span><br><span class="line">  endy = <span class="number">0</span></span><br><span class="line">  <span class="comment"># 到达终点</span></span><br><span class="line">  <span class="keyword">if</span> x==finalx <span class="keyword">and</span> y==finaly:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment"># 未到达终点之前遍历四个方向</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(direct)):</span><br><span class="line">    endx = x+direct[i][<span class="number">0</span>]</span><br><span class="line">    endy = y+direct[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> endy&gt;=<span class="number">0</span> <span class="keyword">and</span> endy&lt;<span class="built_in">len</span>(<span class="built_in">map</span>) <span class="keyword">and</span> endx&gt;=<span class="number">0</span> <span class="keyword">and</span> endx&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>]) <span class="keyword">and</span> <span class="built_in">map</span>[endy][endx] == <span class="number">1</span> <span class="keyword">and</span> sign[endy][endx] !=<span class="number">1</span>:</span><br><span class="line">      sign[endy][endx] = <span class="number">1</span></span><br><span class="line">      flag=flag+signdirect[i]</span><br><span class="line">      dfs(endx,endy)</span><br><span class="line">      sign[endy][endx] = <span class="number">0</span></span><br><span class="line">      flag = flag[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dfs(stx,sty)</span><br><span class="line">运行结果： dssd</span><br></pre></td></tr></table></figure>

<p>如果是用字符串的形式声明迷宫时，map的表示方式，及脚本之中需要改变的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map = [&quot;00000&quot;,&quot;01100&quot;,&quot;00100&quot;,&quot;00110&quot;,&quot;00000&quot;]</span><br><span class="line"># 每一步判断条件的 map[endy][endx] == &#x27;1&#x27; 要修改成满足要求的对应字符而不是数字了</span><br><span class="line">if endy&gt;=0 and endy&lt;len(map) and endx&gt;=0 and endx&lt;len(map[0]) and map[endy][endx] == &#x27;1&#x27; and sign[endy][endx] !=1:    </span><br></pre></td></tr></table></figure>

<h2 id="三维迷宫题的算法实现"><a href="#三维迷宫题的算法实现" class="headerlink" title="三维迷宫题的算法实现"></a>三维迷宫题的算法实现</h2><h3 id="python版本-1"><a href="#python版本-1" class="headerlink" title="python版本"></a>python版本</h3><p>这里需要输入的参数和二维的脚本差不多，只是要多一个z轴上的坐标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">map</span> = [[ <span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaeee&quot;</span>],[<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>],[<span class="string">&quot;aeeaa&quot;</span>,<span class="string">&quot;aeeaa&quot;</span>,<span class="string">&quot;eeeae&quot;</span>,<span class="string">&quot;eaaae&quot;</span>,<span class="string">&quot;eaaae&quot;</span>],[<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;eaaee&quot;</span>],[ <span class="string">&quot;aaeea&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aeeea&quot;</span>,<span class="string">&quot;eeaea&quot;</span>,<span class="string">&quot;eaaea&quot;</span>]]</span><br><span class="line"></span><br><span class="line">sign = [[[<span class="number">0</span>]*<span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 标记起始位置</span></span><br><span class="line">stx = <span class="number">2</span></span><br><span class="line">sty = <span class="number">4</span></span><br><span class="line">stz = <span class="number">0</span></span><br><span class="line"><span class="comment"># 标识终点位置</span></span><br><span class="line">finalx = <span class="number">2</span></span><br><span class="line">finaly = <span class="number">2</span></span><br><span class="line">finalz = <span class="number">2</span></span><br><span class="line"><span class="comment"># 标记下一步的地址</span></span><br><span class="line">endx = <span class="number">0</span></span><br><span class="line">endy = <span class="number">0</span></span><br><span class="line">endz = <span class="number">0</span></span><br><span class="line"><span class="comment"># 每次走的方向 路径</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 标记走的四个方向</span></span><br><span class="line">direct = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line">signdirect=<span class="string">&#x27;daswxy&#x27;</span></span><br><span class="line"><span class="comment"># 深度遍历方法的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y,z</span>):</span><br><span class="line">  <span class="keyword">global</span> flag   <span class="comment">#注意在函数里面要当全局变量使用的变量一定要在函数之中进行声明！！！！！！</span></span><br><span class="line">  endx = <span class="number">0</span></span><br><span class="line">  endy = <span class="number">0</span></span><br><span class="line">  endz = <span class="number">0</span></span><br><span class="line">  <span class="comment"># 到达终点</span></span><br><span class="line">  <span class="keyword">if</span> x==finalx <span class="keyword">and</span> y==finaly <span class="keyword">and</span> z==finalz:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment"># 未到达终点之前遍历6个</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(direct)):</span><br><span class="line">    endx = x+direct[i][<span class="number">0</span>]</span><br><span class="line">    endy = y+direct[i][<span class="number">1</span>]</span><br><span class="line">    endz = z+direct[i][<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> endy&gt;=<span class="number">0</span> <span class="keyword">and</span> endy&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>]) <span class="keyword">and</span> endx&gt;=<span class="number">0</span> <span class="keyword">and</span> endx&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>][<span class="number">0</span>]) <span class="keyword">and</span> endz&gt;=<span class="number">0</span> <span class="keyword">and</span> endz&lt;<span class="built_in">len</span>(<span class="built_in">map</span>) <span class="keyword">and</span> <span class="built_in">map</span>[endz][endy][endx] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">and</span> sign[endz][endy][endx] !=<span class="number">1</span>:</span><br><span class="line">      sign[endz][endy][endx] = <span class="number">1</span></span><br><span class="line">      flag=flag+signdirect[i]</span><br><span class="line">      dfs(endx,endy,endz)</span><br><span class="line">      sign[endz][endy][endx] = <span class="number">0</span></span><br><span class="line">      flag = flag[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dfs(stx,sty,stz)</span><br><span class="line"><span class="comment"># 这里返回的结果有多个，选取其中最短的那个即为正确答案   ddwwxxssxaxwwaasasyywwdd</span></span><br><span class="line">ddwwxxssxaxwwaasasyywwdd</span><br><span class="line">ddwwxxssxaxwwaasasyywwdwds</span><br><span class="line">ddwwxxssxaxwwaasasyywwdwwdss</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdd</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdwds</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdwwdss</span><br></pre></td></tr></table></figure>

<p>有时候迷宫的走法不止一个，就取走的路程最小的那个就可以了</p>
]]></content>
      <categories>
        <category>题型</category>
      </categories>
      <tags>
        <tag>迷宫</tag>
      </tags>
  </entry>
</search>
