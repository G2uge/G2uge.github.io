<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUUCTF的Dig the way - 栈溢出</title>
    <url>/2022/02/27/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h2 id="BUUCTF的Dig-the-way-栈溢出"><a href="#BUUCTF的Dig-the-way-栈溢出" class="headerlink" title="BUUCTF的Dig the way - 栈溢出"></a>BUUCTF的Dig the way - 栈溢出</h2><p>这是一道栈溢出的题目</p>
<p>进入到主函数里面</p>
<p>首先就是读取data之中数据的代码</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227123156345.png" alt="image-20220227123156345"></p>
<p>通过代码我们可以知道这个地方并没有对数据的写入长度进行限制</p>
<h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><p>fseek()函数可以移动文件的读写指针到指定的位置，即移动当前文件的位置指针，其原型为：<br>  int fseek(FILE * stream, long offset, int fromwhere);</p>
<p>【参数】stream为文件指针，offset为偏移量，fromwhere为指针的起始位置。</p>
<p>参数 offset 为根据参数 fromwhere 来移动读写位置的位移数。参数 fromwhere 为下列其中一种：</p>
<ul>
<li>SEEK_SET：从距文件开头 offset 位移量为新的读写位置；</li>
<li>SEEK_CUR：以目前的读写位置往后增加 offset 个位移量；</li>
<li>SEEK_END：将读写位置指向文件尾后再增加 offset 个位移量。</li>
</ul>
<p>例子：</p>
<ul>
<li>将读写位置移动到文件开头：fseek(fp, 0, SEEK_SET);</li>
<li>将读写位置移动到文件尾时：fseek(fp, 0, SEEK_END);</li>
<li>将读写位置动到离文件开头100字节处：fseek(fp,100L, SEEK_SET);</li>
<li>将读写指针移动到离文件当前位置100字节处：fseek(fp,100L, SEEK_CUR);</li>
<li>将读写指针退回到离文件结尾100字节处：fseek(fp, -100L, SEEK_END);</li>
</ul>
<h4 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h4><p>用 法: <code>long ftell(FILE *fp);</code><br>描 述: 返回当前文件指针位置。这个位置是当前文件指针相对于文件开头的位移量。<br>返回值:返回文件指针的位置，若出错则返回-1L。<br>参数：文件指针。</p>
<h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><p>用 法: size_t fread( void *buffer, size_t size, size_t count, FILE *stream ) ;<br>描 述: fread()用来从文件流中读取数据。参数stream为已打开的文件指针，参数buffer指向欲存放读取进来的数据空间，读取的字节数以参数size * count来决定。<br>返回值: 返回实际读取到的count数目，如果此值比参数count来得小，则代表可能读到了文件尾了或者有错误发生(前者几率大)，这时必须用feof()或ferror()来决定发生什么情况。<br>参数：</p>
<p>buffer ：读取的数据存放的内存的指针（可以是数组，也可以是新开辟的空间，buffer就是一个索引）；<br>size ： 每次读取的字节数 ；<br>count ：读取次数 ；<br>strean：要读取的文件的指针；</p>
<h4 id="三个函数的解析"><a href="#三个函数的解析" class="headerlink" title="三个函数的解析"></a>三个函数的解析</h4><h5 id="func0"><a href="#func0" class="headerlink" title="func0"></a>func0</h5><p>交换栈中的两个数据</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113310818.png" alt="image-20220227113300364"></p>
<h5 id="func1"><a href="#func1" class="headerlink" title="func1"></a>func1</h5><p>这个函数的返回值小于等于2</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113437073.png" alt="image-20220227113437073"></p>
<h5 id="func2"><a href="#func2" class="headerlink" title="func2"></a>func2</h5><p>这个函数的返回值大于等于2</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113508616.png" alt="image-20220227113508616"></p>
<p>现在我们需要使v11等于0 ，程序之中给v11赋值的是func2函数，但是该函数的返回值一定是大于等于2的，显示不可能实现v11= 0</p>
<p>但是在上面的三个函数之中我们可以看到func1的返回值能够等于0 ，所以需要使用func0这个函数调换栈中func1和func2这两个函数的位置</p>
<h4 id="交换func1函数和func0函数位置"><a href="#交换func1函数和func0函数位置" class="headerlink" title="交换func1函数和func0函数位置"></a>交换func1函数和func0函数位置</h4><p>运行func0函数时，传入的参数v12和v13是初始值，我们只需将表示func1地址的v15 和 表示func2地址的v16交换</p>
<p>v15的地址是 v8+4*7    v16的地址是v8+4*8 所以需要将v12 和 v13的值设为7 和 8 ；</p>
<p>按道理来说7和8的顺序没有关系，但是实际操作发现7和8的赋值顺序不一样，得到的flag是不一样的，只有把v12 = 7和 v13 = 8才可以得到正确的flag</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227122635003.png" alt="image-20220227122635003"></p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227122638492.png" alt="image-20220227122638492"></p>
<h4 id="使得func1的返回值为0"><a href="#使得func1的返回值为0" class="headerlink" title="使得func1的返回值为0"></a>使得func1的返回值为0</h4><p>运行func2时 v12=2  v13=3 ，所以函数之中进行运算的两个数字是v10和v11，v10的值是2 ，若想要这个函数的返回值是0，需要将v10置为-1 即0xffffffff</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227123021830.png" alt="image-20220227123021830"></p>
<h4 id="data文件的构造"><a href="#data文件的构造" class="headerlink" title="data文件的构造"></a>data文件的构造</h4><p>data数据传入的首地址是v7，因为没有设置传入数据的长度，所以可以传入无限制大小的数据，多出来的部分会对后面的数据进行覆盖，v7的长度是20 ，v10的位置是 20+2*4 = 28  v11的位置是 20+3*4=32  v12的位置是 20+4*4=36 v13的位置是 20+5*4=40 总的数据长度是44</p>
<p>用010构造数据，并且保存为data，和exe文件放到同一目录之下，运行程序</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227130028183.png" alt="image-20220227130028183"></p>
<p>运行的结果：</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227130059588.png" alt="image-20220227130059588"></p>
<p>所以得到的flag是</p>
<p>flag{8cda1bdb68a72a392a3968a71bdb8cda}</p>
<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。</p>
<p>实现栈溢出，要满足两个条件。第一，程序要有向栈内写入数据的行为；第二，程序并不限制写入数据的长度。如果想用栈溢出来执行攻击指令，就要在溢出数据内包含攻击指令的内容或地址，并且要将程序控制权交给该指令。攻击指令可以是自定义的指令片段，也可以利用系统内已有的函数及指令。</p>
</blockquote>
<h3 id="函数状态主要涉及三个寄存器-–-esp，ebp，eip"><a href="#函数状态主要涉及三个寄存器-–-esp，ebp，eip" class="headerlink" title="函数状态主要涉及三个寄存器 – esp，ebp，eip"></a>函数状态主要涉及三个寄存器 – esp，ebp，eip</h3><ul>
<li><p><code>esp</code>用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化</p>
</li>
<li><p><code>ebp</code>用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p>
</li>
<li><p><code>eip</code> 用来存储即将执行的程序指令的地址，cpu依照 eip的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p>
<p>使用这三个寄存器实现 将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。</p>
</li>
</ul>
<h3 id="栈溢出攻击"><a href="#栈溢出攻击" class="headerlink" title="栈溢出攻击"></a>栈溢出攻击</h3><blockquote>
<p>当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是<br>eip。所以我们的目标就是让 eip 载入攻击指令的地址。 首先，在退栈过程中，返回地址会被传给<br>eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。</p>
</blockquote>
<p>四种方法归类：</p>
<p>1.修改返回地址，让其指向溢出数据中的一段指令（shellcode） </p>
<p>2.修改返回地址，让其指向内存中已有的某个函数（return2libc）</p>
<p> 3.修改返回地址，让其指向内存中已有的一段指令（ROP） </p>
<p>4.修改某个被调用函数的地址，让其指向另一个函数（hijack GOT）</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227134449755.png" alt="image-20220227134449755"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>32位x86架构下的通用寄存器包括一般寄存器（eax、ebx、ecx、edx），索引寄存器（esi、edi），以及堆栈指针寄存器（esp、ebp）</p>
<ul>
<li><p>eax被称为累加寄存器（Accumulator），用以进行算数运算和返回函数结果等。</p>
</li>
<li><p>ebx被称为基址寄存器（Base），在内存寻址时（比如数组运算）用以存放基地址。</p>
</li>
<li><p>ecx被称为记数寄存器（Counter），用以在循环过程中记数。</p>
</li>
<li><p>edx 被称为数据寄存器（Data），常配合 eax 一起存放运算结果等数据。</p>
</li>
<li><p>esi 指向要处理的数据地址（Source Index）</p>
</li>
<li><p>edi指向存放处理结果的数据地址（Destination Index）</p>
</li>
</ul>
<p>参考文章： <a href="https://blog.csdn.net/weixin_43092232/article/details/96902468">https://blog.csdn.net/weixin_43092232/article/details/96902468</a></p>
]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>TEA系列加密解密</title>
    <url>/2022/02/28/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h1 id="TEA系列加密解密"><a href="#TEA系列加密解密" class="headerlink" title="TEA系列加密解密"></a>TEA系列加密解密</h1><h2 id="TEA加密解密"><a href="#TEA加密解密" class="headerlink" title="TEA加密解密"></a>TEA加密解密</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>在密码学中，微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。</p>
<p>代码的特点： </p>
<ul>
<li>加密使用的数据为2个32位无符号整数，密钥为4个32位无符号整数即密钥长度为128位（当加密解密的对象是一串数组的时候，需要将这个32位无符号整数的数组<strong>每两个32位无符号整数划分为一组</strong>，对每一组数据单独加密解密得到结果）</li>
<li>该算法使用了一个常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 <strong>0×9E3779B9</strong>）作为魔数</li>
</ul>
</blockquote>
<h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>拥有一个叫做<a href="https://en.wikipedia.org/wiki/Feistel_cipher">Feistel 结构</a>的密码学结构。这种密码学结构通俗的来讲就是会将加密的plaintext分成L、R两部分，并且满足 <code>L_&#123;i+1&#125; = R_i, R_&#123;i+1&#125; = F(K_i,R_i) \oplus L_i</code> 这种交换式的加密方式的一种结构。</p>
<p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228191440573.png" alt="image-20220228191440573"></p>
<h3 id="TEA加密算法的实现"><a href="#TEA加密算法的实现" class="headerlink" title="TEA加密算法的实现"></a>TEA加密算法的实现</h3><p>参数要求：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组）</p>
<p>加密特征：存在一个<strong>delta值</strong>，这个值会不停的增加到<strong>sum</strong>之中，形成一种循环的效果；会有一个<strong>位移-&gt;与密钥相加-&gt;异或</strong>的过程；计算delta的sum状态值也会参与</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TEA解密算法的实现"><a href="#TEA解密算法的实现" class="headerlink" title="TEA解密算法的实现"></a>TEA解密算法的实现</h3><p>参数要求：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//解密函数  </span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */  </span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */  </span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */  </span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */  </span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);  </span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">    &#125;                                              /* end cycle */  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>解密数组：{0x3e8947cb,0xcc944639,0x31358388,0x3b0b6893,0xda627361,0x3b2e6427}</p>
<p>key数组：{0x4445,0x4144,0x4245,0x4546}</p>
<p>因为在解密的过程之中会产生移位的运算，这个过程会产生溢出，所以每组解密的对象声明成 <strong>v1[3]={0x3e8947cb,0xcc944639,0x0}</strong> 这样的形式</p>
<p>解密的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */</span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v1[3]=&#123;0x3e8947cb,0xcc944639,0x0&#125;,k[4]=&#123;0x4445,0x4144,0x4245,0x4546&#125;;</span><br><span class="line">    uint32_t v2[3]=&#123;0x31358388,0x3b0b6893,0x0&#125;;</span><br><span class="line">    uint32_t v3[3]=&#123;0xda627361,0x3b2e6427&#125;;</span><br><span class="line">    decrypt(v1, k);</span><br><span class="line">    decrypt(v2, k);</span><br><span class="line">    decrypt(v3, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s %s %s\n&quot;,(char*)v1,(char*)v2,(char*)v3);   // 注意如何将一串数组以字符串的形式输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出的结果：fvBXQdEa rcbvhBPx cOA8Ag6J</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p>printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p>
<p>参数的格式</p>
<p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228193403698.png" alt="image-20220228193403698"></p>
<h2 id="XTEA加密解密"><a href="#XTEA加密解密" class="headerlink" title="XTEA加密解密"></a>XTEA加密解密</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作</p>
</blockquote>
<h3 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228193746682.png" alt="image-20220228193746682"></p>
<h3 id="XTEA加密算法的实现"><a href="#XTEA加密算法的实现" class="headerlink" title="XTEA加密算法的实现"></a>XTEA加密算法的实现</h3><p>相较于TEA的变化：</p>
<ul>
<li>由之前的**<code>((v1&lt;&lt;4) + k0) ^ ((v1&gt;&gt;5) + k1)</code>** 变化成了 **<code>((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1)</code>**，此时v1内部数据的加密变化不再受到密钥的影响。</li>
<li>原先的<code>v1 + sum</code>变成了<code>(sum + key[sum &amp; 3])</code>以及<code>sum + key[(sum&gt;&gt;11) &amp; 3]</code>，密钥变成了<strong>轮转</strong>使用，而不是固定只针对某种数据进行加密（解密）。并且此时密钥的选取<strong>受到sum的影响</strong></li>
<li><code>sum += delta</code>的时机由每次加密开头就发生变化到v0，v1<strong>两个block加密的中间</strong>。</li>
</ul>
<p>输入的参数：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组），注意这里循环的次数不是固定的了，是需要传入的参数<strong>num_rounds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  </span><br><span class="line">    unsigned int i;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;  </span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  </span><br><span class="line">        sum += delta;  </span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="XTEA解密算法的实现"><a href="#XTEA解密算法的实现" class="headerlink" title="XTEA解密算法的实现"></a>XTEA解密算法的实现</h3><p>输入的参数：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组），注意这里循环的次数不是固定的了，是需要传入的参数<strong>num_rounds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  </span><br><span class="line">    unsigned int i;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;  </span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */</span><br><span class="line"></span><br><span class="line">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[3]=&#123;0x73647979,0x726b6f5f,0x0&#125;;</span><br><span class="line">    uint32_t v1[2]=&#123;0x646f675f,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]=&#123;0X95C4C,0X871D,0X1A7B7,0X12C7C7&#125;;</span><br><span class="line">    unsigned int r=32;//num_rounds建议取值为32</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line">    printf(&quot;加密前原始数据：%s%s\n&quot;,(char*)v,(char*)v1);</span><br><span class="line">    encipher(r, v, k);</span><br><span class="line">    encipher(r, v1, k);</span><br><span class="line">    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v1[0]);</span><br><span class="line">    decipher(r, v, k);</span><br><span class="line">    decipher(r, v1, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s%s\n&quot;,(char*)v,(char*)v1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">加密前原始数据：yyds_okr_god</span><br><span class="line">加密后的数据：3461349474 1314311102 3609197830</span><br><span class="line">解密后的数据：yyds_okr_god</span><br></pre></td></tr></table></figure>

<h2 id="XXTEA加密解密"><a href="#XXTEA加密解密" class="headerlink" title="XXTEA加密解密"></a>XXTEA加密解密</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>XTEA再度进化， 变成了支持块加密<code>XXTEA</code></p>
</blockquote>
<h3 id="加密过程-2"><a href="#加密过程-2" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228200301853.png" alt="image-20220228200301853"></p>
<h3 id="XXTEA加密解密算法的实现"><a href="#XXTEA加密解密算法的实现" class="headerlink" title="XXTEA加密解密算法的实现"></a>XXTEA加密解密算法的实现</h3><p>特点：在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥, 是目前TEA系列中最安全的算法，但性能较上两种有所降低。</p>
<p>参数：输入的是<strong>至少拥有两个元素的32bit的数组</strong>，密钥的长度仍然是<strong>128位</strong>，即拥有<strong>4个元素32位</strong>长度的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdint.h&gt;  </span><br><span class="line">#define DELTA 0x9e3779b9  </span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))  </span><br><span class="line">  </span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])  </span><br><span class="line">&#123;  </span><br><span class="line">    uint32_t y, z, sum;  </span><br><span class="line">    unsigned p, rounds, e;  </span><br><span class="line">    if (n &gt; 1)            /* Coding Part */  </span><br><span class="line">    &#123;  </span><br><span class="line">        rounds = 6 + 52/n;  </span><br><span class="line">        sum = 0;  </span><br><span class="line">        z = v[n-1];  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            sum += DELTA;  </span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;  </span><br><span class="line">            for (p=0; p&lt;n-1; p++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                y = v[p+1];  </span><br><span class="line">                z = v[p] += MX;  </span><br><span class="line">            &#125;  </span><br><span class="line">            y = v[0];  </span><br><span class="line">            z = v[n-1] += MX;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (--rounds);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */  </span><br><span class="line">    &#123;  </span><br><span class="line">        n = -n;  </span><br><span class="line">        rounds = 6 + 52/n;  </span><br><span class="line">        sum = rounds*DELTA;  </span><br><span class="line">        y = v[0];  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;  </span><br><span class="line">            for (p=n-1; p&gt;0; p--)  </span><br><span class="line">            &#123;  </span><br><span class="line">                z = v[p-1];  </span><br><span class="line">                y = v[p] -= MX;  </span><br><span class="line">            &#125;  </span><br><span class="line">            z = v[n-1];  </span><br><span class="line">            y = v[0] -= MX;  </span><br><span class="line">            sum -= DELTA;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (--rounds);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span><br><span class="line"></span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t y, z, sum;</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n-1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=0; p&lt;n-1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+1];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n-1] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=n-1; p&gt;0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p-1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n-1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[4]= &#123;0x73647979,0x726b6f5f,0x646f675f,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]= &#123;0X95C4C,0X871D,0X1A7B7,0X12C7C7&#125;;</span><br><span class="line">    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line">    printf(&quot;加密前原始数据：%s\n&quot;,(char*)v);</span><br><span class="line">    btea(v, n, k);</span><br><span class="line">    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v[3]);</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s\n&quot;,(char*)v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">加密前原始数据：yyds_okr_god</span><br><span class="line">加密后的数据：609835868 2980644312 0</span><br><span class="line">解密后的数据：yyds_okr_god</span><br></pre></td></tr></table></figure>

<h2 id="逆向中TEA系列加密的识别"><a href="#逆向中TEA系列加密的识别" class="headerlink" title="逆向中TEA系列加密的识别"></a>逆向中TEA系列加密的识别</h2><p>解决逆向题大部分出现TEA的场合都是【识别算法-&gt;编写对应解密程序】</p>
<p>分析二进制文件中的算法的时候有几个识别的特征</p>
<ul>
<li>可能存在针对<strong>64bit</strong>以及<strong>128bit</strong>数字的操作（输入的<strong>msg和key</strong>） ，一般会用<strong>无符号的32位的数组</strong>表示</li>
<li>存在<strong>先进行位移，然后异或</strong>的类似操作（<code>(z&gt;&gt;5^y&lt;&lt;2) </code>这类混合变换）**<code>(z&gt;&gt;5^y&lt;&lt;2)</code><strong>就是xxtea加密了，存在</strong>(v0 &lt;&lt; 4)** 和 **(v0 &gt;&gt; 5)**移位就是tea和xtea加密了</li>
<li>前面一个复杂的混合变换的结果可能会<strong>叠加</strong>到另一个值上，两者相互叠加（Feistel 结构）</li>
<li><strong>获取密钥</strong>的时候，会使用某一个常量值作为下标（<code>key[(sum&gt;&gt;11) &amp; 3]</code>）存在轮换的方式获得密钥 就是xtea或者xxtea了</li>
<li>会在算法开始定义一个<strong>delta</strong>，并且这个值不断的参与算法，但是<strong>从来不会受到输入的影响</strong>（delta数值如果没有魔改就是0x9e3779b9）如果出现了<strong>0x9e3779b9</strong>这个数字一般就能确定是TEA加密系列</li>
</ul>
<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/4272e0805da3">https://www.jianshu.com/p/4272e0805da3</a></p>
<p><a href="https://www.anquanke.com/post/id/224198#h3-2">https://www.anquanke.com/post/id/224198#h3-2</a></p>
]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>TEA</tag>
      </tags>
  </entry>
  <entry>
    <title>VNCTF_2022</title>
    <url>/2022/02/25/VNCTF-2022/</url>
    <content><![CDATA[<h2 id="VN2022"><a href="#VN2022" class="headerlink" title="VN2022"></a>VN2022</h2><h4 id="cm狗"><a href="#cm狗" class="headerlink" title="cm狗"></a>cm狗</h4><p>用jadx软件载入这个apk文件</p>
<p>判断flag的函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141557259.png" alt="image-20220215141557259"></p>
<p>判断的函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141619535.png" alt="image-20220215141619535"></p>
<p>loadDexClass()的这个函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141712322.png" alt="image-20220215141712322"></p>
<p>这里copyfile了一个dex的文件，这里copyFile()函数里面应该还有一系列的操作，一系列操作的结果最后写入了创建的一个文件里面</p>
<p>找到这个文件，并且找到这个函数</p>
<p><img src="/images/VNCTF-2022/image-20220219205934006.png" alt="image-20220219205934006"></p>
<p>该函数的详情</p>
<p><img src="/images/VNCTF-2022/image-20220219210128389.png" alt="image-20220219210128389"></p>
<p>主要的代码</p>
<p><img src="/images/VNCTF-2022/image-20220219210151167.png" alt="image-20220219210151167"></p>
<p><img src="/images/VNCTF-2022/image-20220219210531948.png" alt="image-20220219210531948"></p>
<p>注意这个地方是每次取1024出来，外层有个while(true)的循环的操作</p>
<p>得到的这个文件名称是 classes.dex</p>
<p><img src="/images/VNCTF-2022/image-20220219213108277.png" alt="image-20220219213108277"></p>
<p>对文件进行操作的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v0 = &#x27;vn2022&#x27;</span><br><span class="line">with open(&quot;D:\\re\\buuctf\\VN\\3\\ooo&quot;,&#x27;rb&#x27;) as f1:</span><br><span class="line">    c = f1.read()</span><br><span class="line">with open(&quot;D:\\re\\buuctf\\VN\\3\\out&quot;,&#x27;wb&#x27;) as f2:</span><br><span class="line">    for i in range(len(c)):</span><br><span class="line">        f2.write((c[i]^ord(v0[i %1024 % len(v0)])).to_bytes(1,byteorder=&quot;little&quot;,signed=False))</span><br><span class="line">print(&quot;OK&quot;)</span><br></pre></td></tr></table></figure>

<p>将得到的这个文件命名为class.dex，这是一个dex文件，首先使用dex2jar 将 dex文件转变成jar文件，然后使用jd-gui打开这个得到的jar文件，注意使用dex2jar得到jar文件的时候，需要将dex文件放入到dex2jar的文件夹目录之下</p>
<p>得到的这个文件之中 </p>
<p>加密函数 （xxtea加密）</p>
<p><img src="/images/VNCTF-2022/image-20220219223231506.png" alt="image-20220219223231506"></p>
<p>在hcheck这个函数之中，首先给了一堆数字，然后将输入的flag以及xxtea的密钥输入，对输入进行加密，加密的结果就是上面定义的一系列数值</p>
<p><img src="/images/VNCTF-2022/image-20220219223525059.png" alt="image-20220219223525059"></p>
<p><img src="/images/VNCTF-2022/image-20220219223528938.png" alt="image-20220219223528938"></p>
<p>去网上找一个xxtea解密的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9            //固定的一个常量</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   //固定的运算</span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])   //v是要加密的两个元素的数组</span><br><span class="line">&#123;                                                      //n为数组的长度</span><br><span class="line">    uint32_t y, z, sum;                                //无符号整型</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52/n;               //固定的得出轮数</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n-1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;                //每次进行叠加</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;          //固定运算</span><br><span class="line">            for (p=0; p&lt;n-1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+1];</span><br><span class="line">                v[p] += MX;</span><br><span class="line">                      z = v[p];</span><br><span class="line">                        &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n-1] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=n-1; p&gt;0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p-1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n-1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int8_t a[]= &#123;68, 39, -92, 108, -82, -18, 72, -55, 74, -56, 38, 11, 60, 84, 97, -40, 87, 71, 99, -82, 120, 104, 47, -71, -58, -57, 0, 33, 42, 38, -44, -39, -60, 113, -2, 92, -75, 118, -77, 50, -121, 43, 32, -106 &#125;;</span><br><span class="line">    uint32_t *v = (uint32_t *)a;</span><br><span class="line">    uint32_t *k= (uint32_t *)&quot;H4pPY_VNCTF!!OvO&quot;;</span><br><span class="line">    int n= 11;</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    printf(&quot;decrypto result:%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n&quot;,v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10]);</span><br><span class="line">    printf(&quot;result:%s&quot;,v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">VNCTF&#123;93ee7688-f216-42cb-a5c2-191ff4e412ba&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220219230318245.png" alt="image-20220219230318245"></p>
<p>所以最后的flag 是 VNCTF{93ee7688-f216-42cb-a5c2-191ff4e412ba}</p>
<h4 id="BabyMaze"><a href="#BabyMaze" class="headerlink" title="BabyMaze"></a>BabyMaze</h4><p>这道题如果直接使用employee6 解pyc得到代码是不行的，因为在这个代码里面有花指令，</p>
<p>方法一：直接使用pycda中的得到bytecode的底层的代码</p>
<p>看见迷宫，拼一下迷宫，按照w代表向上走，s代表向下走，a代表向左走，d代表向右走的方式走迷宫</p>
<p>python的pyc文件的反编译pycdc和pycdas这两个文件，pycdc反编译为python的代码，pycdas这个文件会将pyc文件编译成字节码的形式 <a href="http://www.syjblog.com/?p=470">pyc反编译</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/89935120">pyc的结构体</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Bytecode object */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">   PyObject_HEAD</span><br><span class="line">   int co_argcount;            /* Code Block的位置参数个数，比如说一个函数的位置参数个数*/</span><br><span class="line">   int co_nlocals;             /* Code Block中局部变量的个数，包括其中位置参数的个数 */</span><br><span class="line">   int co_stacksize;           /* 执行该段Code Block需要的栈空间 */</span><br><span class="line">   int co_flags;               /* CO_..., see below */</span><br><span class="line">   PyObject *co_code;          /* Code Block编译所得的字节码指令序列。以PyStingObjet的形式存在 */</span><br><span class="line">   PyObject *co_consts;        /* PyTupleObject对象，保存CodeBlock中的所常量 */</span><br><span class="line">   PyObject *co_names;         /* PyTupleObject对象，保存CodeBlock中的所有符号 */</span><br><span class="line">   PyObject *co_varnames;      /* Code Block中的局部变量名集合 */</span><br><span class="line">   PyObject *co_freevars;      /* Python实现闭包需要用的东西 */</span><br><span class="line">   PyObject *co_cellvars;      /* Code Block中内部嵌套函数所引用的局部变量名集合 */</span><br><span class="line">   /* The rest doesn&#x27;t count for hash/cmp */</span><br><span class="line">   PyObject *co_filename;      /* Code Block所对应的.py文件的完整路径 */</span><br><span class="line">   PyObject *co_name;          /* Code Block的名字，通常是函数名或类名 */</span><br><span class="line">   int co_firstlineno;         /* Code Block在对应的.py文件中起始行 */</span><br><span class="line">   PyObject *co_lnotab;        /* 字节码指令与.py文件中source code行号的对应关系，以PyStringObject的形式存在 */</span><br><span class="line">   void *co_zombieframe;     /* for optimization only (see frameobject.c) */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>

<p>得到：走出的迷宫的结果</p>
<p>ssssddssaassddddwwwwddwwddddddwwddddddssddwwddddddddssssaawwaassaassaassddssaassaawwwwwwaaaaaaaassaassddddwwddssddssssaassddssssaaaaaawwddwwaawwwwaassssssssssssddddssddssddddddddwwaaaaaawwwwddssddwwwwwwwwddssddssssssssddddss</p>
<p>将上面的解md5(32小写)得到最后的结果  VNCTF{801f190737434100e7d2790bd5b0732e}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                   1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">68      BUILD_LIST              31 1 5 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">132     BUILD_LIST              31 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1</span><br><span class="line">196     BUILD_LIST              31 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1</span><br><span class="line">260     BUILD_LIST              31 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1</span><br><span class="line">324     BUILD_LIST              31 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">388     BUILD_LIST              31 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1</span><br><span class="line">452     BUILD_LIST              31 1 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1</span><br><span class="line">516     BUILD_LIST              31 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1</span><br><span class="line">580     BUILD_LIST              31 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">644     BUILD_LIST              31 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1</span><br><span class="line">708     BUILD_LIST              31 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">772     BUILD_LIST              31 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1</span><br><span class="line">836     BUILD_LIST              31 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">900     BUILD_LIST              31 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1</span><br><span class="line">964     BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">1028    BUILD_LIST              31 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 0 1</span><br><span class="line">1092    BUILD_LIST              31 1 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">1156    BUILD_LIST              31 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1</span><br><span class="line">1220    BUILD_LIST              31 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">1284    BUILD_LIST              31 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 0 1</span><br><span class="line">1348    BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1412    BUILD_LIST              31 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1476    BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1540    BUILD_LIST              31 1 0 1 1 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1604    BUILD_LIST              31 1 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1</span><br><span class="line">1668    BUILD_LIST              31 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1</span><br><span class="line">1732    BUILD_LIST              31 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1</span><br><span class="line">1796    BUILD_LIST              31 1 0 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1</span><br><span class="line">1860    BUILD_LIST              31 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 7 1</span><br><span class="line">1924    BUILD_LIST              31 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>VNCTF{801f190737434100e7d2790bd5b0732e}</p>
<h4 id="时空飞行"><a href="#时空飞行" class="headerlink" title="时空飞行"></a>时空飞行</h4><p>运行一下这个程序，因为不能直接运行，所以使用IDA调试运行，所以现在我们需要找到日期和符来歌（根据运行之中的提示语句得到）</p>
<p><img src="/images/VNCTF-2022/image-20220221120512364.png" alt="image-20220221120512364"></p>
<p>变化之后的日期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0FD07C452h, 0EC90A488h, 68D33CD1h, 96F64587h</span><br></pre></td></tr></table></figure>

<p>对输入的日期进行加密的过程</p>
<p><img src="/images/VNCTF-2022/image-20220221122556035.png" alt="image-20220221122556035"></p>
<p>v5[v3] = sub_401A3B(v5[i + 3] ^ v5[i + 2] ^ (unsigned int)v5[i + 1] ^ dword_405040[i]) ^ v4;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v5[4] = sub_401A3B(v5[3] ^ v5[2] ^ (unsigned int)v5[1] ^ dword_405040[0]) ^ v5[0];</span><br><span class="line">v5[5] = sub_401A3B(v5[4] ^ v5[3] ^ (unsigned int)v5[2] ^ dword_405040[1]) ^ v5[1];</span><br><span class="line">... ...</span><br><span class="line">v5[34] = sub_401A3B(v5[33] ^ v5[32] ^ (unsigned int)v5[31] ^ dword_405040[2]) ^ v5[30];</span><br><span class="line">v5[35] = sub_401A3B(v5[34] ^ v5[33] ^ (unsigned int)v5[32] ^ dword_405040[3]) ^ v5[31];</span><br></pre></td></tr></table></figure>

<p>sub_401A3B()这个函数的作用</p>
<p><img src="/images/VNCTF-2022/image-20220221123230352.png" alt="image-20220221123230352"></p>
<p>a1和a1向左移13位的结果和a1向右移9位的结果做异或运算，</p>
<p>逆向分析的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">unsigned int CalcRound(unsigned int key)&#123;</span><br><span class="line">    return key ^((((key&amp;0xffffffff)&lt;&lt;13)|((key&amp;0xffffffff)&gt;&gt;(32-13)))^(((key&amp;0xffffffff)&lt;&lt;(32-9))|((key&amp;0xffffffff)&gt;&gt;9)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long CK[32] = &#123;</span><br><span class="line">0x00070e15,0x1c232a31,0x383f464d,0x545b6269,</span><br><span class="line">0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,</span><br><span class="line">0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,</span><br><span class="line">0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,</span><br><span class="line">0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,</span><br><span class="line">0x30373e45,0x4c535a61,0x686f767d,0x848b9299,</span><br><span class="line">0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,</span><br><span class="line">0x10171e25,0x2c333a41,0x484f565d,0x646b7279</span><br><span class="line">&#125;;</span><br><span class="line">    unsigned int result[] = &#123;0x0FD07C452, 0x0EC90A488, 0x68D33CD1, 0x96F64587&#125;;</span><br><span class="line">    unsigned int re_result[36];</span><br><span class="line">    for(int i=32;i&lt;36;i++)&#123;</span><br><span class="line">        re_result[i] =result[i-32];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=31;i&gt;=0;i--)&#123;</span><br><span class="line">        re_result[i] = CalcRound(re_result[i+1]^re_result[i+2]^re_result[i+3]^CK[i])^re_result[i+4];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned long tem[4] = &#123;0xA3B1BAC6,0x56AA3350,0x677D9197,0xB27022DC&#125;;</span><br><span class="line">    for(int i=0;i&lt;=3;i++)&#123;</span><br><span class="line">        re_result[i]=re_result[i]^tem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char *data = (unsigned char *)re_result;   //因为日期的表示是8个数字，每个数字是用8位来代表</span><br><span class="line">    for(int i=1;i&lt;=2;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=4;j++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;,data[i*4 - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">20211205</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221133215573.png" alt="image-20220221133215573"></p>
<p>将得到的日期放入之后，就要进行符来歌的输入</p>
<p><img src="/images/VNCTF-2022/image-20220221133557404.png" alt="image-20220221133557404"></p>
<p>最后需要对比的元素是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1ebe,0x1e8e,0x1e44,0x1e39,0x1e5b,0x1e8,0x1e36,0x1e8f,0x1edd,0x1e5e,0x1e94,0x1eb5,0x1e1,0x1e70,0x1eab,0x1e63,0x1ebb,0x1e72,0x1e50,0x1e13,0x1e5d,0x1e25,0x1e16,0x1e78</span><br></pre></td></tr></table></figure>

<p>在上面函数 之中对这个数组中的元素做了一定的运算，下面得到的就是运算加密之后的数组</p>
<p><img src="/images/VNCTF-2022/image-20220221170531828.png" alt="image-20220221170531828"></p>
<p>所以需要比较的数组是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221183335046.png" alt="image-20220221183335046"></p>
<p>用爆破的方式得到上面的解，发现这里某些会有多个解所以需要使用递归的方式，深度优先算法解得所有的解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [ 0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3]</span><br><span class="line">i=0</span><br><span class="line">flags=[]</span><br><span class="line">flag = [0]*24</span><br><span class="line">flag[23] = 0xe3</span><br><span class="line">def DFS(deep):</span><br><span class="line">  global flags</span><br><span class="line">  global flag</span><br><span class="line">  if deep ==0:</span><br><span class="line">    flags.append(flag.copy())</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">    for j in range(1,0xff):</span><br><span class="line">      tem = j^((j % 0x12+ flag[deep] + 0x05) ^ 0x41)</span><br><span class="line">      if tem == obj[deep-1]:</span><br><span class="line">        flag[deep-1]=j</span><br><span class="line">        DFS(deep-1)</span><br><span class="line">              </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  DFS(23)</span><br><span class="line">  for i in range(len(flags)):</span><br><span class="line">    print(flags[i])</span><br><span class="line">[20, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[21, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[22, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[23, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[28, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[29, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[30, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[31, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[128, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[129, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[130, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[131, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[136, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[137, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[138, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[139, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[72, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[73, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[74, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[75, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[80, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[81, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[82, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[83, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[88, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[89, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[184, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[185, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[186, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[187, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221183354391.png" alt="image-20220221183354391"></p>
<p>通过这个我们可以获得 a1[60] a1[61] a1[62] a1[63] a1[64] a1[65] 5个数</p>
<p>对输入的每32个字节的操作：将32位数 F1F1 F2F2 F3F3 F4F4 排列为 F4F4 F3F3 F2F2 F1F1 </p>
<p><img src="/images/VNCTF-2022/image-20220221184405201.png" alt="image-20220221184405201"></p>
<p>将所有输入的字符进行上面的运算，然后重新赋值给a1 则可以知道数组之中有6个元素</p>
<p><img src="/images/VNCTF-2022/image-20220221184743758.png" alt="image-20220221184743758"></p>
<p>然后就需要进行一系列的运算，</p>
<p><img src="/images/VNCTF-2022/image-20220221185657924.png" alt="image-20220221185657924"></p>
<p>当v5不是6的倍数的时候 </p>
<p>当i不是6的倍数的时候：v5[7] = v5[1]^v5[6]   v5[i] = v5[i-6] ^ v5[i-1] </p>
<p>当i是6的倍数的时候：v5[i] = v5[i-6] ^ T(v5[i-1],v3)  v3代表的是第几个6的倍数</p>
<p><strong>T函数的讲解</strong>：</p>
<p><img src="/images/VNCTF-2022/image-20220221190435689.png" alt="image-20220221190435689"></p>
<p>其中的第一个函数：将a1分解成了4个元素的数组0x  F0F0 F1F1 F2F2 F3F3</p>
<p><img src="/images/VNCTF-2022/image-20220221190819733.png" alt="image-20220221190819733"></p>
<p>其中的第二个函数：将数组中的元素循环右移一位 ；例如 a=[a0,a1,a2,a3] 转化成 a=[a1,a2,a3,a0] </p>
<p>[F3F3,F2F2,F1F1,F0F0] [F2F2,F1F1,F0F0,F3F3]</p>
<p><img src="/images/VNCTF-2022/image-20220221191008054.png" alt="image-20220221191008054"></p>
<p>其中第三个函数：整合上面的数组之中的元素  0x F3F3 F0F0 F1F1 F2F2</p>
<p><img src="/images/VNCTF-2022/image-20220221191329845.png" alt="image-20220221191329845"></p>
<p>所以这个函数的作用是 将 0x  F0F0 F1F1 F2F2 F3F3 转化成 0x F3F3 F0F0 F1F1 F2F2 循环左移动了8位 然后再和对应那个6的倍数作为脚标找到数组对应的元素</p>
<p>作为索引对象的数组是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000,</span><br><span class="line">           0x36000000]</span><br></pre></td></tr></table></figure>

<p>每组得到了6个数字，将这六个元素作为66个元素之中的后六位元素</p>
<p>逆向：</p>
<p>当i不是6的倍数时： v5[i-6] = v5[i]^v5[i-1]</p>
<p>当i是6的倍数时： v5[i-6] = v5[i]^ T(v5[i-1],v3) # v3 = i%6 T是将数循环左移动了8位，再和对应的数字进行异或运算</p>
<p>逆向得到的66个元素的前6个元素，将前6个元素转化为字符输出</p>
<p>所有运算的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [ 0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3]</span><br><span class="line">inner_index = [0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000,</span><br><span class="line">           0x36000000]</span><br><span class="line">i=0</span><br><span class="line">flags=[]</span><br><span class="line">flag = [0]*24</span><br><span class="line">flag[23] = 0xe3</span><br><span class="line"># 用递归 ，深度遍历的方法得到所有的解</span><br><span class="line">def DFS(deep):</span><br><span class="line">  global flags</span><br><span class="line">  global flag</span><br><span class="line">  if deep ==0:</span><br><span class="line">    flags.append(flag.copy())</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">    for j in range(1,0xff):</span><br><span class="line">      tem = j^((j % 0x12+ flag[deep] + 0x05) ^ 0x41)</span><br><span class="line">      if tem == obj[deep-1]:</span><br><span class="line">        flag[deep-1]=j</span><br><span class="line">        DFS(deep-1)</span><br><span class="line"></span><br><span class="line"># 位移运算</span><br><span class="line">def rol8(num):</span><br><span class="line">  return ((num&amp;0xffffff)&lt;&lt;8) |((num&amp;0xff000000)&gt;&gt;(32-8))</span><br><span class="line"></span><br><span class="line"># 位移加上 异或运算</span><br><span class="line">def T(num,i):</span><br><span class="line">  num = rol8(num)</span><br><span class="line">  return num^inner_index[i-1]</span><br><span class="line"></span><br><span class="line"># 根据是否是6的倍数进行的不同的异或运算</span><br><span class="line">def multiple(final_flag):</span><br><span class="line">  for i in range(65,5,-1):</span><br><span class="line">    if i%6 !=0:</span><br><span class="line">      final_flag[i-6] = final_flag[i]^final_flag[i-1]</span><br><span class="line">    else:</span><br><span class="line">      final_flag[i - 6] = final_flag[i] ^ T(final_flag[i - 1], i//6)</span><br><span class="line">  return final_flag</span><br><span class="line"></span><br><span class="line"># 将得到的数组进行输出</span><br><span class="line">def print_flag(final_flag):</span><br><span class="line">  for i in range(len(final_flag)):</span><br><span class="line">    for j in range(4):</span><br><span class="line">      print(chr((final_flag[i] &amp; 0xff000000)&gt;&gt;(32-8)),end=&quot;&quot;)</span><br><span class="line">      final_flag[i] = final_flag[i] &lt;&lt; 8</span><br><span class="line">  print()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  DFS(23)</span><br><span class="line">  re_flags = []</span><br><span class="line">  for j in range(len(flags)):</span><br><span class="line">    flag = flags[j]</span><br><span class="line">    tem = []</span><br><span class="line">    # 将每4个8位数组合成 一个16进制的32位数</span><br><span class="line">    for i in range(0, len(flag), 4):</span><br><span class="line">      tem.append(int(</span><br><span class="line">        &quot;0x&quot; + hex(flag[i + 3])[2:].zfill(2) + hex(flag[i + 2])[2:].zfill(2) + hex(flag[i + 1])[2:].zfill(2) + hex(</span><br><span class="line">          flag[i])[2:].zfill(2),16))</span><br><span class="line">    re_flags.append(tem.copy())   # re_flags 里面将24个元素每4个一组转化为一个数</span><br><span class="line"></span><br><span class="line">  # 异或运算的逆向</span><br><span class="line">  final_flag = [0]*66</span><br><span class="line">  re_flags2 = []</span><br><span class="line">  for i in range(len(re_flags)):</span><br><span class="line">    final_flag = [0]*66</span><br><span class="line">    for j in range(6):  #将已知的5个值放入其中</span><br><span class="line">      final_flag[60+j] = re_flags[i][j]</span><br><span class="line">      </span><br><span class="line">    # 利用这5个元素推理出所有的数字</span><br><span class="line">    final_flag = multiple(final_flag)</span><br><span class="line">    tem = []</span><br><span class="line">    for j in range(6):</span><br><span class="line">      tem.append(final_flag[j])</span><br><span class="line">    print(tem)</span><br><span class="line">    re_flags2.append(tem.copy())</span><br><span class="line">  for i in range(len(re_flags2)):</span><br><span class="line">    print_flag(re_flags2[i])</span><br></pre></td></tr></table></figure>

<p>在所有的输出之中找到flag  VNCTF{TimeFlightMachine}</p>
<h4 id="cmgo！"><a href="#cmgo！" class="headerlink" title="cmgo！"></a>cmgo！</h4><p>将这个exe文件拖入ida之中，从函数名称的窗口之中就可以看到这里进行了程序的无符号化，使得函数的名称不能够直观的得到，所以函数的入口难以找到，无符号golang逆向技巧，使用IDAGolangHelper这一脚本，打开脚本文件（文件-脚本文件）找到这个脚本文件夹，选中rename function之后选择go版本,所以将这个exe拖进IDA7.6之中，找到程序入口main.main</p>
<p><img src="/images/VNCTF-2022/image-20220221232254810.png" alt="image-20220221232254810"></p>
<p>找到初始化虚拟机的地方和opcode</p>
<p><img src="/images/VNCTF-2022/image-20220222081345526.png" alt="image-20220222081345526"></p>
<p>第二个函数 mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084558720.png" alt="image-20220222084558720"></p>
<p>第三个函数  mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084616048.png" alt="image-20220222084616048"></p>
<p><img src="/images/VNCTF-2022/image-20220222084743697.png" alt="image-20220222084743697"></p>
<p>第四个函数 mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084926787.png" alt="image-20220222084926787"></p>
<p>第五个函数 push</p>
<p><img src="/images/VNCTF-2022/image-20220222085210002.png" alt="image-20220222085210002"></p>
<p>第六个函数 和push类似的样子</p>
<p><img src="/images/VNCTF-2022/image-20220222085400565.png" alt="image-20220222085400565"></p>
<p>第七个函数 pop</p>
<p><img src="/images/VNCTF-2022/image-20220222085437971.png" alt="image-20220222085437971"></p>
<p>第八个函数 add</p>
<p><img src="/images/VNCTF-2022/image-20220222085652595.png" alt="image-20220222085652595"></p>
<p>第九个函数 sub</p>
<p><img src="/images/VNCTF-2022/image-20220222085733426.png" alt="image-20220222085733426"></p>
<p>第十个函数 div</p>
<p><img src="/images/VNCTF-2022/image-20220222085838161.png" alt="image-20220222085838161"></p>
<p>第十一个函数 mul</p>
<p><img src="/images/VNCTF-2022/image-20220222085928057.png" alt="image-20220222085928057"></p>
<p>第十二个函数 xor</p>
<p><img src="/images/VNCTF-2022/image-20220222090005356.png" alt="image-20220222090005356"></p>
<p>第十三个函数  jmp</p>
<p><img src="/images/VNCTF-2022/image-20220222090054005.png" alt="image-20220222090054005"></p>
<p>第十四个函数 jmp（多了一个判断条件）当等于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090501248.png" alt="image-20220222090501248"></p>
<p>第十五个函数 jnp</p>
<p><img src="/images/VNCTF-2022/image-20220222090557647.png" alt="image-20220222090557647"></p>
<p>第十六个函数 jlp 当小于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090652596.png" alt="image-20220222090652596"></p>
<p>第十七个函数 jhp 当大于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090801331.png" alt="image-20220222090801331"></p>
<p>第十八个函数 scanf</p>
<p><img src="/images/VNCTF-2022/image-20220222091046004.png" alt="image-20220222091046004"></p>
<p>第十九个函数 print</p>
<p><img src="/images/VNCTF-2022/image-20220222091135371.png" alt="image-20220222091135371"></p>
<p>第二十个函数 quit</p>
<p><img src="/images/VNCTF-2022/image-20220222091303160.png" alt="image-20220222091303160"></p>
<p>初始化虚拟机并且载入opcode之后，要运行这个虚拟机，所以查看虚拟机的运行的函数，用流程图的方式查看函数的逻辑，找到逻辑之中的循环，找到其中的关键代码</p>
<p><img src="/images/VNCTF-2022/image-20220222120534330.png" alt="image-20220222120534330"></p>
<p>进行动调得到函数的对应关系，动态调试得到的对应关系,</p>
<p><img src="/images/VNCTF-2022/image-20220223001010055.png" alt="image-20220223001010055"></p>
<p>跟踪到[rbx+rdi*8+1008h]这个里面，通过按D将db的数据转化成dq</p>
<p><img src="/images/VNCTF-2022/image-20220223001105287.png" alt="image-20220223001105287"></p>
<p>通过他们的顺序，就能知道code 和 函数的对应关系</p>
<p>opcode的 0-16对应函数1-17</p>
<p>97 98 99对应函数18 19 20</p>
<p>将opcode得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov r0 0X57</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6C</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X63</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6D</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X74</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X56</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X4E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X43</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X54</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X46</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X30</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X21</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0XA</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X69</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X70</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X75</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X74</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X66</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6C</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X61</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X67</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X3A</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0XA</span><br><span class="line">pushchar(r0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov r19 0X49</span><br><span class="line">mov r3 0X0</span><br><span class="line">mov r1 0X2B</span><br><span class="line">mov r2 0X1</span><br><span class="line">scanf(r0)</span><br><span class="line">push r0</span><br><span class="line">sub r1 r2</span><br><span class="line">if r1 != r3:quit </span><br><span class="line">mov r0 0X0</span><br><span class="line">push r0</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">mov r0 r6</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">mov r0 r6</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">mov r0 r7</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">mov r0 r7</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">mov r0 r8</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">mov r0 r8</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">mov r0 r9</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">mov r0 r9</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">mov r0 r10</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">mov r0 r10</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">mov r0 r11</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">mov r0 r11</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">mov r0 r12</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">mov r0 r12</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100  //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">mov r0 r13</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">mov r0 r13</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">mov r0 r15</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">mov r0 r15</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">mov r0 r16</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">mov r0 r16</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">push r6</span><br><span class="line">push r7</span><br><span class="line">push r8</span><br><span class="line">push r9</span><br><span class="line">push r10</span><br><span class="line">push r11</span><br><span class="line">push r12</span><br><span class="line">push r13</span><br><span class="line">push r14</span><br><span class="line">push r15</span><br><span class="line">push r16</span><br><span class="line">//第一次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X11C</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0XE8D1D5DF</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   // 0XE8D1D5DF 数据的比较</span><br><span class="line">mov r0 0XF5E3C114</span><br><span class="line">if r2 != r0:quit   //  0XF5E3C114</span><br><span class="line">// 第二次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X127</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X228EC216</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit  //  0X228EC216 数据的比较</span><br><span class="line">mov r0 0X89D45A61</span><br><span class="line">if r2 != r0:quit   //  0X89D45A61</span><br><span class="line">// 第三次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X132</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X655B8F69</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit    //  0X655B8F69 数据的比较</span><br><span class="line">mov r0 0X2484A07A</span><br><span class="line">if r2 != r0:quit    //  0X2484A07A</span><br><span class="line">// 第四次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X13D</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0XD9E5E7F8</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   //  0XD9E5E7F8 数据的比较</span><br><span class="line">mov r0 0X3A441532</span><br><span class="line">if r2 != r0:quit   //   0X3A441532</span><br><span class="line">// 第五次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X148</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X91AB7E88</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   // 0X91AB7E88</span><br><span class="line">mov r0 0X69FC64BC</span><br><span class="line">if r2 != r0:quit   //  0X69FC64BC</span><br><span class="line">pop r1</span><br><span class="line">mov r0 0X7D3765</span><br><span class="line">if r1 != r0:quit   //  0X7D3765</span><br><span class="line">mov r0 0X189</span><br><span class="line">jmp r0</span><br><span class="line">quit!</span><br><span class="line"></span><br><span class="line">mov r3 0X9E3779B9  //tea函数开始的地方 delta</span><br><span class="line">mov r4 0X95C4C     //k0</span><br><span class="line">mov r5 0X871D      //k1</span><br><span class="line">mov r6 0X1A7B7     //k2</span><br><span class="line">mov r7 0X12C7C7    //k3</span><br><span class="line">mov r8 0X0</span><br><span class="line">mov r17 0X10  //用于位移的一堆数字</span><br><span class="line">mov r18 0X20</span><br><span class="line">mov r19 0X160</span><br><span class="line">mov r10 0X0</span><br><span class="line">mov r11 0X20</span><br><span class="line">mov r12 0X1</span><br><span class="line">add r8 r3</span><br><span class="line">mov r0 r2</span><br><span class="line">mul r0 r17</span><br><span class="line">add r0 r4</span><br><span class="line">mov r14 r0</span><br><span class="line">mov r0 r2</span><br><span class="line">add r0 r8</span><br><span class="line">mov r15 r0</span><br><span class="line">mov r0 r2</span><br><span class="line">div r0 r18</span><br><span class="line">add r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">xor r0 r15</span><br><span class="line">xor r0 r16</span><br><span class="line">add r1 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">mul r0 r17</span><br><span class="line">add r0 r6</span><br><span class="line">mov r14 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">add r0 r8</span><br><span class="line">mov r15 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">div r0 r18</span><br><span class="line">add r0 r7</span><br><span class="line">mov r16 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">xor r0 r15</span><br><span class="line">xor r0 r16</span><br><span class="line">add r2 r0</span><br><span class="line">sub r11 r12</span><br><span class="line">if r11 != r10:quit </span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">mov r0 0X6E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">mov r0 0X79</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X73</span><br><span class="line">pushchar(r0)</span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">v[2]=&#123;0XE8D1D5DF,0XF5E3C114,0X228EC216,0X89D45A61,0X655B8F69,0X2484A07A,0XD9E5E7F8,0X3A441532,0X91AB7E88,0X69FC64BC,0X7D3765&#125;</span><br></pre></td></tr></table></figure>

<p>网上的TEA的加密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上的TEA的解密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void decrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up; sum is 32*delta */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目之中的TEA解密的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Decrypt(unsigned long* EntryData,unsigned long* Key) &#123;</span><br><span class="line">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br><span class="line">unsigned long x = EntryData[0];</span><br><span class="line">unsigned long y = EntryData[1];</span><br><span class="line"></span><br><span class="line">unsigned long sum = 0xC6EF3720;</span><br><span class="line">unsigned long delta = 0x9E3779B9;</span><br><span class="line">sum = delta &lt;&lt; 5;   //注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.</span><br><span class="line">//总共加密32轮 那么反序也解密32轮</span><br><span class="line">for (int i = 0; i &lt; 32; i++) &#123;</span><br><span class="line">// 先将y解开 然后参与运算在解x</span><br><span class="line">y -= ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);</span><br><span class="line">x -= ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);</span><br><span class="line">sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">//最后加密的结果重新写入到数组中</span><br><span class="line">EntryData[0] = x;</span><br><span class="line">EntryData[1] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">//通过对比元素的代码处将其分为6组，每两个是一组，只有前10个进行了加密的操作</span><br><span class="line">   unsigned long t1[3] = &#123;0XE8D1D5DF,0XF5E3C114,0x0&#125;;</span><br><span class="line">   unsigned long t2[3] = &#123;0X228EC216,0X89D45A61,0x0&#125;;</span><br><span class="line">   unsigned long t3[3] = &#123;0X655B8F69,0X2484A07A,0x0&#125;;</span><br><span class="line">   unsigned long t4[3] = &#123;0XD9E5E7F8,0X3A441532,0x0&#125;;</span><br><span class="line">   unsigned long t5[3] = &#123;0X91AB7E88,0X69FC64BC,0x0&#125;;</span><br><span class="line">   unsigned long t6[2] = &#123;0X7D3765,0x0&#125;;</span><br><span class="line">//printf(&quot;待加密的数值 = %s\r\n&quot;, (char*)Data);</span><br><span class="line"></span><br><span class="line">unsigned long key[4] = &#123; 0X95C4C,0X871D,0X1A7B7,0X12C7C7 &#125;;</span><br><span class="line"></span><br><span class="line">// 分析代码我们可以得到一共加密了5次，所以数组之中只有10个分组进行了加密的操作</span><br><span class="line">Decrypt(t1, key);</span><br><span class="line">Decrypt(t2, key);</span><br><span class="line">Decrypt(t3, key);</span><br><span class="line">Decrypt(t4, key);</span><br><span class="line">Decrypt(t5, key);</span><br><span class="line"></span><br><span class="line">printf(&quot;解密后的数值 = %s%s%s%s%s%s\r\n&quot;, (char*)t1,(char*)t2,(char*)t3,(char*)t4,(char*)t5,(char *)t6);</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">VNCTF&#123;ecd63ae5-8945-4ac4-b5a5-34fc3ade81e7&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>复现</tag>
      </tags>
  </entry>
</search>
