<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022DASCTF_X_SU_StarGate</title>
    <url>/2022/04/05/2022DASCTF-X-SU-StarGate/</url>
    <content><![CDATA[<h2 id="StarGate"><a href="#StarGate" class="headerlink" title="StarGate"></a>StarGate</h2><p>这道题因为自己各种基础知识不牢固的原因写了很久，细节上的知识需要自己不断地积累，也觉得自己写代码太烂了！！！太菜了！！！</p>
<p>使用nc连接靶机，返回得到文件的base64加密内容</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331195957518.png" alt="image-20220331195957518"></p>
<p>提取出这个base64加密的内容，放入<a href="https://www.strerr.com/cn/base64_decode_file.html">在线网站</a>之中bse64解密，得到的是一个elf文件</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331195917666.png" alt="image-20220331195917666"></p>
<p>将这个elf文件放入ida之中，通过字符串定位到关键的代码位置</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331200301470.png" alt="image-20220331200301470"></p>
<h3 id="分析流程（欧拉路径问题）"><a href="#分析流程（欧拉路径问题）" class="headerlink" title="分析流程（欧拉路径问题）"></a>分析流程（欧拉路径问题）</h3><p>题目之中给了提示 “寻找欧拉路径”</p>
<blockquote>
<p>对于一个给定的图，怎样判断是否存在着一个恰好<strong>包含了所有的边</strong>，并且<strong>没有重复的路径</strong>？这就是<strong>一笔画问题</strong>。用图论的术语来说，就是判断这个图是否是一个能够<strong>遍历完所有的边而没有重复</strong>。这样的图现称为<strong>欧拉图</strong>。这时遍历的路径称作<strong>欧拉路径</strong>（一个环或者一条链），如果路径闭合（一个圈），则称为<strong>欧拉回路</strong></p>
</blockquote>
<p>通过catflag这个字符串定位到一个相关联的函数</p>
<p>if语句之中的判断条件是判断走过了所有的路径，每个变量参数代表的是某路径是否走过的标志位</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331201621712.png" alt="image-20220331201621712"></p>
<p>查看字符串表，图中红色方框中的字符串就能够定位到一个函数之中，每个函数之中的逻辑都一样</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331202132905.png" alt="image-20220331202132905"></p>
<p>字符串定位到的函数：每次输入一个字符串，相当于到达某一个对应的函数，跳转就是一条边，每条边的表示方法是dword_41D1C这样的形式 </p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331202356711.png" alt="image-20220331202356711"></p>
<p>走过所有的边，最后catflag的函数：</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220331202805308.png" alt="image-20220331202805308"></p>
<p>所以这个就是一个一笔画问题</p>
<p>因为这是一个图的问题，从代码之中提取出边对应的字符串的表示方法和它对应调用的函数，对应的函数之中又有和这条边相连的能够走的路径，我们要dump出所有的边，并且给按照代码将这些边连接起来生成一个图，再将这个图作为参数传入欧拉路径的算法之中，得到走的路径，按照这个路径再向这个靶机之中传入得到的路径</p>
<p>re模块的常量(属性)</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220401205707835.png" alt="image-20220401205707835"></p>
<h3 id="连接服务器得到elf文件"><a href="#连接服务器得到elf文件" class="headerlink" title="连接服务器得到elf文件"></a>连接服务器得到elf文件</h3><p>用pwn连接服务器，将服务器返回的进行base64加密的elf文件进行解密，并且保存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获得连接服务器得到的脚本</span><br><span class="line">from pwn import *</span><br><span class="line">import base64</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = remote(&quot;node4.buuoj.cn&quot;,25305)</span><br><span class="line">io.recvuntil(&#x27;Gate&#x27;)</span><br><span class="line">code = io.recvuntil(&#x27;==end==&#x27;)</span><br><span class="line">with open(&quot;code&quot;,&quot;wb&quot;) as f:</span><br><span class="line">    f.write(base64.b64decode(code[:-8]))</span><br></pre></td></tr></table></figure>

<h3 id="ida反编译得到c语言文件"><a href="#ida反编译得到c语言文件" class="headerlink" title="ida反编译得到c语言文件"></a>ida反编译得到c语言文件</h3><p>将elf文件放入ida64之中（使用ida64的7.5版本），然后使用File-&gt;Produce File-&gt;Creat C File将反编译的c语言代码dump下来</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220405221614550.png" alt="image-20220405221614550"> </p>
<h3 id="图的生成"><a href="#图的生成" class="headerlink" title="图的生成"></a>图的生成</h3><p>正则搜索code.c文件之中的代码，得到相对应的图（点和点的对应关系）,并将其写入graph.txt文件之中</p>
<p>生成图的方法：</p>
<ul>
<li><p>使用正则表达式搜索到所有具有如下if语句的函数，每个这样的函数将是数组之中的一个元素</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220405223108571.png" alt="image-20220405223108571"></p>
</li>
<li><p>将所有这些函数名集合成一个数组，这个数组就是所有的点</p>
</li>
<li><p>这些函数名跳转到另外一个函数就作为一个边（每个函数名也就是每个点都会有一个对应的字符串），遍历每个函数就能够得到所有的这些边，需要注意的是因为是无向图，同一条边会被表示两次</p>
</li>
<li><p>将数组之中这些函数的索引作为每个点的表示（因为c语言脚本之宗数组的起点是1，所以所有的索引需要加一之后写入）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;code.c&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:   <span class="comment"># 因为后面要用正则匹配的是字符串文本，所以读取的方式不能使用rb，要使用r</span></span><br><span class="line">    codes = f.read()</span><br><span class="line"><span class="comment"># 下面的两个数组字符串和调用的函数关系都是对应的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得字符串（边）</span></span><br><span class="line">passwords = re.findall(<span class="string">&#x27;if \( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 \)&#x27;</span>,codes)   <span class="comment"># 按照顺序提取出来的passwords if ( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 )    !strcmp\(&quot;(.*?)&quot;, s2\)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(passwords))</span><br><span class="line"><span class="comment"># 当前函数（点）经过该字符串（边）到达的函数</span></span><br><span class="line">funcnames_pass = re.findall(<span class="string">&quot;(sub_[0123456789ABCDEF]&#123;6&#125;\(\));\n    exit\(0\);&quot;</span>,codes)   <span class="comment"># 和上面的password具有对应关系的函数名</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(funcnames_pass))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取出所有的选择的函数的所有内容</span></span><br><span class="line">functions = re.findall(<span class="string">&quot;__int64 sub_[0123456789ABCDEF]&#123;6&#125;\(\)\n&#123;\n  char s2\[40\];.*?Wrong password&quot;</span>,codes,re.DOTALL)  <span class="comment"># .*?Wrong password</span></span><br><span class="line"><span class="comment"># 从所有的函数之中提取出来该函数（点）能够到达的函数（点） 用funcnames的index表示每个点</span></span><br><span class="line">funcnames = []</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> functions:</span><br><span class="line">    funcname = re.findall(<span class="string">&quot;__int64 (sub_[0123456789ABCDEF]&#123;6&#125;\(\))&quot;</span>,obj)[<span class="number">0</span>]</span><br><span class="line">    funcnames.append(funcname)</span><br><span class="line"><span class="built_in">print</span>(funcnames)</span><br><span class="line"><span class="comment"># 字典 保存每个函数之中子函数和字符串相应的对应关系的数据</span></span><br><span class="line">dic_child_func = &#123;&#125;</span><br><span class="line">dic_child_str = &#123;&#125;</span><br><span class="line"><span class="comment"># 使用二维数组表示这个图</span></span><br><span class="line">graph = []</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> functions:</span><br><span class="line">    funcname = re.findall(<span class="string">&quot;__int64 (sub_[0123456789ABCDEF]&#123;6&#125;\(\))&quot;</span>,obj)[<span class="number">0</span>]</span><br><span class="line">    child_funcnames = re.findall(<span class="string">&quot;(sub_[0123456789ABCDEF]&#123;6&#125;\(\));\n    exit\(0\);&quot;</span>,obj)</span><br><span class="line">    child_str = re.findall(<span class="string">&#x27;if \( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 \)&#x27;</span>,obj)</span><br><span class="line">    <span class="comment"># print(child_str)</span></span><br><span class="line">    <span class="comment"># print(child_funcnames)</span></span><br><span class="line">    dic_child_func[funcname] = child_funcnames</span><br><span class="line">    dic_child_str[funcname] = child_str</span><br><span class="line">    <span class="keyword">for</span> obj0 <span class="keyword">in</span> child_funcnames:</span><br><span class="line">        tem = []</span><br><span class="line">        tem.append(funcnames.index(funcname)) <span class="comment"># 获得当前函数的索引</span></span><br><span class="line">        tem.append(funcnames.index(obj0))  <span class="comment"># 获取当前函数能够到达的下一个点的索引</span></span><br><span class="line">        graph.append(tem)</span><br><span class="line"><span class="built_in">print</span>(graph)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(graph))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;graph.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 总边数的两倍 总的节点的个数</span></span><br><span class="line">    f.write(<span class="built_in">str</span>(<span class="built_in">len</span>(graph))+<span class="string">&quot;  &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(funcnames)))</span><br><span class="line">    f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">        f.write(<span class="built_in">str</span>(graph[i][<span class="number">0</span>]+<span class="number">1</span>)+<span class="string">&quot;  &quot;</span>+<span class="built_in">str</span>(graph[i][<span class="number">1</span>]+<span class="number">1</span>))</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="欧拉路径算法（fleury算法）"><a href="#欧拉路径算法（fleury算法）" class="headerlink" title="欧拉路径算法（fleury算法）"></a>欧拉路径算法（fleury算法）</h3><p>用c语言读取graph.txt之中点的对应关系，初始化图，得到对应的数组，然后找出欧拉路径，将欧拉路径写入到map.txt文件之中</p>
<p>注意，因为刻画出来的无向图之中，一条边被表示了两次，所以在初始化数组的时候，需要判断一下该条边是否被赋值过，如果已经被赋值了，就不用再次赋值了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> n, m, flag, top, sum, du[N], ans[<span class="number">5005</span>], <span class="built_in">map</span>[N][N];</span><br><span class="line">FILE* fpwrite;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    ans[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[x][i]--;</span><br><span class="line">            <span class="built_in">map</span>[i][x]--;</span><br><span class="line">            dfs(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fleury</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    top = <span class="number">1</span>;</span><br><span class="line">    ans[top] = x;</span><br><span class="line">    <span class="keyword">while</span>(top &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//判断是否可扩展</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[ans[top]][i] &gt;= <span class="number">1</span>)<span class="comment">//若存在一条从ans[top]出发的边  那么就是可扩展</span></span><br><span class="line">            &#123;k = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)<span class="comment">//该点x没有其他的边可以先走了（即不可扩展）， 那么就输出它</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            printf(&quot;%d &quot;, ans[top]);</span></span><br><span class="line">        <span class="built_in">fprintf</span>(fpwrite,<span class="string">&quot;%d&quot;</span>,ans[top]);</span><br><span class="line">        <span class="built_in">fprintf</span>(fpwrite,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">1</span>)<span class="comment">//如可扩展， 则dfs可扩展的哪条路线</span></span><br><span class="line">        &#123;</span><br><span class="line">            top--;<span class="comment">//这需要注意</span></span><br><span class="line">            dfs(ans[top+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* fpread;</span><br><span class="line">    fpread = fopen(<span class="string">&quot;D:\\re\\buuctf\\practice\\1\\graph.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);  <span class="comment">//D:\\re\\buuctf\\practice\\1\\graph</span></span><br><span class="line">    fpwrite = fopen(<span class="string">&quot;D:\\re\\buuctf\\practice\\1\\map.txt&quot;</span>,<span class="string">&quot;w&quot;</span>); <span class="comment">//向其中写入路径的文本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fpread == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file is error!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(fpread,<span class="string">&quot;%d&quot;</span>,&amp;m);  <span class="comment">//得到边的条数两倍</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fpread,<span class="string">&quot;%d&quot;</span>,&amp;n);  <span class="comment">// 得到总的节点个数</span></span><br><span class="line">    <span class="built_in">memset</span>(du, <span class="number">0</span>, <span class="keyword">sizeof</span>(du));</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            <span class="built_in">fscanf</span>(fpread,<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">map</span>[x][y]++; <span class="comment">//记录边， 因为是无向图所以加两条边， 两个点之间可能有多条边</span></span><br><span class="line">            <span class="built_in">map</span>[y][x]++;</span><br><span class="line">            du[x]++;</span><br><span class="line">            du[y]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">1</span>; <span class="comment">// flag标记开始点。 如果所有点度数全为偶数那就从1开始搜</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(du[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                flag = i;<span class="comment">// 若有奇数边， 从奇数边开始搜</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span> || sum == <span class="number">2</span>)</span><br><span class="line">            fleury(flag);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Success！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="用于交互的字符串数组"><a href="#用于交互的字符串数组" class="headerlink" title="用于交互的字符串数组"></a>用于交互的字符串数组</h3><ul>
<li><p>得到的索引需要减一</p>
</li>
<li><p>用python读取整个欧拉路径，得到走这个欧拉路径需要的输入的字符串，再和服务器进行相应的交互，注意的是，得到的欧拉路径可能顺序可能需要颠倒一下（可以根据最后需要到达的函数所需要的字符串来判断是否需要颠倒）</p>
</li>
</ul>
<p>（图中表示的那个函数是输出cat flag的函数，图中标注的字符串是我们需要到达的字符串）</p>
<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220405222345489.png" alt="image-20220405222345489"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">theMap = []  <span class="comment"># 用数字表示的路径</span></span><br><span class="line">theStrmap = []  <span class="comment"># 用字符串表示的路径</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;map.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        theMap.append(<span class="built_in">int</span>(line.strip(<span class="string">&#x27;\n&#x27;</span>))-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(theMap))</span><br><span class="line">theFistFunc = funcnames[theMap[<span class="number">0</span>]]  <span class="comment"># 获得第一个函数的名称</span></span><br><span class="line">theFistFuncStr = passwords[funcnames_pass.index(theFistFunc)] <span class="comment"># 用第一个函数的名称找到函数数组里面的index 然后找到对应的str</span></span><br><span class="line">theStrmap.append(theFistFuncStr)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theMap)-<span class="number">1</span>):</span><br><span class="line">    theFucName = funcnames[theMap[i]]</span><br><span class="line">    theNextFuncName = funcnames[theMap[i+<span class="number">1</span>]]</span><br><span class="line">    theIndex = dic_child_func[theFucName].index(theNextFuncName)</span><br><span class="line">    theStrmap.append(dic_child_str[theFucName][theIndex])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(theStrmap))</span><br><span class="line"><span class="comment"># 查看第一步所到达的函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一步所到达的函数的字符串：&quot;</span>+theFistFuncStr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;到达最后一步函数输入的字符串：&quot;</span>+theStrmap[<span class="built_in">len</span>(theStrmap)-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 代码之中搜查到的最后的一个字符串</span></span><br><span class="line">theCodeFinalStr = re.findall(<span class="string">&quot;  v2 = __readfsqword\(0x28u\);\n  if \( !dword_[0123456789ABCDEF]&#123;6&#125;\n.*?printf\(\&quot;Now you in universe ([a-zA-Z]&#123;1,&#125;)&quot;</span>,codes,re.DOTALL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;是否需要颠倒一下顺序:1.是 2.否&quot;)</span></span><br><span class="line"><span class="comment"># choose = 2</span></span><br><span class="line"><span class="comment"># choose=int(input(&quot;请输入你的选择:&quot;))</span></span><br><span class="line"><span class="comment"># if choose == 1:</span></span><br><span class="line"><span class="comment">#     theStrmap.reverse()</span></span><br><span class="line"><span class="comment"># 如果最后到达的字符串出现在第一步，说明顺序反了，需要颠倒一下</span></span><br><span class="line"><span class="keyword">if</span> theFistFuncStr == theCodeFinalStr:</span><br><span class="line">    theStrmap.reverse()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theStrmap)):</span><br><span class="line">    io.sendline(theStrmap[i])</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># 使用pwn进行服务器的交互</span></span><br></pre></td></tr></table></figure>

<h3 id="脚本汇总"><a href="#脚本汇总" class="headerlink" title="脚本汇总"></a>脚本汇总</h3><p>python的脚本代码(汇总)：需要按照需求在相应的位置停顿</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获得连接服务器得到的脚本</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25305</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Gate&#x27;</span>)</span><br><span class="line">code = io.recvuntil(<span class="string">&#x27;==end==&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;code&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(base64.b64decode(code[:-<span class="number">8</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;请先dump出code.c 之后想要继续请按回车&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;code.c&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:   <span class="comment"># 因为后面要用正则匹配的是字符串文本，所以读取的方式不能使用rb，要使用r</span></span><br><span class="line">    codes = f.read()</span><br><span class="line"><span class="comment"># 下面的两个数组字符串和调用的函数关系都是对应的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得字符串（边）</span></span><br><span class="line">passwords = re.findall(<span class="string">&#x27;if \( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 \)&#x27;</span>,codes)   <span class="comment"># 按照顺序提取出来的passwords if ( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 )    !strcmp\(&quot;(.*?)&quot;, s2\)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(passwords))</span><br><span class="line"><span class="comment"># 当前函数（点）经过该字符串（边）到达的函数</span></span><br><span class="line">funcnames_pass = re.findall(<span class="string">&quot;(sub_[0123456789ABCDEF]&#123;6&#125;\(\));\n    exit\(0\);&quot;</span>,codes)   <span class="comment"># 和上面的password具有对应关系的函数名</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(funcnames_pass))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取出所有的选择的函数的所有内容</span></span><br><span class="line">functions = re.findall(<span class="string">&quot;__int64 sub_[0123456789ABCDEF]&#123;6&#125;\(\)\n&#123;\n  char s2\[40\];.*?Wrong password&quot;</span>,codes,re.DOTALL)  <span class="comment"># .*?Wrong password</span></span><br><span class="line"><span class="comment"># 从所有的函数之中提取出来该函数（点）能够到达的函数（点） 用funcnames的index表示每个点</span></span><br><span class="line">funcnames = []</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> functions:</span><br><span class="line">    funcname = re.findall(<span class="string">&quot;__int64 (sub_[0123456789ABCDEF]&#123;6&#125;\(\))&quot;</span>,obj)[<span class="number">0</span>]</span><br><span class="line">    funcnames.append(funcname)</span><br><span class="line"><span class="built_in">print</span>(funcnames)</span><br><span class="line"><span class="comment"># 字典 保存每个函数之中子函数和字符串相应的对应关系的数据</span></span><br><span class="line">dic_child_func = &#123;&#125;</span><br><span class="line">dic_child_str = &#123;&#125;</span><br><span class="line"><span class="comment"># 使用二维数组表示这个图</span></span><br><span class="line">graph = []</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> functions:</span><br><span class="line">    funcname = re.findall(<span class="string">&quot;__int64 (sub_[0123456789ABCDEF]&#123;6&#125;\(\))&quot;</span>,obj)[<span class="number">0</span>]</span><br><span class="line">    child_funcnames = re.findall(<span class="string">&quot;(sub_[0123456789ABCDEF]&#123;6&#125;\(\));\n    exit\(0\);&quot;</span>,obj)</span><br><span class="line">    child_str = re.findall(<span class="string">&#x27;if \( !strcmp\(&quot;(.*?)&quot;, s2\) &amp;&amp; dword_[0123456789ABCDEF]&#123;6&#125; == 1 \)&#x27;</span>,obj)</span><br><span class="line">    <span class="comment"># print(child_str)</span></span><br><span class="line">    <span class="comment"># print(child_funcnames)</span></span><br><span class="line">    dic_child_func[funcname] = child_funcnames</span><br><span class="line">    dic_child_str[funcname] = child_str</span><br><span class="line">    <span class="keyword">for</span> obj0 <span class="keyword">in</span> child_funcnames:</span><br><span class="line">        tem = []</span><br><span class="line">        tem.append(funcnames.index(funcname)) <span class="comment"># 获得当前函数的索引</span></span><br><span class="line">        tem.append(funcnames.index(obj0))  <span class="comment"># 获取当前函数能够到达的下一个点的索引</span></span><br><span class="line">        graph.append(tem)</span><br><span class="line"><span class="built_in">print</span>(graph)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(graph))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;graph.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 总边数的两倍 总的节点的个数</span></span><br><span class="line">    f.write(<span class="built_in">str</span>(<span class="built_in">len</span>(graph))+<span class="string">&quot;  &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(funcnames)))</span><br><span class="line">    f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">        f.write(<span class="built_in">str</span>(graph[i][<span class="number">0</span>]+<span class="number">1</span>)+<span class="string">&quot;  &quot;</span>+<span class="built_in">str</span>(graph[i][<span class="number">1</span>]+<span class="number">1</span>))</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个地方等待输入，等c语言脚本运行完之后再接着运行</span></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;请先执行c语言代码，之后继续请按回车&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">theMap = []  <span class="comment"># 用数字表示的路径</span></span><br><span class="line">theStrmap = []  <span class="comment"># 用字符串表示的路径</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;map.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        theMap.append(<span class="built_in">int</span>(line.strip(<span class="string">&#x27;\n&#x27;</span>))-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(theMap))</span><br><span class="line">theFistFunc = funcnames[theMap[<span class="number">0</span>]]  <span class="comment"># 获得第一个函数的名称</span></span><br><span class="line">theFistFuncStr = passwords[funcnames_pass.index(theFistFunc)] <span class="comment"># 用第一个函数的名称找到函数数组里面的index 然后找到对应的str</span></span><br><span class="line">theStrmap.append(theFistFuncStr)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theMap)-<span class="number">1</span>):</span><br><span class="line">    theFucName = funcnames[theMap[i]]</span><br><span class="line">    theNextFuncName = funcnames[theMap[i+<span class="number">1</span>]]</span><br><span class="line">    theIndex = dic_child_func[theFucName].index(theNextFuncName)</span><br><span class="line">    theStrmap.append(dic_child_str[theFucName][theIndex])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(theStrmap))</span><br><span class="line"><span class="comment"># 查看第一步所到达的函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一步所到达的函数的字符串：&quot;</span>+theFistFuncStr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;到达最后一步函数输入的字符串：&quot;</span>+theStrmap[<span class="built_in">len</span>(theStrmap)-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 代码之中搜查到的最后的一个字符串</span></span><br><span class="line">theCodeFinalStr = re.findall(<span class="string">&quot;  v2 = __readfsqword\(0x28u\);\n  if \( !dword_[0123456789ABCDEF]&#123;6&#125;\n.*?printf\(\&quot;Now you in universe ([a-zA-Z]&#123;1,&#125;)&quot;</span>,codes,re.DOTALL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;是否需要颠倒一下顺序:1.是 2.否&quot;)</span></span><br><span class="line"><span class="comment"># choose = 2</span></span><br><span class="line"><span class="comment"># choose=int(input(&quot;请输入你的选择:&quot;))</span></span><br><span class="line"><span class="comment"># if choose == 1:</span></span><br><span class="line"><span class="comment">#     theStrmap.reverse()</span></span><br><span class="line"><span class="comment"># 如果最后到达的字符串出现在第一步，说明顺序反了，需要颠倒一下</span></span><br><span class="line"><span class="keyword">if</span> theFistFuncStr == theCodeFinalStr:</span><br><span class="line">    theStrmap.reverse()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theStrmap)):</span><br><span class="line">    io.sendline(theStrmap[i])</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># 使用pwn进行服务器的交互</span></span><br><span class="line">flag&#123;76efc0a7-eba1-4b83-a6d7-dce9cf17f4bd&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/2022DASCTF-X-SU-StarGate/image-20220405222805883.png" alt="image-20220405222805883"></p>
]]></content>
      <tags>
        <tag>复现</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF的Dig the way - 栈溢出</title>
    <url>/2022/02/27/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h2 id="BUUCTF的Dig-the-way-栈溢出"><a href="#BUUCTF的Dig-the-way-栈溢出" class="headerlink" title="BUUCTF的Dig the way - 栈溢出"></a>BUUCTF的Dig the way - 栈溢出</h2><p>这是一道栈溢出的题目</p>
<p>进入到主函数里面</p>
<p>首先就是读取data之中数据的代码</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227123156345.png" alt="image-20220227123156345"></p>
<p>通过代码我们可以知道这个地方并没有对数据的写入长度进行限制</p>
<h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><p>fseek()函数可以移动文件的读写指针到指定的位置，即移动当前文件的位置指针，其原型为：<br>  int fseek(FILE * stream, long offset, int fromwhere);</p>
<p>【参数】stream为文件指针，offset为偏移量，fromwhere为指针的起始位置。</p>
<p>参数 offset 为根据参数 fromwhere 来移动读写位置的位移数。参数 fromwhere 为下列其中一种：</p>
<ul>
<li>SEEK_SET：从距文件开头 offset 位移量为新的读写位置；</li>
<li>SEEK_CUR：以目前的读写位置往后增加 offset 个位移量；</li>
<li>SEEK_END：将读写位置指向文件尾后再增加 offset 个位移量。</li>
</ul>
<p>例子：</p>
<ul>
<li>将读写位置移动到文件开头：fseek(fp, 0, SEEK_SET);</li>
<li>将读写位置移动到文件尾时：fseek(fp, 0, SEEK_END);</li>
<li>将读写位置动到离文件开头100字节处：fseek(fp,100L, SEEK_SET);</li>
<li>将读写指针移动到离文件当前位置100字节处：fseek(fp,100L, SEEK_CUR);</li>
<li>将读写指针退回到离文件结尾100字节处：fseek(fp, -100L, SEEK_END);</li>
</ul>
<h4 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h4><p>用 法: <code>long ftell(FILE *fp);</code><br>描 述: 返回当前文件指针位置。这个位置是当前文件指针相对于文件开头的位移量。<br>返回值:返回文件指针的位置，若出错则返回-1L。<br>参数：文件指针。</p>
<h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><p>用 法: size_t fread( void *buffer, size_t size, size_t count, FILE *stream ) ;<br>描 述: fread()用来从文件流中读取数据。参数stream为已打开的文件指针，参数buffer指向欲存放读取进来的数据空间，读取的字节数以参数size * count来决定。<br>返回值: 返回实际读取到的count数目，如果此值比参数count来得小，则代表可能读到了文件尾了或者有错误发生(前者几率大)，这时必须用feof()或ferror()来决定发生什么情况。<br>参数：</p>
<p>buffer ：读取的数据存放的内存的指针（可以是数组，也可以是新开辟的空间，buffer就是一个索引）；<br>size ： 每次读取的字节数 ；<br>count ：读取次数 ；<br>strean：要读取的文件的指针；</p>
<h4 id="三个函数的解析"><a href="#三个函数的解析" class="headerlink" title="三个函数的解析"></a>三个函数的解析</h4><h5 id="func0"><a href="#func0" class="headerlink" title="func0"></a>func0</h5><p>交换栈中的两个数据</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113310818.png" alt="image-20220227113300364"></p>
<h5 id="func1"><a href="#func1" class="headerlink" title="func1"></a>func1</h5><p>这个函数的返回值小于等于2</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113437073.png" alt="image-20220227113437073"></p>
<h5 id="func2"><a href="#func2" class="headerlink" title="func2"></a>func2</h5><p>这个函数的返回值大于等于2</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113508616.png" alt="image-20220227113508616"></p>
<p>现在我们需要使v11等于0 ，程序之中给v11赋值的是func2函数，但是该函数的返回值一定是大于等于2的，显示不可能实现v11= 0</p>
<p>但是在上面的三个函数之中我们可以看到func1的返回值能够等于0 ，所以需要使用func0这个函数调换栈中func1和func2这两个函数的位置</p>
<h4 id="交换func1函数和func0函数位置"><a href="#交换func1函数和func0函数位置" class="headerlink" title="交换func1函数和func0函数位置"></a>交换func1函数和func0函数位置</h4><p>运行func0函数时，传入的参数v12和v13是初始值，我们只需将表示func1地址的v15 和 表示func2地址的v16交换</p>
<p>v15的地址是 v8+4*7    v16的地址是v8+4*8 所以需要将v12 和 v13的值设为7 和 8 ；</p>
<p>按道理来说7和8的顺序没有关系，但是实际操作发现7和8的赋值顺序不一样，得到的flag是不一样的，只有把v12 = 7和 v13 = 8才可以得到正确的flag</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227122635003.png" alt="image-20220227122635003"></p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227122638492.png" alt="image-20220227122638492"></p>
<h4 id="使得func1的返回值为0"><a href="#使得func1的返回值为0" class="headerlink" title="使得func1的返回值为0"></a>使得func1的返回值为0</h4><p>运行func2时 v12=2  v13=3 ，所以函数之中进行运算的两个数字是v10和v11，v10的值是2 ，若想要这个函数的返回值是0，需要将v10置为-1 即0xffffffff</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227123021830.png" alt="image-20220227123021830"></p>
<h4 id="data文件的构造"><a href="#data文件的构造" class="headerlink" title="data文件的构造"></a>data文件的构造</h4><p>data数据传入的首地址是v7，因为没有设置传入数据的长度，所以可以传入无限制大小的数据，多出来的部分会对后面的数据进行覆盖，v7的长度是20 ，v10的位置是 20+2*4 = 28  v11的位置是 20+3*4=32  v12的位置是 20+4*4=36 v13的位置是 20+5*4=40 总的数据长度是44</p>
<p>用010构造数据，并且保存为data，和exe文件放到同一目录之下，运行程序</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227130028183.png" alt="image-20220227130028183"></p>
<p>运行的结果：</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227130059588.png" alt="image-20220227130059588"></p>
<p>所以得到的flag是</p>
<p>flag{8cda1bdb68a72a392a3968a71bdb8cda}</p>
<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。</p>
<p>实现栈溢出，要满足两个条件。第一，程序要有向栈内写入数据的行为；第二，程序并不限制写入数据的长度。如果想用栈溢出来执行攻击指令，就要在溢出数据内包含攻击指令的内容或地址，并且要将程序控制权交给该指令。攻击指令可以是自定义的指令片段，也可以利用系统内已有的函数及指令。</p>
</blockquote>
<h3 id="函数状态主要涉及三个寄存器-–-esp，ebp，eip"><a href="#函数状态主要涉及三个寄存器-–-esp，ebp，eip" class="headerlink" title="函数状态主要涉及三个寄存器 – esp，ebp，eip"></a>函数状态主要涉及三个寄存器 – esp，ebp，eip</h3><ul>
<li><p><code>esp</code>用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化</p>
</li>
<li><p><code>ebp</code>用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p>
</li>
<li><p><code>eip</code> 用来存储即将执行的程序指令的地址，cpu依照 eip的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p>
<p>使用这三个寄存器实现 将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。</p>
</li>
</ul>
<h3 id="栈溢出攻击"><a href="#栈溢出攻击" class="headerlink" title="栈溢出攻击"></a>栈溢出攻击</h3><blockquote>
<p>当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是<br>eip。所以我们的目标就是让 eip 载入攻击指令的地址。 首先，在退栈过程中，返回地址会被传给<br>eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。</p>
</blockquote>
<p>四种方法归类：</p>
<p>1.修改返回地址，让其指向溢出数据中的一段指令（shellcode） </p>
<p>2.修改返回地址，让其指向内存中已有的某个函数（return2libc）</p>
<p> 3.修改返回地址，让其指向内存中已有的一段指令（ROP） </p>
<p>4.修改某个被调用函数的地址，让其指向另一个函数（hijack GOT）</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227134449755.png" alt="image-20220227134449755"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>32位x86架构下的通用寄存器包括一般寄存器（eax、ebx、ecx、edx），索引寄存器（esi、edi），以及堆栈指针寄存器（esp、ebp）</p>
<ul>
<li><p>eax被称为累加寄存器（Accumulator），用以进行算数运算和返回函数结果等。</p>
</li>
<li><p>ebx被称为基址寄存器（Base），在内存寻址时（比如数组运算）用以存放基地址。</p>
</li>
<li><p>ecx被称为记数寄存器（Counter），用以在循环过程中记数。</p>
</li>
<li><p>edx 被称为数据寄存器（Data），常配合 eax 一起存放运算结果等数据。</p>
</li>
<li><p>esi 指向要处理的数据地址（Source Index）</p>
</li>
<li><p>edi指向存放处理结果的数据地址（Destination Index）</p>
</li>
</ul>
<p>参考文章： <a href="https://blog.csdn.net/weixin_43092232/article/details/96902468">https://blog.csdn.net/weixin_43092232/article/details/96902468</a></p>
]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>AntCTF &amp; Dˆ3CTF 2022（d3arm+d3w0w）</title>
    <url>/2022/03/10/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/</url>
    <content><![CDATA[<h1 id="AntCTF-amp-Dˆ3CTF-2022（d3arm-d3w0w）"><a href="#AntCTF-amp-Dˆ3CTF-2022（d3arm-d3w0w）" class="headerlink" title="AntCTF &amp; Dˆ3CTF 2022（d3arm+d3w0w）"></a>AntCTF &amp; Dˆ3CTF 2022（d3arm+d3w0w）</h1><h2 id="d3arm"><a href="#d3arm" class="headerlink" title="d3arm"></a>d3arm</h2><p>得到了一个bin的文件，如果想要得到代码需要将这个bin文件转化成hex文件，使用bintohex这个软件，得到hex文件，然后将这个hex文件载入到ida之中，将hex文件载入ida的时候需要设置一些参数，这个过程可以参考<a href="https://blog.csdn.net/daidi1989/article/details/86304843">这篇文章</a></p>
<p>将这个hex文件载入ida之中之后，查看字符串，根据图中标记的字符串跟进到关键代码的位置</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308212419039.png" alt="image-20220308212419039"></p>
<h3 id="关键主代码"><a href="#关键主代码" class="headerlink" title="关键主代码"></a>关键主代码</h3><p>图中标记的地方就是可能是flag的地方</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308212548857.png" alt="image-20220308212548857"></p>
<h3 id="引用了flag的函数"><a href="#引用了flag的函数" class="headerlink" title="引用了flag的函数"></a>引用了flag的函数</h3><p>在这个函数里面不能够得到什么数值的有效信息，所以查看引用该函数的其它函数，但是这里通过交叉函数我并不能找到有效的函数，翻看这个函数上下的函数，找到一个<strong>引用了point和flag地址的一个函数，将point作为下标，给flag进行赋值的操作</strong></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308214809866.png" alt="image-20220308214809866"></p>
<p>通过<strong>地址0x800DB64</strong>，在汇编代码的界面之宗，点击G 输入跳转到0x000DB64这个地址，就可以找到这个数组了</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308215223252.png" alt="image-20220308215223252"></p>
<p>这个数组是（上图之中只是部分的数据，一共要取42个数字）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x20,0x6d,0x50,0x30,0x38,0x48,0x20,0x6d,0x5,0x26,0x6d,0x56,0x72,0x6d,0x51,0x22,0x6c,0x4,0x70,0x38,0x0,0x26,0x6a,0x57,0x27,0x6a,0x57,0x74,0x6b,0xa,0x27,0x38,0x1,0x75,0x6a,0x5,0x27,0x68,0x3,0x26,0x3a,0x4e]</span><br></pre></td></tr></table></figure>

<h3 id="异或的对象MEMORY-0x20002314"><a href="#异或的对象MEMORY-0x20002314" class="headerlink" title="异或的对象MEMORY[0x20002314]"></a>异或的对象MEMORY[0x20002314]</h3><p>但是现在还不知道这个数组异或的对象MEMORY[0x20002314]的内容</p>
<p>找到和这个地址的数相关的函数，这个函数有对这个地址赋值的操作，其中的MEMORY[0x20002314] = 0x335E44u &gt;&gt; (8 * v1 &amp; 0xF8)这个式子中的v1来自于 MEMORY[0x2000326C] % 3，MEMORY[0x2000326C]和上一个函数相得知是数组的下标，异或的对象有3种0x44、0x5E、0x33,根据MEMORY[0x2000326C] % 3的结果作为下标来决定异或的对象</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308220048764.png" alt="image-20220308220048764"></p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [0x20,0x6d,0x50,0x30,0x38,0x48,0x20,0x6d,0x5,0x26,0x6d,0x56,0x72,0x6d,0x51,0x22,0x6c,0x4,0x70,0x38,0x0,0x26,0x6a,0x57,0x27,0x6a,0x57,0x74,0x6b,0xa,0x27,0x38,0x1,0x75,0x6a,0x5,0x27,0x68,0x3,0x26,0x3a,0x4e]</span><br><span class="line">key = 0x335E44</span><br><span class="line">for i in range(len(obj)):</span><br><span class="line">  temkey = (key&gt;&gt;((i%3)*8)) &amp; 0xff</span><br><span class="line">  print(chr(temkey^obj[i]),end=&#x27;&#x27;)</span><br><span class="line">d3ctf&#123;d36b3e63bf274f3b4dc4d059cf2146c60bd&#125;</span><br></pre></td></tr></table></figure>

<p>d3ctf{d36b3e63bf274f3b4dc4d059cf2146c60bd}</p>
<h2 id="d3w0w"><a href="#d3w0w" class="headerlink" title="d3w0w"></a>d3w0w</h2><p>使用32位的ida打开这个程序，通过程序之中的字符串定位到关键的代码</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309090157805.png" alt="image-20220309090157805"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309090254186.png" alt="image-20220309090254186"></p>
<p>分析代码显然我们需要使得这两个函数都能够返回0，这里我们得到的v3的结果就是0</p>
<h3 id="第一个函数-sub-401000-amp-v1-amp-unk-4262F8"><a href="#第一个函数-sub-401000-amp-v1-amp-unk-4262F8" class="headerlink" title="第一个函数 sub_401000(&amp;v1, &amp;unk_4262F8)"></a>第一个函数 sub_401000(&amp;v1, &amp;unk_4262F8)</h3><p>第一个函数 sub_401000(&amp;v1, &amp;unk_4262F8) 其中的v1代表我们输入的flag的值，这个flag里面有四种char 1，2，3，4，利用这个flag的字符串用走迷宫的形式给这个数组赋值</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309091251377.png" alt="image-20220309091251377"></p>
<h3 id="32位程序调用64位函数："><a href="#32位程序调用64位函数：" class="headerlink" title="32位程序调用64位函数："></a><a href="https://www.anquanke.com/post/id/171111">32位程序调用64位函数</a>：</h3><p>rewolf-wow64ext的目的就是让运行在Wow64环境中的x86应用程序可以直接调用x64下ntdll.dll中的Native API。</p>
<p> 进程的32位模式改为64位模式的具体代码：</p>
<p>主要方法是 借助retf将<strong>CS寄存器的值</strong>设置为<strong>0x33</strong>。</p>
<p>为什么要将CS寄存器的值设置为0x33？因为我们所需CPU的解码模式需要是<strong>64位模式</strong>，而当前模式是<strong>32位</strong>。64位CPU是通过GDT表中CS段所对应的表项中<strong>L标志位</strong>来确定当前<strong>解码模式</strong>的。</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309092835616.png" alt="image-20220309092835616"></p>
<p>在x64系统下的进程是有32位和64位两种工作模式，这两种工作模式的区别在于CS寄存器。<strong>32位模式</strong>时，<strong>CS = 0x23</strong>；<strong>64位模式</strong>时，<strong>CS = 0x33</strong>。</p>
<p>切换这两种工作模式的方法：</p>
<p>一般会通过retf指令，retf指令和 <strong>pop</strong> ip+<strong>pop</strong> cs 作用相同。如果此时栈中有0x33，则会将0x33弹出到CS寄存器中，实现32位程序切换到64位代码的过程</p>
<p>我们直接打开这个函数，不能够反编译，然后现在查看汇编代码，在程序的开头就调用了一个函数</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309092438231.png" alt="image-20220309092438231"></p>
<p>跟进到这个函数之中去，发现了和32需要调用64位函数的时候的中间代码相同的一段代码，这样我们就能知道这个地方的函数是64位的</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309092509334.png" alt="image-20220309092509334"></p>
<h3 id="第二个函数-sub-401220-amp-unk-4262F8"><a href="#第二个函数-sub-401220-amp-unk-4262F8" class="headerlink" title="第二个函数 sub_401220(&amp;unk_4262F8)"></a>第二个函数 sub_401220(&amp;unk_4262F8)</h3><p> 这个函数的参数就是在上一个函数赋值的数组，这个函数里面就是对这个赋值得到的数组进行一系列的限制，但是这个地方是一个32位的程序之中调用64位的函数，所以我们需要将这个函数dump出来，然后导入到ida64之中去反编译这个函数，但是这里的代码之中即有32位的代码又有64位的代码，这样做是不能通过这样的方法反编译出来的。</p>
<p>但是使用ida7.5反编译这个程序就能够得到这个函数的代码，但是这个代码之中会混杂着一些asm的汇编代码，需要我们仔细地分析这个代码。</p>
<p>这里面参杂着一些64位的汇编代码，它的代码意义在图中有标明进行注释</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310212725752.png" alt="image-20220310212725752"></p>
<h4 id="对迷宫的第一排-第一列-第六排-第六列的限制"><a href="#对迷宫的第一排-第一列-第六排-第六列的限制" class="headerlink" title="对迷宫的第一排 第一列 第六排 第六列的限制"></a>对迷宫的第一排 第一列 第六排 第六列的限制</h4><p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310212935273.png" alt="image-20220310212935273"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310212948727.png" alt="image-20220310212948727"></p>
<h4 id="第一种特殊点的限制"><a href="#第一种特殊点的限制" class="headerlink" title="第一种特殊点的限制"></a>第一种特殊点的限制</h4><p>限制1 ：不能同时含有 8 和 2 并且也不能同时含有4和1 所以有12、9、6、3这四种组合方式</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310213056630.png" alt="image-20220310213056630"></p>
<p>限制2 ：需要赋值两次</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215425865.png" alt="image-20220310215425865"></p>
<p>限制三  ：</p>
<p>如果当前的格子之中是8 则它的上一行的对应的格子就不能是8 </p>
<p>如果当前的格子之中是2 则它的下一行的对应的格子就不能是2</p>
<p>如果当前的格子之中是4 则它的上一格的对应的格子就不能是4</p>
<p>如果当前的格子之中是1 则它的上一行的对应的格子就不能是1</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215559291.png" alt="image-20220310215559291"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215603014.png" alt="image-20220310215603014"></p>
<h4 id="第二种特殊点的限制"><a href="#第二种特殊点的限制" class="headerlink" title="第二种特殊点的限制"></a>第二种特殊点的限制</h4><p>限制一 ：这十个坐标含有2和8的组合 或者 含有1和4的组合</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215808216.png" alt="image-20220310215808216"></p>
<p>限制二 ：</p>
<p>当<strong>本格是10</strong>时，上下两行之中一定要含有1或4</p>
<p>当<strong>本格是5</strong>时，左右两格之中一定要含有8或2</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220010868.png" alt="image-20220310220010868"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220052452.png" alt="image-20220310220052452"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220106999.png" alt="image-20220310220106999"></p>
<h4 id="对走的方向以及迷宫终点设置的代码"><a href="#对走的方向以及迷宫终点设置的代码" class="headerlink" title="对走的方向以及迷宫终点设置的代码"></a>对走的方向以及迷宫终点设置的代码</h4><p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220252666.png" alt="image-20220310220252666"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220335420.png" alt="image-20220310220335420"></p>
<h4 id="整理之后地代码"><a href="#整理之后地代码" class="headerlink" title="整理之后地代码"></a>整理之后地代码</h4><p>别人的wp之中找到对这部分代码的整理之后的结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">spoint1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  spoint1[<span class="number">1</span>] = <span class="number">14</span>;</span><br><span class="line">  spoint1[<span class="number">2</span>] = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//总体限制，不能撞墙，不能重复使用格子</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( table[<span class="number">6</span> * i + j] &gt; <span class="number">0xF</span>u )            <span class="comment">// 每一个格子都不能大于16</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      v14 = table[<span class="number">6</span> * i + j] % <span class="number">0x10</span>u / <span class="number">8</span>;</span><br><span class="line">      v22 = j;</span><br><span class="line">      v15 = table[<span class="number">6</span> * i + j] % <span class="number">8u</span> / <span class="number">4</span> + v14;</span><br><span class="line">      v23 = j;</span><br><span class="line">      v16 = table[<span class="number">6</span> * i + j] % <span class="number">4u</span> / <span class="number">2</span> + v15;</span><br><span class="line">      v24 = j;</span><br><span class="line">      <span class="keyword">if</span> ( table[<span class="number">6</span> * i + j] % <span class="number">2u</span> + v16 &gt; <span class="number">2</span> )    <span class="comment">// 计算二进制1的个数,也就是说每个格子不能被设置两次以上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( !j &amp;&amp; table[<span class="number">6</span> * i] % <span class="number">8u</span> / <span class="number">4</span> )        <span class="comment">// 6*6数组的第一列不能=4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( j == <span class="number">5</span> &amp;&amp; table[<span class="number">6</span> * i + <span class="number">5</span>] % <span class="number">2u</span> )    <span class="comment">// 最后一列不能=1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( !i &amp;&amp; table[j] % <span class="number">0x10</span>u / <span class="number">8</span> )         <span class="comment">// 第一行每一个都不能=8</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( i == <span class="number">5</span> &amp;&amp; table[j + <span class="number">30</span>] % <span class="number">4u</span> / <span class="number">2</span> )   <span class="comment">// 最后一行每一个都不能=2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第一种特殊点限制条件，这种特殊点周围不能连着出现两种操作，碰到必须拐弯</span></span><br><span class="line">  <span class="keyword">for</span> ( k = <span class="number">0</span>; (<span class="type">unsigned</span> __int64)k &lt; <span class="number">3</span>; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    row1 = spoint1[k] / <span class="number">10</span>;                     <span class="comment">// 0 1 2</span></span><br><span class="line">    col1 = spoint1[k] % <span class="number">10</span>;                     <span class="comment">// 0 4 0</span></span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">0x10</span>u / <span class="number">8</span> &amp;&amp; table[<span class="number">6</span> * row1 + col1] % <span class="number">4u</span> / <span class="number">2</span> )<span class="comment">// != 8 != 2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">8u</span> / <span class="number">4</span> &amp;&amp; table[<span class="number">6</span> * row1 + col1] % <span class="number">2u</span> )<span class="comment">// != 4 != 1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    v17 = table[<span class="number">6</span> * row1 + col1] % <span class="number">0x10</span>u / <span class="number">8</span>;</span><br><span class="line">    v25 = col1;</span><br><span class="line">    v18 = table[<span class="number">6</span> * row1 + col1] % <span class="number">4u</span> / <span class="number">2</span> + v17;</span><br><span class="line">    v26 = col1;</span><br><span class="line">    v19 = table[<span class="number">6</span> * row1 + col1] % <span class="number">2u</span> + v18;</span><br><span class="line">    v27 = col1;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">8u</span> / <span class="number">4</span> + v19 != <span class="number">2</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">0x10</span>u / <span class="number">8</span> )   <span class="comment">// 当前格子为8则判断上一行不能为8</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row1 - <span class="number">6</span> + col1] % <span class="number">0x10</span>u / <span class="number">8</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">4u</span> / <span class="number">2</span> ) <span class="comment">// 当前格子为2则判断下一行不能为2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row1 + <span class="number">6</span> + col1] % <span class="number">4u</span> / <span class="number">2</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">8u</span> / <span class="number">4</span> ) <span class="comment">// 当前格子为4则判断上一格不能为4</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row1 - <span class="number">1</span> + col1] % <span class="number">8u</span> / <span class="number">4</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">2u</span> &amp;&amp; !(table[<span class="number">6</span> * row1 + <span class="number">1</span> + col1] % <span class="number">2u</span>) )<span class="comment">// 当前格子为1则判断下一格不能为1</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第二种特殊点限制条件，必须直线进入，连续3格可连成直线，并且是拐弯进入前一格，或者进入后一格后拐弯</span></span><br><span class="line">  spoint2[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">  spoint2[<span class="number">1</span>] = <span class="number">13</span>;</span><br><span class="line">  spoint2[<span class="number">2</span>] = <span class="number">15</span>;</span><br><span class="line">  spoint2[<span class="number">3</span>] = <span class="number">21</span>;</span><br><span class="line">  spoint2[<span class="number">4</span>] = <span class="number">24</span>;</span><br><span class="line">  spoint2[<span class="number">5</span>] = <span class="number">31</span>;</span><br><span class="line">  spoint2[<span class="number">6</span>] = <span class="number">32</span>;</span><br><span class="line">  spoint2[<span class="number">7</span>] = <span class="number">41</span>;</span><br><span class="line">  spoint2[<span class="number">8</span>] = <span class="number">45</span>;</span><br><span class="line">  spoint2[<span class="number">9</span>] = <span class="number">53</span>;</span><br><span class="line">  <span class="keyword">for</span> ( l = <span class="number">0</span>; (<span class="type">unsigned</span> __int64)l &lt; <span class="number">0xA</span>; ++l )</span><br><span class="line">  &#123;</span><br><span class="line">    row2 = spoint2[l] / <span class="number">10</span>;</span><br><span class="line">    col2 = spoint2[l] % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (!(table[<span class="number">6</span> * row2 + col2] % <span class="number">0x10</span>u / <span class="number">8</span>) || !(table[<span class="number">6</span> * row2 + col2] % <span class="number">4u</span> / <span class="number">2</span>))<span class="comment">// 只有 28 或者14的组合</span></span><br><span class="line">      &amp;&amp; (!(table[<span class="number">6</span> * row2 + col2] % <span class="number">8u</span> / <span class="number">4</span>) || !(table[<span class="number">6</span> * row2 + col2] % <span class="number">2u</span>)) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row2 + col2] % <span class="number">0x10</span>u / <span class="number">8</span>     <span class="comment">// 28组合</span></span><br><span class="line">                                                <span class="comment">// 上一行 =4 =1或者</span></span><br><span class="line">                                                <span class="comment">// 下一行 =4 =1</span></span><br><span class="line">      &amp;&amp; table[<span class="number">6</span> * row2 + col2] % <span class="number">4u</span> / <span class="number">2</span></span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">6</span> + col2] % <span class="number">8u</span> / <span class="number">4</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">6</span> + col2] % <span class="number">2u</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">6</span> + col2] % <span class="number">8u</span> / <span class="number">4</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">6</span> + col2] % <span class="number">2u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row2 + col2] % <span class="number">8u</span> / <span class="number">4</span>        <span class="comment">// 14组合</span></span><br><span class="line">                                                <span class="comment">// 上一格 =2 =8或者</span></span><br><span class="line">                                                <span class="comment">// 下一格 =2 =8</span></span><br><span class="line">      &amp;&amp; table[<span class="number">6</span> * row2 + col2] % <span class="number">2u</span></span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">1</span> + col2] % <span class="number">0x10</span>u / <span class="number">8</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">1</span> + col2] % <span class="number">4u</span> / <span class="number">2</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">1</span> + col2] % <span class="number">0x10</span>u / <span class="number">8</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">1</span> + col2] % <span class="number">4u</span> / <span class="number">2</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//校验,使用数组的值移动点，最后能回到(0,0)点就是flag了</span></span><br><span class="line">    oldrow = <span class="number">0</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  row3 = <span class="number">0</span>;</span><br><span class="line">  col3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *table % <span class="number">0x10</span>u / <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    row3 = <span class="number">-1</span>;                                  <span class="comment">// 前一行</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">LABEL_79:</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">0x10</span>u / <span class="number">8</span>) || row3 - <span class="number">1</span> == oldrow &amp;&amp; col3 == v11 )<span class="comment">// 8则转到上一行</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">4u</span> / <span class="number">2</span>) || row3 + <span class="number">1</span> == oldrow &amp;&amp; col3 == v11 )<span class="comment">// 2</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">8u</span> / <span class="number">4</span>) || row3 == oldrow &amp;&amp; col3 - <span class="number">1</span> == v11 )<span class="comment">// 4</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">2u</span>) || row3 == oldrow &amp;&amp; col3 + <span class="number">1</span> == v11 )<span class="comment">// 1</span></span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">            oldrow = row3;</span><br><span class="line">            v11 = col3++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            oldrow = row3;</span><br><span class="line">            v11 = col3--;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          oldrow = row3;</span><br><span class="line">          v11 = col3;</span><br><span class="line">          ++row3;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        oldrow = row3;</span><br><span class="line">        v11 = col3;</span><br><span class="line">        --row3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( row3 || col3 );</span><br><span class="line">    result = <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *table % <span class="number">4u</span> / <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      row3 = <span class="number">1</span>;                                 <span class="comment">// 后一行</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_79;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *table % <span class="number">8u</span> / <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      col3 = <span class="number">-1</span>;                                <span class="comment">// 前一格</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_79;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *table % <span class="number">2u</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      col3 = <span class="number">1</span>;                                 <span class="comment">// 后一格</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_79;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">1</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h4 id="总结第二个函数中对迷宫的限制"><a href="#总结第二个函数中对迷宫的限制" class="headerlink" title="总结第二个函数中对迷宫的限制"></a>总结第二个函数中对迷宫的限制</h4><ol>
<li><p>通过<strong>第一个函数</strong>我们可以知道每当一个格子被设置值（方向）的时候，它所到达的下一个格子也会被设置一个值（方向），下一个格子的值（方向）是和当前格子相反的方向，也就是下一个格子含有指向当前格子的方向，所以迷宫走的路径是<strong>双向设置的</strong>（每一步都是双向的），既能够正着走，也能够反着走，在特殊点的性质设置的时候也会利用到这个迷宫设置的这个特点。</p>
</li>
<li><p>这个迷宫中的数据都要被设置两次</p>
</li>
<li><p>迷宫的第一列不能是4</p>
</li>
</ol>
<p>​       迷宫的第六列不能是1</p>
<p>​       迷宫的第一排不能是8</p>
<p>​       迷宫的第六排不能是2</p>
<ol start="4">
<li>对坐标为（0,0）（1,4）（2,0）的限制（坐标的第一个是行第二个是列）</li>
</ol>
<ul>
<li>这个单元格中不能同时含有 8 和 2 并且也不能同时含有4和1</li>
<li>需要被赋值两次（采用和开头相同的检验是否被赋值了两次以上的检验方法）</li>
<li>如果当前的格子之中是8 则它的上一行的对应的格子就不能是8</li>
<li>如果当前的格子之中是2 则它的下一行的对应的格子就不能是2</li>
<li>如果当前的格子之中是4 则它的上一格的对应的格子就不能是4</li>
<li>如果当前的格子之中是1 则它的上一行的对应的格子就不能是1</li>
<li>这种特殊点周围不能连着出现两种操作，<strong>碰到必须拐弯</strong>。<ul>
<li>它自身就必须含有<strong>水平和竖直</strong>方向的移动<strong>各一种</strong></li>
<li>这种特殊节点需要<strong>连接两个格子</strong>（通过自己有的两个方向能够到达这两个格子），所以这两个格子需要分别存在于它的<strong>水平和竖直方向</strong>上，那么在这个节点必定要<strong>转弯</strong></li>
</ul>
</li>
</ul>
<ol start="5">
<li>对坐标(0,4) (1,3) (1,5) (2,1) (2,4) (3,1) (3,2) (4,1) (4,5) (5,3)的限制</li>
</ol>
<ul>
<li>这十个坐标含有2和8的组合 或者 含有1和4的组合（因为在程序的最开始就标注了每个格子被设置的次数不能超过2次，所以这10个坐标的设置只能是这两种组合种的一种，也就是这10个格子的数值只能是10或者5）</li>
<li>当<strong>本格是10</strong>时，上下两行之中一定要含有1或4（在本格之中即能向上走也能向下走）</li>
<li>当<strong>本格是5</strong>时，左右两格之中一定要含有8或2（在本格之中既能向左走也能向右走）</li>
<li>第二种特殊点限制条件，必须直线进入，<strong>连续3格可连成直线</strong>，并且是<strong>拐弯进入前一格</strong>，或者进入<strong>后一格后拐弯</strong>。<ul>
<li>这种特殊点需要能够到达它的<strong>前后两个节点</strong>（连接两个格子），但是它自己本身这个格子之中方向的定义只有<strong>一种类型</strong>（竖直方向的 或者 水平方向的）。所以它的前后两个格子和它自身必须在<strong>同一条直线</strong>上，那么这样就使得进入这个格子的方向，就是这个格子所具有的方向（水平还是竖直）。</li>
<li>因为第二三个条件的限制使得，它连接的两个格子之中会有转弯的方向，如果是它的前一个格子含有转弯的方向，说明是<strong>拐弯进入前一格</strong>的。如果它的后一个格子含有转弯的方向，说明<strong>进入后一格后拐弯</strong>。</li>
</ul>
</li>
</ul>
<ol start="6">
<li>走迷宫的规则和操作：</li>
</ol>
<ul>
<li>8是向上走 2是向下走 4是向左走 1是向右走（判断的顺序是8 2 4 1）</li>
<li>不能再回到上一格的位置</li>
<li>走到终点的位置是 （0，0）</li>
</ul>
<h3 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h3><p>使用#标注第一种类型的特殊点 使用$来标注第二种特殊类型的点 从上一个函数我们可以知道第一个位置固定是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0  1  2  3  4  5 </span><br><span class="line">0 #3 05 05 05 $5 06  </span><br><span class="line">1 0A 0  03 $5 #4 $A</span><br><span class="line">2 #9 $5 0C 0  $A 0A</span><br><span class="line">3 03 $5 $5 06 0A 0A</span><br><span class="line">4 09 $5 06 09 0C $A</span><br><span class="line">5 0  0  09 $5 05 0C</span><br><span class="line"></span><br><span class="line">[3, 5, 5, 5, 5, 6] </span><br><span class="line">[A, 0, 3, 5, 6, A] </span><br><span class="line">[9, 5, C, 0, A, A] </span><br><span class="line">[3, 5, 5, 6, A, A] </span><br><span class="line">[9, 5, 6, 9, C, A] </span><br><span class="line">[0, 0, 9, 5, 5, C]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">idx</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">#↓</td>
<td align="left">←</td>
<td align="left">←</td>
<td align="left">←</td>
<td align="left">*←</td>
<td align="left">←</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">↓</td>
<td align="left">0</td>
<td align="left">→</td>
<td align="left">*→</td>
<td align="left">#↓</td>
<td align="left">*↑</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">#→</td>
<td align="left">*→</td>
<td align="left">↑</td>
<td align="left">0</td>
<td align="left">*↓</td>
<td align="left">↑</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">↓</td>
<td align="left">*←</td>
<td align="left">*←</td>
<td align="left">←</td>
<td align="left">↓</td>
<td align="left">↑</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">→</td>
<td align="left">*→</td>
<td align="left">↓</td>
<td align="left">↑</td>
<td align="left">←</td>
<td align="left">*↑</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">→</td>
<td align="left">*→</td>
<td align="left">→</td>
<td align="left">↑</td>
</tr>
</tbody></table>
<p>上面这个是走迷宫的过程，得到的按着这个方向正着走到最后之后再按着同样的路线反着走一次就能够得到这个目标的6*6的map了</p>
<p>按照第一个函数的赋值的方式就能够得到这个过程是 d3ctf{22441442223133324424441111133333}</p>
<p>所以最后得到的flag是 d3ctf{22441442223133324424441111133333}</p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>迷宫</tag>
        <tag>binToHex</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF_Oct</title>
    <url>/2022/03/20/DASCTF-Oct/</url>
    <content><![CDATA[<h1 id="DASCTF-Oct-re"><a href="#DASCTF-Oct-re" class="headerlink" title="DASCTF_Oct_re"></a>DASCTF_Oct_re</h1><p>这两道题中都有加密的知识点，第一道题的SM4的解密在最后一步仍然有问题，希望大佬能够指点指点(●’◡’●)</p>
<h2 id="马猴烧酒"><a href="#马猴烧酒" class="headerlink" title="马猴烧酒"></a>马猴烧酒</h2><p><strong>知识点</strong>：</p>
<blockquote>
<ol>
<li>魔改SM4</li>
<li>魔改base64</li>
</ol>
</blockquote>
<p>用ida6将文件载入其中</p>
<p><img src="/images/DASCTF-Oct/image-20220318181826345.png" alt="image-20220318181826345"></p>
<p>定位到相应的代码的位置，这段代码开始的位置就有一段flag{this_is_fake_flag}的flag</p>
<p><img src="/images/DASCTF-Oct/image-20220318182418204.png" alt="image-20220318182418204"></p>
<h3 id="密钥的生成"><a href="#密钥的生成" class="headerlink" title="密钥的生成"></a>密钥的生成</h3><p>第一个函数是获取时间戳，第二个函数是对时间戳base64的变表加密，第三个异或运算得到密钥</p>
<h4 id="获取时间戳"><a href="#获取时间戳" class="headerlink" title="获取时间戳"></a>获取时间戳</h4><p>使用0x61624B82 演变得到一串数组</p>
<p><img src="/images/DASCTF-Oct/image-20220319151621929.png" alt="image-20220319151621929"></p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key = 0x61624B82</span><br><span class="line">a13 = 0</span><br><span class="line">a14 = 0</span><br><span class="line">while key:</span><br><span class="line">    a13 = key%10</span><br><span class="line">    key = key//10</span><br><span class="line">    a14 = 87</span><br><span class="line">    if a13&lt;=9:</span><br><span class="line">        a14 = 48</span><br><span class="line">    print(chr(a13+a14),end=&#x27;&#x27;)</span><br><span class="line">    </span><br><span class="line">obj = &#x27;0181383361&#x27;</span><br><span class="line">for i in range(len(obj)):</span><br><span class="line">    print(obj[len(obj)-1-i],end=&#x27;&#x27;)</span><br><span class="line"> </span><br><span class="line">得到的结果是 1633831810 这个字符串</span><br></pre></td></tr></table></figure>

<h4 id="魔改的base64加密"><a href="#魔改的base64加密" class="headerlink" title="魔改的base64加密"></a>魔改的base64加密</h4><p>用标准的base64加密这个字符串的结果是 MTYzMzgzMTgxMA== </p>
<p>分析本代码之中的base64加密 可以知道如果位数不是3的倍数位也是使用“=”</p>
<p>base64的变表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ=</span><br></pre></td></tr></table></figure>

<p>利用base64的变表和标准表的对应关系得到该代码base64加密的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oldkey = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&#x27;</span><br><span class="line">newkey = &#x27;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ=&#x27;</span><br><span class="line">theMap = &#123;&#125;</span><br><span class="line">for i in range(len(oldkey)):</span><br><span class="line">    theMap[oldkey[i]] = newkey[i]</span><br><span class="line">advert = &#x27;MTYzMzgzMTgxMA==&#x27;</span><br><span class="line">for i  in range(len(advert)):</span><br><span class="line">    print(theMap[advert[i]],end=&#x27;&#x27;)</span><br><span class="line">结果是：mtyNmN6Nmt6Lma==</span><br></pre></td></tr></table></figure>



<p><img src="/images/DASCTF-Oct/image-20220318191421527.png" alt="image-20220318191421527"></p>
<p><img src="/images/DASCTF-Oct/image-20220318191436020.png" alt="image-20220318191436020"></p>
<h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><p>将上面base64的加密结果和字符串  “flag{this_is_fake_flag}”进行异或运算</p>
<p><img src="/images/DASCTF-Oct/image-20220319154418390.png" alt="image-20220319154418390"></p>
<p>脚本（密钥）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tem1 = <span class="string">&#x27;mtyNmN6Nmt6Lma==&#x27;</span></span><br><span class="line">tem2 = <span class="string">&#x27;flag&#123;this_is_fake_flag&#125;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tem1)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(<span class="built_in">ord</span>(tem1[i])^<span class="built_in">ord</span>(tem2[i]))[<span class="number">2</span>:].zfill(<span class="number">2</span>),end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">[<span class="number">0x0b</span>,<span class="number">0x18</span>,<span class="number">0x18</span>,<span class="number">0x29</span>,<span class="number">0x16</span>,<span class="number">0x3a</span>,<span class="number">0x5e</span>,<span class="number">0x27</span>,<span class="number">0x1e</span>,<span class="number">0x2b</span>,<span class="number">0x5f</span>,<span class="number">0x3f</span>,<span class="number">0x32</span>,<span class="number">0x07</span>,<span class="number">0x5c</span>,<span class="number">0x56</span>]</span><br></pre></td></tr></table></figure>

<p>得到的这个数组将会作为SM4加密的key</p>
<h3 id="SM4加密"><a href="#SM4加密" class="headerlink" title="SM4加密"></a><strong>SM4加密</strong></h3><blockquote>
<ol>
<li>识别出SM4加密</li>
<li>找到SM4加密魔改的地方</li>
</ol>
</blockquote>
<p>加密之后的结果和相应的数组对比</p>
<p><img src="/images/DASCTF-Oct/image-20220318193700160.png" alt="image-20220318193700160"></p>
<p>需要解密的对象是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc = [0xf7,0xeb,0x5e,0x87,0x17,0x9c,0x74,0x94,0x44,0xb5,0xf5,0x12,0xf9,0x74,0x15,0x5f]</span><br></pre></td></tr></table></figure>

<p>轮函数每次会处理128bite的数据，会将这128bite的数据分成4个32bite的数据</p>
<p>SM4加密，每组加密的是128bit，每32bit加密之后的顺序发生了变化的</p>
<p><img src="/images/DASCTF-Oct/image-20220318193418765.png" alt="image-20220318193418765"></p>
<p>对每个8bit都用了s盒进行了处理，在内存之中找到s盒是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;0x48, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05&#125;,</span><br><span class="line">    &#123;0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99&#125;,</span><br><span class="line">    &#123;0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62&#125;,</span><br><span class="line">    &#123;0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6&#125;,</span><br><span class="line">    &#123;0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8&#125;,</span><br><span class="line">    &#123;0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35&#125;,</span><br><span class="line">    &#123;0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87&#125;,</span><br><span class="line">    &#123;0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E&#125;,</span><br><span class="line">    &#123;0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1&#125;,</span><br><span class="line">    &#123;0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3&#125;,</span><br><span class="line">    &#123;0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F&#125;,</span><br><span class="line">    &#123;0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51&#125;,</span><br><span class="line">    &#123;0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8&#125;,</span><br><span class="line">    &#123;0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0&#125;,</span><br><span class="line">    &#123;0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84&#125;,</span><br><span class="line">    &#123;0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0xD6&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const unsigned long CK[32] =</span><br><span class="line">&#123;</span><br><span class="line">    0xF4BFE18F, 0xA8AA055C, 0x8B266D2B, 0xB3819D47, 0x0B1B3A85, 0xF7DB86B6, 0xC3279F82, 0x39D9C102,</span><br><span class="line">    0xBEA224C9, 0xE75D4DAC, 0xAC61726C, 0x6F98AA6F, 0xFA2ADA4E, 0x6A7CFF92, 0xA8066E7B, 0x7BE32F9F,</span><br><span class="line">    0x8CD0FED3, 0x4B98AF71, 0x790C2CBC, 0xBF880433, 0xAA46F582, 0x69C17A2C, 0x80BBD5E4, 0x24A02531,</span><br><span class="line">    0x293D87B3, 0x75F159AD, 0xB750AE9D, 0x9886928C, 0x05577A22, 0xB425E19F, 0x124D4F63, 0xE26F66D1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="SM4解密脚本"><a href="#SM4解密脚本" class="headerlink" title="SM4解密脚本"></a>SM4解密脚本</h3><p>网上找一个SM4的c语言脚本，修改里面的Sbox，CK参数，以及将上面得到的key和解密的对象引入（但是我从网上找了两个解密的脚本，修改了里面相应的参数之后，仍然得不到想要的结果，并且在内存之中也没能找到修改之后的CK参数，希望指点指点）</p>
<p>SM.h头部文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __lk_sm4_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __lk_sm4_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpluscplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpluscplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_WORD_SIZE        32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_GCHAR_SIZE       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_GWORD_SIZE       4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>                LK_VOID;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>                 LK_INT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>        UINT;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> i386</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>   UWORD;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>       UWORD;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>   UCHAR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大端转化</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_GE(c, i) (\</span></span><br><span class="line"><span class="meta">        (c[(i)+0] &lt;&lt; 24) | ((c[(i)+1] &lt;&lt; 16)) |\</span></span><br><span class="line"><span class="meta">         (c[(i)+2] &lt;&lt; 8) | (c[(i)+3]) )</span></span><br><span class="line"><span class="comment">//小端转化</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_LE(c, n, i) &#123;\</span></span><br><span class="line"><span class="meta">        c[(i)+0] = ((n) &gt;&gt; 24) &amp; 0x000000ff;\</span></span><br><span class="line"><span class="meta">        c[(i)+1] = ((n) &gt;&gt; 16) &amp; 0x000000ff;\</span></span><br><span class="line"><span class="meta">        c[(i)+2] = ((n) &gt;&gt; 8) &amp; 0x000000ff;\</span></span><br><span class="line"><span class="meta">        c[(i)+3] = (n) &amp; 0x000000ff; &#125;</span></span><br><span class="line"><span class="comment">//循环左移</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOOPSHFT(LK_LSHIFA, LK_LSHIFN) (\</span></span><br><span class="line"><span class="meta">        ((LK_LSHIFA) &lt;&lt; (LK_LSHIFN)) | \</span></span><br><span class="line"><span class="meta">        ((LK_LSHIFA) &gt;&gt; (LK_WORD_SIZE - (LK_LSHIFN))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性变换函数L&#x27; L&#x27;(B)=B^(B&lt;&lt;&lt;13)^(B&lt;&lt;&lt;23)；</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_L0(LK_L0B) (\</span></span><br><span class="line"><span class="meta">    (LK_L0B)^(LOOPSHFT((LK_L0B), 13))^(LOOPSHFT((LK_L0B), 23)) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性变换函数L L(B) = B^(B&lt;&lt;&lt;2)^(B&lt;&lt;&lt;10)^(B&lt;&lt;&lt;18)^(B&lt;&lt;&lt;24)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_L1(LK_L1B) (\</span></span><br><span class="line"><span class="meta">    (LK_L1B)^(LOOPSHFT((LK_L1B), 2))^(LOOPSHFT((LK_L1B), 10))\</span></span><br><span class="line"><span class="meta">    ^(LOOPSHFT((LK_L1B), 18))^(LOOPSHFT((LK_L1B), 24)) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非线性变换 τ函数 (b0 , b1, b2 , b3 ) = τ (A) = ( Sbox (a0 ), Sbox (a1 ), Sbox (a2 ), Sbox (a3 ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_ST(LK_STA) (&#123;\</span></span><br><span class="line"><span class="meta">    LK_INT LK_i;\</span></span><br><span class="line"><span class="meta">    UINT LK_STB = LK_STA;\</span></span><br><span class="line"><span class="meta">    UCHAR *pcr = (UCHAR *)(&amp;LK_STB);\</span></span><br><span class="line"><span class="meta">    for (LK_i = 0; LK_i &lt; 4; LK_i++) &#123;\</span></span><br><span class="line"><span class="meta">        UCHAR high_bval = ((pcr[LK_i] &gt;&gt; 4) &amp; 0x0f);\</span></span><br><span class="line"><span class="meta">        UCHAR low_bval = (pcr[LK_i] &amp; 0x0f);\</span></span><br><span class="line"><span class="meta">        *(pcr+LK_i) = lk_sbox[high_bval][low_bval];\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    LK_STB;\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//合成置换 T  T(.)=L(τ(.))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_T1(LK_TA) (\</span></span><br><span class="line"><span class="meta">    LK_L1(LK_ST(LK_TA)) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//合成置换 T&#x27;  T&#x27;(.)=L&#x27;(τ(.))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_T0(LK_TA) (\</span></span><br><span class="line"><span class="meta">    LK_L0(LK_ST(LK_TA)) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//密钥扩展算法生成轮密钥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_SM4_INIT(lk_context, ekey) &#123;\</span></span><br><span class="line"><span class="meta">    UINT k[36], mk[4];\</span></span><br><span class="line"><span class="meta">    LK_INT i;\</span></span><br><span class="line"><span class="meta">    lk_sm4_context_t *t = (lk_sm4_context_t *)(lk_context);\</span></span><br><span class="line"><span class="meta">    memset(t, 0,sizeof(lk_sm4_context_t));\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 4; i++) &#123;\</span></span><br><span class="line"><span class="meta">        mk[i] = LK_GE(ekey, i * 4);\</span></span><br><span class="line"><span class="meta">        k[i] = mk[i]^lk_fk[i];\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 32; i++) &#123;\</span></span><br><span class="line"><span class="meta">        k[i+4] = (k[i] ^ LK_T0(k[i+1]^k[i+2]^k[i+3]^(lk_ck[i])));\</span></span><br><span class="line"><span class="meta">        t-&gt;e_rk[i] = k[i+4];\</span></span><br><span class="line"><span class="meta">        t-&gt;d_rk[31 - i] = t-&gt;e_rk[i];\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加密函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_SM4_ENC_F(lk_context) &#123;\</span></span><br><span class="line"><span class="meta">    LK_INT i;\</span></span><br><span class="line"><span class="meta">    UINT x[36];\</span></span><br><span class="line"><span class="meta">    lk_sm4_context_t *t = (lk_sm4_context_t *)(lk_context);\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 4; i++) &#123;\</span></span><br><span class="line"><span class="meta">        x[i] = LK_GE(t-&gt;buf, i * 4);\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 32; i++) &#123;\</span></span><br><span class="line"><span class="meta">        x[i + 4] = x[i]^(LK_T1(x[i+1]^x[i+2]^x[i+3]^t-&gt;e_rk[i]));\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;ebuf, x[35], 0)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;ebuf, x[34], 4)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;ebuf, x[33], 8)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;ebuf, x[32], 12)\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">//解密函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LK_SM4_DEC_F(lk_context) &#123;\</span></span><br><span class="line"><span class="meta">    LK_INT i;\</span></span><br><span class="line"><span class="meta">    UINT x[36];\</span></span><br><span class="line"><span class="meta">    lk_sm4_context_t *t = (lk_sm4_context_t *)(lk_context);\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 4; i++) &#123;\</span></span><br><span class="line"><span class="meta">        x[i] = LK_GE(t-&gt;ebuf, i * 4);\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; 32; i++) &#123;\</span></span><br><span class="line"><span class="meta">        x[i + 4] = x[i]^LK_T1(x[i+1]^x[i+2]^x[i+3]^t-&gt;d_rk[i]);\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;buf, x[35], 0)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;buf, x[34], 4)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;buf, x[33], 8)\</span></span><br><span class="line"><span class="meta">    LK_LE(t-&gt;buf, x[32], 12)\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lk_sm4_context_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//需要加密的明文,加密之前需要填充</span></span><br><span class="line">    UCHAR    buf[LK_GCHAR_SIZE];</span><br><span class="line">    <span class="comment">//加密之后的密文,如果是解密的话,解密之前需要填充</span></span><br><span class="line">    UCHAR    ebuf[LK_GCHAR_SIZE];</span><br><span class="line">    <span class="comment">//原密钥经过扩展之后的轮密钥,初始化接口自行填充</span></span><br><span class="line">    UINT    e_rk[LK_WORD_SIZE];</span><br><span class="line">    <span class="comment">//解密过程需要的轮密钥,初始化接口自行填充</span></span><br><span class="line">    UINT    d_rk[LK_WORD_SIZE];</span><br><span class="line">&#125; <span class="type">lk_sm4_context_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpluscplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> LK_VOID <span class="title function_">lk_sm4_enc</span><span class="params">(LK_VOID *p_context)</span>;</span><br><span class="line"><span class="keyword">extern</span> LK_VOID <span class="title function_">lk_sm4_dec</span><span class="params">(LK_VOID *p_context)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpluscplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;SM4.h&quot;</span></span><br><span class="line">//非线性转化用到的sbox对照表</span><br><span class="line">UCHAR lk_sbox[LK_GCHAR_SIZE][LK_GCHAR_SIZE] =  &#123;</span><br><span class="line">    &#123;<span class="number">0x48</span>, <span class="number">0x90</span>, <span class="number">0xE9</span>, <span class="number">0xFE</span>, <span class="number">0xCC</span>, <span class="number">0xE1</span>, <span class="number">0x3D</span>, <span class="number">0xB7</span>, <span class="number">0x16</span>, <span class="number">0xB6</span>, <span class="number">0x14</span>, <span class="number">0xC2</span>, <span class="number">0x28</span>, <span class="number">0xFB</span>, <span class="number">0x2C</span>, <span class="number">0x05</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x2B</span>, <span class="number">0x67</span>, <span class="number">0x9A</span>, <span class="number">0x76</span>, <span class="number">0x2A</span>, <span class="number">0xBE</span>, <span class="number">0x04</span>, <span class="number">0xC3</span>, <span class="number">0xAA</span>, <span class="number">0x44</span>, <span class="number">0x13</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x86</span>, <span class="number">0x06</span>, <span class="number">0x99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x9C</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x91</span>, <span class="number">0xEF</span>, <span class="number">0x98</span>, <span class="number">0x7A</span>, <span class="number">0x33</span>, <span class="number">0x54</span>, <span class="number">0x0B</span>, <span class="number">0x43</span>, <span class="number">0xED</span>, <span class="number">0xCF</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xE4</span>, <span class="number">0xB3</span>, <span class="number">0x1C</span>, <span class="number">0xA9</span>, <span class="number">0xC9</span>, <span class="number">0x08</span>, <span class="number">0xE8</span>, <span class="number">0x95</span>, <span class="number">0x80</span>, <span class="number">0xDF</span>, <span class="number">0x94</span>, <span class="number">0xFA</span>, <span class="number">0x75</span>, <span class="number">0x8F</span>, <span class="number">0x3F</span>, <span class="number">0xA6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x47</span>, <span class="number">0x07</span>, <span class="number">0xA7</span>, <span class="number">0xFC</span>, <span class="number">0xF3</span>, <span class="number">0x73</span>, <span class="number">0x17</span>, <span class="number">0xBA</span>, <span class="number">0x83</span>, <span class="number">0x59</span>, <span class="number">0x3C</span>, <span class="number">0x19</span>, <span class="number">0xE6</span>, <span class="number">0x85</span>, <span class="number">0x4F</span>, <span class="number">0xA8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x68</span>, <span class="number">0x6B</span>, <span class="number">0x81</span>, <span class="number">0xB2</span>, <span class="number">0x71</span>, <span class="number">0x64</span>, <span class="number">0xDA</span>, <span class="number">0x8B</span>, <span class="number">0xF8</span>, <span class="number">0xEB</span>, <span class="number">0x0F</span>, <span class="number">0x4B</span>, <span class="number">0x70</span>, <span class="number">0x56</span>, <span class="number">0x9D</span>, <span class="number">0x35</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x1E</span>, <span class="number">0x24</span>, <span class="number">0x0E</span>, <span class="number">0x5E</span>, <span class="number">0x63</span>, <span class="number">0x58</span>, <span class="number">0xD1</span>, <span class="number">0xA2</span>, <span class="number">0x25</span>, <span class="number">0x22</span>, <span class="number">0x7C</span>, <span class="number">0x3B</span>, <span class="number">0x01</span>, <span class="number">0x21</span>, <span class="number">0x78</span>, <span class="number">0x87</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xD4</span>, <span class="number">0x00</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x9F</span>, <span class="number">0xD3</span>, <span class="number">0x27</span>, <span class="number">0x52</span>, <span class="number">0x4C</span>, <span class="number">0x36</span>, <span class="number">0x02</span>, <span class="number">0xE7</span>, <span class="number">0xA0</span>, <span class="number">0xC4</span>, <span class="number">0xC8</span>, <span class="number">0x9E</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xEA</span>, <span class="number">0xBF</span>, <span class="number">0x8A</span>, <span class="number">0xD2</span>, <span class="number">0x40</span>, <span class="number">0xC7</span>, <span class="number">0x38</span>, <span class="number">0xB5</span>, <span class="number">0xA3</span>, <span class="number">0xF7</span>, <span class="number">0xF2</span>, <span class="number">0xCE</span>, <span class="number">0xF9</span>, <span class="number">0x61</span>, <span class="number">0x15</span>, <span class="number">0xA1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xE0</span>, <span class="number">0xAE</span>, <span class="number">0x5D</span>, <span class="number">0xA4</span>, <span class="number">0x9B</span>, <span class="number">0x34</span>, <span class="number">0x1A</span>, <span class="number">0x55</span>, <span class="number">0xAD</span>, <span class="number">0x93</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0xF5</span>, <span class="number">0x8C</span>, <span class="number">0xB1</span>, <span class="number">0xE3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x1D</span>, <span class="number">0xF6</span>, <span class="number">0xE2</span>, <span class="number">0x2E</span>, <span class="number">0x82</span>, <span class="number">0x66</span>, <span class="number">0xCA</span>, <span class="number">0x60</span>, <span class="number">0xC0</span>, <span class="number">0x29</span>, <span class="number">0x23</span>, <span class="number">0xAB</span>, <span class="number">0x0D</span>, <span class="number">0x53</span>, <span class="number">0x4E</span>, <span class="number">0x6F</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xD5</span>, <span class="number">0xDB</span>, <span class="number">0x37</span>, <span class="number">0x45</span>, <span class="number">0xDE</span>, <span class="number">0xFD</span>, <span class="number">0x8E</span>, <span class="number">0x2F</span>, <span class="number">0x03</span>, <span class="number">0xFF</span>, <span class="number">0x6A</span>, <span class="number">0x72</span>, <span class="number">0x6D</span>, <span class="number">0x6C</span>, <span class="number">0x5B</span>, <span class="number">0x51</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x8D</span>, <span class="number">0x1B</span>, <span class="number">0xAF</span>, <span class="number">0x92</span>, <span class="number">0xBB</span>, <span class="number">0xDD</span>, <span class="number">0xBC</span>, <span class="number">0x7F</span>, <span class="number">0x11</span>, <span class="number">0xD9</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x1F</span>, <span class="number">0x10</span>, <span class="number">0x5A</span>, <span class="number">0xD8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x0A</span>, <span class="number">0xC1</span>, <span class="number">0x31</span>, <span class="number">0x88</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>, <span class="number">0x7B</span>, <span class="number">0xBD</span>, <span class="number">0x2D</span>, <span class="number">0x74</span>, <span class="number">0xD0</span>, <span class="number">0x12</span>, <span class="number">0xB8</span>, <span class="number">0xE5</span>, <span class="number">0xB4</span>, <span class="number">0xB0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x89</span>, <span class="number">0x69</span>, <span class="number">0x97</span>, <span class="number">0x4A</span>, <span class="number">0x0C</span>, <span class="number">0x96</span>, <span class="number">0x77</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0xB9</span>, <span class="number">0xF1</span>, <span class="number">0x09</span>, <span class="number">0xC5</span>, <span class="number">0x6E</span>, <span class="number">0xC6</span>, <span class="number">0x84</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x18</span>, <span class="number">0xF0</span>, <span class="number">0x7D</span>, <span class="number">0xEC</span>, <span class="number">0x3A</span>, <span class="number">0xDC</span>, <span class="number">0x4D</span>, <span class="number">0x20</span>, <span class="number">0x79</span>, <span class="number">0xEE</span>, <span class="number">0x5F</span>, <span class="number">0x3E</span>, <span class="number">0xD7</span>, <span class="number">0xCB</span>, <span class="number">0x39</span>, <span class="number">0xD6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//系统参数FK</span><br><span class="line">UINT lk_fk[<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="number">0xA3B1BAC6</span>,<span class="number">0x56AA3350</span>,</span><br><span class="line">    <span class="number">0x677D9197</span>,<span class="number">0xB27022DC</span></span><br><span class="line">&#125;;</span><br><span class="line">//固定参数CK</span><br><span class="line">UINT lk_ck[<span class="number">32</span>] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="number">0xF4BFE18F</span>, <span class="number">0xA8AA055C</span>, <span class="number">0x8B266D2B</span>, <span class="number">0xB3819D47</span>, <span class="number">0x0B1B3A85</span>, <span class="number">0xF7DB86B6</span>, <span class="number">0xC3279F82</span>, <span class="number">0x39D9C102</span>,</span><br><span class="line">    <span class="number">0xBEA224C9</span>, <span class="number">0xE75D4DAC</span>, <span class="number">0xAC61726C</span>, <span class="number">0x6F98AA6F</span>, <span class="number">0xFA2ADA4E</span>, <span class="number">0x6A7CFF92</span>, <span class="number">0xA8066E7B</span>, <span class="number">0x7BE32F9F</span>,</span><br><span class="line">    <span class="number">0x8CD0FED3</span>, <span class="number">0x4B98AF71</span>, <span class="number">0x790C2CBC</span>, <span class="number">0xBF880433</span>, <span class="number">0xAA46F582</span>, <span class="number">0x69C17A2C</span>, <span class="number">0x80BBD5E4</span>, <span class="number">0x24A02531</span>,</span><br><span class="line">    <span class="number">0x293D87B3</span>, <span class="number">0x75F159AD</span>, <span class="number">0xB750AE9D</span>, <span class="number">0x9886928C</span>, <span class="number">0x05577A22</span>, <span class="number">0xB425E19F</span>, <span class="number">0x124D4F63</span>, <span class="number">0xE26F66D1</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LK_VOID lk_sm4_init(LK_VOID *p_context, UCHAR *ekey)</span><br><span class="line">&#123;</span><br><span class="line">    //进行密钥扩展,生成轮转密钥rk</span><br><span class="line">    LK_SM4_INIT(p_context, ekey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LK_VOID lk_sm4_enc(LK_VOID *p_context)</span><br><span class="line">&#123;</span><br><span class="line">    LK_SM4_ENC_F(p_context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LK_VOID lk_sm4_dec(LK_VOID *p_context)</span><br><span class="line">&#123;</span><br><span class="line">    LK_SM4_DEC_F(p_context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LK_INT main(LK_VOID)</span><br><span class="line">&#123;</span><br><span class="line">    LK_INT i;</span><br><span class="line">    lk_sm4_context_t context;</span><br><span class="line">    UCHAR ekey[<span class="number">16</span>] = &#123; <span class="number">0x0b</span>,<span class="number">0x18</span>,<span class="number">0x18</span>,<span class="number">0x29</span>,<span class="number">0x16</span>,<span class="number">0x3a</span>,<span class="number">0x5e</span>,<span class="number">0x27</span>,<span class="number">0x1e</span>,<span class="number">0x2b</span>,<span class="number">0x5f</span>,<span class="number">0x3f</span>,<span class="number">0x32</span>,<span class="number">0x07</span>,<span class="number">0x5c</span>,<span class="number">0x56</span> &#125;;</span><br><span class="line">    UCHAR data[<span class="number">16</span>] = &#123; <span class="number">0xf7</span>,<span class="number">0xeb</span>,<span class="number">0x5e</span>,<span class="number">0x87</span>,<span class="number">0x17</span>,<span class="number">0x9c</span>,<span class="number">0x74</span>,<span class="number">0x94</span>,<span class="number">0x44</span>,<span class="number">0xb5</span>,<span class="number">0xf5</span>,<span class="number">0x12</span>,<span class="number">0xf9</span>,<span class="number">0x74</span>,<span class="number">0x15</span>,<span class="number">0x5f</span> &#125;;</span><br><span class="line">    //初始化</span><br><span class="line">    lk_sm4_init(&amp;context, ekey);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    //待加密数据填充</span><br><span class="line">//    memcpy(context.buf, data, sizeof(data));</span><br><span class="line">//    //对数据进行加密</span><br><span class="line">//    lk_sm4_enc(&amp;context);</span><br><span class="line">//    //打印密文值</span><br><span class="line">//    printf(<span class="string">&quot;enc data:&quot;</span>);</span><br><span class="line">//    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LK_GCHAR_SIZE; i++)</span><br><span class="line">//        printf(<span class="string">&quot; %02x &quot;</span>, context.ebuf[i]);</span><br><span class="line">//    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //待解密的对象</span><br><span class="line">    printf(<span class="string">&quot;enc data：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sizeof(data) ; i++)</span><br><span class="line">        printf(<span class="string">&quot; %02x &quot;</span>, data[i]);</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    //对数据进行解密</span><br><span class="line">    memcpy(context.ebuf, data, sizeof(data));</span><br><span class="line">    lk_sm4_dec(&amp;context);</span><br><span class="line">    //打印解密数据</span><br><span class="line">    printf(<span class="string">&quot;dec data:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LK_GCHAR_SIZE; i++)</span><br><span class="line">        printf(<span class="string">&quot; %02x &quot;</span>, context.buf[i]);</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/images/DASCTF-Oct/image-20220320092347815.png" alt="image-20220320092347815"></p>
<p>misc  <a href="https://jxswcy.top/da212791.html">DASCTF Oct X writeup | jxswcy’s blog</a></p>
<h2 id="魔法叠加"><a href="#魔法叠加" class="headerlink" title="魔法叠加"></a>魔法叠加</h2><p>知识点：</p>
<blockquote>
<ul>
<li>pyc文件头部（py3.7）</li>
<li>base91解密</li>
</ul>
</blockquote>
<h3 id="修改pyc头部"><a href="#修改pyc头部" class="headerlink" title="修改pyc头部"></a>修改pyc头部</h3><p>文件头部修改成如图所示 这里是python3.7</p>
<p>这个pyc是python3.7的版本 ，所以修改magic头部为 42 0D，后面34 改为32，因为要减去两个多出来的字节</p>
<p><img src="/images/DASCTF-Oct/image-20220319095943868.png" alt="image-20220319095943868"></p>
<p>在网上找到一个pyc的文件头部（对比着来修改）<img src="/images/DASCTF-Oct/image-20220319102000542.png" alt="image-20220319102000542"></p>
<h3 id="unemployee6反编译"><a href="#unemployee6反编译" class="headerlink" title="unemployee6反编译"></a>unemployee6反编译</h3><p>修改完pyc的文件头部之后，用unemployee6进行反编译（看到下面的命名方式，可以自行修改一下命名）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uncompyle6 version 3.8.1.dev0</span></span><br><span class="line"><span class="comment"># Python bytecode 3.7.0 (3394)</span></span><br><span class="line"><span class="comment"># Decompiled from: Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)]</span></span><br><span class="line"><span class="comment"># Embedded file name: ./2.py</span></span><br><span class="line"><span class="comment"># Compiled at: 2021-10-20 11:56:04</span></span><br><span class="line"><span class="comment"># Size of source mod 2**32: 1928 bytes</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">O0O00O00O00O0O00O = [</span><br><span class="line"> <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;@&#x27;</span>, <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;`&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;~&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">O000O00000OO00OOO</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">    OOOO00OOO00O000OO = <span class="number">0</span></span><br><span class="line">    OOOOOOOOOO00O0OOO = <span class="number">0</span></span><br><span class="line">    OO0OOO000000OOOOO = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> O0O0OO0OOOOOOOO00 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(O000O00000OO00OOO)):</span><br><span class="line">        O000O0OOOOO00O0O0 = O000O00000OO00OOO[O0O0OO0OOOOOOOO00:O0O0OO0OOOOOOOO00 + <span class="number">1</span>]</span><br><span class="line">        OOOO00OOO00O000OO |= struct.unpack(<span class="string">&#x27;B&#x27;</span>, O000O0OOOOO00O0O0)[<span class="number">0</span>] &lt;&lt; OOOOOOOOOO00O0OOO</span><br><span class="line">        OOOOOOOOOO00O0OOO += <span class="number">8</span></span><br><span class="line">        <span class="keyword">if</span> OOOOOOOOOO00O0OOO &gt; <span class="number">13</span>:</span><br><span class="line">            OO00O0OO00OOO000O = OOOO00OOO00O000OO &amp; <span class="number">8191</span></span><br><span class="line">            <span class="keyword">if</span> OO00O0OO00OOO000O &gt; <span class="number">88</span>:</span><br><span class="line">                OOOO00OOO00O000OO &gt;&gt;= <span class="number">13</span></span><br><span class="line">                OOOOOOOOOO00O0OOO -= <span class="number">13</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                OO00O0OO00OOO000O = OOOO00OOO00O000OO &amp; <span class="number">16383</span></span><br><span class="line">                OOOO00OOO00O000OO &gt;&gt;= <span class="number">14</span></span><br><span class="line">                OOOOOOOOOO00O0OOO -= <span class="number">14</span></span><br><span class="line">            OO0OOO000000OOOOO += O0O00O00O00O0O0O0[(OO00O0OO00OOO000O % <span class="number">91</span>)] + O0O00O00O00O0O0O0[(OO00O0OO00OOO000O // <span class="number">91</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> OOOOOOOOOO00O0OOO:</span><br><span class="line">        OO0OOO000000OOOOO += O0O00O00O00O0O0O0[(OOOO00OOO00O000OO % <span class="number">91</span>)]</span><br><span class="line">        <span class="keyword">if</span> OOOOOOOOOO00O0OOO &gt; <span class="number">7</span> <span class="keyword">or</span> OOOO00OOO00O000OO &gt; <span class="number">90</span>:</span><br><span class="line">            OO0OOO000000OOOOO += O0O00O00O00O0O0O0[(OOOO00OOO00O000OO // <span class="number">91</span>)]</span><br><span class="line">    <span class="keyword">return</span> OO0OOO000000OOOOO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O0O00O00O00O0O0O0 = []</span><br><span class="line">OO000O00O00O0O0O0 = []</span><br><span class="line">O0O0O0O0000O0O00O = <span class="built_in">input</span>(<span class="string">&#x27;plz input O0O0O0O0000O0O00O:\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">52</span>):</span><br><span class="line">    O0O00O00O00O0O0O0 = O0O00O00O00O0O00O[i:] + O0O00O00O00O0O00O[<span class="number">0</span>:i]</span><br><span class="line">    O0O0O0O0000O0O00O = encode(O0O0O0O0000O0O00O.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">dic = <span class="built_in">open</span>(<span class="string">&#x27;./00.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">dic.write(O0O0O0O0000O0O00O)</span><br><span class="line">dic.close</span><br><span class="line"><span class="comment"># okay decompiling D:\re\buuctf\buu\ħ������\magic.pyc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面给的数组的长度是91 并且每次模的对象也是91，所以这里应该是[base91](<a href="https://github.com/aberaud/base91-python">aberaud/base91-python: A python implementation of Base91 as described on http://base91.sourceforge.net/ (github.com)</a>)</p>
<p>整理得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct</span><br><span class="line">key = [</span><br><span class="line"> &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;!&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;, &#x27;&quot;&#x27;]</span><br><span class="line"></span><br><span class="line">def encode(num):</span><br><span class="line">    &quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">    tem1 = 0</span><br><span class="line">    tem2 = 0</span><br><span class="line">    temstr = &#x27;&#x27;</span><br><span class="line">    for i in range(len(num)):</span><br><span class="line">        tem = num[i:i + 1]</span><br><span class="line">        tem1 |= struct.unpack(&#x27;B&#x27;, tem)[0] &lt;&lt; tem2</span><br><span class="line">        tem2 += 8</span><br><span class="line">        if tem2 &gt; 13:</span><br><span class="line">            tem0 = tem1 &amp; 8191</span><br><span class="line">            if tem0 &gt; 88:</span><br><span class="line">                tem1 &gt;&gt;= 13</span><br><span class="line">                tem2 -= 13</span><br><span class="line">            else:</span><br><span class="line">                tem0 = tem1 &amp; 16383</span><br><span class="line">                tem1 &gt;&gt;= 14</span><br><span class="line">                tem2 -= 14</span><br><span class="line">            temstr += key2[(tem0 % 91)] + key2[(tem0 // 91)]</span><br><span class="line"></span><br><span class="line">    if tem2:</span><br><span class="line">        temstr += key2[(tem1 % 91)]</span><br><span class="line">        if tem2 &gt; 7 or tem1 &gt; 90:</span><br><span class="line">            temstr += key2[(tem1 // 91)]</span><br><span class="line">    return temstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key2 = []</span><br><span class="line">OO000O00O00O0O0O0 = []</span><br><span class="line">text = input(&#x27;plz input text:\n&#x27;)</span><br><span class="line">for i in range(0, 52):</span><br><span class="line">    key2 = key[i:] + key[0:i]</span><br><span class="line">    text = encode(text.encode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">dic = open(&#x27;./00.txt&#x27;, &#x27;a&#x27;)</span><br><span class="line">dic.write(text)</span><br><span class="line">dic.close</span><br></pre></td></tr></table></figure>

<h3 id="base91的解密"><a href="#base91的解密" class="headerlink" title="base91的解密"></a>base91的解密</h3><p>加密解密base91的<strong>官方文档</strong>（注意每个函数参数类型）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct</span><br><span class="line"></span><br><span class="line">base91_alphabet = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;,</span><br><span class="line">	&#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;,</span><br><span class="line">	&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;,</span><br><span class="line">	&#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;,</span><br><span class="line">	&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;!&#x27;, &#x27;#&#x27;, &#x27;$&#x27;,</span><br><span class="line">	&#x27;%&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;,</span><br><span class="line">	&#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;, &#x27;&quot;&#x27;]</span><br><span class="line"></span><br><span class="line">decode_table = dict((v,k) for k,v in enumerate(base91_alphabet))</span><br><span class="line"></span><br><span class="line">def decode(encoded_str):</span><br><span class="line">    &#x27;&#x27;&#x27; Decode Base91 string to a bytearray &#x27;&#x27;&#x27;</span><br><span class="line">    v = -1</span><br><span class="line">    b = 0</span><br><span class="line">    n = 0</span><br><span class="line">    out = bytearray()</span><br><span class="line">    for strletter in encoded_str:</span><br><span class="line">        if not strletter in decode_table:</span><br><span class="line">            continue</span><br><span class="line">        c = decode_table[strletter]</span><br><span class="line">        if(v &lt; 0):</span><br><span class="line">            v = c</span><br><span class="line">        else:</span><br><span class="line">            v += c*91</span><br><span class="line">            b |= v &lt;&lt; n</span><br><span class="line">            n += 13 if (v &amp; 8191)&gt;88 else 14</span><br><span class="line">            while True:</span><br><span class="line">                out += struct.pack(&#x27;B&#x27;, b&amp;255)</span><br><span class="line">                b &gt;&gt;= 8</span><br><span class="line">                n -= 8</span><br><span class="line">                if not n&gt;7:</span><br><span class="line">                    break</span><br><span class="line">            v = -1</span><br><span class="line">    if v+1:</span><br><span class="line">        out += struct.pack(&#x27;B&#x27;, (b | v &lt;&lt; n) &amp; 255 )</span><br><span class="line">    return out</span><br><span class="line"></span><br><span class="line">def encode(bindata):</span><br><span class="line">    &#x27;&#x27;&#x27; Encode a bytearray to a Base91 string &#x27;&#x27;&#x27;</span><br><span class="line">    b = 0</span><br><span class="line">    n = 0</span><br><span class="line">    out = &#x27;&#x27;</span><br><span class="line">    for count in range(len(bindata)):</span><br><span class="line">        byte = bindata[count:count+1]</span><br><span class="line">        b |= struct.unpack(&#x27;B&#x27;, byte)[0] &lt;&lt; n</span><br><span class="line">        n += 8</span><br><span class="line">        if n&gt;13:</span><br><span class="line">            v = b &amp; 8191</span><br><span class="line">            if v &gt; 88:</span><br><span class="line">                b &gt;&gt;= 13</span><br><span class="line">                n -= 13</span><br><span class="line">            else:</span><br><span class="line">                v = b &amp; 16383</span><br><span class="line">                b &gt;&gt;= 14</span><br><span class="line">                n -= 14</span><br><span class="line">            out += base91_alphabet[v % 91] + base91_alphabet[v // 91]</span><br><span class="line">    if n:</span><br><span class="line">        out += base91_alphabet[b % 91]</span><br><span class="line">        if n&gt;7 or b&gt;90:</span><br><span class="line">            out += base91_alphabet[b // 91]</span><br><span class="line">    return out</span><br></pre></td></tr></table></figure>

<p>通过上面的循环我们可以知道一共进行了52次循环，所以利用对应每次变换得到的表进行每次的base91的解密</p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct</span><br><span class="line">base91_alphabet = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;,</span><br><span class="line">	&#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;,</span><br><span class="line">	&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;,</span><br><span class="line">	&#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;,</span><br><span class="line">	&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;!&#x27;, &#x27;#&#x27;, &#x27;$&#x27;,</span><br><span class="line">	&#x27;%&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;,</span><br><span class="line">	&#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;, &#x27;&quot;&#x27;]</span><br><span class="line"></span><br><span class="line">def decode(encoded_str):</span><br><span class="line">    &#x27;&#x27;&#x27; Decode Base91 string to a bytearray &#x27;&#x27;&#x27;</span><br><span class="line">    v = -1</span><br><span class="line">    b = 0</span><br><span class="line">    n = 0</span><br><span class="line">    out = b&#x27;&#x27;</span><br><span class="line">    for strletter in encoded_str():   </span><br><span class="line">        if not strletter in decode_table:</span><br><span class="line">            continue</span><br><span class="line">        c = decode_table[strletter]</span><br><span class="line">        if(v &lt; 0):</span><br><span class="line">            v = c</span><br><span class="line">        else:</span><br><span class="line">            v += c*91</span><br><span class="line">            b |= v &lt;&lt; n</span><br><span class="line">            n += 13 if (v &amp; 8191)&gt;88 else 14</span><br><span class="line">            while True:</span><br><span class="line">                out += struct.pack(&#x27;B&#x27;, b&amp;255)</span><br><span class="line">                b &gt;&gt;= 8</span><br><span class="line">                n -= 8</span><br><span class="line">                if not n&gt;7:</span><br><span class="line">                    break</span><br><span class="line">            v = -1</span><br><span class="line">    if v+1:</span><br><span class="line">        out += struct.pack(&#x27;B&#x27;, (b | v &lt;&lt; n) &amp; 255 )</span><br><span class="line">    return out</span><br><span class="line"></span><br><span class="line">with open(&quot;D:\\re\\buuctf\\buu\魔法叠加\\00.txt&quot;,&#x27;rb&#x27;) as f:</span><br><span class="line">    data = f.read()</span><br><span class="line">for i in range(51,-1,-1):</span><br><span class="line">    tem  = base91_alphabet[i:] + base91_alphabet[0:i]</span><br><span class="line">    decode_table = dict((v, k) for k, v in enumerate(tem))</span><br><span class="line">    data = decode(data.decode()) # 该函数之中传入的参数应该是字符串型 但是我们得到的是byte类型 所以需要decoed() 将byte转换成string类型的数据</span><br><span class="line">    print(i)</span><br><span class="line">print(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意byte 和 石头人相互转换的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># str to bytes</span><br><span class="line"> str.encode(s)</span><br><span class="line"></span><br><span class="line"> # bytes to str</span><br><span class="line"> bytes.decode(b)</span><br></pre></td></tr></table></figure>

<p>因为解密的长度太长了，所以就直接用别人跑出来的结果</p>
<p><img src="/images/DASCTF-Oct/image-20220319124833684.png" alt="image-20220319124833684"></p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>base91解密</tag>
        <tag>SM4解密</tag>
      </tags>
  </entry>
  <entry>
    <title>SUSCTF_tttree（使用idapython去混淆的学习）</title>
    <url>/2022/03/06/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="SUSCTF-tttree（使用idapython去混淆的学习）"><a href="#SUSCTF-tttree（使用idapython去混淆的学习）" class="headerlink" title="SUSCTF_tttree（使用idapython去混淆的学习）"></a>SUSCTF_tttree（使用idapython去混淆的学习）</h1><p>这道题里面有大量的相同结构的混淆，所以采用了idapython的方式解混淆，这道题需要就是学习用idapython解混淆的过程。后面的平衡树的算法太难了，就没有继续往下解了。</p>
<h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><p>这里面有两个混淆，出题人声称采用了 这里参考了古月浪子大佬的一个混淆思路。</p>
<h3 id="混淆一"><a href="#混淆一" class="headerlink" title="混淆一"></a>混淆一</h3><p>重构序列</p>
<p><strong>花指令形式特征</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push rax </span><br><span class="line">push rax </span><br><span class="line">pushfq </span><br><span class="line">call $+5 </span><br><span class="line">pop rax </span><br><span class="line">add rax,xxxx </span><br><span class="line">push rax </span><br><span class="line">mov [rsp+10h], rax </span><br><span class="line">popfq </span><br><span class="line">pop rax</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：</p>
<p>当该花指令的后面接着的是retn这个指令的时候，就是跳转到这个计算得到的地址</p>
<p>当该花指令的后面接着的是jmp addr2这个指令时，相当于call addr2（addr1就是这个指令之后的返回地址）</p>
<p><strong>解混淆的方法</strong>：</p>
<p>如果是retn指令时:通过“pop rax”和”add rax,xxxx”这两个指令计算得到需要jmp的偏移地址，将jmp+偏移地址的指令写入花指令这个地方的地址，其余空间地址“nop”</p>
<p>如果时jmp addr2指令时，先将这个“pop rax”和”add rax,xxxx”这两个指令计算得到的目标地址（注意这个地方不是相对地址）push，将push+目标地址的指令写入花指令的地址，其余空间地址“nop”。然后先jmp “jmp addr2”的地址，再jmp “push”指令里面的地址</p>
<p>该程序之中的<strong>示例</strong>：</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306092253733.png" alt="image-20220306092253733"></p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306092311317.png" alt="image-20220306092311317"></p>
<h3 id="混淆二"><a href="#混淆二" class="headerlink" title="混淆二"></a>混淆二</h3><p><strong>无效push 和 pop</strong></p>
<p>花指令形式特征</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push [rax|...] </span><br><span class="line">pop [rax|...]</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：push之后马上pop出来，显然这个指令时无效的</p>
<p><strong>解混淆的方法</strong>：直接pop掉这两句就可以了</p>
<p>该程序之中的示例:</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306093739567.png" alt="image-20220306093739567"></p>
<h3 id="idapython脚本"><a href="#idapython脚本" class="headerlink" title="idapython脚本"></a>idapython脚本</h3><p><a href="https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/">idapython的教程</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct</span><br><span class="line">start = 0x140001000  #起始位置</span><br><span class="line">end = 0x14001C694    #结束位置</span><br><span class="line">address_m = [0 for x in range(11)]</span><br><span class="line">address_target = [&#x27;push    rax&#x27;,&#x27;push    rax&#x27;,&#x27;pushfq&#x27;,&#x27;call    $+5&#x27;,&#x27;pop     rax&#x27;,&#x27;add     rax,&#x27;,&#x27;mov &#x27;,&#x27;popfq&#x27;,&#x27;pop     rax&#x27;,&#x27;retn&#x27;]</span><br><span class="line">  # 第一种花指令的特征 注意这个里面的每一条指令中间的空格数都要和ida之中展示的汇编代码相同，所以最好是进行复制粘贴</span><br><span class="line"></span><br><span class="line">def check1():</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i in range(9):</span><br><span class="line">        if i == 5 or i == 6:</span><br><span class="line">            cnt += GetDisasm(address_m[i]).find(address_target[i]) != -1 # GetDisasm：获得对应位置的汇编地址 因为&#x27;add rax,&#x27;,&#x27;mov &#x27;这两个指令中有数据，每个部分的代码就会不一样，所以使用find函数来判断是否存在</span><br><span class="line">        else:</span><br><span class="line">            cnt += GetDisasm(address_m[i]) == address_target[i] # 除了那两个语句以外就需要判断剩下的这些语句是否相等就可以了</span><br><span class="line">    return cnt == 9  # 如果9条语句都和目标类型已知 就认为是第一种花指令</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def check2(x,y):</span><br><span class="line">    cnt = 0</span><br><span class="line">    cnt += print_insn_mnem(x) == &quot;push&quot; # idc.print_insn_mnem()获取操作符 判断操作符是否是push指令</span><br><span class="line">    cnt += print_insn_mnem(y) == &quot;pop&quot;  # idc.print_insn_mnem(y)获取操作符 判断操作符是否是 pop 指令</span><br><span class="line">    cnt += print_operand(x,0) == print_operand(y,0) # idc.print_operand(x, 0) 获取第一个操作数 判断这两个指令的操作数是否相等</span><br><span class="line">    return cnt == 3  # 当以上的三个条件都满足的时候就是第二种花指令</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def check3():</span><br><span class="line">    cnt = 0</span><br><span class="line">    cnt += print_insn_mnem(address_m[0]) == &quot;push&quot; # print_insn_mnem获取操作符 判断操作符是否是push</span><br><span class="line">    cnt += get_operand_type(address_m[0], 0) == o_imm # 如果操作数是一个确定的数值的话，那么返回类型，值为 5</span><br><span class="line">    return cnt == 2</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def nop(u,v): # u是指令的起始地址 v是结束的地址，但是v地址的指令不会被nop</span><br><span class="line">    patch_add = u</span><br><span class="line">    while(patch_add &lt; v):</span><br><span class="line">        patch_byte(patch_add,0x90)</span><br><span class="line">        patch_add += 1</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">p = start</span><br><span class="line">while p &lt;= end:</span><br><span class="line">    address_m[0] = p</span><br><span class="line">    p = next_head(p)   # 利用了 idc.next_head()使当前地址不断增长</span><br><span class="line"></span><br><span class="line">    # 将第二种花指令进行nop</span><br><span class="line">    while print_insn_mnem(p) == &quot;nop&quot;: # 如果是nop语句就跳过</span><br><span class="line">        p = next_head(p)</span><br><span class="line">    if check2(address_m[0], p) == 1: # 判断这两个连续的语句是否是满足第二种花指令的要求</span><br><span class="line">        p = next_head(p) # p定位到第二种花指令结束之后那个地址</span><br><span class="line">        nop(address_m[0], p) # address_m[0]是nop的起始位置  p是nop的结束位置</span><br><span class="line">    else:</span><br><span class="line">        p = address_m[0] # 如果不是花指令起点又回到最初的那个地方</span><br><span class="line"></span><br><span class="line">    # 将第一种花指令nop</span><br><span class="line">    address_m[0] = p # 将起始的地址放入到数组的第一项之中</span><br><span class="line">    for i in range(1, 11): # 判断这个地方连续的10条指令是否满足第一种花指令的要求，取出这10条指令的地址放入到数组之中</span><br><span class="line">        address_m[i] = next_head(address_m[i - 1])</span><br><span class="line"></span><br><span class="line">    if check1() == 1: # 判断是否是第一种花指令</span><br><span class="line">        addri = get_operand_value(address_m[5], 1) # get_operand_value(address_m[5], 1)  获取操作数的数值 即该条 &#x27;add rax,&#x27; 命令的第二个操作数的数值</span><br><span class="line">        addri += address_m[4]  # rax加上操作数，得到目标地址 x+a4-a0-5</span><br><span class="line">        if address_target[9] == GetDisasm(address_m[9]):  # 当最后一条指令是ret时</span><br><span class="line">            addri -= (address_m[0] + 5)</span><br><span class="line">            patch_byte(address_m[0], 0xE9) # 将这个地方的值修改为 0xE9 就是jmp指令 因为 0xE9 JMP 后面的四个字节是偏移 所以这里addri需要计算成偏移地址</span><br><span class="line">            patch_dword(address_m[0] + 1, addri &amp; 0xffffffff) # dw的数值来存放目标的地址</span><br><span class="line">            nop(address_m[0] + 5, address_m[10]) # 将剩下的nop掉</span><br><span class="line">            p = address_m[10]</span><br><span class="line">        else:</span><br><span class="line">            patch_byte(address_m[0], 0x68) # 0x68是push 入栈的操作</span><br><span class="line">            patch_dword(address_m[0] + 1, addri &amp; 0xffffffff) # 将对应的地址push</span><br><span class="line">            nop(address_m[0] + 5, address_m[9])</span><br><span class="line">            p = address_m[9]</span><br><span class="line">    else:</span><br><span class="line">        p = address_m[1] # 指向下一个指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对第一种花指令中结尾是push的操作</span><br><span class="line">p = start # 从程序的开始进行遍历</span><br><span class="line">while p &lt;= end:</span><br><span class="line">    address_m[0] = p</span><br><span class="line">    address_m[1] = next_head(p)</span><br><span class="line">    if check3() == 1: # 当指令满足check3()中指令的要求时进行的操作</span><br><span class="line">        addri = get_operand_value(address_m[0], 0) + 2 ** 32 # get_operand_value 获取push的地址的值   2 ** 32代表2的32次方</span><br><span class="line">        p = address_m[1]   # push指令后的下一条指令</span><br><span class="line">        while print_insn_mnem(p) == &quot;nop&quot;: # 如果遇到nop指令就跳过</span><br><span class="line">            p += 1</span><br><span class="line">        if print_insn_mnem(p) == &quot;jmp&quot;: # 如果是jmp指令</span><br><span class="line">            addrj = struct.unpack(&#x27;&lt;I&#x27;, get_bytes(p + 1, 4))[0] + p - address_m[0] # struct.unpack(&#x27;&lt;I&#x27;, get_bytes(p + 1, 4)) 利用小序端取得地址 这个得到的是一个元组 这条jmp指令的起始位置 减去上一条指令的位置</span><br><span class="line">            addri -= p + 5 # push的地址 减去jmp地址结束的那个地址</span><br><span class="line">            if addri &lt; 0:</span><br><span class="line">                addri += 2 ** 32 # 保持addri这个地址始终大于0</span><br><span class="line">            patch_byte(address_m[0], 0xe8) # 0xE8 CALL 后面的四个字节是地址</span><br><span class="line">            patch_dword(address_m[0] + 1, addrj &amp; 0xffffffff)</span><br><span class="line">            patch_byte(p, 0xe9) # 0xE9 JMP 后面的四个字节是偏移</span><br><span class="line">            p += 1</span><br><span class="line">            patch_dword(p, addri)# 需要跳转到的偏移地址</span><br><span class="line">            p += 4</span><br><span class="line">    else:</span><br><span class="line">        p = address_m[1] # 下一个指令</span><br><span class="line">print(&quot;Finish&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="idapython脚本学习"><a href="#idapython脚本学习" class="headerlink" title="idapython脚本学习"></a>idapython脚本学习</h2><p>idapython的指令<a href="https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/">查询</a></p>
<h3 id="跳转指令和机器码"><a href="#跳转指令和机器码" class="headerlink" title="跳转指令和机器码"></a>跳转指令和机器码</h3><p>注意相同的指令，但是不同的机器码后面所跟着的地址的要求是不一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xE8 CALL 后面的四个字节是地址</span><br><span class="line">0xE9 JMP 后面的四个字节是偏移</span><br><span class="line">0xEB JMP 后面的二个字节是偏移</span><br><span class="line">0xFF15 CALL 后面的四个字节是存放地址的地址</span><br><span class="line">0xFF25 JMP 后面的四个字节是存放地址的地址</span><br><span class="line"></span><br><span class="line">0x68 PUSH 后面的四个字节入栈</span><br><span class="line">0x6A PUSH 后面的一个字节入栈</span><br><span class="line">对于每条指令我们检查他的操作数类型是否为 o_imm(值为 5)，o_imm 类型的操作数就是一个确定的数值或者偏移，一旦这个发现这种类型的操作数</span><br></pre></td></tr></table></figure>

<h3 id="常用到的idapython的函数"><a href="#常用到的idapython的函数" class="headerlink" title="常用到的idapython的函数"></a>常用到的idapython的函数</h3><p>对指令（操作符 操作数等）进行操作的函数：</p>
<ul>
<li>**GetDisasm(ea)**：获得ea这个地址的汇编代码</li>
<li><strong>print_insn_mnem(ea)<strong>：获取ea这个地址的</strong>操作符</strong></li>
<li><strong>print_operand(ea, 0)</strong>:获取当前地址<strong>操作数</strong>。例如获取“MOV AH，06H“指令的AH这个操作数</li>
<li><strong>get_operand_value(ea, n)<strong>：获取</strong>操作数的数值</strong></li>
<li><strong>next_head(ea)<strong>：获取</strong>下一个</strong>指令地址 </li>
<li><strong>prev_head(ea)<strong>：获取</strong>上一个</strong>指令地址</li>
<li><strong>next_addr(ea)<strong>：获取</strong>下一个</strong>地址</li>
<li><strong>prev_addr(ea)<strong>：获取</strong>上一个</strong>地址</li>
<li>**get_operand_type(ea,n)**：获取操作数类型。其返回类型有八种 + 不同的处理器 6 种，这道题之中的o_imm代表是一个确定的数值。还有其它的类型，可以查看上面的那个网址</li>
</ul>
<p>补丁：</p>
<ul>
<li><strong>patch_byte/patch_word/patch_dword/patch_qword(ea, value)</strong>:打补丁，反调试  混淆等等都用得到，修改相应的机器码等，比如这道题之中的指令 patch_byte(address_m[0], 0xe8) 就是修改这个地址的机器码为0xe8 这个jmp指令</li>
</ul>
<p>机器码式搜索：</p>
<ul>
<li>**FindBinary(ea,flag, searchstr, radix=16)**：实行字节或者二进制的搜索。ea代表地址，flag 代表搜索方向或者条件（有具体的参数可以选择，根据需要查表填入）比如说SEARCH_UP和SEARCH_DOWN 用来指明搜索的方向。searchstr代表的是字节字符串，形如’55 48 89 E5’这个样子的</li>
</ul>
<p>对汇编之中函数操作的函数：</p>
<ul>
<li>**idautils.Functions()**：获取函数列表，使用for循环的方式遍历所有的这些地址，然后对每个函数对象进行相应的操作。例如 get_func_name(func) func就是这个函数列表之中的一个对象，这个函数获取这个函数对象的名称。</li>
<li>**get_func_attr(func, FUNCATTR_FLAGS)**：信息收集函数，可以用来检索关于函数的信息，例如它是否是库中代码，或者函数是否有返回值等。对于一个函数来说有九个可能的标志。</li>
</ul>
<h2 id="python函数说明"><a href="#python函数说明" class="headerlink" title="python函数说明"></a>python函数说明</h2><h3 id="struct-pack-和struct-unpack"><a href="#struct-pack-和struct-unpack" class="headerlink" title="struct.pack()和struct.unpack()"></a>struct.pack()和struct.unpack()</h3><p>使用这两个函数需要使用struct包</p>
<p>**struct.pack(fmt,v1,v2,…..)**：将v1,v2等参数的值进行一层包装，包装的方法由fmt指定。被包装的参数必须严格符合fmt。最后返回一个包装后的字符串。 将数据转换成c语言之中相应的存储的形式。</p>
<p><strong>struct.unpack(fmt,string)<strong>：顾名思义，解包。返回一个由解包数据(string)得到的一个</strong>元组(tuple)</strong>, 即使仅有一个数据也会被解包成元组。其中len(string) 必须等于 calcsize(fmt)，这里面涉及到了一个calcsize函数。struct.calcsize(fmt)：这个就是用来计算fmt格式所描述的结构的大小。</p>
<p><strong>fmt的构造</strong>：</p>
<p>格式字符串(format string)由一个或多个格式字符(format characters)组成</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306114015713.png" alt="image-20220306114015713"></p>
<p>在Format string 的首位，有一个可选字符来决定大端和小端：</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306114148873.png" alt="image-20220306114148873"></p>
<p>例子：</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306152233838.png" alt="image-20220306152233838"></p>
<h3 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a>find()函数</h3><p><strong>描述</strong>：Python find() 方法检测字符串中<strong>是否包含子字符串 str</strong> 。如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在<strong>指定范围</strong>内，如果包含子字符串返回开始的索引值，否则返回-1</p>
<p><strong>语法</strong>：str.find(str, beg=0, end=len(string))  </p>
<ul>
<li>str – 指定检索的字符串</li>
<li>beg – 开始索引，默认为0。</li>
<li>end – 结束索引，默认为字符串的长度。</li>
</ul>
<p><strong>返回值</strong>：如果包含子字符串返回开始的索引值，否则返回-1。</p>
<p><strong>注意</strong>：寻找目的是搜索的对象（子字符串）是不是在这串字符串里面，不在于它（子字符串）的位置在哪里。子字符串之中的空格是不能忽视的，并且搜索对象（子字符串）在字符串之中必须是连续完整存在的，这样才能说明字符串中包含了子字符串 str。</p>
<p>参考文章：<a href="https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/">https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/</a></p>
]]></content>
      <categories>
        <category>混淆</category>
      </categories>
      <tags>
        <tag>idapython</tag>
      </tags>
  </entry>
  <entry>
    <title>TEA系列加密解密</title>
    <url>/2022/02/28/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h1 id="TEA系列加密解密"><a href="#TEA系列加密解密" class="headerlink" title="TEA系列加密解密"></a>TEA系列加密解密</h1><h2 id="TEA加密解密"><a href="#TEA加密解密" class="headerlink" title="TEA加密解密"></a>TEA加密解密</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>在密码学中，微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。</p>
<p>代码的特点： </p>
<ul>
<li>加密使用的数据为2个32位无符号整数，密钥为4个32位无符号整数即密钥长度为128位（当加密解密的对象是一串数组的时候，需要将这个32位无符号整数的数组<strong>每两个32位无符号整数划分为一组</strong>，对每一组数据单独加密解密得到结果）</li>
<li>该算法使用了一个常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 <strong>0×9E3779B9</strong>）作为魔数</li>
</ul>
</blockquote>
<h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>拥有一个叫做<a href="https://en.wikipedia.org/wiki/Feistel_cipher">Feistel 结构</a>的密码学结构。这种密码学结构通俗的来讲就是会将加密的plaintext分成L、R两部分，并且满足 <code>L_&#123;i+1&#125; = R_i, R_&#123;i+1&#125; = F(K_i,R_i) \oplus L_i</code> 这种交换式的加密方式的一种结构。</p>
<p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228191440573.png" alt="image-20220228191440573"></p>
<h3 id="TEA加密算法的实现"><a href="#TEA加密算法的实现" class="headerlink" title="TEA加密算法的实现"></a>TEA加密算法的实现</h3><p>参数要求：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组）</p>
<p>加密特征：存在一个<strong>delta值</strong>，这个值会不停的增加到<strong>sum</strong>之中，形成一种循环的效果；会有一个<strong>位移-&gt;与密钥相加-&gt;异或</strong>的过程；计算delta的sum状态值也会参与</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TEA解密算法的实现"><a href="#TEA解密算法的实现" class="headerlink" title="TEA解密算法的实现"></a>TEA解密算法的实现</h3><p>参数要求：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//解密函数  </span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */  </span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */  </span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */  </span><br><span class="line">    sum = delta &lt;&lt; 5;   //32轮运算，所以是2的5次方；16轮运算，所以是2的4次方；8轮运算，所以是2的3次方</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */  </span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);  </span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">    &#125;                                              /* end cycle */  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>解密数组：{0x3e8947cb,0xcc944639,0x31358388,0x3b0b6893,0xda627361,0x3b2e6427}</p>
<p>key数组：{0x4445,0x4144,0x4245,0x4546}</p>
<p>因为在解密的过程之中会产生移位的运算，这个过程会产生溢出，所以每组解密的对象声明成 <strong>v1[3]={0x3e8947cb,0xcc944639,0x0}</strong> 这样的形式</p>
<p>解密的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */</span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v1[3]=&#123;0x3e8947cb,0xcc944639,0x0&#125;,k[4]=&#123;0x4445,0x4144,0x4245,0x4546&#125;;</span><br><span class="line">    uint32_t v2[3]=&#123;0x31358388,0x3b0b6893,0x0&#125;;</span><br><span class="line">    uint32_t v3[3]=&#123;0xda627361,0x3b2e6427&#125;;</span><br><span class="line">    decrypt(v1, k);</span><br><span class="line">    decrypt(v2, k);</span><br><span class="line">    decrypt(v3, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s %s %s\n&quot;,(char*)v1,(char*)v2,(char*)v3);   // 注意如何将一串数组以字符串的形式输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出的结果：fvBXQdEa rcbvhBPx cOA8Ag6J</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p>printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p>
<p>参数的格式</p>
<p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228193403698.png" alt="image-20220228193403698"></p>
<h2 id="XTEA加密解密"><a href="#XTEA加密解密" class="headerlink" title="XTEA加密解密"></a>XTEA加密解密</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作</p>
</blockquote>
<h3 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228193746682.png" alt="image-20220228193746682"></p>
<h3 id="XTEA加密算法的实现"><a href="#XTEA加密算法的实现" class="headerlink" title="XTEA加密算法的实现"></a>XTEA加密算法的实现</h3><p>相较于TEA的变化：</p>
<ul>
<li>由之前的**<code>((v1&lt;&lt;4) + k0) ^ ((v1&gt;&gt;5) + k1)</code>** 变化成了 **<code>((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1)</code>**，此时v1内部数据的加密变化不再受到密钥的影响。</li>
<li>原先的<code>v1 + sum</code>变成了<code>(sum + key[sum &amp; 3])</code>以及<code>sum + key[(sum&gt;&gt;11) &amp; 3]</code>，密钥变成了<strong>轮转</strong>使用，而不是固定只针对某种数据进行加密（解密）。并且此时密钥的选取<strong>受到sum的影响</strong></li>
<li><code>sum += delta</code>的时机由每次加密开头就发生变化到v0，v1<strong>两个block加密的中间</strong>。</li>
</ul>
<p>输入的参数：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组），注意这里循环的次数不是固定的了，是需要传入的参数<strong>num_rounds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  </span><br><span class="line">    unsigned int i;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;  </span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  </span><br><span class="line">        sum += delta;  </span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="XTEA解密算法的实现"><a href="#XTEA解密算法的实现" class="headerlink" title="XTEA解密算法的实现"></a>XTEA解密算法的实现</h3><p>输入的参数：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组），注意这里循环的次数不是固定的了，是需要传入的参数<strong>num_rounds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  </span><br><span class="line">    unsigned int i;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;  </span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */</span><br><span class="line"></span><br><span class="line">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[3]=&#123;0x73647979,0x726b6f5f,0x0&#125;;</span><br><span class="line">    uint32_t v1[2]=&#123;0x646f675f,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]=&#123;0X95C4C,0X871D,0X1A7B7,0X12C7C7&#125;;</span><br><span class="line">    unsigned int r=32;//num_rounds建议取值为32</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line">    printf(&quot;加密前原始数据：%s%s\n&quot;,(char*)v,(char*)v1);</span><br><span class="line">    encipher(r, v, k);</span><br><span class="line">    encipher(r, v1, k);</span><br><span class="line">    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v1[0]);</span><br><span class="line">    decipher(r, v, k);</span><br><span class="line">    decipher(r, v1, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s%s\n&quot;,(char*)v,(char*)v1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">加密前原始数据：yyds_okr_god</span><br><span class="line">加密后的数据：3461349474 1314311102 3609197830</span><br><span class="line">解密后的数据：yyds_okr_god</span><br></pre></td></tr></table></figure>

<h2 id="XXTEA加密解密"><a href="#XXTEA加密解密" class="headerlink" title="XXTEA加密解密"></a>XXTEA加密解密</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>XTEA再度进化， 变成了支持块加密<code>XXTEA</code></p>
</blockquote>
<h3 id="加密过程-2"><a href="#加密过程-2" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228200301853.png" alt="image-20220228200301853"></p>
<h3 id="XXTEA加密解密算法的实现"><a href="#XXTEA加密解密算法的实现" class="headerlink" title="XXTEA加密解密算法的实现"></a>XXTEA加密解密算法的实现</h3><p>特点：在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥, 是目前TEA系列中最安全的算法，但性能较上两种有所降低。</p>
<p>参数：输入的是<strong>至少拥有两个元素的32bit的数组</strong>，密钥的长度仍然是<strong>128位</strong>，即拥有<strong>4个元素32位</strong>长度的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdint.h&gt;  </span><br><span class="line">#define DELTA 0x9e3779b9  </span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))  </span><br><span class="line">  </span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])  </span><br><span class="line">&#123;  </span><br><span class="line">    uint32_t y, z, sum;  </span><br><span class="line">    unsigned p, rounds, e;  </span><br><span class="line">    if (n &gt; 1)            /* Coding Part */  </span><br><span class="line">    &#123;  </span><br><span class="line">        rounds = 6 + 52/n;  </span><br><span class="line">        sum = 0;  </span><br><span class="line">        z = v[n-1];  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            sum += DELTA;  </span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;  </span><br><span class="line">            for (p=0; p&lt;n-1; p++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                y = v[p+1];  </span><br><span class="line">                z = v[p] += MX;  </span><br><span class="line">            &#125;  </span><br><span class="line">            y = v[0];  </span><br><span class="line">            z = v[n-1] += MX;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (--rounds);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */  </span><br><span class="line">    &#123;  </span><br><span class="line">        n = -n;  </span><br><span class="line">        rounds = 6 + 52/n;  </span><br><span class="line">        sum = rounds*DELTA;  </span><br><span class="line">        y = v[0];  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;  </span><br><span class="line">            for (p=n-1; p&gt;0; p--)  </span><br><span class="line">            &#123;  </span><br><span class="line">                z = v[p-1];  </span><br><span class="line">                y = v[p] -= MX;  </span><br><span class="line">            &#125;  </span><br><span class="line">            z = v[n-1];  </span><br><span class="line">            y = v[0] -= MX;  </span><br><span class="line">            sum -= DELTA;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (--rounds);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span><br><span class="line"></span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t y, z, sum;</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n-1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=0; p&lt;n-1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+1];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n-1] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=n-1; p&gt;0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p-1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n-1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[4]= &#123;0x73647979,0x726b6f5f,0x646f675f,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]= &#123;0X95C4C,0X871D,0X1A7B7,0X12C7C7&#125;;</span><br><span class="line">    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line">    printf(&quot;加密前原始数据：%s\n&quot;,(char*)v);</span><br><span class="line">    btea(v, n, k);</span><br><span class="line">    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v[3]);</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s\n&quot;,(char*)v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">加密前原始数据：yyds_okr_god</span><br><span class="line">加密后的数据：609835868 2980644312 0</span><br><span class="line">解密后的数据：yyds_okr_god</span><br></pre></td></tr></table></figure>

<h2 id="逆向中TEA系列加密的识别"><a href="#逆向中TEA系列加密的识别" class="headerlink" title="逆向中TEA系列加密的识别"></a>逆向中TEA系列加密的识别</h2><p>解决逆向题大部分出现TEA的场合都是【识别算法-&gt;编写对应解密程序】</p>
<p>分析二进制文件中的算法的时候有几个识别的特征</p>
<ul>
<li>可能存在针对<strong>64bit</strong>以及<strong>128bit</strong>数字的操作（输入的<strong>msg和key</strong>） ，一般会用<strong>无符号的32位的数组</strong>表示</li>
<li>存在<strong>先进行位移，然后异或</strong>的类似操作（<code>(z&gt;&gt;5^y&lt;&lt;2) </code>这类混合变换）**<code>(z&gt;&gt;5^y&lt;&lt;2)</code><strong>就是xxtea加密了，存在</strong>(v0 &lt;&lt; 4)** 和 **(v0 &gt;&gt; 5)**移位就是tea和xtea加密了</li>
<li>前面一个复杂的混合变换的结果可能会<strong>叠加</strong>到另一个值上，两者相互叠加（Feistel 结构）</li>
<li><strong>获取密钥</strong>的时候，会使用某一个常量值作为下标（<code>key[(sum&gt;&gt;11) &amp; 3]</code>）存在轮换的方式获得密钥 就是xtea或者xxtea了</li>
<li>会在算法开始定义一个<strong>delta</strong>，并且这个值不断的参与算法，但是<strong>从来不会受到输入的影响</strong>（delta数值如果没有魔改就是0x9e3779b9）如果出现了<strong>0x9e3779b9</strong>这个数字一般就能确定是TEA加密系列</li>
</ul>
<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/4272e0805da3">https://www.jianshu.com/p/4272e0805da3</a></p>
<p><a href="https://www.anquanke.com/post/id/224198#h3-2">https://www.anquanke.com/post/id/224198#h3-2</a></p>
]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>TEA</tag>
      </tags>
  </entry>
  <entry>
    <title>frida+d3mug复现</title>
    <url>/2022/03/17/frida-d3mug%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="FRIDA-API使用篇"><a href="#FRIDA-API使用篇" class="headerlink" title="FRIDA-API使用篇"></a>FRIDA-API使用篇</h1><p>frida中有五种对象，分别是Java、Interceptor、NativePointer、NativeFunction、NativeCallback对象</p>
<p>这些都是在编写frida脚本的时候会用到的对象以及对应的函数。</p>
<p>frida知识更多的学习，可以查看<a href="https://www.anquanke.com/member.html?memberId=131652">这些文章</a></p>
<h2 id="Java对象"><a href="#Java对象" class="headerlink" title="Java对象"></a>Java对象</h2><p>无论是想对<code>so</code>层亦或java层进行拦截，都必须编写<code>Java.perform</code>，java对象是很重要的</p>
<h3 id="附加调用Java-perform"><a href="#附加调用Java-perform" class="headerlink" title="附加调用Java.perform"></a>附加调用Java.perform</h3><p><code>Java.perform（fn）</code>主要用于<strong>当前线程附加到<code>Java VM</code><strong>并且</strong>调用<code>fn</code>方法</strong>。该API是非常重要的</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unction frida_Java() &#123;</span><br><span class="line">    //运行当前js脚本时会对当前线程附加到Java VM虚拟机，并且执行function方法</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        //判断是否Java VM正常运行</span><br><span class="line">        if(Java.available)</span><br><span class="line">        &#123;</span><br><span class="line">            //如不意外会直接输出 hello</span><br><span class="line">            console.log(&quot;hello&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;       </span><br><span class="line">setImmediate(frida_Java,0);</span><br><span class="line"></span><br><span class="line">输出如下。</span><br><span class="line">[Google Pixel::com.roysue.roysueapplication]-&gt; hello</span><br></pre></td></tr></table></figure>

<h3 id="判断加载Java-available"><a href="#判断加载Java-available" class="headerlink" title="判断加载Java.available"></a>判断加载Java.available</h3><p>该函数一般用来<strong>判断</strong>当前进程是否加载了**<code>JavaVM，Dalvik</code>或<code>ART</code>虚拟机**</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function frida_Java() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        //作为判断用</span><br><span class="line">        if(Java.available)</span><br><span class="line">        &#123;</span><br><span class="line">            //注入的逻辑代码</span><br><span class="line">            console.log(&quot;hello java vm&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //未能正常加载JAVA VM</span><br><span class="line">            console.log(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;       </span><br><span class="line">setImmediate(frida_Java,0);</span><br><span class="line"></span><br><span class="line">输出如下。</span><br><span class="line">hello java vm</span><br></pre></td></tr></table></figure>

<h3 id="版本号Java-androidVersion"><a href="#版本号Java-androidVersion" class="headerlink" title="版本号Java.androidVersion"></a>版本号Java.androidVersion</h3><p>显示<strong>android系统版本号</strong></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function frida_Java() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        //作为判断用</span><br><span class="line">        if(Java.available)</span><br><span class="line">        &#123;</span><br><span class="line">            //注入的逻辑代码</span><br><span class="line">            console.log(&quot;&quot;,Java.androidVersion);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //未能正常加载JAVA VM</span><br><span class="line">            console.log(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;       </span><br><span class="line">setImmediate(frida_Java,0);</span><br></pre></td></tr></table></figure>

<h3 id="获取类Java-use"><a href="#获取类Java-use" class="headerlink" title="获取类Java.use"></a>获取类Java.use</h3><p><code>Java.use(className)，</code>动态获取<code>className</code>的类定义，通过对其调用<code>$new()</code>来调用构造函数，可以从中<strong>实例化对象</strong>。当想要<strong>回收类</strong>时可以调用<code>$Dispose()</code>方法显式释放，当然也可以等待<code>JavaScript</code>的垃圾回收机制，当实例化一个对象之后，可以通过其<strong>实例对象调用类中的静态或非静态的方法</strong></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">  //获取android.app.Activity类</span><br><span class="line">  var Activity = Java.use(&#x27;android.app.Activity&#x27;);</span><br><span class="line">  //获取java.lang.Exception类</span><br><span class="line">  var Exception = Java.use(&#x27;java.lang.Exception&#x27;);</span><br><span class="line">  //拦截Activity类的onResume方法</span><br><span class="line">  Activity.onResume.implementation = function () &#123;</span><br><span class="line">    //调用onResume方法的时候，会在此处被拦截并且调用以下代码抛出异常！</span><br><span class="line">    throw Exception.$new(&#x27;Oh noes!&#x27;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="枚举类Java-enumerateLoadedClasses"><a href="#枚举类Java-enumerateLoadedClasses" class="headerlink" title="枚举类Java.enumerateLoadedClasses"></a>枚举类Java.enumerateLoadedClasses</h3><p>该API枚举当前<strong>加载的所有类信息</strong>，它有一个<strong>回调函数</strong>分别是<code>onMatch、onComplete</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function frida_Java() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        if(Java.available)</span><br><span class="line">        &#123;</span><br><span class="line">            //console.log(&quot;&quot;,Java.androidVersion);</span><br><span class="line">            //枚举当前加载的所有类</span><br><span class="line">            Java.enumerateLoadedClasses(&#123;</span><br><span class="line">                //每一次回调此函数时其参数className就是类的信息</span><br><span class="line">                onMatch: function (className)</span><br><span class="line">                &#123;</span><br><span class="line">                    //输出类字符串</span><br><span class="line">                    console.log(&quot;&quot;,className);</span><br><span class="line">                &#125;,</span><br><span class="line">                //枚举完毕所有类之后的回调函数</span><br><span class="line">                onComplete: function ()</span><br><span class="line">                &#123;</span><br><span class="line">                    //输出类字符串</span><br><span class="line">                    console.log(&quot;输出完毕&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;       </span><br><span class="line">setImmediate(frida_Java,0);</span><br></pre></td></tr></table></figure>

<h3 id="扫描实例类Java-choose"><a href="#扫描实例类Java-choose" class="headerlink" title="扫描实例类Java.choose"></a>扫描实例类Java.choose</h3><p>在堆上查找实例化的对象，实例化对象的意思就是用这个类创建的一个对象（如同人这个类中的叫小明的这个人）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">    //查找android.view.View类在堆上的实例化对象</span><br><span class="line">    Java.choose(&quot;android.view.View&quot;, &#123;</span><br><span class="line">        //枚举时调用</span><br><span class="line">        onMatch:function(instance)&#123;</span><br><span class="line">            //打印实例</span><br><span class="line">            console.log(instance);</span><br><span class="line">        &#125;,</span><br><span class="line">        //枚举完成后调用</span><br><span class="line">        onComplete:function() &#123;</span><br><span class="line">            console.log(&quot;end&quot;)</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">android.view.View&#123;2292774 V.ED..... ......ID 0,1794-1080,1920 #1020030 android:id/navigationBarBackground&#125;</span><br><span class="line">android.view.View&#123;d43549d V.ED..... ......ID 0,0-1080,63 #102002f android:id/statusBarBackground&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="类型转换器Java-cast"><a href="#类型转换器Java-cast" class="headerlink" title="类型转换器Java.cast"></a>类型转换器Java.cast</h3><p>使用 <code>Java.cast(object,Class)</code> 可以转换一个对象的类型。通常在拦截<code>so</code>层时会使用此函数将<code>jstring、jarray</code>等等转换之后查看其值。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">performNow</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Student</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.example.myapplication.Student&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> student = <span class="title class_">Student</span>.$new(<span class="string">&#x27;田所浩二&#x27;</span>,<span class="number">24</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">class</span>);</span><br><span class="line">  <span class="comment">//将Student类对象强制转化成Object类对象</span></span><br><span class="line">  student = <span class="title class_">Java</span>.<span class="title function_">cast</span>(student,<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">class</span>);</span><br><span class="line">  <span class="comment">//将上面强制转换成的Object类对象转换成Student类对象</span></span><br><span class="line">  student = <span class="title class_">Java</span>.<span class="title function_">cast</span>(student,<span class="title class_">Student</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">class</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="定义任意数组类型Java-array"><a href="#定义任意数组类型Java-array" class="headerlink" title="定义任意数组类型Java.array"></a>定义任意数组类型Java.array</h3><p>frida提供了<strong>在js代码</strong>中定义<strong>java数组</strong>的api，该数组可以用于传递给java API。定义格式为<code>Java.array(&#39;type&#39;,[value1,value2,....]);</code></p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//定义一个int数组、值是1003, 1005, 1007</span></span><br><span class="line">        <span class="keyword">var</span> intarr = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&#x27;int&#x27;</span>, [ <span class="number">1003</span>, <span class="number">1005</span>, <span class="number">1007</span> ]);</span><br><span class="line">        <span class="comment">//定义一个byte数组、值是0x48, 0x65, 0x69</span></span><br><span class="line">        <span class="keyword">var</span> bytearr = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&#x27;byte&#x27;</span>, [ <span class="number">0x48</span>, <span class="number">0x65</span>, <span class="number">0x69</span> ]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;bytearr.<span class="property">length</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出每个byte元素</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(bytearr[i])</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Java-vm对象"><a href="#Java-vm对象" class="headerlink" title="Java.vm对象"></a>Java.vm对象</h3><p>Java.vm对象十分常用，比如想要拿到<strong>JNI层的JNIEnv对象</strong>，可以使用**getEnv()**。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function frida_Java() &#123;     </span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">         //拦截getStr函数</span><br><span class="line">         Interceptor.attach(Module.findExportByName(&quot;libhello.so&quot; , &quot;Java_com_roysue_roysueapplication_hellojni_getStr&quot;), &#123;</span><br><span class="line">            onEnter: function(args) &#123;</span><br><span class="line">                console.log(&quot;getStr&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave:function(retval)&#123;</span><br><span class="line">                //它的返回值的是retval 在jni层getStr的返回值的jstring </span><br><span class="line">                //我们在这里做的事情就是替换掉结果</span><br><span class="line">                //先获取一个Env对象</span><br><span class="line">                var env = Java.vm.getEnv();</span><br><span class="line">                //通过newStringUtf方法构建一个jstirng字符串</span><br><span class="line">                var jstring = env.newStringUtf(&#x27;roysue&#x27;);</span><br><span class="line">                //replace替换掉结果</span><br><span class="line">                retval.replace(jstring);</span><br><span class="line">                console.log(&quot;getSum方法返回值为:roysue&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(frida_Java,0);</span><br></pre></td></tr></table></figure>

<h2 id="Interceptor对象"><a href="#Interceptor对象" class="headerlink" title="Interceptor对象"></a>Interceptor对象</h2><p>函数原型是**Interceptor.attach(target, callbacks)**：</p>
<p><strong>target参数</strong>：是需要拦截的位置的<strong>函数地址</strong>，也就是填某个**<code>so</code>层函数的地址<strong>即可对其拦截，<code>target</code>是一个</strong><code>NativePointer</code>参数**，用来指定你想要拦截的函数的地址，<code>NativePointer</code>是一个指针（下面有对NativePointer的说明）；对于<code>Thumb</code>函数需要对函数地址<code>+1</code></p>
<p><strong>callbacks参数</strong>：它的回调函数，有两个onEnter: function (args) 和 onLeave: function (retval)函数</p>
<h3 id="Interceptor-attach"><a href="#Interceptor-attach" class="headerlink" title="Interceptor.attach"></a>Interceptor.attach</h3><p><strong>两个回调函数</strong>：</p>
<ul>
<li><p><code>onEnter：</code>函数（<code>args</code>）：回调函数，给定一个参数<code>args</code>，可用于读取或写入参数作为 <code>NativePointer</code> 对象的数组。</p>
</li>
<li><p><code>onLeave：</code>函数（<code>retval</code>）：回调函数给定一个参数 <code>retval</code>，该参数是包含原始返回值的 <code>NativePointer</code> 派生对象。可以调用 <code>retval.replace（1337）</code> 以整数 <code>1337</code> 替换返回值，或者调用 <code>retval.replace（ptr（&quot;0x1234&quot;））</code>以替换为指针。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用Module对象getExportByNameAPI直接获取libc.so中的导出函数read的地址，对read函数进行附加拦截</span><br><span class="line">Interceptor.attach(Module.getExportByName(&#x27;libc.so&#x27;, &#x27;read&#x27;), &#123;</span><br><span class="line">  //每次read函数调用的时候会执行onEnter回调函数</span><br><span class="line">  onEnter: function (args) &#123;</span><br><span class="line">    this.fileDescriptor = args[0].toInt32();</span><br><span class="line">  &#125;,</span><br><span class="line">  //read函数执行完成之后会执行onLeave回调函数</span><br><span class="line">  onLeave: function (retval) &#123;</span><br><span class="line">    if (retval.toInt32() &gt; 0) &#123;</span><br><span class="line">      /* do something with this.fileDescriptor */</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Interceptor.attach函数的一些属性</strong>：</p>
<ul>
<li><table>
<thead>
<tr>
<th>returnAddress</th>
<th>返回地址，类型是<code>NativePointer</code></th>
</tr>
</thead>
<tbody><tr>
<td>threadId</td>
<td>操作系统线程ID</td>
</tr>
<tr>
<td>context</td>
<td>上下文：具有键<code>pc</code>和<code>sp</code>的对象，它们是分别为<code>ia32/x64/arm</code>指定<code>EIP/RIP/PC</code>和<code>ESP/RSP/SP的NativePointer</code>对象。其他处理器特定的键也可用，例如<code>eax、rax、r0、x0</code>等。也可以通过分配给这些键来更新寄存器值。</td>
</tr>
<tr>
<td>errno</td>
<td>当前<code>errno</code>值</td>
</tr>
<tr>
<td>lastError</td>
<td>当前操作系统错误值</td>
</tr>
<tr>
<td>depth</td>
<td>相对于其他调用的调用深度</td>
</tr>
</tbody></table>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Interceptor.attach(Module.findExportByName(&quot;libhello.so&quot; , &quot;Java_com_roysue_roysueapplication_hellojni_getSum&quot;), &#123;</span><br><span class="line">            onEnter: function(args) &#123;</span><br><span class="line">                //输出</span><br><span class="line">                console.log(&#x27;Context information:&#x27;);</span><br><span class="line">                //输出上下文因其是一个Objection对象，需要它进行接送、转换才能正常看到值</span><br><span class="line">                console.log(&#x27;Context  : &#x27; + JSON.stringify(this.context));</span><br><span class="line">                //输出返回地址</span><br><span class="line">                console.log(&#x27;Return   : &#x27; + this.returnAddress);</span><br><span class="line">                //输出线程id</span><br><span class="line">                console.log(&#x27;ThreadId : &#x27; + this.threadId);</span><br><span class="line">                console.log(&#x27;Depth    : &#x27; + this.depth);</span><br><span class="line">                console.log(&#x27;Errornr  : &#x27; + this.err);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave:function(retval)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Interceptor-detachAll"><a href="#Interceptor-detachAll" class="headerlink" title="Interceptor.detachAll"></a>Interceptor.detachAll</h3><p>简单来说这个的函数的作用就是让之前所有的<code>Interceptor.attach</code>附加拦截的回调函数失效</p>
<h3 id="Interceptor-replace"><a href="#Interceptor-replace" class="headerlink" title="Interceptor.replace"></a>Interceptor.replace</h3><p>相当于<strong>替换掉原本的函数</strong>，用替换时的实现替换目标处的函数。如果想要完全或部分替换现有函数的实现，则通常使用此函数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function frida_Interceptor() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">       //这个c_getSum方法有两个int参数、返回结果为两个参数相加</span><br><span class="line">       //这里用NativeFunction函数自己定义了一个c_getSum函数</span><br><span class="line">       var add_method = new NativeFunction(Module.findExportByName(&#x27;libhello.so&#x27;, &#x27;c_getSum&#x27;), </span><br><span class="line">       &#x27;int&#x27;,[&#x27;int&#x27;,&#x27;int&#x27;]);</span><br><span class="line">       //输出结果 那结果肯定就是 3</span><br><span class="line">       console.log(&quot;result:&quot;,add_method(1,2));</span><br><span class="line">       //这里对原函数的功能进行替换实现</span><br><span class="line">       Interceptor.replace(add_method, new NativeCallback(function (a, b) &#123;</span><br><span class="line">           //h不论是什么参数都返回123</span><br><span class="line">            return 123;</span><br><span class="line">       &#125;, &#x27;int&#x27;, [&#x27;int&#x27;, &#x27;int&#x27;]));</span><br><span class="line">       //再次调用 则返回123</span><br><span class="line">       console.log(&quot;result:&quot;,add_method(1,2));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NativePointer对象"><a href="#NativePointer对象" class="headerlink" title="NativePointer对象"></a>NativePointer对象</h2><p>同等与C语言中的指针</p>
<h3 id="new-NativePointer-s"><a href="#new-NativePointer-s" class="headerlink" title="new NativePointer(s)"></a>new NativePointer(s)</h3><p>声明定义NativePointer类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ptr1 = new NativePointer(&quot;100&quot;);</span><br><span class="line">console.log(&quot;ptr1:&quot;,ptr1);</span><br></pre></td></tr></table></figure>

<h3 id="运算符以及指针读写API"><a href="#运算符以及指针读写API" class="headerlink" title="运算符以及指针读写API"></a>运算符以及指针读写API</h3><p>这里有个表，可以用这个指针对这些API进行调用</p>
<p><img src="https://p3.ssl.qhimg.com/t0135a7319c873d8d52.png" alt="img"></p>
<p><img src="https://p3.ssl.qhimg.com/t01821e14d1331f0aef.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用readByteArray函数来读取libc.so文件在内存中的数据</span><br><span class="line">var pointer = Process.findModuleByName(&quot;libc.so&quot;).base;</span><br><span class="line">//读取从pointer地址开始的16个字节 (从libc文件读取0x10个字节的长度)</span><br><span class="line">console.log(pointer.readByteArray(0x10));</span><br></pre></td></tr></table></figure>

<p>上面这些API的调用的部分示例可以查看<a href="https://www.anquanke.com/post/id/195869#h2-13">这篇文章</a>中的NativePointer对象这个部分</p>
<h2 id="NativeFunction对象"><a href="#NativeFunction对象" class="headerlink" title="NativeFunction对象"></a>NativeFunction对象</h2><p>作用：调用<code>address</code>处的函数(用<code>NativePointer</code>指定)</p>
<p>函数定义格式：new NativeFunction(address, returnType, argTypes[, options])</p>
<ul>
<li><strong>returnType和argTypes[，]中能够填写的数据类型</strong>：void、pointer、int、uint、long、ulong、char、uchar、float、double、int8、uint8、int16、uint16、int32、uint32、int64、uint64这些类型。假设有<strong>三个参数</strong>都是<code>int</code>，则<strong>new NativeFunction(address, returnType, [‘int’, ‘int’, ‘int’])</strong></li>
<li>定义的时候必须要将<strong>参数类型个数</strong>和<strong>参数类型</strong>以及<strong>返回值</strong>完全匹配。</li>
<li>并且第一个参数一定要是<strong>函数地址指针</strong></li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// LargeObject HandyClass::friendlyFunctionName();</span><br><span class="line">//创建friendlyFunctionPtr地址的函数</span><br><span class="line">var friendlyFunctionName = new NativeFunction(friendlyFunctionPtr,</span><br><span class="line">    &#x27;void&#x27;, [&#x27;pointer&#x27;, &#x27;pointer&#x27;]);</span><br><span class="line">//申请内存空间    </span><br><span class="line">var returnValue = Memory.alloc(sizeOfLargeObject);</span><br><span class="line">//调用friendlyFunctionName函数</span><br><span class="line">friendlyFunctionName(returnValue, thisPtr);</span><br></pre></td></tr></table></figure>

<h2 id="NativeCallback对象"><a href="#NativeCallback对象" class="headerlink" title="NativeCallback对象"></a>NativeCallback对象</h2><p>作用：创建一个回调函数</p>
<p>函数定义格式：new NativeCallback(func，rereturn Type，argTypes[，ABI])</p>
<ul>
<li>func参数：由JavaScript函数实现的函数</li>
<li><code>rereturn Type</code>指定返回类型，<code>argTypes</code>数组指定参数类型</li>
</ul>
<p>当将产生的回调与<code>Interceptor.replace()</code>一起使用时，将调用func，并将其绑定到具有一些有用属性的对象，就像<code>Interceptor.Attach()</code>中的那样</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//替换对象的函数指针</span></span><br><span class="line">   <span class="keyword">var</span> add_method = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(<span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&#x27;libhello.so&#x27;</span>, <span class="string">&#x27;c_getSum&#x27;</span>), </span><br><span class="line">   <span class="string">&#x27;int&#x27;</span>,[<span class="string">&#x27;int&#x27;</span>,<span class="string">&#x27;int&#x27;</span>]);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;result:&quot;</span>,<span class="title function_">add_method</span>(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">   <span class="comment">//在这里new一个新的函数，但是参数的个数和返回值必须对应</span></span><br><span class="line">   <span class="title class_">Interceptor</span>.<span class="title function_">replace</span>(add_method, <span class="keyword">new</span> <span class="title class_">NativeCallback</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">   &#125;, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>]));</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;result:&quot;</span>,<span class="title function_">add_method</span>(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用java.perform()中写入js脚本</p>
<p>使用Module对象获得一些so文件的地址信息</p>
<p>利用so文件的地址信息使用NativeFunction 得到so文件之中的对象，再使用Interceptor对象的API，对相应的函数进行一定的操作</p>
<p>运行这个函数，设置这个函数的输入的参数，设置这个函数的返回的参数</p>
<h1 id="FRIDA-API使用篇：rpc、Process、Module、Memory"><a href="#FRIDA-API使用篇：rpc、Process、Module、Memory" class="headerlink" title="FRIDA-API使用篇：rpc、Process、Module、Memory"></a>FRIDA-API使用篇：rpc、Process、Module、Memory</h1><p>这里对frida官方的一些非常常用的<code>API</code>进行介绍</p>
<h2 id="FRIDA输出打印"><a href="#FRIDA输出打印" class="headerlink" title="FRIDA输出打印"></a>FRIDA输出打印</h2><p>在官方API有两种打印的方式，分别是<code>console</code>、<code>send</code></p>
<h3 id="console输出"><a href="#console输出" class="headerlink" title="console输出"></a>console输出</h3><p>在<code>FRIDA</code>的<code>console</code>中有三个级别分别是<code>log、warn、error</code>。一般在使用中我们只会使用<code>log</code>来输出想看的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello_printf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello-log&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;hello-warn&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;hello-error&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(hello_printf,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="console之hexdump"><a href="#console之hexdump" class="headerlink" title="console之hexdump"></a>console之hexdump</h4><p>hexdump的含义:<strong>打印内存中的地址</strong>，target参数可以是<strong>ArrayBuffer</strong>或者<strong>NativePointer</strong>,而<strong>options参数</strong>则是自定义输出格式可以填这几个参数offset、lengt、header、ansi</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> libc = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&#x27;libc.so&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(libc, &#123;</span><br><span class="line">  <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">64</span>,</span><br><span class="line">  <span class="attr">header</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">ansi</span>: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>执行效果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">00000000  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............</span><br><span class="line">00000010  03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00  ..(.........4...</span><br><span class="line">00000020  34 a8 04 00 00 00 00 05 34 00 20 00 08 00 28 00  4.......4. ...(.</span><br><span class="line">00000030  1e 00 1d 00 06 00 00 00 34 00 00 00 34 00 00 00  ........4...4...</span><br></pre></td></tr></table></figure>

<h3 id="send"><a href="#send" class="headerlink" title="send"></a><strong>send</strong></h3><p>原理：send是在<strong>python层</strong>定义的<strong>on_message回调函数</strong>，jscode内所有的信息都被监控<strong>script.on(‘message’, on_message)<strong>，当</strong>输出信息</strong>的时候on_message函数会拿到其数据再通过format转换、</p>
<p>输出效果：能够直接将数据以**<code>json</code>格式**输出，当然数据是二进制的时候也依然是可以使用<code>send</code></p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">def <span class="title function_">on_message</span>(message, data):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="title function_">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="attr">else</span>:</span><br><span class="line">        <span class="title function_">print</span>(message)</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    Java.perform(function () </span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        var jni_env = Java.vm.getEnv();</span></span><br><span class="line"><span class="string">        console.log(jni_env);</span></span><br><span class="line"><span class="string">        send(jni_env);</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string"> &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">process = frida.<span class="title function_">get_usb_device</span>().<span class="title function_">attach</span>(<span class="string">&#x27;com.roysue.roysueapplication&#x27;</span>)</span><br><span class="line">script = process.<span class="title function_">create_script</span>(jscode)</span><br><span class="line">script.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">script.<span class="title function_">load</span>()</span><br><span class="line">sys.<span class="property">stdin</span>.<span class="title function_">read</span>()</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roysue@ubuntu:~/Desktop/Chap09$ python Chap03.py </span><br><span class="line">[object Object]</span><br><span class="line">[*] &#123;&#x27;handle&#x27;: &#x27;0xdf4f8000&#x27;, &#x27;vm&#x27;: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FRIDA变量类型"><a href="#FRIDA变量类型" class="headerlink" title="FRIDA变量类型"></a>FRIDA变量类型</h2><p>在脚本之中如何声明变量类型。以及<code>frida</code>为<code>Int64(v)</code>提供了一些相关的API的使用</p>
<h3 id="声明变量类型"><a href="#声明变量类型" class="headerlink" title="声明变量类型"></a>声明变量类型</h3><table>
<thead>
<tr>
<th>索引</th>
<th>API</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>new Int64(v)</td>
<td>定义一个有符号Int64类型的变量值为v，参数v可以是字符串或者以0x开头的的十六进制值</td>
</tr>
<tr>
<td>2</td>
<td>new UInt64(v)</td>
<td>定义一个无符号Int64类型的变量值为v，参数v可以是字符串或者以0x开头的的十六进制值</td>
</tr>
<tr>
<td>3</td>
<td>new NativePointer(s)</td>
<td>定义一个指针，指针地址为s</td>
</tr>
<tr>
<td>4</td>
<td>ptr(“0”)</td>
<td>同上</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new Int64(1):&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new UInt64(1):&quot;</span>+<span class="keyword">new</span> <span class="title class_">UInt64</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new NativePointer(0xEC644071):&quot;</span>+<span class="keyword">new</span> <span class="title class_">NativePointer</span>(<span class="number">0xEC644071</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new ptr(&#x27;0xEC644071&#x27;):&quot;</span>+<span class="keyword">new</span> <span class="title function_">ptr</span>(<span class="number">0xEC644071</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Int64-v-使用的API"><a href="#Int64-v-使用的API" class="headerlink" title="Int64(v)使用的API"></a>Int64(v)使用的API</h3><table>
<thead>
<tr>
<th>索引</th>
<th>API</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>add(rhs)、sub(rhs)、and(rhs)、or(rhs)、xor(rhs)</td>
<td>加、减、逻辑运算</td>
</tr>
<tr>
<td>2</td>
<td>shr(N)、shl(n)</td>
<td>向右/向左移位n位生成新的Int64</td>
</tr>
<tr>
<td>3</td>
<td>Compare(Rhs)</td>
<td>返回整数比较结果</td>
</tr>
<tr>
<td>4</td>
<td>toNumber()</td>
<td>转换为数字</td>
</tr>
<tr>
<td>5</td>
<td>toString([radix=10])</td>
<td>转换为可选基数的字符串(默认为10)</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello_type</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//8888 + 1 = 8889</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8888 + 1:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="string">&quot;8888&quot;</span>).<span class="title function_">add</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//8888 - 1 = 8887</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8888 - 1:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="string">&quot;8888&quot;</span>).<span class="title function_">sub</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//8888 &lt;&lt; 1 = 4444</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8888 &lt;&lt; 1:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="string">&quot;8888&quot;</span>).<span class="title function_">shr</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//8888 == 22 = 1 1是false</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8888 == 22:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="string">&quot;8888&quot;</span>).<span class="title function_">compare</span>(<span class="number">22</span>));</span><br><span class="line">        <span class="comment">//转string</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8888 toString:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Int64</span>(<span class="string">&quot;8888&quot;</span>).<span class="title function_">toString</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Process对象"><a href="#Process对象" class="headerlink" title="Process对象"></a>Process对象</h2><p>介绍以及使用一些<code>Process</code>对象中比较常用的<code>api</code></p>
<h3 id="Process-id"><a href="#Process-id" class="headerlink" title="Process.id"></a>Process.id</h3><p>Process.id：返回附加<strong>目标进程的PID</strong></p>
<h3 id="Process-isDebuggerAttached"><a href="#Process-isDebuggerAttached" class="headerlink" title="Process.isDebuggerAttached()"></a>Process.isDebuggerAttached()</h3><p><strong>检测</strong>当前是否对目标程序已经附加</p>
<h3 id="Process-enumerateModules"><a href="#Process-enumerateModules" class="headerlink" title="Process.enumerateModules()"></a>Process.enumerateModules()</h3><p><strong>枚举</strong>当前加载的<strong>模块</strong>，返回模块对象的数组。会枚举当前所有已加载的<code>so</code>模块，并且返回了数组<code>Module</code>对象。</p>
<p>枚举得到的每个module对象，再使用每个module对象进行操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">frida_Process</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> process_Obj_Module_Arr = <span class="title class_">Process</span>.<span class="title function_">enumerateModules</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; process_Obj_Module_Arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span>,process_Obj_Module_Arr[i].<span class="property">name</span>);<span class="comment">//这里使用了module的name属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(frida_Process,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Process-enumerateThreads"><a href="#Process-enumerateThreads" class="headerlink" title="Process.enumerateThreads()"></a>Process.enumerateThreads()</h3><p>枚举当前所有的线程，返回包含以下属性的对象数组：</p>
<table>
<thead>
<tr>
<th align="left">索引</th>
<th align="left">属性</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">id</td>
<td align="left">线程id</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">state</td>
<td align="left">当前运行状态有running, stopped, waiting, uninterruptible or halted</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">context</td>
<td align="left">带有键pc和sp的对象，它们是分别为ia32/x64/arm指定EIP/RIP/PC和ESP/RSP/SP的NativePointer对象。也可以使用其他处理器特定的密钥，例如eax、rax、r0、x0等。</td>
</tr>
</tbody></table>
<h3 id="Process-getCurrentThreadId"><a href="#Process-getCurrentThreadId" class="headerlink" title="Process.getCurrentThreadId()"></a>Process.getCurrentThreadId()</h3><p>获取此线程的操作系统特定 <code>ID</code> 作为数字</p>
<h2 id="Module对象"><a href="#Module对象" class="headerlink" title="Module对象"></a>Module对象</h2><p>获得程序中函数 类等的一些信息的时候（基地址，偏移地址等）就会用到这个对象</p>
<h3 id="Module对象的属性"><a href="#Module对象的属性" class="headerlink" title="Module对象的属性"></a>Module对象的属性</h3><table>
<thead>
<tr>
<th>索引</th>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>name</td>
<td>模块名称</td>
</tr>
<tr>
<td>2</td>
<td>base</td>
<td>模块地址，其变量类型为NativePointer</td>
</tr>
<tr>
<td>3</td>
<td>size</td>
<td>大小</td>
</tr>
<tr>
<td>4</td>
<td>path</td>
<td>完整文件系统路径</td>
</tr>
</tbody></table>
<h3 id="Module对象的API"><a href="#Module对象的API" class="headerlink" title="Module对象的API"></a>Module对象的API</h3><table>
<thead>
<tr>
<th>索引</th>
<th>API</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Module.load()</td>
<td>加载指定so文件，返回一个Module对象</td>
</tr>
<tr>
<td>2</td>
<td>enumerateImports()</td>
<td>枚举所有Import库函数，返回Module数组对象</td>
</tr>
<tr>
<td>3</td>
<td>enumerateExports()</td>
<td>枚举所有Export库函数，返回Module数组对象</td>
</tr>
<tr>
<td>4</td>
<td>enumerateSymbols()</td>
<td>枚举所有Symbol库函数，返回Module数组对象</td>
</tr>
<tr>
<td>5</td>
<td>Module.findExportByName(exportName)、Module.getExportByName(exportName)</td>
<td>寻找指定so中export库中的函数地址</td>
</tr>
<tr>
<td>6</td>
<td>Module.findBaseAddress(name)、Module.getBaseAddress(name)</td>
<td>返回so的基地址</td>
</tr>
</tbody></table>
<h3 id="enumerateImports"><a href="#enumerateImports" class="headerlink" title="enumerateImports()"></a>enumerateImports()</h3><p>该API会枚举模块中所有中的所有Import函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hooks = Module.load(&#x27;libhello.so&#x27;);</span><br><span class="line">var Imports = hooks.enumerateImports();//再遍历这个得到的枚举数组</span><br></pre></td></tr></table></figure>

<h3 id="enumerateExports"><a href="#enumerateExports" class="headerlink" title="enumerateExports()"></a>enumerateExports()</h3><p>该API会枚举模块中所有中的所有<code>Export</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hooks = Module.load(&#x27;libhello.so&#x27;);</span><br><span class="line">var Exports = hooks.enumerateExports();</span><br></pre></td></tr></table></figure>

<h3 id="enumerateSymbols"><a href="#enumerateSymbols" class="headerlink" title="enumerateSymbols()"></a>enumerateSymbols()</h3><p>该API会枚举模块中所有中的所有symbols 符号，使用symbols 符号可以定位native方法。返回的是一个数组对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hooks = Module.load(&#x27;libc.so&#x27;);</span><br><span class="line">var Symbol = hooks.enumerateSymbols();</span><br></pre></td></tr></table></figure>

<h3 id="Module-findExportByName-exportName-Module-getExportByName-exportName"><a href="#Module-findExportByName-exportName-Module-getExportByName-exportName" class="headerlink" title="Module.findExportByName(exportName), Module.getExportByName(exportName)"></a>Module.findExportByName(exportName), Module.getExportByName(exportName)</h3><p>返回<code>so</code>文件中<code>Export</code>函数库中函数名称为**<code>exportName</code>函数<strong>的</strong>绝对地址**</p>
<p>这个方法只适用于Export函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&#x27;libhello.so&#x27;</span>, <span class="string">&#x27;c_getStr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Java_com_roysue_roysueapplication_hellojni_getStraddress:&quot;</span>,<span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&#x27;libhello.so&#x27;</span>, <span class="string">&#x27;Java_com_roysue_roysueapplication_hellojni_getStr&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Java_com_roysue_roysueapplication_hellojni_getStraddress:&quot;</span>,<span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&#x27;libhello.so&#x27;</span>, <span class="string">&#x27;Java_com_roysue_roysueapplication_hellojni_getStr&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Module-findBaseAddress-name-、Module-getBaseAddress-name"><a href="#Module-findBaseAddress-name-、Module-getBaseAddress-name" class="headerlink" title="Module.findBaseAddress(name)、Module.getBaseAddress(name)"></a>Module.findBaseAddress(name)、Module.getBaseAddress(name)</h3><p>返回<code>name</code>模块的基地址</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;libhello.so&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;so address:&quot;</span>,<span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(name));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;so address:&quot;</span>,<span class="title class_">Module</span>.<span class="title function_">getBaseAddress</span>(name));</span><br></pre></td></tr></table></figure>

<h2 id="Memory对象"><a href="#Memory对象" class="headerlink" title="Memory对象"></a>Memory对象</h2><p><code>Memory</code>的一些<code>API</code>的作用：通常是对内存处理，譬如<code>Memory.copy()</code>复制内存</p>
<h3 id="Memory-scan搜索内存数据"><a href="#Memory-scan搜索内存数据" class="headerlink" title="Memory.scan搜索内存数据"></a>Memory.scan搜索内存数据</h3><p>功能：搜索内存中以<code>address</code>地址开始，搜索长度为<code>size</code>，需要搜是条件是<code>pattern，callbacks</code>搜索之后的回调函数</p>
<p>格式：Memory.scan(module.base, module.size, pattern，callbacks）</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">        //先获取so的module对象</span><br><span class="line">        var module = Process.findModuleByName(&quot;libhello.so&quot;); </span><br><span class="line">        //??是通配符</span><br><span class="line">        var pattern = &quot;03 49 ?? 50 20 44&quot;;</span><br><span class="line">        //基址</span><br><span class="line">        console.log(&quot;base:&quot;+module.base)</span><br><span class="line">        //从so的基址开始搜索，搜索大小为so文件的大小，搜指定条件03 49 ?? 50 20 44的数据</span><br><span class="line">        var res = Memory.scan(module.base, module.size, pattern, &#123;</span><br><span class="line">            onMatch: function(address, size)&#123;</span><br><span class="line">                //搜索成功</span><br><span class="line">                console.log(&#x27;搜索到 &#x27; +pattern +&quot; 地址是:&quot;+ address.toString());  </span><br><span class="line">            &#125;, </span><br><span class="line">            onError: function(reason)&#123;</span><br><span class="line">                //搜索失败</span><br><span class="line">                console.log(&#x27;搜索失败&#x27;);</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: function()</span><br><span class="line">            &#123;</span><br><span class="line">                //搜索完毕</span><br><span class="line">                console.log(&quot;搜索完毕&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="内存分配Memory-alloc"><a href="#内存分配Memory-alloc" class="headerlink" title="内存分配Memory.alloc"></a>内存分配Memory.alloc</h3><p>作用：在目标进程中的堆上<strong>申请<code>size</code>大小的内存</strong>，并且会按照<code>Process.pageSize</code>对齐，返回一个<code>NativePointer</code>，并且申请的内存如果在<code>JavaScript</code>里面没有对这个内存的使用的时候会自动释放的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> r = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(r, &#123;</span><br><span class="line">            <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">length</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">header</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">ansi</span>: <span class="literal">false</span></span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure>

<h3 id="内存复制Memory-copy"><a href="#内存复制Memory-copy" class="headerlink" title="内存复制Memory.copy"></a>内存复制Memory.copy</h3><p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申请一个内存空间大小为10个字节</span></span><br><span class="line"><span class="keyword">const</span> r = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//复制以module.base地址开始的10个字节 那肯定会是7F 45 4C 46...因为一个ELF文件的Magic属性如此。</span></span><br><span class="line"><span class="title class_">Memory</span>.<span class="title function_">copy</span>(r,<span class="variable language_">module</span>.<span class="property">base</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="写入内存Memory-writeByteArray’"><a href="#写入内存Memory-writeByteArray’" class="headerlink" title="写入内存Memory.writeByteArray’"></a>写入内存Memory.writeByteArray’</h3><p>将字节数组<strong>写入一个指定内存</strong></p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义需要写入的字节数组 这个字节数组是字符串&quot;roysue&quot;的十六进制</span></span><br><span class="line"><span class="keyword">var</span> arr = [ <span class="number">0x72</span>, <span class="number">0x6F</span>, <span class="number">0x79</span>, <span class="number">0x73</span>, <span class="number">0x75</span>, <span class="number">0x65</span>];</span><br><span class="line"><span class="comment">//申请一个新的内存空间 返回指针 大小是arr.length</span></span><br><span class="line"><span class="keyword">const</span> r = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(arr.<span class="property">length</span>);</span><br><span class="line"><span class="comment">//将arr数组写入R地址中</span></span><br><span class="line"><span class="title class_">Memory</span>.<span class="title function_">writeByteArray</span>(r,arr);</span><br></pre></td></tr></table></figure>

<h3 id="读取内存Memory-readByteArray"><a href="#读取内存Memory-readByteArray" class="headerlink" title="读取内存Memory.readByteArray"></a>读取内存Memory.readByteArray</h3><p>这个函数的第一个参数传入的是 NativePointer 类型的地址指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//读取r指针，长度是arr.length 也就是会打印上面一样的值</span><br><span class="line">var buffer = Memory.readByteArray(r, arr.length);</span><br></pre></td></tr></table></figure>

<p>参考文章：<a href="https://www.anquanke.com/post/id/195215#h2-1">FRIDA-API使用篇：rpc、Process、Module、Memory使用方法及示例 - 安全客</a></p>
<h1 id="frida的so函数hook"><a href="#frida的so函数hook" class="headerlink" title="frida的so函数hook"></a>frida的so函数hook</h1><p>so文件之中的函数有导出函数和非导出函数,导出函数打开IDA后能够在导出表中找到的函数就是导出函数，未导出函数则在导出表中寻找不到。一般来说<strong>静态编写的native函数都能在导出表中寻找到，而动态加载的则无法在导出表中发现</strong></p>
<p>在IDA的Exports页面之中查看导出函数窗口</p>
<p>示例：</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220315233226275.png" alt="image-20220315233226275"></p>
<p><strong>导出函数hook</strong>：导出函数窗口可以看到导出函数的函数名，偏移量 。导出函数的hook可以通过<strong>函数名</strong>或者<strong>偏移量</strong>。</p>
<p><strong>非导出函数hook</strong>：只能通过<strong>地址hook</strong>。定位到函数的位置，直接看它的偏移量即可</p>
<h2 id="通过函数地址获取指定-so-文件的函数"><a href="#通过函数地址获取指定-so-文件的函数" class="headerlink" title="通过函数地址获取指定 so 文件的函数"></a>通过函数地址获取指定 so 文件的函数</h2><p><strong>函数地址 = so基地址 + 函数偏移</strong>(如果Thumb 指令， hook 的偏移地址需要进行 <strong>+1 操作</strong>)</p>
<p><strong>IDA 判断 Thumb 指令集和 Arm指令集</strong></p>
<ul>
<li><strong>IDA - Options - General - number of opcode bytes</strong> - 设置为 4</li>
<li>此时查看 IDA VIew 中 opcode 的长度, 如果出现 <strong>2 个字节</strong>和 <strong>4 个字节</strong>的, 说明为 <strong>thumb 指令集</strong></li>
<li>如果都是 <strong>4 个字节</strong>的, 说明是 <strong>arm 指令集</strong>;</li>
<li>在 Thumb 指令集下, inline hook 的偏移地址需要进行 +1 操作;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str_name_so = &quot;libjnitest.so&quot;;    //需要hook的so名</span><br><span class="line">var n_addr_func_offset = 0x00000680;         //需要hook的函数的偏移</span><br><span class="line">var n_addr_so = Module.findBaseAddress(str_name_so); //加载到内存后 函数地址 = so地址 + 函数偏移</span><br><span class="line">var n_addr_func = parseInt(n_addr_so, 16) + n_addr_func_offset;</span><br><span class="line">var ptr_func = new NativePointer(n_addr_func);</span><br></pre></td></tr></table></figure>

<h2 id="通过函数名获取指定-so-文件的函数"><a href="#通过函数名获取指定-so-文件的函数" class="headerlink" title="通过函数名获取指定 so 文件的函数"></a><strong>通过函数名获取指定 so 文件的函数</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var ptr_func = Module.findExportByName(&quot;libjnitest.so&quot;,&quot;test_add&quot;) //对函数名hook</span><br></pre></td></tr></table></figure>

<h2 id="通过-symbols-符号定位-native-方法"><a href="#通过-symbols-符号定位-native-方法" class="headerlink" title="通过 symbols 符号定位 native 方法"></a><strong>通过 symbols 符号定位 native 方法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    var NewStringUTF_addr = null;</span><br><span class="line">    var symbols = Process.findModuleByName(&quot;libart.so&quot;).enumerateSymbols(); //使用enumerateSymbols()函数得到所有的symbols 然后对symbols中所有的对象进行遍历，然后判断语句获得目标函数的地址</span><br><span class="line">    for (var i in symbols) &#123;</span><br><span class="line">        var symbol = symbols[i];</span><br><span class="line">        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;</span><br><span class="line">            symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;</span><br><span class="line">            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0</span><br><span class="line">        )&#123;</span><br><span class="line">            if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;= 0) &#123;</span><br><span class="line">                console.log(&quot;find target symbols&quot;, symbol.name, &quot;address is &quot;, symbol.address);</span><br><span class="line">                NewStringUTF_addr = symbol.address;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;NewStringUTF_addr is &quot;, NewStringUTF_addr);</span><br><span class="line">//得到函数地址之后 使用这个函数地址attach</span><br><span class="line">Interceptor.attach(NewStringUTF_addr, &#123;</span><br><span class="line">        onEnter: function (args) &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave: function (returnResult) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="通过-Intercept-拦截器打印-native-方法参数和返回值-并修改返回值"><a href="#通过-Intercept-拦截器打印-native-方法参数和返回值-并修改返回值" class="headerlink" title="通过 Intercept 拦截器打印 native 方法参数和返回值, 并修改返回值"></a><strong>通过 Intercept 拦截器打印 native 方法参数和返回值, 并修改返回值</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var add_c_addr = Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;add_c&quot;);</span><br><span class="line">    console.log(&quot;add_c_addr is :&quot;,add_c_addr);</span><br><span class="line">    // 添加拦截器</span><br><span class="line">    Interceptor.attach(add_c_addr,&#123;</span><br><span class="line">        // 打印入参</span><br><span class="line">        onEnter: function (args) &#123;</span><br><span class="line">            console.log(&quot;add_c called&quot;);</span><br><span class="line">            console.log(&quot;arg1:&quot;,args[0].toInt32());</span><br><span class="line">            console.log(&quot;arg2&quot;, args[1].toInt32());</span><br><span class="line">        &#125;,</span><br><span class="line">        // 打印返回值</span><br><span class="line">        onLeave: function (returnValue) &#123;</span><br><span class="line">            console.log(&quot;add_c result is :&quot;, returnValue.toInt32());</span><br><span class="line">            // 修改返回值</span><br><span class="line">            returnValue.replace(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>



<h2 id="获取指定-so-文件的基地址"><a href="#获取指定-so-文件的基地址" class="headerlink" title="获取指定 so 文件的基地址"></a><strong>获取指定 so 文件的基地址</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var baseAddr = Module.findBaseAddress(&quot;libnative-lib.so&quot;);</span><br><span class="line">console.log(&quot;baseAddr&quot;, baseAddr);</span><br></pre></td></tr></table></figure>

<h2 id="Hook修改native层函数返回值为int类型的情况"><a href="#Hook修改native层函数返回值为int类型的情况" class="headerlink" title="Hook修改native层函数返回值为int类型的情况"></a><strong>Hook修改native层函数返回值为int类型的情况</strong></h2><p>使用<code>replace()</code>函数直接修改即可</p>
<p>frida脚本示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import frida</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">jscode = &quot;&quot;&quot;</span><br><span class="line">Java.perform(function()&#123;</span><br><span class="line">    var str_name_so = &quot;libjnitest.so&quot;;    //需要hook的so名</span><br><span class="line">    var n_addr_func_offset = 0x00000680;         //需要hook的函数的偏移</span><br><span class="line">    var n_addr_so = Module.findBaseAddress(str_name_so); //加载到内存后 函数地址 = so地址 + 函数偏移</span><br><span class="line">    var n_addr_func = parseInt(n_addr_so, 16) + n_addr_func_offset;</span><br><span class="line">    var ptr_func = new NativePointer(n_addr_func);</span><br><span class="line">    //var ptr_func = Module.findExportByName(&quot;libjnitest.so&quot;,&quot;test_add&quot;) //对函数名hook</span><br><span class="line"></span><br><span class="line">    Interceptor.attach(ptr_func,&#123; </span><br><span class="line">        //onEnter: 进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始是我们java层传入的参数</span><br><span class="line">        onEnter: function(args) &#123;</span><br><span class="line">            send(&quot;Hook start&quot;);</span><br><span class="line">            send(&quot;args[2]=&quot; + args[2]); //第一个传入的参数</span><br><span class="line">            send(&quot;args[3]=&quot; + args[3]); //第二个参数</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave: function(retval)&#123; //onLeave: 该函数执行结束要执行的代码，其中retval参数即是返回值</span><br><span class="line">            send(&quot;return:&quot;+retval); //返回值</span><br><span class="line">            retval.replace(100); //替换返回值为100</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def printMessage(message,data):</span><br><span class="line">    if message[&#x27;type&#x27;] == &#x27;send&#x27;:</span><br><span class="line">        print(&#x27;[*] &#123;0&#125;&#x27;.format(message[&#x27;payload&#x27;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(&#x27;com.example.testso&#x27;) #进程名</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(&#x27;message&#x27;,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>

<h2 id="Hook修改native层函数返回值为string类型"><a href="#Hook修改native层函数返回值为string类型" class="headerlink" title="Hook修改native层函数返回值为string类型"></a><strong>Hook修改native层函数返回值为string类型</strong></h2><p>返回值为字符串其实是返回了一个<code>char \*</code>（字符串指针），所以简单的替换是无法取效果的</p>
<p>关键代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数</span><br><span class="line">var jstrings = env.newStringUtf(&quot;tamper&quot;); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针</span><br><span class="line">retval.replace(jstrings); //替换返回值</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import frida</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">jscode = &quot;&quot;&quot;</span><br><span class="line">Java.perform(function()&#123;</span><br><span class="line">    Interceptor.attach(Module.findExportByName(&quot;libfridaso.so&quot;,&quot;Java_com_example_fridasostring_fridaSoString_FridaSo&quot;),&#123;</span><br><span class="line">        onEnter: function(args) &#123;</span><br><span class="line">            send(&quot;Hook start&quot;);</span><br><span class="line">            send(&quot;args[2]=&quot; + args[2]);</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave: function(retval)&#123;</span><br><span class="line">            send(&quot;return:&quot;+retval);</span><br><span class="line">            var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数</span><br><span class="line">            var jstrings = env.newStringUtf(&quot;tamper&quot;); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针</span><br><span class="line">            retval.replace(jstrings); //替换返回值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def printMessage(message,data):</span><br><span class="line">    if message[&#x27;type&#x27;] == &#x27;send&#x27;:</span><br><span class="line">        print(&#x27;[*] &#123;0&#125;&#x27;.format(message[&#x27;payload&#x27;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(&#x27;com.example.fridasostring&#x27;)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(&#x27;message&#x27;,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>

<h2 id="Frida命令"><a href="#Frida命令" class="headerlink" title="Frida命令"></a>Frida命令</h2><p>基础命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动frida-server(模拟器)</span><br><span class="line">./data/local/tmp/frida-server-12.8.0-android-x86</span><br><span class="line"></span><br><span class="line"># 启动frida-server(Pixel真机)</span><br><span class="line">./data/local/tmp/frida-server-12.8.0-android-arm64</span><br><span class="line"></span><br><span class="line"># 在我的电脑之中模拟器运行frida-server(因为将这个文件导入的时候进行了重命名为frida-server)</span><br><span class="line">./data/local/tmp/frida-server</span><br><span class="line"></span><br><span class="line"># 转发端口</span><br><span class="line">adb forward tcp:27042 tcp:27042</span><br><span class="line">adb forward tcp:27043 tcp:27043</span><br><span class="line"></span><br><span class="line"># 列举出来所有连接到电脑上的设备</span><br><span class="line">frida-ls-devices</span><br><span class="line"></span><br><span class="line"># 连接到指定设备</span><br><span class="line">frida-ps -D tcp</span><br><span class="line"></span><br><span class="line"># 列举出来设备上的所有进程</span><br><span class="line">frida-ps -U</span><br><span class="line"></span><br><span class="line"># 列举出来设备上的所有应用程序</span><br><span class="line">frida-ps -Ua</span><br><span class="line"></span><br><span class="line"># 列举出来设备上的所有已安装应用程序和对应的名字</span><br><span class="line">frida-ps -Uai</span><br><span class="line"></span><br><span class="line"># 跟踪某个函数</span><br><span class="line">frida-trace -U -f Name -i &quot;函数名&quot;</span><br><span class="line"># frida-trace -U -f com.autonavi.minimap -i &quot;getRequestParams&quot;</span><br><span class="line"></span><br><span class="line"># 跟踪某个方法</span><br><span class="line">frida-trace -U -f Name -m &quot;方法名&quot;</span><br><span class="line"># frida-trace -U -f com.autonavi.minimap -m &quot;MapLoader&quot;</span><br></pre></td></tr></table></figure>



<h1 id="d3mug"><a href="#d3mug" class="headerlink" title="d3mug"></a>d3mug</h1><p>ctf之中的游戏逆向（unity3D逆向分析）</p>
<p>unity逆向的文章（里面有各种各样的有关unity的题目，可以学习一下）：<a href="https://forum.butian.net/share/1294">https://forum.butian.net/share/1294</a></p>
<p><strong>unity游戏IL2CPP类型</strong></p>
<p>这道题是 ：IL2CPP类型相对来说，题目难度有一个质的提升。对unity的理解程度需要更深。IL2CPP的Unity3D游戏的逆向，只需要根据global-metadata.dat和libil2cpp.so来进行就可以了。</p>
<p><strong>il2cpp的内部实现文档</strong>：<a href="https://blogs.unity3d.com/2015/05/06/an-introduction-to-ilcpp-internals/">https://blogs.unity3d.com/2015/05/06/an-introduction-to-ilcpp-internals/</a></p>
<p>il2cpp（主要分析metadata的一篇文章）</p>
<p>游戏的主页面</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305085623123.png" alt="image-20220305085623123"></p>
<p>游戏的运行界面：需要在白线的上面不停的点击这些蓝色的模块，如果能在白线的位置上点击到，那么GOOD就会增加一</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305085823662.png" alt="image-20220305085823662"></p>
<h2 id="IL2CPPDumper"><a href="#IL2CPPDumper" class="headerlink" title="IL2CPPDumper"></a>IL2CPPDumper</h2><p>使用<strong>IL2CPPDumper这个工具</strong>将apk解包之后的<strong>global-metadata.dat</strong>和<strong>libil2cpp.so</strong>这两个文件，<strong>dump出</strong>该DLL里的所有类以及类里的方法和成员，</p>
<p>使用<a href="https://blog.csdn.net/linxinfa/article/details/116572369">IL2CPPDumper</a>这个工具dump的方法以及dump出来的文件说明</p>
<p>dump（input文件）</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305092747884.png" alt="image-20220305092747884"></p>
<p>dump（output文件）</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305092816043.png" alt="image-20220305092816043"></p>
<p><strong>dump.cs</strong>:</p>
<p>这个文件会把<code>C#</code>的<code>dll</code>代码的类、方法、字段列出来。这里面有非常多的数据</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305093238515.png" alt="image-20220305093238515"></p>
<p><strong>il2cpp.h</strong>：</p>
<p>生成的<code>cpp</code>的头文件，从头文件里我们也可以看到相关的数据结构</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305093516208.png" alt="image-20220305093516208"></p>
<p><strong>script.json</strong>：</p>
<p>以<code>json</code>格式显示类的方法信息</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305093703245.png" alt="image-20220305093703245"></p>
<p><strong>stringliteral.json</strong>：</p>
<p>以json的格式显示所有的字符串信息</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305094319654.png" alt="image-20220305094319654"></p>
<p><strong>DummyDll/Assembly-CSharp.dll</strong></p>
<p>进入DummyDll目录，可以看到很多dll，其中就有Assembly-CSharp.dll，使用dnspy打开这个文件</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305095103745.png" alt="image-20220305095103745"></p>
<p>文件列表：可以看到这里是游戏页面的初始化，组件（线），音乐等等</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220305095653171.png" alt="image-20220305095653171"></p>
<p>从上面<strong>IL2CppDumper</strong>我们可以发现，逆向得到的函数体都是空的，看不了内部逻辑。内部的逻辑结构就需要使用IDA查看libil2cpp.so这个文件，在这个文件中使用上面得到的cs文件的偏移量找到目标的函数</p>
<h2 id="关键函数定位"><a href="#关键函数定位" class="headerlink" title="关键函数定位"></a>关键函数定位</h2><p>将Il2CppDumper 处理之后得到的Assembly-CSharp.dll文件放入到dnspy之中，这个文件里面存放了这个游戏里面函数的偏移地址</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314175022511.png" alt="image-20220314175022511"></p>
<p>根据需要查看相应的类，再查看相应的类中的函数的偏移地址</p>
<p>这里我们需要查看 GameManager和 ScoreScene类中的函数</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314175327440.png" alt="image-20220314175327440"></p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314175404995.png" alt="image-20220314175404995"></p>
<h2 id="游戏逻辑分析"><a href="#游戏逻辑分析" class="headerlink" title="游戏逻辑分析"></a>游戏逻辑分析</h2><p>使用上面得到的Assembly-CSharp.dll文件定位到函数的关键地址</p>
<h3 id="NoteObject类中的OnClicked-函数"><a href="#NoteObject类中的OnClicked-函数" class="headerlink" title="NoteObject类中的OnClicked()函数"></a>NoteObject类中的OnClicked()函数</h3><p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314180743397.png" alt="image-20220314180743397"></p>
<p>再跟进这个判断时间的函数之中 它的rva是RVA = “0x62B64C” ，查看Assembly-CSharp.dll这个文件我们可以知道它就是NoteHit()函数</p>
<h3 id="GameManager类的NoteHit-函数"><a href="#GameManager类的NoteHit-函数" class="headerlink" title="GameManager类的NoteHit()函数"></a>GameManager类的NoteHit()函数</h3><p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314180815068.png" alt="image-20220314180815068"></p>
<h3 id="GameManager类中的update-函数"><a href="#GameManager类中的update-函数" class="headerlink" title="GameManager类中的update()函数"></a>GameManager类中的update()函数</h3><p>从上面那张图中可以得到在NoteHit()函数的结尾的地方调用了update()函数</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314182013914.png" alt="image-20220314182013914"></p>
<p>上面这个update()函数调用了libd3mug.so的update()函数，这个函数的最后调用了server.run</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220315210534201.png" alt="image-20220315210534201"></p>
<p>逻辑分析：点击了NodeObject是表示音游之中的方块的类，NoteObject类中的OnClicked()函数表示点击方块，之后会触发GameManager类的NoteHit()函数分析点击的时间，从而确定是否点击成功与否，该函数之后会调用GameManager类中的update()函数</p>
<p>然后查看分数的模块ScoreScene类</p>
<h3 id="ScoreScene类的get-函数"><a href="#ScoreScene类的get-函数" class="headerlink" title="ScoreScene类的get()函数"></a>ScoreScene类的get()函数</h3><p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314183330050.png" alt="image-20220314183330050"></p>
<p>上面这个get()函数里面调用了libd3mug.so中的get()函数</p>
<h3 id="libd3mug-so中的get-函数"><a href="#libd3mug-so中的get-函数" class="headerlink" title="libd3mug.so中的get()函数"></a>libd3mug.so中的get()函数</h3><p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220315210430564.png" alt="image-20220315210430564"></p>
<p>通过这个函数交叉查询一下，找到引用该函数的函数sub_62EE40() 它便是ScoreScene类的Start()函数</p>
<h3 id="ScoreScene类的Start-函数"><a href="#ScoreScene类的Start-函数" class="headerlink" title="ScoreScene类的Start()函数"></a>ScoreScene类的Start()函数</h3><p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314183807139.png" alt="image-20220314183807139"></p>
<p>逻辑分析：游戏结束之后会转到的类是ScoreScene类，其中最后显示分数的函数中，调用了get()函数，这样获得了一个字符串</p>
<h2 id="AssertStudio获得谱面"><a href="#AssertStudio获得谱面" class="headerlink" title="AssertStudio获得谱面"></a>AssertStudio获得谱面</h2><p>这是一个音游的游戏，由于需要我们踩点正确，所以就要我们找到这个游戏中的谱面（音乐的谱子），使用<a href="%5B(6%E6%9D%A1%E6%B6%88%E6%81%AF">AssertStudio</a> Unity解包提取资源/AssetStudio的简单使用_咲奈的平行时空-CSDN博客_unity解包](<a href="https://blog.csdn.net/qq_21567385/article/details/107015800))%E5%8A%A0%E8%BD%BD%E8%BF%99%E4%B8%AAunity%E6%B8%B8%E6%88%8F%E7%9A%84assets%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%9C%A8%E5%AE%83%E7%9A%84Asset">https://blog.csdn.net/qq_21567385/article/details/107015800))加载这个unity游戏的assets目录，在它的Asset</a> List下面我们能够看到很多资源文件，其中的hitpoints的文件就是它的谱面</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314193510893.png" alt="image-20220314193510893"></p>
<p>在这个游戏页面的首页之中我们就能够看到这个游戏的音乐是 Chromevox</p>
<p>这里有三个音乐的hitpoints 我们选择其中是Chromevox的</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314194026586.png" alt="image-20220314194026586"></p>
<p>将这个文件导出出来,这个文件之中前面表示的是轨道数，后面表示的是时间</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314194629112.png" alt="image-20220314194629112"></p>
<p>按照之前的方法找到GameManager类的NoteMissed()函数</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314195819635.png" alt="image-20220314195819635"></p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314195836835.png" alt="image-20220314195836835"></p>
<p>从图中我们可以知道update()中的参数就是msecs，所以我们需要将得到的hitpoints中的msecs作为 参数传入其中，这个过程就需要frida来hook函数</p>
<h2 id="frida"><a href="#frida" class="headerlink" title="frida"></a>frida</h2><p>查看frida-server是否成功开启，-U表示USB，允许Frida检查USB设备，这时将看到一个进程列表。</p>
<p><img src="/images/frida-d3mug%E5%A4%8D%E7%8E%B0/image-20220314205710639.png" alt="image-20220314205710639"></p>
<p>通过该命令可以得到frida脚本中所需要的文件信息(pid 和 应用名和包名)</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import frida, sys</span><br><span class="line"></span><br><span class="line">jscode = &quot;&quot;&quot;</span><br><span class="line">console.log(&#x27;12345&#x27;)</span><br><span class="line">let hitpoints = [0, 0, 0, 146, 292, 292, 439, 512, 585, 585, 658, 731, 804, 878, 1024, 1170, 1170, 1317, 1463, 1463, 1609, 1682, 1756, 1756, 1902, 2048, 2195, 2341, 2341, 2487, 2634, 2634, 2780, 2853, 2926, 2926, 3073, 3146, 3219, 3219, 3365, 3439, 3512, 3512, 3658, 3804, 3878, 3951, 4024, 4097, 4097, 4243, 4390, 4682, 4682, 4682, 4829, 4975, 4975, 5121, 5195, 5268, 5341, 5414, 5487, 5560, 5560, 5853, 5853, 5999, 6146, 6146, 6292, 6365, 6439, 6439, 6585, 6731, 6731, 6731, 7024, 7024, 7170, 7317, 7317, 7463, 7536, 7609, 7609, 7682, 7756, 7829, 7902, 7902, 7975, 8048, 8121, 8195, 8341, 8487, 8634, 8780, 9073, 9073, 9073, 9219, 9365, 9365, 9512, 9658, 9658, 9804, 9878, 9951, 9951, 10097, 10243, 10243, 10243, 10390, 10463, 10536, 10536, 10682, 10829, 10829, 10975, 11121, 11121, 11268, 11414, 11414, 11560, 11707, 11707, 11853, 11999, 11999, 11999, 12146, 12292, 12292, 12439, 12439, 12585, 12585, 12585, 12731, 12878, 12951, 13024, 13097, 13170, 13170, 13317, 13463, 13463, 13463, 13609, 13756, 13756, 13756, 13902, 14048, 14048, 14195, 14341, 14487, 14634, 14634, 14926, 14926, 14926, 15219, 15219, 15219, 15365, 15365, 15512, 15512, 15658, 15804, 15804, 15951, 16024, 16097, 16097, 16170, 16243, 16317, 16390, 16390, 16536, 16682, 16682, 16829, 16902, 16975, 16975, 17121, 17268, 17268, 17268, 17414, 17560, 17634, 17707, 17780, 17853, 17926, 17999, 18073, 18146, 18146, 18292, 18439, 18439, 18731, 18731, 18731, 18878, 19024, 19024, 19024, 19170, 19243, 19317, 19463, 19609, 19609, 19609, 19756, 19829, 19902, 20048, 20195, 20195, 20341, 20487, 20487, 20634, 20780, 20780, 20926, 21073, 21073, 21219, 21365, 21365, 21365, 21512, 21585, 21658, 21658, 21804, 21951, 21951, 21951, 22097, 22243, 22317, 22390, 22463, 22536, 22536, 22609, 22682, 22756, 22829, 22829, 22975, 23121, 23121, 23268, 23414, 23560, 23707, 23780, 23853, 23926, 23999, 23999, 24073, 24146, 24219, 24292, 24365, 24439, 24512, 24585, 24585, 24731, 24731, 24878, 24878, 24878, 25024, 25170, 25170, 25317, 25390, 25463, 25463, 25609, 25756, 25756, 25756, 25902, 25902, 26048, 26048, 26195, 26195, 26341, 26341, 26414, 26487, 26487, 26560, 26634, 26634, 26780, 26780, 26926, 27219, 27512, 27585, 27658, 27731, 27804, 27804, 28097, 28097, 28390, 28682, 28682, 28975, 29268, 29268, 29560, 29560, 29853, 29853, 30146, 30439, 30439, 30731, 31024, 31024, 31317, 31609, 31609, 31902, 32195, 32195, 32487, 32780, 32780, 32780, 33365, 33365, 33365, 33951, 33951, 34243, 34536, 34536, 34829, 35121, 35121, 35414, 35707, 35707, 35707, 35999, 36292, 36585, 36878, 36878, 37024, 37024, 37170, 37170, 37463, 37463, 37463, 37609, 37756, 37756, 37902, 38048, 38048, 38195, 38341, 38341, 38487, 38634, 38634, 38780, 38926, 39073, 39219, 39365, 39512, 39658, 39804, 39804, 39951, 40097, 40097, 40243, 40390, 40390, 40536, 40682, 40829, 40975, 40975, 41121, 41268, 41414, 41560, 41707, 41853, 41999, 42146, 42146, 42292, 42292, 42439, 42585, 42731, 42731, 42878, 42878, 43024, 43170, 43317, 43317, 43463, 43463, 43609, 43609, 43682, 43756, 43756, 43829, 43902, 43902, 44048, 44048, 44195, 44195, 44341, 44341, 44487, 44560, 44634, 44707, 44780, 44853, 44926, 44999, 45073, 45146, 45219, 45292, 45365, 45439, 45512, 45585, 45658, 45658, 45804, 45951, 45951, 46097, 46243, 46243, 46536, 46536, 46536, 46829, 46829, 46902, 46975, 47121, 47121, 47268, 47414, 47414, 47560, 47634, 47707, 47707, 47853, 47926, 47999, 47999, 48146, 48292, 48292, 48439, 48585, 48585, 48731, 48878, 48878, 49024, 49170, 49170, 49243, 49317, 49463, 49463, 49609, 49756, 49756, 49902, 49975, 50048, 50048, 50121, 50195, 50268, 50341, 50341, 50487, 50487, 50707, 50707, 50926, 50926, 51073, 51219, 51365, 51512, 51512, 51585, 51658, 51804, 51804, 51951, 52097, 52097, 52170, 52243, 52317, 52390, 52390, 52536, 52609, 52682, 52682, 52829, 52975, 52975, 53121, 53268, 53268, 53414, 53560, 53560, 53707, 53853, 53853, 53926, 53999, 54073, 54146, 54146, 54219, 54292, 54365, 54439, 54439, 54512, 54585, 54658, 54731, 54731, 54878, 54878, 55024, 55024, 55024, 55317, 55317, 55317, 55609, 55609, 55609, 55902, 55902, 55902, 56195, 56268, 56341, 56487, 56487, 56634, 56780, 56780, 56926, 56999, 57073, 57073, 57219, 57292, 57365, 57365, 57512, 57658, 57658, 57804, 57951, 57951, 58097, 58243, 58243, 58390, 58536, 58536, 58609, 58682, 58829, 58829, 58975, 59121, 59121, 59268, 59341, 59414, 59414, 59560, 59634, 59707, 59707, 59853, 59926, 59999, 59999, 60073, 60292, 60292, 60439, 60585, 60585, 60731, 60878, 60878, 60951, 61024, 61024, 61170, 61170, 61317, 61317, 61463, 61463, 61463, 61536, 61609, 61609, 61756, 61756, 61902, 61902, 62048, 62048, 62048, 62121, 62195, 62195, 62341, 62341, 62414, 62487, 62560, 62634, 62634, 62780, 62780, 62926, 62926, 63073, 63073, 63219, 63219, 63292, 63365, 63439, 63512, 63512, 63585, 63658, 63731, 63804, 63804, 63878, 63951, 64024, 64097, 64097, 64170, 64243, 64317, 64390, 64390, 64536, 64536, 64609, 64682, 64829, 64975, 65121, 65268, 65414, 65560, 65560, 65707, 65853, 65999, 66146, 66146, 66439, 66585, 66878, 67170, 67317, 67317, 67609, 67902, 68048, 68195, 68341, 68487, 68487, 68780, 68926, 69073, 69219, 69365, 69512, 69658, 69658, 69804, 69951, 70243, 70390, 70536, 70682, 70829, 70829, 71121, 71268, 71560, 71853, 71999, 71999, 72292, 72585, 72731, 72878, 73024, 73170, 73317, 73463, 73609, 73609, 73756, 73975, 74195, 74341, 74341, 74634, 74707, 74780, 74926, 74926, 75073, 75073, 75219, 75219, 75219, 75365, 75512, 75512, 75658, 75658, 75804, 75804, 75804, 75951, 76097, 76097, 76390, 76390, 76390, 76536, 76682, 76682, 76829, 76829, 76975, 76975, 76975, 77268, 77268, 77414, 77560, 77560, 77561, 77707, 77853, 77853, 77999, 77999, 78146, 78146, 78146, 78292, 78439, 78439, 78731, 78732, 78732, 78878, 79024, 79024, 79170, 79171, 79317, 79317, 79463, 79609, 79609, 79756, 79902, 79902, 80048, 80195, 80341, 80341, 80487, 80487, 80634, 80780, 80780, 80926, 80926, 81073, 81073, 81073, 81219, 81365, 81512, 81512, 81658, 81658, 81658, 81951, 81951, 81951, 82097, 82243, 82243, 82390, 82536, 82682, 82682, 82829, 82829, 82829, 82975, 83121, 83121, 83268, 83414, 83414, 83560, 83707, 83853, 83853, 83999, 83999, 83999, 84292, 84292, 84365, 84439, 84512, 84585, 84585, 84731, 84804, 84878, 84878, 84951, 85024, 85097, 85170, 85170, 85317, 85390, 85463, 85463, 85536, 85609, 85682, 85756, 85756, 85829, 85902, 85975, 86048, 86048, 86121, 86195, 86268, 86341, 86341, 86487, 86634, 86634, 86707, 86780, 86853, 86926, 86926, 87073, 87146, 87219, 87219, 87292, 87365, 87439, 87512, 87512, 87658, 87804, 87804, 87878, 87951, 88024, 88097, 88097, 88170, 88243, 88317, 88390, 88390, 88536, 88609, 88682, 88682, 88829, 88975, 88975, 89121, 89121, 89268, 89268, 89414, 89414, 89560, 89560, 89707, 89707, 89853, 89853, 89999, 89999, 90146, 90146, 90292, 90292, 90439, 90439, 90585, 90585, 90731, 90731, 90878, 90878, 91024, 91024, 91170, 91170, 91317, 91317, 91390, 91463, 91536, 91609, 91682, 91756, 91829, 91902, 91975, 92048, 92121, 92195, 92268, 92341, 92634, 92780, 92926, 93219, 93365, 93365, 93365, 93365, 93658, 93658, 93804, 93878, 93951, 93951, 94097, 94243, 94317, 94390, 94463, 94536, 94536, 94682, 94829, 94829, 94975, 95121, 95121, 95268, 95414, 95487, 95560, 95634, 95707, 95707, 95853, 95853, 95999, 95999, 96146, 96292, 96292, 96292, 96439, 96585, 96585, 96658, 96731, 96804, 96878, 96878, 97024, 97170, 97170, 97317, 97390, 97463, 97463, 97609, 97756, 97756, 97829, 97902, 98048, 98048, 98048, 98195, 98341, 98341, 98487, 98560, 98634, 98634, 98780, 98926, 98926, 99073, 99219, 99219, 99365, 99512, 99512, 99658, 99804, 99804, 99951, 100097, 100170, 100243, 100317, 100390, 100390, 100536, 100682, 100682, 100829, 100975, 100975, 100975, 101121, 101268, 101268, 101341, 101414, 101487, 101560, 101560, 101707, 101853, 101853, 101926, 101999, 102073, 102146, 102146, 102292, 102439, 102439, 102439, 102585, 102658, 102731, 102731, 102878, 103024, 103024, 103024, 103170, 103243, 103317, 103317, 103317, 103463, 103609, 103682, 103756, 103829, 103902, 103902, 104048, 104195, 104195, 104341, 104487, 104487, 104487, 104634, 104780, 104853, 104926, 104999, 105073, 105073, 105219, 105365, 105365, 105512, 105658, 105658, 105658, 105804, 105951, 105951, 106097, 106170, 106243, 106243, 106317, 106390, 106536, 106536, 106682, 106756, 106829, 106829, 106829, 106975, 107121, 107121, 107268, 107268, 107414, 107414, 107414, 107560, 107707, 107707, 107707, 107853, 107999, 107999, 107999, 108146, 108292, 108292, 108439, 108585, 108585, 108731, 108878, 108878, 108878, 109024, 109170, 109170, 109317, 109463, 109463, 109536, 109609, 109682, 109756, 109756, 109902, 110048, 110048, 110048, 110195, 110195, 110341, 110341, 110341, 110487, 110487, 110634, 110634, 110634, 110780, 110780, 110926, 110926, 110926, 111073, 111073, 111219, 111219, 111219, 111365, 111512, 111658, 111731, 111804, 111878, 111951, 112024, 112097, 112097, 112097, 112390, 112390, 112536, 112682, 112682, 112682, 112829, 112975, 112975, 113121, 113268, 113268, 113414, 113560, 113560, 113707, 113853, 113853, 113999, 114146, 114219, 114292, 114365, 114439, 114439, 114585, 114731, 114731, 114878, 115024, 115024, 115024, 115170, 115317, 115317, 115463, 115536, 115609, 115609, 115756, 115902, 115902, 115975, 116048, 116121, 116195, 116195, 116268, 116341, 116414, 116487, 116487, 116560, 116634, 116707, 116780, 116780, 116926, 117073, 117073, 117219, 117365, 117365, 117512, 117658, 117658, 117804, 117878, 117951, 117951, 118097, 118243, 118243, 118390, 118536, 118536, 118682, 118829, 118902, 118975, 119048, 119121, 119121, 119268, 119414, 119414, 119560, 119707, 119707, 119853, 119999, 119999, 120146, 120292, 120292, 120439, 120439, 120731, 121024, 121170, 121463, 121536, 121609, 121682, 121756, 121756, 121756, 121902, 122048, 122048, 122048, 122195, 122341, 122341, 122341, 122487, 122560, 122634, 122634, 122634, 122780, 122926, 122926, 122926, 123073, 123219, 123219, 123219, 123365, 123512, 123512, 123512, 123585, 123658, 123731, 123804, 123804, 123804, 123951, 124097, 124097, 124097, 124243, 124390, 124390, 124390, 124536, 124682, 124682, 124682, 124829, 124975, 124975, 124975, 125121, 125268, 125268, 125268, 125414, 125487, 125560, 125560, 125560, 125707, 125853, 125853, 125853, 125999, 126146, 126146, 126146, 126292, 126439, 126439, 126439, 126585, 126585, 126731, 126731, 126878, 126878, 127024, 127024, 127024, 127170, 127170, 127317, 127317, 127463, 127463, 127609, 127609, 127609, 127756, 127756, 127902, 127902, 128048, 128048, 128195, 128195, 128268, 128341, 128341, 128414, 128487, 128487, 128560, 128634, 128707, 128780, 128780, 128853, 128926, 128999, 129073, 129146, 129219, 129292, 129365, 129365, 129439, 129512, 129585, 129658, 129731, 129804, 129878, 129951, 129951, 130024, 130097, 130170, 130243, 130243, 130317, 130390, 130463, 130536, 130536, 130682, 130756, 130829, 130829, 130829, 130975, 130975, 131121, 131195, 131268, 131341, 131560, 131707, 131707, 131780, 131853, 131926, 132146, 132292, 132365, 132439, 132512, 132731, 132878, 132878, 132951, 133024, 133097, 133463, 133463, 133756, 134048, 134048, 134048, 134341, 134634, 134634, 134926, 134926, 135219, 135219, 135219, 135512, 135512, 135658, 135658, 135804, 135804, 135951, 135951, 136097, 136097, 136243, 136243, 136390, 136390, 136536, 136536, 136609, 136682, 136682, 136829, 136829, 136902, 136975, 136975, 137121, 137121, 137268, 137268, 137414, 137414, 137560, 137560, 137707, 137707, 137780, 137853, 137926, 137999, 137999, 138073, 138146, 138146, 138219, 138292, 138365, 138439, 138439, 138512, 138585, 138658, 138731, 138731, 138804, 138878, 138951, 139024, 139024, 139097, 139170, 139243, 139317, 139317, 139463, 139463, 139609, 139609, 139756, 139756, 139902, 139902, 140195, 140195, 140195, 140195]</span><br><span class="line">let UpdateFunc = new NativeFunction(Module.findExportByName(&quot;libd3mug.so&quot;,&quot;update&quot;),&quot;void&quot;,[&#x27;int&#x27;])</span><br><span class="line">for(let i=0;i&lt;hitpoints.length;i++)&#123;</span><br><span class="line">UpdateFunc(hitpoints[i]);</span><br><span class="line">&#125;</span><br><span class="line">let GetFunc = new NativeFunction(Module.findExportByName(&quot;libd3mug.so&quot;,&quot;get&quot;),&quot;pointer&quot;,[]);</span><br><span class="line">var result = GetFunc();</span><br><span class="line">console.log(ptr(result));</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#x27;type&#x27;] == &#x27;send&#x27;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line"># 查找USB设备并附加到目标进程</span><br><span class="line">#session = frida.get_remote_device(timeout=1000).attach(4103) # 通过命令查到的pid</span><br><span class="line"># 使用进程名称attach</span><br><span class="line"># session = frida.get_remote_device(timeout=1000).attach(&quot;LostBits&quot;)</span><br><span class="line"># 在我的电脑上能够attach的方法</span><br><span class="line">device = frida.get_remote_device()</span><br><span class="line">pid = device.spawn([&#x27;com.DefaultCompany.com.unity.template.mobile2D&#x27;])</span><br><span class="line">print(pid)</span><br><span class="line">session = device.attach(pid)</span><br><span class="line"># 在目标进程里创建脚本</span><br><span class="line">script = session.create_script(jscode)</span><br><span class="line"># 注册消息回调</span><br><span class="line">script.on(&#x27;message&#x27;, on_message)</span><br><span class="line">print(&#x27;[*] Start attach&#x27;)</span><br><span class="line"># 加载创建好的javascript脚本</span><br><span class="line">script.load()</span><br><span class="line"># 读取系统输入</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>

<p>D3CTF{Gb78e-7b04-4364-82d2-7f44}</p>
<p>如果用解密的方法从libd3mug.so函数分析加密的结果得到flag的脚本</p>
<p>官方的解释：libd3mug.so中的算法是一个类似于feistel的东西，通过一个静态的种子初始化</p>
<p>mt19937随机数生成器，然后先生成随机数判定是否要进入下一步解密，在解密中重新生成随机数作为key，然后选取</p>
<p>一个偏移在数据中取出32字节，加密其中的16字节并将左右位置互换，将每个note的击打时间都录入update函数，即</p>
<p>可解出正确答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;random&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const DWORD hitp[] = &#123; 0,0,0,146,292,292,439,512,585,585,658,731,804,878,1024,1170,1170,1317,1463,1463,1609,1682,1756,1756,1902,2048,2195,2341,2341,2487,2634,2634,2780,2853,2926,2926,3073,3146,3219,3219,3365,3439,3512,3512,3658,3804,3878,3951,4024,4097,4097,4243,4390,4682,4682,4682,4829,4975,4975,5121,5195,5268,5341,5414,5487,5560,5560,5853,5853,5999,6146,6146,6292,6365,6439,6439,6585,6731,6731,6731,7024,7024,7170,7317,7317,7463,7536,7609,7609,7682,7756,7829,7902,7902,7975,8048,8121,8195,8341,8487,8634,8780,9073,9073,9073,9219,9365,9365,9512,9658,9658,9804,9878,9951,9951,10097,10243,10243,10243,10390,10463,10536,10536,10682,10829,10829,10975,11121,11121,11268,11414,11414,11560,11707,11707,11853,11999,11999,11999,12146,12292,12292,12439,12439,12585,12585,12585,12731,12878,12951,13024,13097,13170,13170,13317,13463,13463,13463,13609,13756,13756,13756,13902,14048,14048,14195,14341,14487,14634,14634,14926,14926,14926,15219,15219,15219,15365,15365,15512,15512,15658,15804,15804,15951,16024,16097,16097,16170,16243,16317,16390,16390,16536,16682,16682,16829,16902,16975,16975,17121,17268,17268,17268,17414,17560,17634,17707,17780,17853,17926,17999,18073,18146,18146,18292,18439,18439,18731,18731,18731,18878,19024,19024,19024,19170,19243,19317,19463,19609,19609,19609,19756,19829,19902,20048,20195,20195,20341,20487,20487,20634,20780,20780,20926,21073,21073,21219,21365,21365,21365,21512,21585,21658,21658,21804,21951,21951,21951,22097,22243,22317,22390,22463,22536,22536,22609,22682,22756,22829,22829,22975,23121,23121,23268,23414,23560,23707,23780,23853,23926,23999,23999,24073,24146,24219,24292,24365,24439,24512,24585,24585,24731,24731,24878,24878,24878,25024,25170,25170,25317,25390,25463,25463,25609,25756,25756,25756,25902,25902,26048,26048,26195,26195,26341,26341,26414,26487,26487,26560,26634,26634,26780,26780,26926,27219,27512,27585,27658,27731,27804,27804,28097,28097,28390,28682,28682,28975,29268,29268,29560,29560,29853,29853,30146,30439,30439,30731,31024,31024,31317,31609,31609,31902,32195,32195,32487,32780,32780,32780,33365,33365,33365,33951,33951,34243,34536,34536,34829,35121,35121,35414,35707,35707,35707,35999,36292,36585,36878,36878,37024,37024,37170,37170,37463,37463,37463,37609,37756,37756,37902,38048,38048,38195,38341,38341,38487,38634,38634,38780,38926,39073,39219,39365,39512,39658,39804,39804,39951,40097,40097,40243,40390,40390,40536,40682,40829,40975,40975,41121,41268,41414,41560,41707,41853,41999,42146,42146,42292,42292,42439,42585,42731,42731,42878,42878,43024,43170,43317,43317,43463,43463,43609,43609,43682,43756,43756,43829,43902,43902,44048,44048,44195,44195,44341,44341,44487,44560,44634,44707,44780,44853,44926,44999,45073,45146,45219,45292,45365,45439,45512,45585,45658,45658,45804,45951,45951,46097,46243,46243,46536,46536,46536,46829,46829,46902,46975,47121,47121,47268,47414,47414,47560,47634,47707,47707,47853,47926,47999,47999,48146,48292,48292,48439,48585,48585,48731,48878,48878,49024,49170,49170,49243,49317,49463,49463,49609,49756,49756,49902,49975,50048,50048,50121,50195,50268,50341,50341,50487,50487,50707,50707,50926,50926,51073,51219,51365,51512,51512,51585,51658,51804,51804,51951,52097,52097,52170,52243,52317,52390,52390,52536,52609,52682,52682,52829,52975,52975,53121,53268,53268,53414,53560,53560,53707,53853,53853,53926,53999,54073,54146,54146,54219,54292,54365,54439,54439,54512,54585,54658,54731,54731,54878,54878,55024,55024,55024,55317,55317,55317,55609,55609,55609,55902,55902,55902,56195,56268,56341,56487,56487,56634,56780,56780,56926,56999,57073,57073,57219,57292,57365,57365,57512,57658,57658,57804,57951,57951,58097,58243,58243,58390,58536,58536,58609,58682,58829,58829,58975,59121,59121,59268,59341,59414,59414,59560,59634,59707,59707,59853,59926,59999,59999,60073,60292,60292,60439,60585,60585,60731,60878,60878,60951,61024,61024,61170,61170,61317,61317,61463,61463,61463,61536,61609,61609,61756,61756,61902,61902,62048,62048,62048,62121,62195,62195,62341,62341,62414,62487,62560,62634,62634,62780,62780,62926,62926,63073,63073,63219,63219,63292,63365,63439,63512,63512,63585,63658,63731,63804,63804,63878,63951,64024,64097,64097,64170,64243,64317,64390,64390,64536,64536,64609,64682,64829,64975,65121,65268,65414,65560,65560,65707,65853,65999,66146,66146,66439,66585,66878,67170,67317,67317,67609,67902,68048,68195,68341,68487,68487,68780,68926,69073,69219,69365,69512,69658,69658,69804,69951,70243,70390,70536,70682,70829,70829,71121,71268,71560,71853,71999,71999,72292,72585,72731,72878,73024,73170,73317,73463,73609,73609,73756,73975,74195,74341,74341,74634,74707,74780,74926,74926,75073,75073,75219,75219,75219,75365,75512,75512,75658,75658,75804,75804,75804,75951,76097,76097,76390,76390,76390,76536,76682,76682,76829,76829,76975,76975,76975,77268,77268,77414,77560,77560,77561,77707,77853,77853,77999,77999,78146,78146,78146,78292,78439,78439,78731,78732,78732,78878,79024,79024,79170,79171,79317,79317,79463,79609,79609,79756,79902,79902,80048,80195,80341,80341,80487,80487,80634,80780,80780,80926,80926,81073,81073,81073,81219,81365,81512,81512,81658,81658,81658,81951,81951,81951,82097,82243,82243,82390,82536,82682,82682,82829,82829,82829,82975,83121,83121,83268,83414,83414,83560,83707,83853,83853,83999,83999,83999,84292,84292,84365,84439,84512,84585,84585,84731,84804,84878,84878,84951,85024,85097,85170,85170,85317,85390,85463,85463,85536,85609,85682,85756,85756,85829,85902,85975,86048,86048,86121,86195,86268,86341,86341,86487,86634,86634,86707,86780,86853,86926,86926,87073,87146,87219,87219,87292,87365,87439,87512,87512,87658,87804,87804,87878,87951,88024,88097,88097,88170,88243,88317,88390,88390,88536,88609,88682,88682,88829,88975,88975,89121,89121,89268,89268,89414,89414,89560,89560,89707,89707,89853,89853,89999,89999,90146,90146,90292,90292,90439,90439,90585,90585,90731,90731,90878,90878,91024,91024,91170,91170,91317,91317,91390,91463,91536,91609,91682,91756,91829,91902,91975,92048,92121,92195,92268,92341,92634,92780,92926,93219,93365,93365,93365,93365,93658,93658,93804,93878,93951,93951,94097,94243,94317,94390,94463,94536,94536,94682,94829,94829,94975,95121,95121,95268,95414,95487,95560,95634,95707,95707,95853,95853,95999,95999,96146,96292,96292,96292,96439,96585,96585,96658,96731,96804,96878,96878,97024,97170,97170,97317,97390,97463,97463,97609,97756,97756,97829,97902,98048,98048,98048,98195,98341,98341,98487,98560,98634,98634,98780,98926,98926,99073,99219,99219,99365,99512,99512,99658,99804,99804,99951,100097,100170,100243,100317,100390,100390,100536,100682,100682,100829,100975,100975,100975,101121,101268,101268,101341,101414,101487,101560,101560,101707,101853,101853,101926,101999,102073,102146,102146,102292,102439,102439,102439,102585,102658,102731,102731,102878,103024,103024,103024,103170,103243,103317,103317,103317,103463,103609,103682,103756,103829,103902,103902,104048,104195,104195,104341,104487,104487,104487,104634,104780,104853,104926,104999,105073,105073,105219,105365,105365,105512,105658,105658,105658,105804,105951,105951,106097,106170,106243,106243,106317,106390,106536,106536,106682,106756,106829,106829,106829,106975,107121,107121,107268,107268,107414,107414,107414,107560,107707,107707,107707,107853,107999,107999,107999,108146,108292,108292,108439,108585,108585,108731,108878,108878,108878,109024,109170,109170,109317,109463,109463,109536,109609,109682,109756,109756,109902,110048,110048,110048,110195,110195,110341,110341,110341,110487,110487,110634,110634,110634,110780,110780,110926,110926,110926,111073,111073,111219,111219,111219,111365,111512,111658,111731,111804,111878,111951,112024,112097,112097,112097,112390,112390,112536,112682,112682,112682,112829,112975,112975,113121,113268,113268,113414,113560,113560,113707,113853,113853,113999,114146,114219,114292,114365,114439,114439,114585,114731,114731,114878,115024,115024,115024,115170,115317,115317,115463,115536,115609,115609,115756,115902,115902,115975,116048,116121,116195,116195,116268,116341,116414,116487,116487,116560,116634,116707,116780,116780,116926,117073,117073,117219,117365,117365,117512,117658,117658,117804,117878,117951,117951,118097,118243,118243,118390,118536,118536,118682,118829,118902,118975,119048,119121,119121,119268,119414,119414,119560,119707,119707,119853,119999,119999,120146,120292,120292,120439,120439,120731,121024,121170,121463,121536,121609,121682,121756,121756,121756,121902,122048,122048,122048,122195,122341,122341,122341,122487,122560,122634,122634,122634,122780,122926,122926,122926,123073,123219,123219,123219,123365,123512,123512,123512,123585,123658,123731,123804,123804,123804,123951,124097,124097,124097,124243,124390,124390,124390,124536,124682,124682,124682,124829,124975,124975,124975,125121,125268,125268,125268,125414,125487,125560,125560,125560,125707,125853,125853,125853,125999,126146,126146,126146,126292,126439,126439,126439,126585,126585,126731,126731,126878,126878,127024,127024,127024,127170,127170,127317,127317,127463,127463,127609,127609,127609,127756,127756,127902,127902,128048,128048,128195,128195,128268,128341,128341,128414,128487,128487,128560,128634,128707,128780,128780,128853,128926,128999,129073,129146,129219,129292,129365,129365,129439,129512,129585,129658,129731,129804,129878,129951,129951,130024,130097,130170,130243,130243,130317,130390,130463,130536,130536,130682,130756,130829,130829,130829,130975,130975,131121,131195,131268,131341,131560,131707,131707,131780,131853,131926,132146,132292,132365,132439,132512,132731,132878,132878,132951,133024,133097,133463,133463,133756,134048,134048,134048,134341,134634,134634,134926,134926,135219,135219,135219,135512,135512,135658,135658,135804,135804,135951,135951,136097,136097,136243,136243,136390,136390,136536,136536,136609,136682,136682,136829,136829,136902,136975,136975,137121,137121,137268,137268,137414,137414,137560,137560,137707,137707,137780,137853,137926,137999,137999,138073,138146,138146,138219,138292,138365,138439,138439,138512,138585,138658,138731,138731,138804,138878,138951,139024,139024,139097,139170,139243,139317,139317,139463,139463,139609,139609,139756,139756,139902,139902,140195,140195,140195,140195 &#125;;</span><br><span class="line"></span><br><span class="line">DWORD __ROR4__(DWORD a1, char a2)</span><br><span class="line">&#123;</span><br><span class="line">  return (a1 &gt;&gt; a2) | (a1 &lt;&lt; (32 - a2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int rounds(uint8_t* bytes, unsigned int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  DWORD* v3; // r4</span><br><span class="line">  DWORD v4; // r12</span><br><span class="line">  DWORD v5[2]; // r5</span><br><span class="line">  DWORD v6; // r3</span><br><span class="line">  DWORD result; // r0</span><br><span class="line"></span><br><span class="line">  v3 = (DWORD*)((char*)bytes + a3);</span><br><span class="line">  v4 = *(DWORD*)((char*)bytes + a3);</span><br><span class="line">  *(DWORD64*)&amp;v5[0] = *(DWORD64*)((char*)bytes + a3 + 4);</span><br><span class="line">  v6 = *(DWORD*)((char*)bytes + a3 + 12);</span><br><span class="line">  *(DWORD*)((char*)bytes + a3) = *(&amp;v5[0] + 1);</span><br><span class="line">  result = v4 ^ __ROR4__(*(&amp;v5[0] + 1) ^ a2, 19);</span><br><span class="line">  v3[3] = v5[0] ^ __ROR4__(v6, 18) ^ __ROR4__(*(&amp;v5[0] + 1) ^ a2, 19);</span><br><span class="line">  v3[1] = v6;</span><br><span class="line">  v3[2] = result;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char enc_bytes[] =</span><br><span class="line">  &#123;</span><br><span class="line">    0x3C, 0xAC, 0x92, 0x6F, 0x44, 0xA1, 0xC1, 0x17, 0xFD, 0x62,</span><br><span class="line">    0x60, 0xDD, 0x63, 0xF8, 0xE3, 0x2A, 0x5E, 0x75, 0x78, 0xBE,</span><br><span class="line">    0x59, 0x46, 0x33, 0xF6, 0x2E, 0x64, 0x61, 0x8A, 0x27, 0x93,</span><br><span class="line">    0x21, 0x7D, 0x00</span><br><span class="line">  &#125;;</span><br><span class="line">  mt19937 rng(-196167794);</span><br><span class="line">  for (int i = 0; i &lt; 1608; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    if (rng() % 7 &gt;= 3)</span><br><span class="line">    &#123;</span><br><span class="line">      rounds(enc_bytes, rng(), hitp[i] &amp; 0xF);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%s\n&quot;, enc_bytes);</span><br><span class="line">  getchar();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">D3CTF&#123;Gb78e-7b04-4364-82d2-7f44&#125;</span><br></pre></td></tr></table></figure>

<p>最后得到flag：D3CTF{Gb78e-7b04-4364-82d2-7f44}</p>
]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>复现</tag>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>VNCTF_2022</title>
    <url>/2022/02/25/VNCTF-2022/</url>
    <content><![CDATA[<h2 id="VN2022"><a href="#VN2022" class="headerlink" title="VN2022"></a>VN2022</h2><h4 id="cm狗"><a href="#cm狗" class="headerlink" title="cm狗"></a>cm狗</h4><p>用jadx软件载入这个apk文件</p>
<p>判断flag的函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141557259.png" alt="image-20220215141557259"></p>
<p>判断的函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141619535.png" alt="image-20220215141619535"></p>
<p>loadDexClass()的这个函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141712322.png" alt="image-20220215141712322"></p>
<p>这里copyfile了一个dex的文件，这里copyFile()函数里面应该还有一系列的操作，一系列操作的结果最后写入了创建的一个文件里面</p>
<p>找到这个文件，并且找到这个函数</p>
<p><img src="/images/VNCTF-2022/image-20220219205934006.png" alt="image-20220219205934006"></p>
<p>该函数的详情</p>
<p><img src="/images/VNCTF-2022/image-20220219210128389.png" alt="image-20220219210128389"></p>
<p>主要的代码</p>
<p><img src="/images/VNCTF-2022/image-20220219210151167.png" alt="image-20220219210151167"></p>
<p><img src="/images/VNCTF-2022/image-20220219210531948.png" alt="image-20220219210531948"></p>
<p>注意这个地方是每次取1024出来，外层有个while(true)的循环的操作</p>
<p>得到的这个文件名称是 classes.dex</p>
<p><img src="/images/VNCTF-2022/image-20220219213108277.png" alt="image-20220219213108277"></p>
<p>对文件进行操作的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v0 = &#x27;vn2022&#x27;</span><br><span class="line">with open(&quot;D:\\re\\buuctf\\VN\\3\\ooo&quot;,&#x27;rb&#x27;) as f1:</span><br><span class="line">    c = f1.read()</span><br><span class="line">with open(&quot;D:\\re\\buuctf\\VN\\3\\out&quot;,&#x27;wb&#x27;) as f2:</span><br><span class="line">    for i in range(len(c)):</span><br><span class="line">        f2.write((c[i]^ord(v0[i %1024 % len(v0)])).to_bytes(1,byteorder=&quot;little&quot;,signed=False))</span><br><span class="line">print(&quot;OK&quot;)</span><br></pre></td></tr></table></figure>

<p>将得到的这个文件命名为class.dex，这是一个dex文件，首先使用dex2jar 将 dex文件转变成jar文件，然后使用jd-gui打开这个得到的jar文件，注意使用dex2jar得到jar文件的时候，需要将dex文件放入到dex2jar的文件夹目录之下</p>
<p>得到的这个文件之中 </p>
<p>加密函数 （xxtea加密）</p>
<p><img src="/images/VNCTF-2022/image-20220219223231506.png" alt="image-20220219223231506"></p>
<p>在hcheck这个函数之中，首先给了一堆数字，然后将输入的flag以及xxtea的密钥输入，对输入进行加密，加密的结果就是上面定义的一系列数值</p>
<p><img src="/images/VNCTF-2022/image-20220219223525059.png" alt="image-20220219223525059"></p>
<p><img src="/images/VNCTF-2022/image-20220219223528938.png" alt="image-20220219223528938"></p>
<p>去网上找一个xxtea解密的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9            //固定的一个常量</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   //固定的运算</span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])   //v是要加密的两个元素的数组</span><br><span class="line">&#123;                                                      //n为数组的长度</span><br><span class="line">    uint32_t y, z, sum;                                //无符号整型</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52/n;               //固定的得出轮数</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n-1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;                //每次进行叠加</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;          //固定运算</span><br><span class="line">            for (p=0; p&lt;n-1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+1];</span><br><span class="line">                v[p] += MX;</span><br><span class="line">                      z = v[p];</span><br><span class="line">                        &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n-1] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=n-1; p&gt;0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p-1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n-1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int8_t a[]= &#123;68, 39, -92, 108, -82, -18, 72, -55, 74, -56, 38, 11, 60, 84, 97, -40, 87, 71, 99, -82, 120, 104, 47, -71, -58, -57, 0, 33, 42, 38, -44, -39, -60, 113, -2, 92, -75, 118, -77, 50, -121, 43, 32, -106 &#125;;</span><br><span class="line">    uint32_t *v = (uint32_t *)a;</span><br><span class="line">    uint32_t *k= (uint32_t *)&quot;H4pPY_VNCTF!!OvO&quot;;</span><br><span class="line">    int n= 11;</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    printf(&quot;decrypto result:%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n&quot;,v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10]);</span><br><span class="line">    printf(&quot;result:%s&quot;,v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">VNCTF&#123;93ee7688-f216-42cb-a5c2-191ff4e412ba&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220219230318245.png" alt="image-20220219230318245"></p>
<p>所以最后的flag 是 VNCTF{93ee7688-f216-42cb-a5c2-191ff4e412ba}</p>
<h4 id="BabyMaze"><a href="#BabyMaze" class="headerlink" title="BabyMaze"></a>BabyMaze</h4><p>这道题如果直接使用employee6 解pyc得到代码是不行的，因为在这个代码里面有花指令，</p>
<p>方法一：直接使用pycda中的得到bytecode的底层的代码</p>
<p>看见迷宫，拼一下迷宫，按照w代表向上走，s代表向下走，a代表向左走，d代表向右走的方式走迷宫</p>
<p>python的pyc文件的反编译pycdc和pycdas这两个文件，pycdc反编译为python的代码，pycdas这个文件会将pyc文件编译成字节码的形式 <a href="http://www.syjblog.com/?p=470">pyc反编译</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/89935120">pyc的结构体</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Bytecode object */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">   PyObject_HEAD</span><br><span class="line">   int co_argcount;            /* Code Block的位置参数个数，比如说一个函数的位置参数个数*/</span><br><span class="line">   int co_nlocals;             /* Code Block中局部变量的个数，包括其中位置参数的个数 */</span><br><span class="line">   int co_stacksize;           /* 执行该段Code Block需要的栈空间 */</span><br><span class="line">   int co_flags;               /* CO_..., see below */</span><br><span class="line">   PyObject *co_code;          /* Code Block编译所得的字节码指令序列。以PyStingObjet的形式存在 */</span><br><span class="line">   PyObject *co_consts;        /* PyTupleObject对象，保存CodeBlock中的所常量 */</span><br><span class="line">   PyObject *co_names;         /* PyTupleObject对象，保存CodeBlock中的所有符号 */</span><br><span class="line">   PyObject *co_varnames;      /* Code Block中的局部变量名集合 */</span><br><span class="line">   PyObject *co_freevars;      /* Python实现闭包需要用的东西 */</span><br><span class="line">   PyObject *co_cellvars;      /* Code Block中内部嵌套函数所引用的局部变量名集合 */</span><br><span class="line">   /* The rest doesn&#x27;t count for hash/cmp */</span><br><span class="line">   PyObject *co_filename;      /* Code Block所对应的.py文件的完整路径 */</span><br><span class="line">   PyObject *co_name;          /* Code Block的名字，通常是函数名或类名 */</span><br><span class="line">   int co_firstlineno;         /* Code Block在对应的.py文件中起始行 */</span><br><span class="line">   PyObject *co_lnotab;        /* 字节码指令与.py文件中source code行号的对应关系，以PyStringObject的形式存在 */</span><br><span class="line">   void *co_zombieframe;     /* for optimization only (see frameobject.c) */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>

<p>得到：走出的迷宫的结果</p>
<p>ssssddssaassddddwwwwddwwddddddwwddddddssddwwddddddddssssaawwaassaassaassddssaassaawwwwwwaaaaaaaassaassddddwwddssddssssaassddssssaaaaaawwddwwaawwwwaassssssssssssddddssddssddddddddwwaaaaaawwwwddssddwwwwwwwwddssddssssssssddddss</p>
<p>将上面的解md5(32小写)得到最后的结果  VNCTF{801f190737434100e7d2790bd5b0732e}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                   1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">68      BUILD_LIST              31 1 5 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">132     BUILD_LIST              31 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1</span><br><span class="line">196     BUILD_LIST              31 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1</span><br><span class="line">260     BUILD_LIST              31 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1</span><br><span class="line">324     BUILD_LIST              31 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">388     BUILD_LIST              31 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1</span><br><span class="line">452     BUILD_LIST              31 1 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1</span><br><span class="line">516     BUILD_LIST              31 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1</span><br><span class="line">580     BUILD_LIST              31 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">644     BUILD_LIST              31 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1</span><br><span class="line">708     BUILD_LIST              31 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">772     BUILD_LIST              31 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1</span><br><span class="line">836     BUILD_LIST              31 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">900     BUILD_LIST              31 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1</span><br><span class="line">964     BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">1028    BUILD_LIST              31 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 0 1</span><br><span class="line">1092    BUILD_LIST              31 1 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">1156    BUILD_LIST              31 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1</span><br><span class="line">1220    BUILD_LIST              31 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">1284    BUILD_LIST              31 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 0 1</span><br><span class="line">1348    BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1412    BUILD_LIST              31 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1476    BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1540    BUILD_LIST              31 1 0 1 1 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1604    BUILD_LIST              31 1 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1</span><br><span class="line">1668    BUILD_LIST              31 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1</span><br><span class="line">1732    BUILD_LIST              31 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1</span><br><span class="line">1796    BUILD_LIST              31 1 0 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1</span><br><span class="line">1860    BUILD_LIST              31 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 7 1</span><br><span class="line">1924    BUILD_LIST              31 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>VNCTF{801f190737434100e7d2790bd5b0732e}</p>
<h4 id="时空飞行"><a href="#时空飞行" class="headerlink" title="时空飞行"></a>时空飞行</h4><p>运行一下这个程序，因为不能直接运行，所以使用IDA调试运行，所以现在我们需要找到日期和符来歌（根据运行之中的提示语句得到）</p>
<p><img src="/images/VNCTF-2022/image-20220221120512364.png" alt="image-20220221120512364"></p>
<p>变化之后的日期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0FD07C452h, 0EC90A488h, 68D33CD1h, 96F64587h</span><br></pre></td></tr></table></figure>

<p>对输入的日期进行加密的过程</p>
<p><img src="/images/VNCTF-2022/image-20220221122556035.png" alt="image-20220221122556035"></p>
<p>v5[v3] = sub_401A3B(v5[i + 3] ^ v5[i + 2] ^ (unsigned int)v5[i + 1] ^ dword_405040[i]) ^ v4;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v5[4] = sub_401A3B(v5[3] ^ v5[2] ^ (unsigned int)v5[1] ^ dword_405040[0]) ^ v5[0];</span><br><span class="line">v5[5] = sub_401A3B(v5[4] ^ v5[3] ^ (unsigned int)v5[2] ^ dword_405040[1]) ^ v5[1];</span><br><span class="line">... ...</span><br><span class="line">v5[34] = sub_401A3B(v5[33] ^ v5[32] ^ (unsigned int)v5[31] ^ dword_405040[2]) ^ v5[30];</span><br><span class="line">v5[35] = sub_401A3B(v5[34] ^ v5[33] ^ (unsigned int)v5[32] ^ dword_405040[3]) ^ v5[31];</span><br></pre></td></tr></table></figure>

<p>sub_401A3B()这个函数的作用</p>
<p><img src="/images/VNCTF-2022/image-20220221123230352.png" alt="image-20220221123230352"></p>
<p>a1和a1向左移13位的结果和a1向右移9位的结果做异或运算，</p>
<p>逆向分析的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">unsigned int CalcRound(unsigned int key)&#123;</span><br><span class="line">    return key ^((((key&amp;0xffffffff)&lt;&lt;13)|((key&amp;0xffffffff)&gt;&gt;(32-13)))^(((key&amp;0xffffffff)&lt;&lt;(32-9))|((key&amp;0xffffffff)&gt;&gt;9)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long CK[32] = &#123;</span><br><span class="line">0x00070e15,0x1c232a31,0x383f464d,0x545b6269,</span><br><span class="line">0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,</span><br><span class="line">0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,</span><br><span class="line">0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,</span><br><span class="line">0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,</span><br><span class="line">0x30373e45,0x4c535a61,0x686f767d,0x848b9299,</span><br><span class="line">0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,</span><br><span class="line">0x10171e25,0x2c333a41,0x484f565d,0x646b7279</span><br><span class="line">&#125;;</span><br><span class="line">    unsigned int result[] = &#123;0x0FD07C452, 0x0EC90A488, 0x68D33CD1, 0x96F64587&#125;;</span><br><span class="line">    unsigned int re_result[36];</span><br><span class="line">    for(int i=32;i&lt;36;i++)&#123;</span><br><span class="line">        re_result[i] =result[i-32];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=31;i&gt;=0;i--)&#123;</span><br><span class="line">        re_result[i] = CalcRound(re_result[i+1]^re_result[i+2]^re_result[i+3]^CK[i])^re_result[i+4];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned long tem[4] = &#123;0xA3B1BAC6,0x56AA3350,0x677D9197,0xB27022DC&#125;;</span><br><span class="line">    for(int i=0;i&lt;=3;i++)&#123;</span><br><span class="line">        re_result[i]=re_result[i]^tem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char *data = (unsigned char *)re_result;   //因为日期的表示是8个数字，每个数字是用8位来代表</span><br><span class="line">    for(int i=1;i&lt;=2;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=4;j++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;,data[i*4 - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">20211205</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221133215573.png" alt="image-20220221133215573"></p>
<p>将得到的日期放入之后，就要进行符来歌的输入</p>
<p><img src="/images/VNCTF-2022/image-20220221133557404.png" alt="image-20220221133557404"></p>
<p>最后需要对比的元素是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1ebe,0x1e8e,0x1e44,0x1e39,0x1e5b,0x1e8,0x1e36,0x1e8f,0x1edd,0x1e5e,0x1e94,0x1eb5,0x1e1,0x1e70,0x1eab,0x1e63,0x1ebb,0x1e72,0x1e50,0x1e13,0x1e5d,0x1e25,0x1e16,0x1e78</span><br></pre></td></tr></table></figure>

<p>在上面函数 之中对这个数组中的元素做了一定的运算，下面得到的就是运算加密之后的数组</p>
<p><img src="/images/VNCTF-2022/image-20220221170531828.png" alt="image-20220221170531828"></p>
<p>所以需要比较的数组是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221183335046.png" alt="image-20220221183335046"></p>
<p>用爆破的方式得到上面的解，发现这里某些会有多个解所以需要使用递归的方式，深度优先算法解得所有的解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [ 0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3]</span><br><span class="line">i=0</span><br><span class="line">flags=[]</span><br><span class="line">flag = [0]*24</span><br><span class="line">flag[23] = 0xe3</span><br><span class="line">def DFS(deep):</span><br><span class="line">  global flags</span><br><span class="line">  global flag</span><br><span class="line">  if deep ==0:</span><br><span class="line">    flags.append(flag.copy())</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">    for j in range(1,0xff):</span><br><span class="line">      tem = j^((j % 0x12+ flag[deep] + 0x05) ^ 0x41)</span><br><span class="line">      if tem == obj[deep-1]:</span><br><span class="line">        flag[deep-1]=j</span><br><span class="line">        DFS(deep-1)</span><br><span class="line">              </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  DFS(23)</span><br><span class="line">  for i in range(len(flags)):</span><br><span class="line">    print(flags[i])</span><br><span class="line">[20, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[21, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[22, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[23, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[28, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[29, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[30, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[31, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[128, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[129, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[130, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[131, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[136, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[137, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[138, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[139, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[72, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[73, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[74, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[75, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[80, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[81, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[82, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[83, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[88, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[89, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[184, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[185, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[186, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[187, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221183354391.png" alt="image-20220221183354391"></p>
<p>通过这个我们可以获得 a1[60] a1[61] a1[62] a1[63] a1[64] a1[65] 5个数</p>
<p>对输入的每32个字节的操作：将32位数 F1F1 F2F2 F3F3 F4F4 排列为 F4F4 F3F3 F2F2 F1F1 </p>
<p><img src="/images/VNCTF-2022/image-20220221184405201.png" alt="image-20220221184405201"></p>
<p>将所有输入的字符进行上面的运算，然后重新赋值给a1 则可以知道数组之中有6个元素</p>
<p><img src="/images/VNCTF-2022/image-20220221184743758.png" alt="image-20220221184743758"></p>
<p>然后就需要进行一系列的运算，</p>
<p><img src="/images/VNCTF-2022/image-20220221185657924.png" alt="image-20220221185657924"></p>
<p>当v5不是6的倍数的时候 </p>
<p>当i不是6的倍数的时候：v5[7] = v5[1]^v5[6]   v5[i] = v5[i-6] ^ v5[i-1] </p>
<p>当i是6的倍数的时候：v5[i] = v5[i-6] ^ T(v5[i-1],v3)  v3代表的是第几个6的倍数</p>
<p><strong>T函数的讲解</strong>：</p>
<p><img src="/images/VNCTF-2022/image-20220221190435689.png" alt="image-20220221190435689"></p>
<p>其中的第一个函数：将a1分解成了4个元素的数组0x  F0F0 F1F1 F2F2 F3F3</p>
<p><img src="/images/VNCTF-2022/image-20220221190819733.png" alt="image-20220221190819733"></p>
<p>其中的第二个函数：将数组中的元素循环右移一位 ；例如 a=[a0,a1,a2,a3] 转化成 a=[a1,a2,a3,a0] </p>
<p>[F3F3,F2F2,F1F1,F0F0] [F2F2,F1F1,F0F0,F3F3]</p>
<p><img src="/images/VNCTF-2022/image-20220221191008054.png" alt="image-20220221191008054"></p>
<p>其中第三个函数：整合上面的数组之中的元素  0x F3F3 F0F0 F1F1 F2F2</p>
<p><img src="/images/VNCTF-2022/image-20220221191329845.png" alt="image-20220221191329845"></p>
<p>所以这个函数的作用是 将 0x  F0F0 F1F1 F2F2 F3F3 转化成 0x F3F3 F0F0 F1F1 F2F2 循环左移动了8位 然后再和对应那个6的倍数作为脚标找到数组对应的元素</p>
<p>作为索引对象的数组是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000,</span><br><span class="line">           0x36000000]</span><br></pre></td></tr></table></figure>

<p>每组得到了6个数字，将这六个元素作为66个元素之中的后六位元素</p>
<p>逆向：</p>
<p>当i不是6的倍数时： v5[i-6] = v5[i]^v5[i-1]</p>
<p>当i是6的倍数时： v5[i-6] = v5[i]^ T(v5[i-1],v3) # v3 = i%6 T是将数循环左移动了8位，再和对应的数字进行异或运算</p>
<p>逆向得到的66个元素的前6个元素，将前6个元素转化为字符输出</p>
<p>所有运算的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [ 0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3]</span><br><span class="line">inner_index = [0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000,</span><br><span class="line">           0x36000000]</span><br><span class="line">i=0</span><br><span class="line">flags=[]</span><br><span class="line">flag = [0]*24</span><br><span class="line">flag[23] = 0xe3</span><br><span class="line"># 用递归 ，深度遍历的方法得到所有的解</span><br><span class="line">def DFS(deep):</span><br><span class="line">  global flags</span><br><span class="line">  global flag</span><br><span class="line">  if deep ==0:</span><br><span class="line">    flags.append(flag.copy())</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">    for j in range(1,0xff):</span><br><span class="line">      tem = j^((j % 0x12+ flag[deep] + 0x05) ^ 0x41)</span><br><span class="line">      if tem == obj[deep-1]:</span><br><span class="line">        flag[deep-1]=j</span><br><span class="line">        DFS(deep-1)</span><br><span class="line"></span><br><span class="line"># 位移运算</span><br><span class="line">def rol8(num):</span><br><span class="line">  return ((num&amp;0xffffff)&lt;&lt;8) |((num&amp;0xff000000)&gt;&gt;(32-8))</span><br><span class="line"></span><br><span class="line"># 位移加上 异或运算</span><br><span class="line">def T(num,i):</span><br><span class="line">  num = rol8(num)</span><br><span class="line">  return num^inner_index[i-1]</span><br><span class="line"></span><br><span class="line"># 根据是否是6的倍数进行的不同的异或运算</span><br><span class="line">def multiple(final_flag):</span><br><span class="line">  for i in range(65,5,-1):</span><br><span class="line">    if i%6 !=0:</span><br><span class="line">      final_flag[i-6] = final_flag[i]^final_flag[i-1]</span><br><span class="line">    else:</span><br><span class="line">      final_flag[i - 6] = final_flag[i] ^ T(final_flag[i - 1], i//6)</span><br><span class="line">  return final_flag</span><br><span class="line"></span><br><span class="line"># 将得到的数组进行输出</span><br><span class="line">def print_flag(final_flag):</span><br><span class="line">  for i in range(len(final_flag)):</span><br><span class="line">    for j in range(4):</span><br><span class="line">      print(chr((final_flag[i] &amp; 0xff000000)&gt;&gt;(32-8)),end=&quot;&quot;)</span><br><span class="line">      final_flag[i] = final_flag[i] &lt;&lt; 8</span><br><span class="line">  print()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  DFS(23)</span><br><span class="line">  re_flags = []</span><br><span class="line">  for j in range(len(flags)):</span><br><span class="line">    flag = flags[j]</span><br><span class="line">    tem = []</span><br><span class="line">    # 将每4个8位数组合成 一个16进制的32位数</span><br><span class="line">    for i in range(0, len(flag), 4):</span><br><span class="line">      tem.append(int(</span><br><span class="line">        &quot;0x&quot; + hex(flag[i + 3])[2:].zfill(2) + hex(flag[i + 2])[2:].zfill(2) + hex(flag[i + 1])[2:].zfill(2) + hex(</span><br><span class="line">          flag[i])[2:].zfill(2),16))</span><br><span class="line">    re_flags.append(tem.copy())   # re_flags 里面将24个元素每4个一组转化为一个数</span><br><span class="line"></span><br><span class="line">  # 异或运算的逆向</span><br><span class="line">  final_flag = [0]*66</span><br><span class="line">  re_flags2 = []</span><br><span class="line">  for i in range(len(re_flags)):</span><br><span class="line">    final_flag = [0]*66</span><br><span class="line">    for j in range(6):  #将已知的5个值放入其中</span><br><span class="line">      final_flag[60+j] = re_flags[i][j]</span><br><span class="line">      </span><br><span class="line">    # 利用这5个元素推理出所有的数字</span><br><span class="line">    final_flag = multiple(final_flag)</span><br><span class="line">    tem = []</span><br><span class="line">    for j in range(6):</span><br><span class="line">      tem.append(final_flag[j])</span><br><span class="line">    print(tem)</span><br><span class="line">    re_flags2.append(tem.copy())</span><br><span class="line">  for i in range(len(re_flags2)):</span><br><span class="line">    print_flag(re_flags2[i])</span><br></pre></td></tr></table></figure>

<p>在所有的输出之中找到flag  VNCTF{TimeFlightMachine}</p>
<h4 id="cmgo！"><a href="#cmgo！" class="headerlink" title="cmgo！"></a>cmgo！</h4><p>将这个exe文件拖入ida之中，从函数名称的窗口之中就可以看到这里进行了程序的无符号化，使得函数的名称不能够直观的得到，所以函数的入口难以找到，无符号golang逆向技巧，使用IDAGolangHelper这一脚本，打开脚本文件（文件-脚本文件）找到这个脚本文件夹，选中rename function之后选择go版本,所以将这个exe拖进IDA7.6之中，找到程序入口main.main</p>
<p><img src="/images/VNCTF-2022/image-20220221232254810.png" alt="image-20220221232254810"></p>
<p>找到初始化虚拟机的地方和opcode</p>
<p><img src="/images/VNCTF-2022/image-20220222081345526.png" alt="image-20220222081345526"></p>
<p>第二个函数 mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084558720.png" alt="image-20220222084558720"></p>
<p>第三个函数  mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084616048.png" alt="image-20220222084616048"></p>
<p><img src="/images/VNCTF-2022/image-20220222084743697.png" alt="image-20220222084743697"></p>
<p>第四个函数 mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084926787.png" alt="image-20220222084926787"></p>
<p>第五个函数 push</p>
<p><img src="/images/VNCTF-2022/image-20220222085210002.png" alt="image-20220222085210002"></p>
<p>第六个函数 和push类似的样子</p>
<p><img src="/images/VNCTF-2022/image-20220222085400565.png" alt="image-20220222085400565"></p>
<p>第七个函数 pop</p>
<p><img src="/images/VNCTF-2022/image-20220222085437971.png" alt="image-20220222085437971"></p>
<p>第八个函数 add</p>
<p><img src="/images/VNCTF-2022/image-20220222085652595.png" alt="image-20220222085652595"></p>
<p>第九个函数 sub</p>
<p><img src="/images/VNCTF-2022/image-20220222085733426.png" alt="image-20220222085733426"></p>
<p>第十个函数 div</p>
<p><img src="/images/VNCTF-2022/image-20220222085838161.png" alt="image-20220222085838161"></p>
<p>第十一个函数 mul</p>
<p><img src="/images/VNCTF-2022/image-20220222085928057.png" alt="image-20220222085928057"></p>
<p>第十二个函数 xor</p>
<p><img src="/images/VNCTF-2022/image-20220222090005356.png" alt="image-20220222090005356"></p>
<p>第十三个函数  jmp</p>
<p><img src="/images/VNCTF-2022/image-20220222090054005.png" alt="image-20220222090054005"></p>
<p>第十四个函数 jmp（多了一个判断条件）当等于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090501248.png" alt="image-20220222090501248"></p>
<p>第十五个函数 jnp</p>
<p><img src="/images/VNCTF-2022/image-20220222090557647.png" alt="image-20220222090557647"></p>
<p>第十六个函数 jlp 当小于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090652596.png" alt="image-20220222090652596"></p>
<p>第十七个函数 jhp 当大于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090801331.png" alt="image-20220222090801331"></p>
<p>第十八个函数 scanf</p>
<p><img src="/images/VNCTF-2022/image-20220222091046004.png" alt="image-20220222091046004"></p>
<p>第十九个函数 print</p>
<p><img src="/images/VNCTF-2022/image-20220222091135371.png" alt="image-20220222091135371"></p>
<p>第二十个函数 quit</p>
<p><img src="/images/VNCTF-2022/image-20220222091303160.png" alt="image-20220222091303160"></p>
<p>初始化虚拟机并且载入opcode之后，要运行这个虚拟机，所以查看虚拟机的运行的函数，用流程图的方式查看函数的逻辑，找到逻辑之中的循环，找到其中的关键代码</p>
<p><img src="/images/VNCTF-2022/image-20220222120534330.png" alt="image-20220222120534330"></p>
<p>进行动调得到函数的对应关系，动态调试得到的对应关系,</p>
<p><img src="/images/VNCTF-2022/image-20220223001010055.png" alt="image-20220223001010055"></p>
<p>跟踪到[rbx+rdi*8+1008h]这个里面，通过按D将db的数据转化成dq</p>
<p><img src="/images/VNCTF-2022/image-20220223001105287.png" alt="image-20220223001105287"></p>
<p>通过他们的顺序，就能知道code 和 函数的对应关系</p>
<p>opcode的 0-16对应函数1-17</p>
<p>97 98 99对应函数18 19 20</p>
<p>将opcode得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov r0 0X57</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6C</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X63</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6D</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X74</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X56</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X4E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X43</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X54</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X46</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X30</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X21</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0XA</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X69</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X70</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X75</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X74</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X66</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6C</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X61</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X67</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X3A</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0XA</span><br><span class="line">pushchar(r0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov r19 0X49</span><br><span class="line">mov r3 0X0</span><br><span class="line">mov r1 0X2B</span><br><span class="line">mov r2 0X1</span><br><span class="line">scanf(r0)</span><br><span class="line">push r0</span><br><span class="line">sub r1 r2</span><br><span class="line">if r1 != r3:quit </span><br><span class="line">mov r0 0X0</span><br><span class="line">push r0</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">mov r0 r6</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">mov r0 r6</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">mov r0 r7</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">mov r0 r7</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">mov r0 r8</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">mov r0 r8</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">mov r0 r9</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">mov r0 r9</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">mov r0 r10</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">mov r0 r10</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">mov r0 r11</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">mov r0 r11</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">mov r0 r12</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">mov r0 r12</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100  //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">mov r0 r13</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">mov r0 r13</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">mov r0 r15</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">mov r0 r15</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">mov r0 r16</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">mov r0 r16</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">push r6</span><br><span class="line">push r7</span><br><span class="line">push r8</span><br><span class="line">push r9</span><br><span class="line">push r10</span><br><span class="line">push r11</span><br><span class="line">push r12</span><br><span class="line">push r13</span><br><span class="line">push r14</span><br><span class="line">push r15</span><br><span class="line">push r16</span><br><span class="line">//第一次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X11C</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0XE8D1D5DF</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   // 0XE8D1D5DF 数据的比较</span><br><span class="line">mov r0 0XF5E3C114</span><br><span class="line">if r2 != r0:quit   //  0XF5E3C114</span><br><span class="line">// 第二次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X127</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X228EC216</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit  //  0X228EC216 数据的比较</span><br><span class="line">mov r0 0X89D45A61</span><br><span class="line">if r2 != r0:quit   //  0X89D45A61</span><br><span class="line">// 第三次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X132</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X655B8F69</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit    //  0X655B8F69 数据的比较</span><br><span class="line">mov r0 0X2484A07A</span><br><span class="line">if r2 != r0:quit    //  0X2484A07A</span><br><span class="line">// 第四次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X13D</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0XD9E5E7F8</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   //  0XD9E5E7F8 数据的比较</span><br><span class="line">mov r0 0X3A441532</span><br><span class="line">if r2 != r0:quit   //   0X3A441532</span><br><span class="line">// 第五次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X148</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X91AB7E88</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   // 0X91AB7E88</span><br><span class="line">mov r0 0X69FC64BC</span><br><span class="line">if r2 != r0:quit   //  0X69FC64BC</span><br><span class="line">pop r1</span><br><span class="line">mov r0 0X7D3765</span><br><span class="line">if r1 != r0:quit   //  0X7D3765</span><br><span class="line">mov r0 0X189</span><br><span class="line">jmp r0</span><br><span class="line">quit!</span><br><span class="line"></span><br><span class="line">mov r3 0X9E3779B9  //tea函数开始的地方 delta</span><br><span class="line">mov r4 0X95C4C     //k0</span><br><span class="line">mov r5 0X871D      //k1</span><br><span class="line">mov r6 0X1A7B7     //k2</span><br><span class="line">mov r7 0X12C7C7    //k3</span><br><span class="line">mov r8 0X0</span><br><span class="line">mov r17 0X10  //用于位移的一堆数字</span><br><span class="line">mov r18 0X20</span><br><span class="line">mov r19 0X160</span><br><span class="line">mov r10 0X0</span><br><span class="line">mov r11 0X20</span><br><span class="line">mov r12 0X1</span><br><span class="line">add r8 r3</span><br><span class="line">mov r0 r2</span><br><span class="line">mul r0 r17</span><br><span class="line">add r0 r4</span><br><span class="line">mov r14 r0</span><br><span class="line">mov r0 r2</span><br><span class="line">add r0 r8</span><br><span class="line">mov r15 r0</span><br><span class="line">mov r0 r2</span><br><span class="line">div r0 r18</span><br><span class="line">add r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">xor r0 r15</span><br><span class="line">xor r0 r16</span><br><span class="line">add r1 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">mul r0 r17</span><br><span class="line">add r0 r6</span><br><span class="line">mov r14 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">add r0 r8</span><br><span class="line">mov r15 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">div r0 r18</span><br><span class="line">add r0 r7</span><br><span class="line">mov r16 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">xor r0 r15</span><br><span class="line">xor r0 r16</span><br><span class="line">add r2 r0</span><br><span class="line">sub r11 r12</span><br><span class="line">if r11 != r10:quit </span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">mov r0 0X6E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">mov r0 0X79</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X73</span><br><span class="line">pushchar(r0)</span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">v[2]=&#123;0XE8D1D5DF,0XF5E3C114,0X228EC216,0X89D45A61,0X655B8F69,0X2484A07A,0XD9E5E7F8,0X3A441532,0X91AB7E88,0X69FC64BC,0X7D3765&#125;</span><br></pre></td></tr></table></figure>

<p>网上的TEA的加密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上的TEA的解密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void decrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up; sum is 32*delta */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目之中的TEA解密的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Decrypt(unsigned long* EntryData,unsigned long* Key) &#123;</span><br><span class="line">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br><span class="line">unsigned long x = EntryData[0];</span><br><span class="line">unsigned long y = EntryData[1];</span><br><span class="line"></span><br><span class="line">unsigned long sum = 0xC6EF3720;</span><br><span class="line">unsigned long delta = 0x9E3779B9;</span><br><span class="line">sum = delta &lt;&lt; 5;   //注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.</span><br><span class="line">//总共加密32轮 那么反序也解密32轮</span><br><span class="line">for (int i = 0; i &lt; 32; i++) &#123;</span><br><span class="line">// 先将y解开 然后参与运算在解x</span><br><span class="line">y -= ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);</span><br><span class="line">x -= ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);</span><br><span class="line">sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">//最后加密的结果重新写入到数组中</span><br><span class="line">EntryData[0] = x;</span><br><span class="line">EntryData[1] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">//通过对比元素的代码处将其分为6组，每两个是一组，只有前10个进行了加密的操作</span><br><span class="line">   unsigned long t1[3] = &#123;0XE8D1D5DF,0XF5E3C114,0x0&#125;;</span><br><span class="line">   unsigned long t2[3] = &#123;0X228EC216,0X89D45A61,0x0&#125;;</span><br><span class="line">   unsigned long t3[3] = &#123;0X655B8F69,0X2484A07A,0x0&#125;;</span><br><span class="line">   unsigned long t4[3] = &#123;0XD9E5E7F8,0X3A441532,0x0&#125;;</span><br><span class="line">   unsigned long t5[3] = &#123;0X91AB7E88,0X69FC64BC,0x0&#125;;</span><br><span class="line">   unsigned long t6[2] = &#123;0X7D3765,0x0&#125;;</span><br><span class="line">//printf(&quot;待加密的数值 = %s\r\n&quot;, (char*)Data);</span><br><span class="line"></span><br><span class="line">unsigned long key[4] = &#123; 0X95C4C,0X871D,0X1A7B7,0X12C7C7 &#125;;</span><br><span class="line"></span><br><span class="line">// 分析代码我们可以得到一共加密了5次，所以数组之中只有10个分组进行了加密的操作</span><br><span class="line">Decrypt(t1, key);</span><br><span class="line">Decrypt(t2, key);</span><br><span class="line">Decrypt(t3, key);</span><br><span class="line">Decrypt(t4, key);</span><br><span class="line">Decrypt(t5, key);</span><br><span class="line"></span><br><span class="line">printf(&quot;解密后的数值 = %s%s%s%s%s%s\r\n&quot;, (char*)t1,(char*)t2,(char*)t3,(char*)t4,(char*)t5,(char *)t6);</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">VNCTF&#123;ecd63ae5-8945-4ac4-b5a5-34fc3ade81e7&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>susctf(DigitalCircuits+hello_word)</title>
    <url>/2022/03/04/susctf-DigitalCircuits-hello-word/</url>
    <content><![CDATA[<h1 id="SUSCTF-DigitalCircuits-hello-word"><a href="#SUSCTF-DigitalCircuits-hello-word" class="headerlink" title="SUSCTF(DigitalCircuits+hello_word)"></a>SUSCTF(DigitalCircuits+hello_word)</h1><p><a href="https://github.com/susers/SUSCTF2022_official_wp/tree/main/reverse">官方的WP</a></p>
<h2 id="DigitalCircuits"><a href="#DigitalCircuits" class="headerlink" title="DigitalCircuits"></a>DigitalCircuits</h2><p>这是一个pyc反编译的题目</p>
<h3 id="pyc文件转换成py文件"><a href="#pyc文件转换成py文件" class="headerlink" title="pyc文件转换成py文件"></a>pyc文件转换成py文件</h3><p>这是一个将pyc打包成地exe文件，首先使用软件解包，这个软件反编译出来地主程序并不是一个pyc文件，需要自己通过instruct这个文件修改这个文件地格式</p>
<p>将pyc文件用unemployed6 编译为py文件，然后得到源代码，分析代码，发现这是一个tea加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># uncompyle6 version 3.8.1.dev0</span><br><span class="line"># Python bytecode 3.7.0 (3394)</span><br><span class="line"># Decompiled from: Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)]</span><br><span class="line"># Embedded file name: DigitalCircuits.py</span><br><span class="line"># Compiled at: 1995-09-28 00:18:56</span><br><span class="line"># Size of source mod 2**32: 257 bytes</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def f1(a, b):   # 只有当两个字符都是1的时候才输出为1 与运算&amp;</span><br><span class="line">    if a == &#x27;1&#x27;:</span><br><span class="line">        if b == &#x27;1&#x27;:</span><br><span class="line">            return &#x27;1&#x27;</span><br><span class="line">    return &#x27;0&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f2(a, b):     # 有1则1    或运算|</span><br><span class="line">    if a == &#x27;0&#x27;:</span><br><span class="line">        if b == &#x27;0&#x27;:</span><br><span class="line">            return &#x27;0&#x27;</span><br><span class="line">    return &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f3(a):    # 取反运算~</span><br><span class="line">    if a == &#x27;1&#x27;:</span><br><span class="line">        return &#x27;0&#x27;</span><br><span class="line">    if a == &#x27;0&#x27;:</span><br><span class="line">        return &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f4(a, b):    # 当一个字符相同的时候返回0 当两个字符不同的时候返回1 异或运算</span><br><span class="line">    # f1(a, f3(b) ： a&amp;(~b)</span><br><span class="line">    # f1(f3(a), b) : (~a)&amp;b</span><br><span class="line">    # f2(f1(a, f3(b)), f1(f3(a), b)) : (a&amp;(~b))|((~a)&amp;b)</span><br><span class="line">    return f2(f1(a, f3(b)), f1(f3(a), b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f5(x, y, z):</span><br><span class="line">    # f4(x, y) ： d = (x&amp;(~y))|((~x)&amp;y) = x^y</span><br><span class="line">    # f4(d, z) :  ((x^y)&amp;(~z))|((~(x^y))&amp;z) 若z是0时 x和y要不同才返回1 若z是1时 x和y要相同 才返回1</span><br><span class="line">    s = f4(f4(x, y), z)</span><br><span class="line">    # f1(x, y) ： x&amp;y</span><br><span class="line">    # f2(x, y) : x|y</span><br><span class="line">    # f1(z, f2(x, y)) : z&amp;(x|y)</span><br><span class="line">    # f2(f1(x, y), f1(z, f2(x, y))) : (x&amp;y)|(z&amp;(x|y)) 当x和y都是1时 或者 z是1 x和y其中一个是1时 返回1</span><br><span class="line">    c = f2(f1(x, y), f1(z, f2(x, y)))</span><br><span class="line">    return (s, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f6(a, b):</span><br><span class="line">    ans = &#x27;&#x27;</span><br><span class="line">    z = &#x27;0&#x27;</span><br><span class="line">    a = a[::-1]   # 将其倒过来</span><br><span class="line">    b = b[::-1]   # 将其倒过来</span><br><span class="line">    for i in range(32):   # 循环32次</span><br><span class="line">        ans += f5(a[i], b[i], z)[0]   # 单个字符</span><br><span class="line">        z = f5(a[i], b[i], z)[1]      # 单个字符</span><br><span class="line"></span><br><span class="line">def f6(a, b):</span><br><span class="line">    ans = &#x27;&#x27;</span><br><span class="line">    z = &#x27;0&#x27;</span><br><span class="line">    a = a[::-1]  # 将其倒过来</span><br><span class="line">    b = b[::-1]  # 将其倒过来</span><br><span class="line">    for i in range(32):  # 循环32次</span><br><span class="line">        ans += ((a[i]^b[i])&amp;(~z))|((~(a[i]^b[i]))&amp;z)  # 单个字符 ((x^y)&amp;(~z))|((~(x^y))&amp;z)</span><br><span class="line">        z = (a[i]&amp;b[i])|(z&amp;(a[i]|b[i]))  # 单个字符</span><br><span class="line">    return ans[::-1]</span><br><span class="line"></span><br><span class="line"># 向左移4位</span><br><span class="line">def f7(a, n):</span><br><span class="line">    return a[n:] + &#x27;0&#x27; * n</span><br><span class="line"></span><br><span class="line"># 向右移5位</span><br><span class="line">def f8(a, n):</span><br><span class="line">    return n * &#x27;0&#x27; + a[:-n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f9(a, b):</span><br><span class="line">    ans = &#x27;&#x27;</span><br><span class="line">    for i in range(32):</span><br><span class="line">        ans += f4(a[i], b[i])   # 逐项比较每一位数，如果相同则加0 如果不同则加1</span><br><span class="line"></span><br><span class="line">    return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f10(v0, v1, k0, k1, k2, k3):</span><br><span class="line">    s = &#x27;00000000000000000000000000000000&#x27;</span><br><span class="line">    d = &#x27;10011110001101110111100110111001&#x27;</span><br><span class="line">    for i in range(32):</span><br><span class="line">        s = f6(s, d)</span><br><span class="line">        # f7(v1, 4) v1&lt;&lt;4    f8(v1, 5) v1&gt;&gt;5</span><br><span class="line">        # f6(v0, f9(f9(f6(v1&lt;&lt;4, k0), f6(v1, s)), f6(v1&gt;&gt;5, k1)))</span><br><span class="line">        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))</span><br><span class="line">        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return v0 + v1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k0 = &#x27;0100010001000101&#x27;.zfill(32)   # 0x4445</span><br><span class="line">k1 = &#x27;0100000101000100&#x27;.zfill(32)   # 0x4144</span><br><span class="line">k2 = &#x27;0100001001000101&#x27;.zfill(32)   # 0x4245</span><br><span class="line">k3 = &#x27;0100010101000110&#x27;.zfill(32)   # 0x4546</span><br><span class="line">flag = input(&#x27;please input flag:&#x27;)</span><br><span class="line">if flag[0:7] != &#x27;SUSCTF&#123;&#x27; or flag[(-1)] != &#x27;&#125;&#x27;:</span><br><span class="line">    print(&#x27;Error!!!The formate of flag is SUSCTF&#123;XXX&#125;&#x27;)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    exit(0)</span><br><span class="line">flagstr = flag[7:-1]</span><br><span class="line">if len(flagstr) != 24:</span><br><span class="line">    print(&#x27;Error!!!The length of flag 24&#x27;)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    exit(0)</span><br><span class="line">else:</span><br><span class="line">    res = &#x27;&#x27;</span><br><span class="line">    # 将这里面的字符串每8个分为一组</span><br><span class="line">    for i in range(0, len(flagstr), 8):</span><br><span class="line">        v0 = flagstr[i:i + 4]</span><br><span class="line">        v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[(i + 1)]))[2:].zfill(8) + bin(ord(flagstr[(i + 2)]))[2:].zfill(8) + bin(ord(flagstr[(i + 3)]))[2:].zfill(8)</span><br><span class="line">        v1 = bin(ord(flagstr[(i + 4)]))[2:].zfill(8) + bin(ord(flagstr[(i + 5)]))[2:].zfill(8) + bin(ord(flagstr[(i + 6)]))[2:].zfill(8) + bin(ord(flagstr[(i + 7)]))[2:].zfill(8)</span><br><span class="line">        res += f10(v0, v1, k0, k1, k2, k3)</span><br><span class="line"></span><br><span class="line">    if res == &#x27;001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111&#x27;:</span><br><span class="line">        print(&#x27;True&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;False&#x27;)</span><br><span class="line">time.sleep(5)</span><br></pre></td></tr></table></figure>

<h3 id="tea算法"><a href="#tea算法" class="headerlink" title="tea算法"></a>tea算法</h3><p>tea 的密钥是：0x4445,0x4144,0x4245,0x4546</p>
<p>最后的加密结果：[0x3e8947cb,0xcc944639,0x31358388,0x3b0b6893,0xda627361,0x3b2e6427]</p>
<p>dalt：0x9e3779b9</p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */</span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v1[3]=&#123;0x3e8947cb,0xcc944639,0x0&#125;,k[4]=&#123;0x4445,0x4144,0x4245,0x4546&#125;;</span><br><span class="line">    uint32_t v2[3]=&#123;0x31358388,0x3b0b6893,0x0&#125;;</span><br><span class="line">    uint32_t v3[3]=&#123;0xda627361,0x3b2e6427&#125;;</span><br><span class="line">    decrypt(v1, k);</span><br><span class="line">    decrypt(v2, k);</span><br><span class="line">    decrypt(v3, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s %s %s\n&quot;,(char*)v1,(char*)v2,(char*)v3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">fvBXQdEa rcbvhBPx cOA8Ag6J</span><br></pre></td></tr></table></figure>

<p>在输入数据的时候：从图中我们可以看到每组字符串中（每4个字符为一组）它将低位的字符放到二进制的高位，所以最后的结果还需要调整字符串的顺序，逆序取出每组数据</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220226130532348.png" alt="image-20220226130532348"></p>
<p>最后的flag是 SUSCTF{XBvfaEdQvbcrxPBh8AOcJ6gA}</p>
<h2 id="hello-word"><a href="#hello-word" class="headerlink" title="hello_word"></a>hello_word</h2><p>这个题目考察vhdl </p>
<h3 id="定位代码"><a href="#定位代码" class="headerlink" title="定位代码"></a>定位代码</h3><p>通过字符串找到一个含有inputflag页面的函数，在里面出现了有vhdl</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220226224203141.png" alt="image-20220226224203141"></p>
<h3 id="VHDL介绍"><a href="#VHDL介绍" class="headerlink" title="VHDL介绍"></a>VHDL介绍</h3><blockquote>
<p>GHDL是一个基于GCC的VHDL语言编译/模拟命令行工具</p>
<p>通过使用代码生成器（<a href="https://llvm.org/">LLVM</a>、<a href="https://gcc.gnu.org/">GCC</a>或仅<a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> / <a href="https://en.wikipedia.org/wiki/Intel_80386">i386</a>，内置的），它比任何解释模拟器都要快得多。它可以处理非常大的设计，例如<a href="https://www.gaisler.com/index.php/downloads/leongrlib">leon3/grlib</a>。</p>
<p>可将波形写入<a href="https://ghdl.github.io/ghdl/using/Simulation.html?highlight=GHW#cmdoption-wave">GHW</a>、<a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD</a>或 FST 文件。结合基于<a href="https://en.wikipedia.org/wiki/Graphical_user_interface">GUI的</a><a href="https://en.wikipedia.org/wiki/Waveform_viewer">波形查看器</a>和良好的文本编辑器，GHDL 是用于<strong>编写、测试和模拟代码</strong>的非常强大的工具。</p>
</blockquote>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220303190451907.png" alt="image-20220303190451907"></p>
<h3 id="状态机介绍"><a href="#状态机介绍" class="headerlink" title="状态机介绍"></a>状态机介绍</h3><p>分析代码这是一个状态机</p>
<blockquote>
<p><strong>有限状态机</strong>（Finite-state machine,FSM）：又称有限状态自动机，简称状态机，是表示有限个状态以及在<strong>这些状态之间的转移和动作等行为的数学模型</strong>。</p>
<p><strong>FSM</strong>：是一种算法思想，简单而言，有限状态机<strong>由一组状态、一个初始状态、输入和根据输入及现有状态转换为下一个状态的转换函数</strong>组成。</p>
<p><strong>六种元素</strong>：起始、终止、现态、次态（目标状态）、动作、条件，我们就可以完成一个状态机图</p>
<p>状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学<a href="https://so.csdn.net/so/search?q=%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">模型</a>。说白了，一般就是指一张状态转换图。</p>
<p>例如：自动门有两个状态，open 和 closed ，closed 状态下，如果读取开门信号，那么状态就会切换为 open 。open 状态下如果读取关门信号，状态就会切换为 closed 。</p>
</blockquote>
<p>能够抽象出来的图：</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304122921881.png" alt="image-20220304122921881">、</p>
<p>状态机的四大概念：</p>
<ul>
<li>第一个是 <strong>State</strong> ，状态。一个状态机至少要<strong>包含两个状态</strong>。例如上面自动门的例子，有 open 和 closed 两个状态。</li>
<li>第二个是 <strong>Event</strong> ，事件。事件就是执行某个操作的触发<strong>条件或者口令</strong>。对于自动门，“按下开门按钮”就是一个事件。</li>
<li>第三个是 <strong>Action</strong> ，动作。事件发生以后要<strong>执行动作</strong>。例如事件是“按开门按钮”，动作是“开门”。编程的时候，一个 Action一般就对应一个函数。</li>
<li>第四个是 <strong>Transition</strong> ，变换。也就是从一个状态<strong>变化</strong>为另一个状态。例如“开门过程”就是一个变换。</li>
</ul>
<h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><p>这道题是被strip了的，下面是对strip概念的解释</p>
<p><strong>strip的作用</strong>：</p>
<p>so文件组成：一个完整的 so 由C代码加一些 debug 信息组成，这些debug信息会记录 so 中所有方法的对照表，就是方法名和其偏移地址的对应表，也叫做符号表。</p>
<p>未strip的so文件：这种既有c代码和debug信息的 so文件就是未 strip 的so文件，通常体积会比较大</p>
<p>strip操作：so 中的debug信息会被剥离，整个 so 的体积也会缩小。</p>
<p>strip操作解说：</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304124408410.png" alt="image-20220304124408410"></p>
<h3 id="逻辑电路"><a href="#逻辑电路" class="headerlink" title="逻辑电路"></a>逻辑电路</h3><p>逻辑电路一般是状态机</p>
<blockquote>
<p>逻辑电路：是指完成逻辑运算的电路。这种电路，一般有<strong>若干个输入端</strong>和<strong>一个 或几个输出端</strong>，当输入信号之间满足某一特定逻辑关系时，电路就开通，有输 出;否则，电路就关闭，无输出。所以，这种电路又叫逻辑门电路，简称门电路。</p>
</blockquote>
<p>这里的case语句展示了这样的逻辑电路的构成</p>
<p>这里考察的是VHDL这个程序</p>
<h3 id="case语句的代码的算法分析"><a href="#case语句的代码的算法分析" class="headerlink" title="case语句的代码的算法分析"></a>case语句的代码的算法分析</h3><h4 id="定位代码-1"><a href="#定位代码-1" class="headerlink" title="定位代码"></a>定位代码</h4><p>首先通过字符串inputflag定位到对应的函数，这是一个switch的循环语句</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304130403296.png" alt="image-20220304130403296"></p>
<p>分析这个switch语句</p>
<h4 id="case1-4"><a href="#case1-4" class="headerlink" title="case1-4"></a>case1-4</h4><p>case1-4不断地跳转，这个地方地代码是对输入地flag的长度赋值</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304130605519.png" alt="image-20220304130605519"></p>
<p>向下跳转到case9的地方</p>
<h4 id="case9模块"><a href="#case9模块" class="headerlink" title="case9模块"></a>case9模块</h4><p>这个地方把输入的值给到vhdl中进行xor模块，然后跳到case10模块</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304132901912.png" alt="image-20220304132901912"></p>
<h4 id="case10模块"><a href="#case10模块" class="headerlink" title="case10模块"></a>case10模块</h4><p>调用vhdl的异或的方法，并且在这里可以知道一个用于异或运算的数组</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133058776.png" alt="image-20220304133058776"></p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133113178.png" alt="image-20220304133113178"></p>
<p>数组是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x56,0xda,0xcd,0x3a,0x7e,0x86,0x13,0xb5,0x1d,0x9d,0xfc,0x97,0x8c,0x31,0x6b,0xc9,0xfb,0x1a,0xe2,0x2d,0xdc,0xd3,0xf1,0xf4,0x36,0x09,0x20,0x42,0x04,0x6a,0x71,0x53,0x78,0xa4,0x97,0x8f,0x7a,0x72,0x39,0xe8,0x3d,0xfa,0x40,0x3d,0x98,0x01]</span><br></pre></td></tr></table></figure>

<h4 id="case11"><a href="#case11" class="headerlink" title="case11"></a>case11</h4><p>将异或的结果和最后的答案对比</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133511919.png" alt="image-20220304133511919"></p>
<p>对比使用的数组：</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133538057.png" alt="image-20220304133538057"></p>
<p>数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x05,0x8f,0x9e,0x79,0x2a,0xc0,0x68,0x81,0x2d,0xfc,0xcf,0xa4,0xb5,0x55,0x5f,0xe4,0x9d,0x23,0xd6,0x1d,0xf1,0xe7,0x97,0x91,0x06,0x24,0x42,0x71,0x3c,0x58,0x5c,0x30,0x19,0xc6,0xf5,0xbc,0x4b,0x42,0x5d,0xda,0x58,0x9b,0x24,0x40]</span><br></pre></td></tr></table></figure>

<h4 id="case-5模块"><a href="#case-5模块" class="headerlink" title="case 5模块"></a>case 5模块</h4><p>通过表示正确字符个数的correct判断最后的结果，错误就跳转到wrong的case5这个模块</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304134147758.png" alt="image-20220304134147758"></p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj1 = [0x05,0x8f,0x9e,0x79,0x2a,0xc0,0x68,0x81,0x2d,0xfc,0xcf,0xa4,0xb5,0x55,0x5f,0xe4,0x9d,0x23,0xd6,0x1d,0xf1,0xe7,0x97,0x91,0x06,0x24,0x42,0x71,0x3c,0x58,0x5c,0x30,0x19,0xc6,0xf5,0xbc,0x4b,0x42,0x5d,0xda,0x58,0x9b,0x24,0x40]</span><br><span class="line">obj2=[0x56,0xda,0xcd,0x3a,0x7e,0x86,0x13,0xb5,0x1d,0x9d,0xfc,0x97,0x8c,0x31,0x6b,0xc9,0xfb,0x1a,0xe2,0x2d,0xdc,0xd3,0xf1,0xf4,0x36,0x09,0x20,0x42,0x04,0x6a,0x71,0x53,0x78,0xa4,0x97,0x8f,0x7a,0x72,0x39,0xe8,0x3d,0xfa,0x40,0x3d,0x98,0x01]</span><br><span class="line">for i in range(len(obj1)):</span><br><span class="line">  print(chr(obj1[i]^obj2[i]),end=&#x27;&#x27;)</span><br><span class="line">  SUSCTF&#123;40a339d4-f940-4fe0-b382-cabb310d2ead&#125;</span><br></pre></td></tr></table></figure>

<p>所以最后的flag是 SUSCTF{40a339d4-f940-4fe0-b382-cabb310d2ead}</p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>susctf</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向之native层的so文件格式</title>
    <url>/2022/03/03/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="安卓逆向之native层的so文件格式"><a href="#安卓逆向之native层的so文件格式" class="headerlink" title="安卓逆向之native层的so文件格式"></a>安卓逆向之native层的so文件格式</h1><h2 id="安卓逆向的相关工具介绍"><a href="#安卓逆向的相关工具介绍" class="headerlink" title="安卓逆向的相关工具介绍"></a>安卓逆向的相关工具介绍</h2><p>反编译代码的工具：</p>
<ul>
<li><a href="https://sourceforge.net/projects/dex2jar/files/">dex2jar</a>:把dex文件转成jar文件</li>
<li><a href="http://java-decompiler.github.io/">jd-gui</a>: 这个工具用于将jar文件转换成java代码</li>
</ul>
<p>反编译资源的工具：</p>
<ul>
<li><a href="https://ibotpeaches.github.io/Apktool/install/">APKTool</a>: 本文重要工具，APK逆向工具。它可以将资源解码，并在修改后可以重新构建它们。它还可以执行一些自动化任务，例如构建apk。解码就是将其恢复成未打包的资源文件（包括resources.arsc，class.dex，9.png和xml）；解码的资源可以重新打包成apk/jar文件；组织和处理依赖于框架资源的APK；Smali调试；执行自动化任务</li>
<li><strong>JEB</strong>:JEB是一个功能强大为安全专业人士设计的安卓应用程序反编译工具，用于逆向工程或者审计apk文件。它是可以直接反编译apk文件的。</li>
<li><a href="https://github.com/skylot/jadx">jadx</a>：jadx是一款反编译利器，同时支持命令行和图形界面，能以最简便的方式完成apk的反编译操作。工具支持<strong>apk、dex、jar、aar</strong>等格式的文件</li>
</ul>
<h2 id="so文件介绍"><a href="#so文件介绍" class="headerlink" title="so文件介绍"></a>so文件介绍</h2><p><strong>概念</strong>：.so 文件是ELF对象文件中可被共享的对象文件(Shared object file)，这些就是所谓的动态库文件。</p>
<p><strong>动态文件的作用</strong>：如果用静态库来生成可执行程序，那每个生成的可执行程序中都会有一份库代码的拷贝。如果在磁盘中存储这些可执行程序，那就会占用额外的磁盘空 间；另外如果拿它们放到Linux系统上一起运行，也会浪费掉宝贵的物理内存。如果将静态库换成动态库，那么这些问题都不会出现。</p>
<p>Android中的so文件就是elf文件，所以需要了解so文件，必须先来了解一下elf文件的格式。</p>
<h3 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h3><p>为了让大家对elf文件格式有一个整体的了解，首先先看一张非虫先生总结好的图片讲解：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/20140918103240781.png" alt="20140918103240781.png"></p>
<p>ELF文件的两种视图，分别是<strong>链接视图</strong>和<strong>执行视图</strong>。</p>
<p><strong>链接视图</strong>：是在<strong>链接时</strong>用到的视图， 以<strong>节</strong>（section）为单位，下图<strong>左侧</strong>的视角是从链接来看的。从图中我们得到，在链接阶段，我们可以忽略<strong>program header table</strong>来处理此文件，因为它是按照<strong>section header table</strong>来处理此文件的。</p>
<p><strong>执行视图</strong>：在<strong>执行时</strong>用到的视图，是以<strong>段</strong>（segment）为单位，下图<strong>右侧</strong>的视角是执行来看的。从图中我们可以得到，在运行阶段可以忽略<strong>section header table</strong>来处理此程序，因为它是按照<strong>program header table</strong>来处理此文件的。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220302143454066.png" alt="image-20220302143454066"></p>
<p><strong>文件的组成</strong>：</p>
<ul>
<li><strong>ELF heade</strong>r： 描述整个文件的组织。</li>
<li><strong>Program Header Table</strong>: 描述文件中的各种segments，用来告诉系统如何创建进程映像的。 </li>
<li><strong>sections</strong> 或者 <strong>segments</strong>：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。</li>
<li><strong>Section Header Table</strong>: 包含了文件各个segction的属性信息</li>
</ul>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220302144111413.png" alt="image-20220302144111413"></p>
<p><strong>区分两种视图的原因</strong>：</p>
<p>在内存之中，多个具有<strong>相同权限</strong>（flg值）section<strong>合并</strong>一个segment。操作系统往往以<strong>页</strong>为基本单位来<strong>管理内存分配</strong>，以及<strong>内存的权限</strong>管理的粒度也是以页为单位。每个section在映射时的长度都是系统<strong>页长度的整数倍</strong>，如果section的长度不是其整数倍，则导致多余部分也将占用一个页，因为一个ELF文件具有很多的section，那么这样将会导致内存浪费严重。为了减少页面内部的碎片，节省了空间，显著提高内存利用率，就将相同权限（flg值）section合并一个segment。</p>
<h4 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h4><p>32位ELF文件中常用的<strong>数据格式</strong>：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303170256836.png" alt="image-20220303170256836"></p>
<p>ELF Header的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define EI_NIDENT 16</span><br><span class="line">typedef struct &#123;</span><br><span class="line">       unsigned char e_ident[EI_NIDENT];  // ELF的一些标识信息，前四位为.ELF,其他的信息比如大小端等</span><br><span class="line">       ELF32_Half e_type;                 // 标识了文件类型</span><br><span class="line">       ELF32_Half e_machine;              // 文件的目标体系架构，比如ARM</span><br><span class="line">       ELF32_Word e_version;              // 0为非法版本，1为当前版本</span><br><span class="line">       ELF32__Addr e_entry;               // 程序入口的虚拟地址</span><br><span class="line">       ELF32_Off e_phoff;                 // 程序头部表偏移地址</span><br><span class="line">       ELF32_Off e_shoff;                 // 节区头部表偏移地址</span><br><span class="line">       ELF32_Word e_flags;                // 保存与文件相关的，特定于处理器的标志</span><br><span class="line">       ELF32_Half e_ehsize;               // ELF头的大小</span><br><span class="line">       ELF32_Half e_phentsize;            // 每个程序头部表的大小</span><br><span class="line">       ELF32_Half e_phnum;                // 程序头部表的数量</span><br><span class="line">       ELF32_Half e_shentsize;            // 每个节区头部表的大小</span><br><span class="line">       ELF32_Half e_shnum;                // 节区头部表的数量</span><br><span class="line">       ELF32_Half e_shstrndx;             // 节区字符串表位置</span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<p>查看ELF Header结构的内容命令： readelf -h android_server</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303171118246.png" alt="image-20220303171118246"></p>
<h5 id="e-entry"><a href="#e-entry" class="headerlink" title="e_entry"></a>e_entry</h5><p>e_entry表示程序入口地址。谓<strong>程序进入点</strong>是指当程序真正执行起来的时候，要运行的指令的运行时地址。其第一条可执行文件test和动态库.so都存在所谓的进入点，且可执行文件的<strong>e_entry</strong>指向C库中的**_start<strong>，而</strong>动态库.so**中的进入点指向 <strong>call_gmon_start</strong>。</p>
<h5 id="重点关注的字段"><a href="#重点关注的字段" class="headerlink" title="重点关注的字段"></a>重点关注的字段</h5><p>在ELF Header中我们需要重点关注以下几个字段：</p>
<ul>
<li><strong>e_entry</strong>：表示程序<strong>入口地址</strong></li>
<li><strong>e_ehsize</strong>：ELF Header<strong>结构大小</strong></li>
<li><strong>e_phoff、e_phentsize、e_phnum</strong>：描述<strong>Program Header Table</strong>的偏移、大小、结构。</li>
<li><strong>e_shoff、e_shentsize、e_shnum</strong>：描述<strong>Section Header Table</strong>的偏移、大小、结构。</li>
<li><strong>e_shstrndx</strong>：这一项描述的是<strong>字符串表</strong>在<strong>Section Header Tabl</strong>e中的索引，值25表示的是Section Header Table中第25项是字符串表（String Table）</li>
</ul>
<h4 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h4><p>section head table(SHT)包含了用来描述每一个<strong>section的条目（entry）</strong>，每一个entry的内容主要包括该 section 的<strong>名称、类型、大小以及在整个ELF文件中的字节偏移位置</strong>等等。</p>
<p>每个条目结构定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    Elf32_Word sh_name;   //节区名，是节区头部字符串表节区（Section Header String Table Section）的索引。名字是一个 NULL 结尾的字符串。</span><br><span class="line">    Elf32_Word sh_type;    //为节区类型</span><br><span class="line">    Elf32_Word sh_flags;    //节区标志</span><br><span class="line">    Elf32_Addr sh_addr;    //如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应处的位置。否则，此字段为 0。</span><br><span class="line">    Elf32_Off sh_offset;    //此成员的取值给出节区的第一个字节与文件头之间的偏移。</span><br><span class="line">    Elf32_Word sh_size;   //此 成 员 给 出 节 区 的 长 度 （ 字 节 数 ）。</span><br><span class="line">    Elf32_Word sh_link;   //此成员给出节区头部表索引链接。其具体的解释依赖于节区类型。</span><br><span class="line">    Elf32_Word sh_info;       //此成员给出附加信息，其解释依赖于节区类型。</span><br><span class="line">    Elf32_Word sh_addralign;    //某些节区带有地址对齐约束.</span><br><span class="line">    Elf32_Word sh_entsize;    //某些节区中包含固定大小的项目，如符号表。对于这类节区，此成员给出每个表项的长度字节数。</span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<h4 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h4><p>有些节区是系统预订的，一般以点开头号,</p>
<h5 id="常用的系统节区"><a href="#常用的系统节区" class="headerlink" title="常用的系统节区"></a>常用的系统节区</h5><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>.bss</td>
<td>SHT_NOBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>包含将出现在程序的内存映像中的为初始化数据。根据定义，当程序开始执行，系统将把这些数据初始化为 0。此节区不占用文件空间。</td>
</tr>
<tr>
<td>.comment</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>包含版本控制信息。</td>
</tr>
<tr>
<td>.data</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td>
</tr>
<tr>
<td>.data1</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td>
</tr>
<tr>
<td>.debug</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>此节区包含用于符号调试的信息。</td>
</tr>
<tr>
<td>.dynamic</td>
<td>SHT_DYNAMIC</td>
<td></td>
<td>此节区包含动态链接信息。节区的属性将包含 SHF_ALLOC 位。是否 SHF_WRITE 位被设置取决于处理器。</td>
</tr>
<tr>
<td>.dynstr</td>
<td>SHT_STRTAB</td>
<td>SHF_ALLOC</td>
<td>此节区包含用于动态链接的字符串，大多数情况下这些字符串代表了与符号表项相关的名称。</td>
</tr>
<tr>
<td>.dynsym</td>
<td>SHT_DYNSYM</td>
<td>SHF_ALLOC</td>
<td>此节区包含了动态链接符号表。</td>
</tr>
<tr>
<td>.fini</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含了可执行的指令，是进程终止代码的一部分。程序正常退出时，系统将安排执行这里的代码。</td>
</tr>
<tr>
<td>.got</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含全局偏移表。</td>
</tr>
<tr>
<td>.hash</td>
<td>SHT_HASH</td>
<td>SHF_ALLOC</td>
<td>此节区包含了一个符号哈希表。</td>
</tr>
<tr>
<td>.init</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含了可执行指令，是进程初始化代码的一部分。当程序开始执行时，系统要在开始调用主程序入口之前（通常指 C 语言的 main 函数）执行这些代码。</td>
</tr>
<tr>
<td>.interp</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含程序解释器的路径名。如果程序包含一个可加载的段，段中包含此节区，那么节区的属性将包含 SHF_ALLOC 位，否则该位为 0。</td>
</tr>
<tr>
<td>.line</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>此节区包含符号调试的行号信息，其中描述了源程序与机器指令之间的对应关系。其内容是未定义的。</td>
</tr>
<tr>
<td>.note</td>
<td>SHT_NOTE</td>
<td>(无)</td>
<td>此节区中包含注释信息，有独立的格式。</td>
</tr>
<tr>
<td>.plt</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含过程链接表（procedure linkage table）。</td>
</tr>
<tr>
<td>.relname .relaname</td>
<td>SHT_REL SHT_RELA</td>
<td></td>
<td>这些节区中包含了重定位信息。如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含 SHF_ALLOC 位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。例如 .text 节区的重定位节区名字将是：.rel.text 或者 .rela.text。</td>
</tr>
<tr>
<td>.rodata .rodata1</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC</td>
<td>这些节区包含只读数据，这些数据通常参与进程映像的不可写段。</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含节区名称。</td>
</tr>
<tr>
<td>.strtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含字符串，通常是代表与符号表项相关的名称。如果文件拥有一个可加载的段，段中包含符号串表，节区的属性将包含SHF_ALLOC 位，否则该位为 0。</td>
</tr>
<tr>
<td>.symtab</td>
<td>SHT_SYMTAB</td>
<td></td>
<td>此节区包含一个符号表。如果文件中包含一个可加载的段，并且该段中包含符号表，那么节区的属性中包含SHF_ALLOC 位，否则该位置为 0。</td>
</tr>
<tr>
<td>.text</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含程序的可执行指令。</td>
</tr>
</tbody></table>
<h5 id="so文件中重要的Section"><a href="#so文件中重要的Section" class="headerlink" title="so文件中重要的Section"></a>so文件中重要的Section</h5><h6 id="符号表-dynsym"><a href="#符号表-dynsym" class="headerlink" title="-符号表(.dynsym)"></a><strong>-符号表(.dynsym)</strong></h6><p>符号表包含用来<strong>定位、重定位程序中符号定义和引用的信息</strong>，简单的理解就是符号表记录了该文件中的所有符号，所谓的符号就是经过<strong>修饰了的函数名或者变量名</strong>，不同的编译器有不同的修饰规则。<strong>例如</strong>符号_ZL15global_static_a，就是由global_static_a变量名经过修饰而来。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">     Elf32_Word st_name;      //符号表项名称。如果该值非0，则表示符号名的字符串表索引(offset)，否则符号表项没有名称。</span><br><span class="line">     Elf32_Addr st_value;       //符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。</span><br><span class="line">     Elf32_Word st_size;         //符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。</span><br><span class="line">     unsigned char st_info;    //符号的类型和绑定属性。</span><br><span class="line">     unsigned char st_other;  //该成员当前包含 0，其含义没有定义。</span><br><span class="line">     Elf32_Half st_shndx;        //每个符号表项都以和其他节区的关系的方式给出定义。此成员给出相关的节区头部表索引。</span><br><span class="line">&#125; Elf32_sym;</span><br></pre></td></tr></table></figure>

<p>符号表的内容</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303175513396.png" alt="image-20220303175513396"></p>
<h6 id="字符串表（-dynstr）"><a href="#字符串表（-dynstr）" class="headerlink" title="-字符串表（.dynstr）"></a><strong>-字符串表（.dynstr）</strong></h6><p>字符串表中存放着<strong>所有符号的名称字符串</strong>。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303175720635.png" alt="image-20220303175720635"></p>
<h6 id="重定位表"><a href="#重定位表" class="headerlink" title="-重定位表"></a><strong>-重定位表</strong></h6><p>重定位就是为程序不同部分<strong>分配加载地址</strong>，<strong>调整</strong>程序中的数据和代码以反映<strong>所分配地址</strong>的过程。简单的言之，则是将程序中的各个部分<strong>映射到合理的地址</strong>上来。例如，当程序调用了一个函数时，相关的调用指令必须把控制传输到适当的目标执行地址。</p>
<p>重定位文件必须包含<strong>如何修改其节区内容的信息</strong>，从而允许可执行文件和共享目标文件保存进程的程序映象的正确信息。</p>
<p>重定位表项的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Addr r_offset;     //重定位动作所适用的位置（受影响的存储单位的第一个字节的偏移或者虚拟地址）</span><br><span class="line">    Elf32_Word r_info;       //要进行重定位的符号表索引，以及将实施的重定位类型（哪些位需要修改，以及如何计算它们的取值）</span><br><span class="line">                                         //其中 .rel.dyn 重定位类型一般为R_386_GLOB_DAT和R_386_COPY；.rel.plt为R_386_JUMP_SLOT</span><br><span class="line">&#125; Elf32_Rel; </span><br></pre></td></tr></table></figure>

<p>r_info 成员使用 <strong>ELF32_R_TYPE 宏运算</strong>可得到<strong>重定位类型</strong>，使用 <strong>ELF32_R_SYM 宏运算</strong>可得到符号在符号表里的<strong>索引值</strong>。</p>
<p>三种宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ELF32_R_SYM(i) ((i)&gt;&gt;8)</span><br><span class="line">#define ELF32_R_TYPE(i) ((unsigned char)(i))</span><br><span class="line">#define ELF32_R_INFO(s, t) (((s)&lt;&lt;8) + (unsigned char)(t))</span><br></pre></td></tr></table></figure>

<p>重定位表中的内容</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303180343936.png" alt="image-20220303180343936"></p>
<h4 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h4><p>程序头部（Program Header）用来在文件中定位各个段的映像,同时包含其他一些用来为程序创建映像所必须的信息。</p>
<p>文件头部的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Word p_type;           //此数组元素描述的段的类型，或者如何解释此数组元素的信息。 </span><br><span class="line">    Elf32_Off  p_offset;           //此成员给出从文件头到该段第一个字节的偏移</span><br><span class="line">    Elf32_Addr p_vaddr;         //此成员给出段的第一个字节将被放到内存中的虚拟地址</span><br><span class="line">    Elf32_Addr p_paddr;        //此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息。</span><br><span class="line">    Elf32_Word p_filesz;         //此成员给出段在文件映像中所占的字节数。可以为0。</span><br><span class="line">    Elf32_Word p_memsz;     //此成员给出段在内存映像中占用的字节数。可以为0。</span><br><span class="line">    Elf32_Word p_flags;         //此成员给出与段相关的标志。</span><br><span class="line">    Elf32_Word p_align;        //此成员给出段在文件中和内存中如何对齐。</span><br><span class="line">&#125; Elf32_phdr;</span><br></pre></td></tr></table></figure>

<p>程序头部表中的内容：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303181440086.png" alt="image-20220303181440086"></p>
<p>so文件格式中结构体的某些参数未详细说明，可以去查看下面的这个参考文章。</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/mergerly/article/details/94585901">https://blog.csdn.net/mergerly/article/details/94585901</a></p>
]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>so文件</tag>
      </tags>
  </entry>
  <entry>
    <title>陇原战疫2021网络安全大赛</title>
    <url>/2022/03/29/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="陇原战”疫”2021网络安全大赛"><a href="#陇原战”疫”2021网络安全大赛" class="headerlink" title="陇原战”疫”2021网络安全大赛"></a>陇原战”疫”2021网络安全大赛</h1><p>最后还加了一道周末打的DASCTF比赛的re题目</p>
<h2 id="findme"><a href="#findme" class="headerlink" title="findme"></a>findme</h2><p>RC4加密</p>
<h3 id="定位加密函数"><a href="#定位加密函数" class="headerlink" title="定位加密函数"></a>定位加密函数</h3><p>在main函数之中是主逻辑</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193151182.png" alt="image-20220324193151182"></p>
<p>通过里面比较的函数定位到对应的位置，发现是引用了strcmp这个函数</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193140351.png" alt="image-20220324193140351"></p>
<p>可以看到这个函数可能被另外一个函数改动了，定位到这个函数，这一看到这个函数把strcmp指引到了另外一个函数</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193117669.png" alt="image-20220324193117669"></p>
<h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><p>S盒的生成</p>
<p>它的S盒是利用用户输入的密钥生成S盒</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193044135.png" alt="image-20220324193044135"></p>
<p>利用密钥流进行加密的操作</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193028708.png" alt="image-20220324193028708"></p>
<h4 id="RC4加密的函数"><a href="#RC4加密的函数" class="headerlink" title="RC4加密的函数"></a>RC4加密的函数</h4><p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193322692.png" alt="image-20220324193322692"></p>
<h4 id="S盒的生成"><a href="#S盒的生成" class="headerlink" title="S盒的生成"></a>S盒的生成</h4><p>S盒的生成的函数：sub_40164C((int)v9, (int)v7, v4);</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193416009.png" alt="image-20220324193416009"></p>
<p>对输入进行加密的函数：sub_401767((int)v8, (int)v6, v10); </p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324193543255.png" alt="image-20220324193543255"></p>
<p>所以将内存之中需要解密的数据dump出来</p>
<h3 id="密文"><a href="#密文" class="headerlink" title="密文"></a>密文</h3><p>需要解密的对象是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0xb7,0x52,0x85,0xc1,0x90,0xe9,0x07,0xb8,0xe4,0x1a,0xc3,0xbd,0x1d,0x8e,0x85,0x46,0x00,0x21,0x44,0xaf,0xef,0x70,0x32,0xb5,0x11,0xc6]</span><br></pre></td></tr></table></figure>

<h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥是引用该函数输入的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SETCTF2021</span><br></pre></td></tr></table></figure>

<h3 id="和密文进行异或的数组"><a href="#和密文进行异或的数组" class="headerlink" title="和密文进行异或的数组"></a>和密文进行异或的数组</h3><p>输入的字符串和图中的数进行异或运算就得到加密的结果，所以我们可以输入26个字符(这里输入的是flag{11111111111111111111})，得到加密的结果</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324205255817.png" alt="image-20220324205255817"></p>
<p>利用这个加密的结果和输入的字符串对应进行异或运算，再和最后对比结果进行异或运算，就能够得到正确的flag</p>
<p>假flag异或运算得到的结果</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324205611680.png" alt="image-20220324205611680"></p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [  0x82, 0x7B, 0xB0, 0xE5, 0xBF, 0x9E, 0x4D, 0xDD, 0xBD, 0x1A,</span><br><span class="line">  0x81, 0xD3, 0x45, 0x8A, 0xEB, 0x32, 0x03, 0x4F, 0x40, 0xEA,</span><br><span class="line">  0x8C, 0x22, 0x6E, 0xBD, 0x01, 0xC6]</span><br><span class="line">obj2 = [0xb7,0x52,0x85,0xc1,0x90,0xe9,0x07,0xb8,0xe4,0x1a,0xc3,0xbd,0x1d,0x8e,0x85,0x46,0x00,0x21,0x44,0xaf,0xef,0x70,0x32,0xb5,0x11,0xc6]</span><br><span class="line">str = &#x27;flag&#123;11111111111111111111&#125;&#x27;</span><br><span class="line">for i in range(len(obj)):</span><br><span class="line">    print(chr(obj[i]^obj2[i]^ord(str[i])),end=&#x27;&#x27;)</span><br><span class="line">SETCTF&#123;Th1s_i5_E2_5tRcm9!&#125;</span><br></pre></td></tr></table></figure>

<p>所以最后的flag是 SETCTF{Th1s_i5_E2_5tRcm9!}</p>
<p>这里如果使用RC4解密的问题是，最后对比的加密结果不能转换成char类型</p>
<h2 id="power"><a href="#power" class="headerlink" title="power"></a>power</h2><p>这是一个arm汇编源文件</p>
<h3 id="arm文件的编译"><a href="#arm文件的编译" class="headerlink" title="arm文件的编译"></a>arm文件的编译</h3><p>在linux之中使用 arm-linux-gnueabi-as power -o power.o 将其编译为elf文件，然后拖入ida32之中即可找到下面这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-as power -o power.o</span><br></pre></td></tr></table></figure>



<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324220844188.png" alt="image-20220324220844188"></p>
<h3 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h3><p>得到的代码我们能够看出这里使用的是AES加密 ，从图中标记的地方知道，虽然这个地方用的函数是cbc加密模式，但是从循环语句，每次加密16个字符（128位），把32个字符的输入分成了前16个和后16个字符各为一组数据，这样的加密模式显示是ECB模式</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324214742877.png" alt="image-20220324214742877"></p>
<p>从上面我们能够知道加密的结果 hex类型的数据：1030a9254d44937bed312da03d2db9adbec5762c2eca7b5853e489d2a140427b</p>
<p>密钥是16字节的字符串：this_is_a_key!!!</p>
<p>偏移量是：this_is_a_key!!!</p>
<h3 id="AES解密"><a href="#AES解密" class="headerlink" title="AES解密"></a>AES解密</h3><p>故用在线解密软件得到解密的结果是：</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220324215149254.png" alt="image-20220324215149254"></p>
<p>最后的flag是 flag{y0u_found_the_aes_12113112}</p>
<h2 id="EasyRE-Revenge"><a href="#EasyRE-Revenge" class="headerlink" title="EasyRE_Revenge"></a>EasyRE_Revenge</h2><p>通过字符串定位到关键代码</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220325122807647.png" alt="image-20220325122807647"></p>
<p>先对输入的长度进行判断（32），再对输入进行变换</p>
<p>将跳转到另外一个函数，但是发现这个函数要去花指令之后才能反编译</p>
<p>加密输入，和加密结果进行对比的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x42, 0xB0, 0xE8, 0xEE, 0x6C, 0xEE, 0xD0, 0x57, 0x32, 0x4B, </span><br><span class="line">0xF5, 0xF3, 0xD6, 0xB7, 0xF0, 0xD3, 0x89, 0xC3, 0x61, 0x0A, </span><br><span class="line">0x40, 0xBA, 0xC7, 0x38, 0x2C, 0x9E, 0x3D, 0x0C, 0x84, 0x92, </span><br><span class="line">0x4A, 0xD6</span><br></pre></td></tr></table></figure>

<h3 id="Eat-something"><a href="#Eat-something" class="headerlink" title="Eat_something"></a>Eat_something</h3><p>得到了一个页面，这里关键代码再wasm文件之中</p>
<p>wasm文件：</p>
<blockquote>
<p>wasm 是 <strong>WebAssembly 的二进制文件</strong>，包含二进制字节码。 写网站基本上是用 JavaScript, 当 JavaScript 速度不够快时，某个模块就可以用 C/C++ 编写，再编译成 wasm，供 JS 调用</p>
</blockquote>
<p>页面网络之中得到wasm文件，感觉源文件是类似于字节码的东西</p>
<img src="/images/陇原战疫2021网络安全大赛/image-20220326082218639.png" alt="image-20220326082218639" style="zoom: 67%;" />

<h3 id="wasm文件的编译"><a href="#wasm文件的编译" class="headerlink" title="wasm文件的编译"></a>wasm文件的编译</h3><p>将wasm文件转换成.o文件</p>
<p>使用[该文章](<a href="https://www.52pojie.cn/thread-1438499-1-1.html">wasm一键转c - 『原创发布区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a>)之中提供的软件将wasm的文件转换成.o格式的文件</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220328124110199.png" alt="image-20220328124110199"></p>
<h3 id="定位关键函数"><a href="#定位关键函数" class="headerlink" title="定位关键函数"></a>定位关键函数</h3><p>将文件放入到ida之中，关注它反编译得到的函数名称</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220328124259347.png" alt="image-20220328124259347"></p>
<p>定位到有特别含义的函数名称，定位到_w2c_checkright这个函数</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220328130246604.png" alt="image-20220328130246604"></p>
<h3 id="密文-1"><a href="#密文-1" class="headerlink" title="密文"></a>密文</h3><p>定位到w2c_memory 偏移为1024赋值的函数</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220328130406773.png" alt="image-20220328130406773"></p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220328130634714.png" alt="image-20220328130634714"></p>
<p>提取出其中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc =   [0x86, 0x8B, 0xAA, 0x85, 0xAC, 0x89, 0xF0, 0xAF, 0xD8, 0x69, </span><br><span class="line">  0xD6, 0xDD, 0xB2, 0xBF, 0x6E, 0xE5, 0xAE, 0x99, 0xCC, 0xD5, </span><br><span class="line">  0xBC, 0x8B, 0xF2, 0x7D, 0x7A, 0xE3, 0x59, 0x6F, 0x75, 0x20, </span><br><span class="line">  0x61, 0x72, 0x65, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x21, </span><br><span class="line">  0x00, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77, </span><br><span class="line">  0x72, 0x6F, 0x6E, 0x67, 0x21, 0x00]</span><br></pre></td></tr></table></figure>

<h3 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc =   [0x86, 0x8B, 0xAA, 0x85, 0xAC, 0x89, 0xF0, 0xAF, 0xD8, 0x69,</span><br><span class="line">  0xD6, 0xDD, 0xB2, 0xBF, 0x6E, 0xE5, 0xAE, 0x99, 0xCC, 0xD5,</span><br><span class="line">  0xBC, 0x8B, 0xF2, 0x7D, 0x7A, 0xE3, 0x59, 0x6F, 0x75, 0x20,</span><br><span class="line">  0x61, 0x72, 0x65, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x21,</span><br><span class="line">  0x00, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77,</span><br><span class="line">  0x72, 0x6F, 0x6E, 0x67, 0x21, 0x00]</span><br><span class="line">for i in range(len(enc)):</span><br><span class="line">    print(chr((enc[i]^i)//2),end=&#x27;&#x27;)</span><br><span class="line">CETCTF&#123;Th0nk_Y0u_DocTOr51&#125;</span><br></pre></td></tr></table></figure>

<p>最后的flag是CETCTF{Th0nk_Y0u_DocTOr51}</p>
<h2 id="easyre-DACTF2022"><a href="#easyre-DACTF2022" class="headerlink" title="easyre-DACTF2022"></a>easyre-DACTF2022</h2><p>用PE打开发现是ASpack的壳，使用Stripper脱壳(工具在 看雪论坛的工具之中搜ASpack，其中有脱该壳的工具，也有手动脱壳的方法)</p>
<p>将脱壳得到的文件放入到ida32之中</p>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>首先判断了长度 和 前六个字符</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125348507.png" alt="image-20220329125348507"></p>
<h3 id="判断的输入的主逻辑函数"><a href="#判断的输入的主逻辑函数" class="headerlink" title="判断的输入的主逻辑函数"></a>判断的输入的主逻辑函数</h3><p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125735359.png" alt="image-20220329125735359"></p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125737500.png" alt="image-20220329125737500"></p>
<h3 id="动态提取dword-492940数组的过程"><a href="#动态提取dword-492940数组的过程" class="headerlink" title="动态提取dword_492940数组的过程"></a>动态提取dword_492940数组的过程</h3><p>下断点</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125814919.png" alt="image-20220329125814919"></p>
<p>按照基本的要求，字符串的长度是42，前六个字符是DASCTF，构造输入</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125913628.png" alt="image-20220329125913628"></p>
<p>然后提取数据：</p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125940909.png" alt="image-20220329125940909"></p>
<p><img src="/images/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/image-20220329125950987.png" alt="image-20220329125950987"></p>
<p>dword_492940:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x38,0x78,0xdd,0xe8,0x00,0xaf,0xbf,0x3a,0x6b,0xfb,0xb8,0x0c,0x85,0x35,0x5c,0xad,0xe6,0x00,0xe0,0x8a,0x1d,0xbd,0x46,0xd2,0x2b,0x00,0x15,0x24,0xc6,0xad,0xa1,0xc9,0x7b,0x12,0x28,0x00,0x05,0x00,0x72,0x3e,0x10,0xa1,0x00,0x00]</span><br></pre></td></tr></table></figure>

<p>最后对比的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0xC3,0x80,0xD5,0xF2,0x9B,0x30,0x0B,0xB4,0x55,0xDE,0x22,0x83,0x2f,0x97,0xB8,0x20,0x1D,0x74,0xd1,1,0x73,0x1A,0xB2,0xc8,0xc5,0x74,0xc0,0x5B,0xf7,0xF,0xD3,1,0x55,0xB2,0xA4,0xAE,0x7B,0xAC,0x5c,0x56,0xbc,0x23]</span><br></pre></td></tr></table></figure>

<h3 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">para = [0x38,0x78,0xdd,0xe8,0x00,0xaf,0xbf,0x3a,0x6b,0xfb,0xb8,0x0c,0x85,0x35,0x5c,0xad,0xe6,0x00,0xe0,0x8a,0x1d,0xbd,0x46,0xd2,0x2b,0x00,0x15,0x24,0xc6,0xad,0xa1,0xc9,0x7b,0x12,0x28,0x00,0x05,0x00,0x72,0x3e,0x10,0xa1,0x00,0x00]</span><br><span class="line">para2 = [0xC3,0x80,0xD5,0xF2,0x9B,0x30,0x0B,0xB4,0x55,0xDE,0x22,0x83,0x2f,0x97,0xB8,0x20,0x1D,0x74,0xd1,1,0x73,0x1A,0xB2,0xc8,0xc5,0x74,0xc0,0x5B,0xf7,0xF,0xD3,1,0x55,0xB2,0xA4,0xAE,0x7B,0xAC,0x5c,0x56,0xbc,0x23]</span><br><span class="line">for i in range(len(para2)):</span><br><span class="line">    if para2[i] &gt;71:</span><br><span class="line">        print(chr((para2[i] - 71) ^ para[i]), end=&quot;&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(chr((para2[i] +256 - 71) ^ para[i]), end=&quot;&quot;)</span><br><span class="line">DASCTF&#123;Welc0me-t0-j01n-SU-l0ve-suyug1eg1e&#125;</span><br></pre></td></tr></table></figure>

<p>最后的flag：DASCTF{Welc0me-t0-j01n-SU-l0ve-suyug1eg1e}</p>
<p>参考文章：</p>
<p><a href="https://zzzzsky.com/2021/11/11/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021_RE_WP/">陇原战”疫”2021网络安全大赛_RE_WP | zsky’s Blog (zzzzsky.com)</a></p>
<p><a href="https://blog.shi1011.cn/ctf/1808">陇原战”疫”2021网络安全大赛 - 翻车鱼 (shi1011.cn)</a></p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>复现</tag>
        <tag>wasm</tag>
        <tag>AES</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫_逆向</title>
    <url>/2022/03/02/%E8%BF%B7%E5%AE%AB-%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<h1 id="迷宫-逆向"><a href="#迷宫-逆向" class="headerlink" title="迷宫_逆向"></a>迷宫_逆向</h1><h2 id="深度优先算法介绍"><a href="#深度优先算法介绍" class="headerlink" title="深度优先算法介绍"></a>深度优先算法介绍</h2><blockquote>
<p>深度优先搜索算法（Depth-First-Search），是搜索算法的一种。是沿着树的深度遍历树的节点，<strong>尽可能深</strong>的搜索树的分支。当节点v的所有边都己被探寻过，搜索将<strong>回溯</strong>到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于<strong>盲目搜索</strong>。</p>
</blockquote>
<h2 id="深度优先算法在迷宫中的使用"><a href="#深度优先算法在迷宫中的使用" class="headerlink" title="深度优先算法在迷宫中的使用"></a>深度优先算法在迷宫中的使用</h2><p>二维的迷宫：</p>
<ul>
<li>使用递归的方法，用栈的思想放入和取出路径，用数组的方式存放迷宫图</li>
<li>使用for循环遍历四个方向，在每个节点选择走的方向，如果按这个方向向下走一步能够满足条件（不是墙并且没有到达过），就可以将这一步的目标地址进行标记（已经走过），并且将走的方向放入路径之中</li>
<li>当死路的时候就会向上返回。如果四个方向都遍历，没有一个方向能够满足条件，那么就会返回上一轮，并且将这步错误的方向在路径之中去除，并且将这个地址再次标记为未可达</li>
<li>递归的结束条件。已经到达了目标地址的坐标，就可以返回这个路径了</li>
</ul>
<h2 id="二维迷宫题算法实现"><a href="#二维迷宫题算法实现" class="headerlink" title="二维迷宫题算法实现"></a>二维迷宫题算法实现</h2><h3 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h3><p>map：迷宫地图，数组需要在声明的时候进行初始化</p>
<p>stages：上下左右的表示方法</p>
<p>n,m：一共有多少排多少列</p>
<p>stx,sty：迷宫起始的位置，需要对应数组的下标</p>
<p>endx,endy：迷宫终点的位置，需要对应数组相应的下标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> tmap[<span class="number">32</span>][<span class="number">32</span>]=&#123;<span class="string">&quot;00000&quot;</span>,<span class="string">&quot;01100&quot;</span>,<span class="string">&quot;00100&quot;</span>,<span class="string">&quot;00110&quot;</span>,<span class="string">&quot;00000&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> sign[<span class="number">50</span>][<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 右左下上</span></span><br><span class="line"><span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> stages[] = <span class="string">&quot;dasw&quot;</span>;</span><br><span class="line"><span class="comment">//这个迷宫有几排几列，用于判断有没有超出边界</span></span><br><span class="line"><span class="type">int</span> n=<span class="number">5</span>,m=<span class="number">5</span>;</span><br><span class="line"><span class="comment">// 标记起始位置</span></span><br><span class="line"><span class="type">int</span> stx=<span class="number">1</span>,sty=<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 标记终点位置</span></span><br><span class="line"><span class="type">int</span> endx=<span class="number">3</span>,endy=<span class="number">3</span>;</span><br><span class="line"><span class="comment">// road 路径</span></span><br><span class="line"><span class="type">char</span> road[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//已经走了多少步了</span></span><br><span class="line"><span class="type">int</span> steps=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addSteps</span><span class="params">(<span class="type">char</span> stage)</span>&#123;</span><br><span class="line">    road[steps] = stage;</span><br><span class="line">    steps++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">subSteps</span><span class="params">()</span>&#123;</span><br><span class="line">    steps--;</span><br><span class="line">    road[steps] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先算法 提供的参数是走迷宫的起始位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tx,ty;</span><br><span class="line">    <span class="keyword">if</span>(x == endx&amp;&amp;y == endy)&#123;</span><br><span class="line">        <span class="comment">//到达了最后的地方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;走的路径是：%s&quot;</span>,(<span class="type">char</span>*)road);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//tx 和 ty标记到达地址</span></span><br><span class="line">            tx = x+next[i][<span class="number">0</span>];</span><br><span class="line">            ty = y+next[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 当沿着这个方向的下一步不是墙 不是已经走过的地方 并且到达的这个地址在范围之内</span></span><br><span class="line">        <span class="keyword">if</span>(tx&gt;=<span class="number">0</span>&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=<span class="number">0</span>&amp;&amp;ty&lt;m&amp;&amp;tmap[ty][tx]!=<span class="string">&#x27;0&#x27;</span>&amp;&amp;sign[ty][tx]==<span class="number">0</span>)&#123;</span><br><span class="line">            sign[ty][tx]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将之前长度的字符串放入到其中 并且再添加一个字符（表示这一步的方向）</span></span><br><span class="line">            addSteps(stages[i]);</span><br><span class="line">            dfs(tx,ty);</span><br><span class="line">            sign[ty][tx]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//除去最后一步</span></span><br><span class="line">            subSteps();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当四个方向都不满足的时候跳出循环</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    dfs(stx,sty);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：dssd</span><br></pre></td></tr></table></figure>



<h3 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h3><p>使用脚本的时候根据题目的不同需要进行修改的脚本之中的参数有</p>
<p>map：map使用数字类型的数字表示，还是用char类型的数组表示，map的声明以及每一步的是否正确的判断条件都是不一样的</p>
<p>stx和sty：迷宫的起点，数组的起点是从0开始标识的</p>
<p>endx和endy：迷宫的终点，注意数组的下标</p>
<p>signdirect：题目之中这四个方向所代表的字符都是不一样的，需要根据题目的要求具体的表示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># map是迷宫</span></span><br><span class="line"><span class="built_in">map</span> = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line"><span class="comment"># 标记该路径是否走过 5*5的数组的表示方法</span></span><br><span class="line">sign = [[<span class="number">0</span>]*<span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 起始的位置</span></span><br><span class="line">stx = <span class="number">1</span></span><br><span class="line">sty = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记下一步的地址</span></span><br><span class="line">endx = <span class="number">0</span></span><br><span class="line">endy = <span class="number">0</span></span><br><span class="line"><span class="comment"># 每次走的方向 路径</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 标记走的四个方向</span></span><br><span class="line">direct = [[<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 这四个方向的表示方法</span></span><br><span class="line">signdirect=<span class="string">&#x27;dasw&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度遍历方法的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y</span>):</span><br><span class="line">  <span class="keyword">global</span> flag   <span class="comment">#注意在函数里面要当全局变量使用的变量一定要在函数之中进行声明！！！！！！</span></span><br><span class="line">  endx = <span class="number">0</span></span><br><span class="line">  endy = <span class="number">0</span></span><br><span class="line">  <span class="comment"># 到达终点</span></span><br><span class="line">  <span class="keyword">if</span> x==finalx <span class="keyword">and</span> y==finaly:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment"># 未到达终点之前遍历四个方向</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(direct)):</span><br><span class="line">    endx = x+direct[i][<span class="number">0</span>]</span><br><span class="line">    endy = y+direct[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> endy&gt;=<span class="number">0</span> <span class="keyword">and</span> endy&lt;<span class="built_in">len</span>(<span class="built_in">map</span>) <span class="keyword">and</span> endx&gt;=<span class="number">0</span> <span class="keyword">and</span> endx&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>]) <span class="keyword">and</span> <span class="built_in">map</span>[endy][endx] == <span class="number">1</span> <span class="keyword">and</span> sign[endy][endx] !=<span class="number">1</span>:</span><br><span class="line">      sign[endy][endx] = <span class="number">1</span></span><br><span class="line">      flag=flag+signdirect[i]</span><br><span class="line">      dfs(endx,endy)</span><br><span class="line">      sign[endy][endx] = <span class="number">0</span></span><br><span class="line">      flag = flag[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dfs(stx,sty)</span><br><span class="line">运行结果： dssd</span><br></pre></td></tr></table></figure>

<p>如果是用字符串的形式声明迷宫时，map的表示方式，及脚本之中需要改变的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map = [&quot;00000&quot;,&quot;01100&quot;,&quot;00100&quot;,&quot;00110&quot;,&quot;00000&quot;]</span><br><span class="line"># 每一步判断条件的 map[endy][endx] == &#x27;1&#x27; 要修改成满足要求的对应字符而不是数字了</span><br><span class="line">if endy&gt;=0 and endy&lt;len(map) and endx&gt;=0 and endx&lt;len(map[0]) and map[endy][endx] == &#x27;1&#x27; and sign[endy][endx] !=1:    </span><br></pre></td></tr></table></figure>

<h2 id="三维迷宫题的算法实现"><a href="#三维迷宫题的算法实现" class="headerlink" title="三维迷宫题的算法实现"></a>三维迷宫题的算法实现</h2><h3 id="python版本-1"><a href="#python版本-1" class="headerlink" title="python版本"></a>python版本</h3><p>这里需要输入的参数和二维的脚本差不多，只是要多一个z轴上的坐标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">map</span> = [[ <span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaeee&quot;</span>],[<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>],[<span class="string">&quot;aeeaa&quot;</span>,<span class="string">&quot;aeeaa&quot;</span>,<span class="string">&quot;eeeae&quot;</span>,<span class="string">&quot;eaaae&quot;</span>,<span class="string">&quot;eaaae&quot;</span>],[<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;eaaee&quot;</span>],[ <span class="string">&quot;aaeea&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aeeea&quot;</span>,<span class="string">&quot;eeaea&quot;</span>,<span class="string">&quot;eaaea&quot;</span>]]</span><br><span class="line"></span><br><span class="line">sign = [[[<span class="number">0</span>]*<span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 标记起始位置</span></span><br><span class="line">stx = <span class="number">2</span></span><br><span class="line">sty = <span class="number">4</span></span><br><span class="line">stz = <span class="number">0</span></span><br><span class="line"><span class="comment"># 标识终点位置</span></span><br><span class="line">finalx = <span class="number">2</span></span><br><span class="line">finaly = <span class="number">2</span></span><br><span class="line">finalz = <span class="number">2</span></span><br><span class="line"><span class="comment"># 标记下一步的地址</span></span><br><span class="line">endx = <span class="number">0</span></span><br><span class="line">endy = <span class="number">0</span></span><br><span class="line">endz = <span class="number">0</span></span><br><span class="line"><span class="comment"># 每次走的方向 路径</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 标记走的四个方向</span></span><br><span class="line">direct = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line">signdirect=<span class="string">&#x27;daswxy&#x27;</span></span><br><span class="line"><span class="comment"># 深度遍历方法的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y,z</span>):</span><br><span class="line">  <span class="keyword">global</span> flag   <span class="comment">#注意在函数里面要当全局变量使用的变量一定要在函数之中进行声明！！！！！！</span></span><br><span class="line">  endx = <span class="number">0</span></span><br><span class="line">  endy = <span class="number">0</span></span><br><span class="line">  endz = <span class="number">0</span></span><br><span class="line">  <span class="comment"># 到达终点</span></span><br><span class="line">  <span class="keyword">if</span> x==finalx <span class="keyword">and</span> y==finaly <span class="keyword">and</span> z==finalz:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment"># 未到达终点之前遍历6个</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(direct)):</span><br><span class="line">    endx = x+direct[i][<span class="number">0</span>]</span><br><span class="line">    endy = y+direct[i][<span class="number">1</span>]</span><br><span class="line">    endz = z+direct[i][<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> endy&gt;=<span class="number">0</span> <span class="keyword">and</span> endy&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>]) <span class="keyword">and</span> endx&gt;=<span class="number">0</span> <span class="keyword">and</span> endx&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>][<span class="number">0</span>]) <span class="keyword">and</span> endz&gt;=<span class="number">0</span> <span class="keyword">and</span> endz&lt;<span class="built_in">len</span>(<span class="built_in">map</span>) <span class="keyword">and</span> <span class="built_in">map</span>[endz][endy][endx] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">and</span> sign[endz][endy][endx] !=<span class="number">1</span>:</span><br><span class="line">      sign[endz][endy][endx] = <span class="number">1</span></span><br><span class="line">      flag=flag+signdirect[i]</span><br><span class="line">      dfs(endx,endy,endz)</span><br><span class="line">      sign[endz][endy][endx] = <span class="number">0</span></span><br><span class="line">      flag = flag[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dfs(stx,sty,stz)</span><br><span class="line"><span class="comment"># 这里返回的结果有多个，选取其中最短的那个即为正确答案   ddwwxxssxaxwwaasasyywwdd</span></span><br><span class="line">ddwwxxssxaxwwaasasyywwdd</span><br><span class="line">ddwwxxssxaxwwaasasyywwdwds</span><br><span class="line">ddwwxxssxaxwwaasasyywwdwwdss</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdd</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdwds</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdwwdss</span><br></pre></td></tr></table></figure>

<p>有时候迷宫的走法不止一个，就取走的路程最小的那个就可以了</p>
]]></content>
      <categories>
        <category>题型</category>
      </categories>
      <tags>
        <tag>迷宫</tag>
      </tags>
  </entry>
</search>
