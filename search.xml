<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AntCTF &amp; Dˆ3CTF 2022（d3arm+d3w0w）</title>
    <url>/2022/03/10/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/</url>
    <content><![CDATA[<h1 id="AntCTF-amp-Dˆ3CTF-2022（d3arm-d3w0w）"><a href="#AntCTF-amp-Dˆ3CTF-2022（d3arm-d3w0w）" class="headerlink" title="AntCTF &amp; Dˆ3CTF 2022（d3arm+d3w0w）"></a>AntCTF &amp; Dˆ3CTF 2022（d3arm+d3w0w）</h1><h2 id="d3arm"><a href="#d3arm" class="headerlink" title="d3arm"></a>d3arm</h2><p>得到了一个bin的文件，如果想要得到代码需要将这个bin文件转化成hex文件，使用bintohex这个软件，得到hex文件，然后将这个hex文件载入到ida之中，将hex文件载入ida的时候需要设置一些参数，这个过程可以参考<a href="https://blog.csdn.net/daidi1989/article/details/86304843">这篇文章</a></p>
<p>将这个hex文件载入ida之中之后，查看字符串，根据图中标记的字符串跟进到关键代码的位置</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308212419039.png" alt="image-20220308212419039"></p>
<h3 id="关键主代码"><a href="#关键主代码" class="headerlink" title="关键主代码"></a>关键主代码</h3><p>图中标记的地方就是可能是flag的地方</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308212548857.png" alt="image-20220308212548857"></p>
<h3 id="引用了flag的函数"><a href="#引用了flag的函数" class="headerlink" title="引用了flag的函数"></a>引用了flag的函数</h3><p>在这个函数里面不能够得到什么数值的有效信息，所以查看引用该函数的其它函数，但是这里通过交叉函数我并不能找到有效的函数，翻看这个函数上下的函数，找到一个<strong>引用了point和flag地址的一个函数，将point作为下标，给flag进行赋值的操作</strong></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308214809866.png" alt="image-20220308214809866"></p>
<p>通过<strong>地址0x800DB64</strong>，在汇编代码的界面之宗，点击G 输入跳转到0x000DB64这个地址，就可以找到这个数组了</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308215223252.png" alt="image-20220308215223252"></p>
<p>这个数组是（这里取出来的数组有一定的问题，在内存之中我只找到部分的数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">,0x20,0x6d,0x50,0x30,0x38,0x48,0x20,0x6d,0x5,0x26,0x6d,0x56,0x72,0x6d,0x51,0x22,0x6c,0x4,0x70,0x38,0x1,0x7d,0x6a,0x5,0x7c,0x6e,0x55,0x27,0x69,0x4e</span><br></pre></td></tr></table></figure>

<h3 id="异或的对象MEMORY-0x20002314"><a href="#异或的对象MEMORY-0x20002314" class="headerlink" title="异或的对象MEMORY[0x20002314]"></a>异或的对象MEMORY[0x20002314]</h3><p>但是现在还不知道这个数组异或的对象MEMORY[0x20002314]的内容</p>
<p>找到和这个地址的数相关的函数，这个函数有对这个地址赋值的操作，其中的MEMORY[0x20002314] = 0x335E44u &gt;&gt; (8 * v1 &amp; 0xF8)这个式子中的v1来自于 MEMORY[0x2000326C] % 3，MEMORY[0x2000326C]和上一个函数相得知是数组的下标</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220308220048764.png" alt="image-20220308220048764"></p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [0x20,0x6d,0x50,0x30,0x38,0x48,0x20,0x6d,0x5,0x26,0x6d,0x56,0x72,0x6d,0x51,0x22,0x6c,0x4,0x70,0x38,0x1,0x7d,0x6a,0x5,0x7c,0x6e,0x55,0x27,0x69,0x4e]</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(len(obj)):</span><br><span class="line">  key = 0x335E44 &gt;&gt; (8 * (i%3)&amp;0xf8) &amp;0xff  #注意这里异或运算的结果并不是8位，所以我们需要通过&amp;0xff取出最后的8位数</span><br><span class="line">  flag+=chr(obj[i]^key)</span><br><span class="line">print(flag)</span><br><span class="line">d3ctf&#123;d36b3e63bf274f294680fc7&#125;</span><br></pre></td></tr></table></figure>

<p>d3ctf{d36b3e63bf274f294680fc7}</p>
<h2 id="d3w0w"><a href="#d3w0w" class="headerlink" title="d3w0w"></a>d3w0w</h2><p>使用32位的ida打开这个程序，通过程序之中的字符串定位到关键的代码</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309090157805.png" alt="image-20220309090157805"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309090254186.png" alt="image-20220309090254186"></p>
<p>分析代码显然我们需要使得这两个函数都能够返回0，这里我们得到的v3的结果就是0</p>
<h3 id="第一个函数-sub-401000-amp-v1-amp-unk-4262F8"><a href="#第一个函数-sub-401000-amp-v1-amp-unk-4262F8" class="headerlink" title="第一个函数 sub_401000(&amp;v1, &amp;unk_4262F8)"></a>第一个函数 sub_401000(&amp;v1, &amp;unk_4262F8)</h3><p>第一个函数 sub_401000(&amp;v1, &amp;unk_4262F8) 其中的v1代表我们输入的flag的值，这个flag里面有四种char 1，2，3，4，利用这个flag的字符串用走迷宫的形式给这个数组赋值</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309091251377.png" alt="image-20220309091251377"></p>
<h3 id="32位程序调用64位函数："><a href="#32位程序调用64位函数：" class="headerlink" title="32位程序调用64位函数："></a><a href="https://www.anquanke.com/post/id/171111">32位程序调用64位函数</a>：</h3><p>rewolf-wow64ext的目的就是让运行在Wow64环境中的x86应用程序可以直接调用x64下ntdll.dll中的Native API。</p>
<p> 进程的32位模式改为64位模式的具体代码：</p>
<p>主要方法是 借助retf将<strong>CS寄存器的值</strong>设置为<strong>0x33</strong>。</p>
<p>为什么要将CS寄存器的值设置为0x33？因为我们所需CPU的解码模式需要是<strong>64位模式</strong>，而当前模式是<strong>32位</strong>。64位CPU是通过GDT表中CS段所对应的表项中<strong>L标志位</strong>来确定当前<strong>解码模式</strong>的。</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309092835616.png" alt="image-20220309092835616"></p>
<p>在x64系统下的进程是有32位和64位两种工作模式，这两种工作模式的区别在于CS寄存器。<strong>32位模式</strong>时，<strong>CS = 0x23</strong>；<strong>64位模式</strong>时，<strong>CS = 0x33</strong>。</p>
<p>切换这两种工作模式的方法：</p>
<p>一般会通过retf指令，retf指令和 <strong>pop</strong> ip+<strong>pop</strong> cs 作用相同。如果此时栈中有0x33，则会将0x33弹出到CS寄存器中，实现32位程序切换到64位代码的过程</p>
<p>我们直接打开这个函数，不能够反编译，然后现在查看汇编代码，在程序的开头就调用了一个函数</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309092438231.png" alt="image-20220309092438231"></p>
<p>跟进到这个函数之中去，发现了和32需要调用64位函数的时候的中间代码相同的一段代码，这样我们就能知道这个地方的函数是64位的</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220309092509334.png" alt="image-20220309092509334"></p>
<h3 id="第二个函数-sub-401220-amp-unk-4262F8"><a href="#第二个函数-sub-401220-amp-unk-4262F8" class="headerlink" title="第二个函数 sub_401220(&amp;unk_4262F8)"></a>第二个函数 sub_401220(&amp;unk_4262F8)</h3><p> 这个函数的参数就是在上一个函数赋值的数组，这个函数里面就是对这个赋值得到的数组进行一系列的限制，但是这个地方是一个32位的程序之中调用64位的函数，所以我们需要将这个函数dump出来，然后导入到ida64之中去反编译这个函数，但是这里的代码之中即有32位的代码又有64位的代码，这样做是不能通过这样的方法反编译出来的。</p>
<p>但是使用ida7.5反编译这个程序就能够得到这个函数的代码，但是这个代码之中会混杂着一些asm的汇编代码，需要我们仔细地分析这个代码。</p>
<p>这里面参杂着一些64位的汇编代码，它的代码意义在图中有标明进行注释</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310212725752.png" alt="image-20220310212725752"></p>
<h4 id="对迷宫的第一排-第一列-第六排-第六列的限制"><a href="#对迷宫的第一排-第一列-第六排-第六列的限制" class="headerlink" title="对迷宫的第一排 第一列 第六排 第六列的限制"></a>对迷宫的第一排 第一列 第六排 第六列的限制</h4><p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310212935273.png" alt="image-20220310212935273"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310212948727.png" alt="image-20220310212948727"></p>
<h4 id="第一种特殊点的限制"><a href="#第一种特殊点的限制" class="headerlink" title="第一种特殊点的限制"></a>第一种特殊点的限制</h4><p>限制1 ：不能同时含有 8 和 2 并且也不能同时含有4和1 所以有12、9、6、3这四种组合方式</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310213056630.png" alt="image-20220310213056630"></p>
<p>限制2 ：需要赋值两次</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215425865.png" alt="image-20220310215425865"></p>
<p>限制三  ：</p>
<p>如果当前的格子之中是8 则它的上一行的对应的格子就不能是8 </p>
<p>如果当前的格子之中是2 则它的下一行的对应的格子就不能是2</p>
<p>如果当前的格子之中是4 则它的上一格的对应的格子就不能是4</p>
<p>如果当前的格子之中是1 则它的上一行的对应的格子就不能是1</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215559291.png" alt="image-20220310215559291"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215603014.png" alt="image-20220310215603014"></p>
<h4 id="第二种特殊点的限制"><a href="#第二种特殊点的限制" class="headerlink" title="第二种特殊点的限制"></a>第二种特殊点的限制</h4><p>限制一 ：这十个坐标含有2和8的组合 或者 含有1和4的组合</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310215808216.png" alt="image-20220310215808216"></p>
<p>限制二 ：</p>
<p>当<strong>本格是10</strong>时，上下两行之中一定要含有1或4</p>
<p>当<strong>本格是5</strong>时，左右两格之中一定要含有8或2</p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220010868.png" alt="image-20220310220010868"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220052452.png" alt="image-20220310220052452"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220106999.png" alt="image-20220310220106999"></p>
<h4 id="对走的方向以及迷宫终点设置的代码"><a href="#对走的方向以及迷宫终点设置的代码" class="headerlink" title="对走的方向以及迷宫终点设置的代码"></a>对走的方向以及迷宫终点设置的代码</h4><p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220252666.png" alt="image-20220310220252666"></p>
<p><img src="/images/AntCTF-D%CB%863CTF-2022%EF%BC%88d3arm-d3w0w%EF%BC%89/image-20220310220335420.png" alt="image-20220310220335420"></p>
<h4 id="整理之后地代码"><a href="#整理之后地代码" class="headerlink" title="整理之后地代码"></a>整理之后地代码</h4><p>别人的wp之中找到对这部分代码的整理之后的结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">spoint1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  spoint1[<span class="number">1</span>] = <span class="number">14</span>;</span><br><span class="line">  spoint1[<span class="number">2</span>] = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//总体限制，不能撞墙，不能重复使用格子</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( table[<span class="number">6</span> * i + j] &gt; <span class="number">0xF</span>u )            <span class="comment">// 每一个格子都不能大于16</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      v14 = table[<span class="number">6</span> * i + j] % <span class="number">0x10</span>u / <span class="number">8</span>;</span><br><span class="line">      v22 = j;</span><br><span class="line">      v15 = table[<span class="number">6</span> * i + j] % <span class="number">8u</span> / <span class="number">4</span> + v14;</span><br><span class="line">      v23 = j;</span><br><span class="line">      v16 = table[<span class="number">6</span> * i + j] % <span class="number">4u</span> / <span class="number">2</span> + v15;</span><br><span class="line">      v24 = j;</span><br><span class="line">      <span class="keyword">if</span> ( table[<span class="number">6</span> * i + j] % <span class="number">2u</span> + v16 &gt; <span class="number">2</span> )    <span class="comment">// 计算二进制1的个数,也就是说每个格子不能被设置两次以上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( !j &amp;&amp; table[<span class="number">6</span> * i] % <span class="number">8u</span> / <span class="number">4</span> )        <span class="comment">// 6*6数组的第一列不能=4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( j == <span class="number">5</span> &amp;&amp; table[<span class="number">6</span> * i + <span class="number">5</span>] % <span class="number">2u</span> )    <span class="comment">// 最后一列不能=1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( !i &amp;&amp; table[j] % <span class="number">0x10</span>u / <span class="number">8</span> )         <span class="comment">// 第一行每一个都不能=8</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">      <span class="keyword">if</span> ( i == <span class="number">5</span> &amp;&amp; table[j + <span class="number">30</span>] % <span class="number">4u</span> / <span class="number">2</span> )   <span class="comment">// 最后一行每一个都不能=2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第一种特殊点限制条件，这种特殊点周围不能连着出现两种操作，碰到必须拐弯</span></span><br><span class="line">  <span class="keyword">for</span> ( k = <span class="number">0</span>; (<span class="type">unsigned</span> __int64)k &lt; <span class="number">3</span>; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    row1 = spoint1[k] / <span class="number">10</span>;                     <span class="comment">// 0 1 2</span></span><br><span class="line">    col1 = spoint1[k] % <span class="number">10</span>;                     <span class="comment">// 0 4 0</span></span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">0x10</span>u / <span class="number">8</span> &amp;&amp; table[<span class="number">6</span> * row1 + col1] % <span class="number">4u</span> / <span class="number">2</span> )<span class="comment">// != 8 != 2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">8u</span> / <span class="number">4</span> &amp;&amp; table[<span class="number">6</span> * row1 + col1] % <span class="number">2u</span> )<span class="comment">// != 4 != 1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    v17 = table[<span class="number">6</span> * row1 + col1] % <span class="number">0x10</span>u / <span class="number">8</span>;</span><br><span class="line">    v25 = col1;</span><br><span class="line">    v18 = table[<span class="number">6</span> * row1 + col1] % <span class="number">4u</span> / <span class="number">2</span> + v17;</span><br><span class="line">    v26 = col1;</span><br><span class="line">    v19 = table[<span class="number">6</span> * row1 + col1] % <span class="number">2u</span> + v18;</span><br><span class="line">    v27 = col1;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">8u</span> / <span class="number">4</span> + v19 != <span class="number">2</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">0x10</span>u / <span class="number">8</span> )   <span class="comment">// 当前格子为8则判断上一行不能为8</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row1 - <span class="number">6</span> + col1] % <span class="number">0x10</span>u / <span class="number">8</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">4u</span> / <span class="number">2</span> ) <span class="comment">// 当前格子为2则判断下一行不能为2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row1 + <span class="number">6</span> + col1] % <span class="number">4u</span> / <span class="number">2</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">8u</span> / <span class="number">4</span> ) <span class="comment">// 当前格子为4则判断上一格不能为4</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row1 - <span class="number">1</span> + col1] % <span class="number">8u</span> / <span class="number">4</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( table[<span class="number">6</span> * row1 + col1] % <span class="number">2u</span> &amp;&amp; !(table[<span class="number">6</span> * row1 + <span class="number">1</span> + col1] % <span class="number">2u</span>) )<span class="comment">// 当前格子为1则判断下一格不能为1</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第二种特殊点限制条件，必须直线进入，连续3格可连成直线，并且是拐弯进入前一格，或者进入后一格后拐弯</span></span><br><span class="line">  spoint2[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">  spoint2[<span class="number">1</span>] = <span class="number">13</span>;</span><br><span class="line">  spoint2[<span class="number">2</span>] = <span class="number">15</span>;</span><br><span class="line">  spoint2[<span class="number">3</span>] = <span class="number">21</span>;</span><br><span class="line">  spoint2[<span class="number">4</span>] = <span class="number">24</span>;</span><br><span class="line">  spoint2[<span class="number">5</span>] = <span class="number">31</span>;</span><br><span class="line">  spoint2[<span class="number">6</span>] = <span class="number">32</span>;</span><br><span class="line">  spoint2[<span class="number">7</span>] = <span class="number">41</span>;</span><br><span class="line">  spoint2[<span class="number">8</span>] = <span class="number">45</span>;</span><br><span class="line">  spoint2[<span class="number">9</span>] = <span class="number">53</span>;</span><br><span class="line">  <span class="keyword">for</span> ( l = <span class="number">0</span>; (<span class="type">unsigned</span> __int64)l &lt; <span class="number">0xA</span>; ++l )</span><br><span class="line">  &#123;</span><br><span class="line">    row2 = spoint2[l] / <span class="number">10</span>;</span><br><span class="line">    col2 = spoint2[l] % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (!(table[<span class="number">6</span> * row2 + col2] % <span class="number">0x10</span>u / <span class="number">8</span>) || !(table[<span class="number">6</span> * row2 + col2] % <span class="number">4u</span> / <span class="number">2</span>))<span class="comment">// 只有 28 或者14的组合</span></span><br><span class="line">      &amp;&amp; (!(table[<span class="number">6</span> * row2 + col2] % <span class="number">8u</span> / <span class="number">4</span>) || !(table[<span class="number">6</span> * row2 + col2] % <span class="number">2u</span>)) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row2 + col2] % <span class="number">0x10</span>u / <span class="number">8</span>     <span class="comment">// 28组合</span></span><br><span class="line">                                                <span class="comment">// 上一行 =4 =1或者</span></span><br><span class="line">                                                <span class="comment">// 下一行 =4 =1</span></span><br><span class="line">      &amp;&amp; table[<span class="number">6</span> * row2 + col2] % <span class="number">4u</span> / <span class="number">2</span></span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">6</span> + col2] % <span class="number">8u</span> / <span class="number">4</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">6</span> + col2] % <span class="number">2u</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">6</span> + col2] % <span class="number">8u</span> / <span class="number">4</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">6</span> + col2] % <span class="number">2u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( table[<span class="number">6</span> * row2 + col2] % <span class="number">8u</span> / <span class="number">4</span>        <span class="comment">// 14组合</span></span><br><span class="line">                                                <span class="comment">// 上一格 =2 =8或者</span></span><br><span class="line">                                                <span class="comment">// 下一格 =2 =8</span></span><br><span class="line">      &amp;&amp; table[<span class="number">6</span> * row2 + col2] % <span class="number">2u</span></span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">1</span> + col2] % <span class="number">0x10</span>u / <span class="number">8</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 + <span class="number">1</span> + col2] % <span class="number">4u</span> / <span class="number">2</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">1</span> + col2] % <span class="number">0x10</span>u / <span class="number">8</span>)</span><br><span class="line">      &amp;&amp; !(table[<span class="number">6</span> * row2 - <span class="number">1</span> + col2] % <span class="number">4u</span> / <span class="number">2</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//校验,使用数组的值移动点，最后能回到(0,0)点就是flag了</span></span><br><span class="line">    oldrow = <span class="number">0</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  row3 = <span class="number">0</span>;</span><br><span class="line">  col3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *table % <span class="number">0x10</span>u / <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    row3 = <span class="number">-1</span>;                                  <span class="comment">// 前一行</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">LABEL_79:</span><br><span class="line">      <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">0x10</span>u / <span class="number">8</span>) || row3 - <span class="number">1</span> == oldrow &amp;&amp; col3 == v11 )<span class="comment">// 8则转到上一行</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">4u</span> / <span class="number">2</span>) || row3 + <span class="number">1</span> == oldrow &amp;&amp; col3 == v11 )<span class="comment">// 2</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">8u</span> / <span class="number">4</span>) || row3 == oldrow &amp;&amp; col3 - <span class="number">1</span> == v11 )<span class="comment">// 4</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !(table[<span class="number">6</span> * row3 + col3] % <span class="number">2u</span>) || row3 == oldrow &amp;&amp; col3 + <span class="number">1</span> == v11 )<span class="comment">// 1</span></span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>i64;</span><br><span class="line">            oldrow = row3;</span><br><span class="line">            v11 = col3++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            oldrow = row3;</span><br><span class="line">            v11 = col3--;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          oldrow = row3;</span><br><span class="line">          v11 = col3;</span><br><span class="line">          ++row3;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        oldrow = row3;</span><br><span class="line">        v11 = col3;</span><br><span class="line">        --row3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( row3 || col3 );</span><br><span class="line">    result = <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *table % <span class="number">4u</span> / <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      row3 = <span class="number">1</span>;                                 <span class="comment">// 后一行</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_79;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *table % <span class="number">8u</span> / <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      col3 = <span class="number">-1</span>;                                <span class="comment">// 前一格</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_79;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *table % <span class="number">2u</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      col3 = <span class="number">1</span>;                                 <span class="comment">// 后一格</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_79;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">1</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h4 id="总结第二个函数中对迷宫的限制"><a href="#总结第二个函数中对迷宫的限制" class="headerlink" title="总结第二个函数中对迷宫的限制"></a>总结第二个函数中对迷宫的限制</h4><ol>
<li><p>通过<strong>第一个函数</strong>我们可以知道每当一个格子被设置值（方向）的时候，它所到达的下一个格子也会被设置一个值（方向），下一个格子的值（方向）是和当前格子相反的方向，也就是下一个格子含有指向当前格子的方向，所以迷宫走的路径是<strong>双向设置的</strong>（每一步都是双向的），既能够正着走，也能够反着走，在特殊点的性质设置的时候也会利用到这个迷宫设置的这个特点。</p>
</li>
<li><p>这个迷宫中的数据都要被设置两次</p>
</li>
<li><p>迷宫的第一列不能是4</p>
</li>
</ol>
<p>​       迷宫的第六列不能是1</p>
<p>​       迷宫的第一排不能是8</p>
<p>​       迷宫的第六排不能是2</p>
<ol start="4">
<li>对坐标为（0,0）（1,4）（2,0）的限制（坐标的第一个是行第二个是列）</li>
</ol>
<ul>
<li>这个单元格中不能同时含有 8 和 2 并且也不能同时含有4和1</li>
<li>需要被赋值两次（采用和开头相同的检验是否被赋值了两次以上的检验方法）</li>
<li>如果当前的格子之中是8 则它的上一行的对应的格子就不能是8</li>
<li>如果当前的格子之中是2 则它的下一行的对应的格子就不能是2</li>
<li>如果当前的格子之中是4 则它的上一格的对应的格子就不能是4</li>
<li>如果当前的格子之中是1 则它的上一行的对应的格子就不能是1</li>
<li>这种特殊点周围不能连着出现两种操作，<strong>碰到必须拐弯</strong>。<ul>
<li>它自身就必须含有<strong>水平和竖直</strong>方向的移动<strong>各一种</strong></li>
<li>这种特殊节点需要<strong>连接两个格子</strong>（通过自己有的两个方向能够到达这两个格子），所以这两个格子需要分别存在于它的<strong>水平和竖直方向</strong>上，那么在这个节点必定要<strong>转弯</strong></li>
</ul>
</li>
</ul>
<ol start="5">
<li>对坐标(0,4) (1,3) (1,5) (2,1) (2,4) (3,1) (3,2) (4,1) (4,5) (5,3)的限制</li>
</ol>
<ul>
<li>这十个坐标含有2和8的组合 或者 含有1和4的组合（因为在程序的最开始就标注了每个格子被设置的次数不能超过2次，所以这10个坐标的设置只能是这两种组合种的一种，也就是这10个格子的数值只能是10或者5）</li>
<li>当<strong>本格是10</strong>时，上下两行之中一定要含有1或4（在本格之中即能向上走也能向下走）</li>
<li>当<strong>本格是5</strong>时，左右两格之中一定要含有8或2（在本格之中既能向左走也能向右走）</li>
<li>第二种特殊点限制条件，必须直线进入，<strong>连续3格可连成直线</strong>，并且是<strong>拐弯进入前一格</strong>，或者进入<strong>后一格后拐弯</strong>。<ul>
<li>这种特殊点需要能够到达它的<strong>前后两个节点</strong>（连接两个格子），但是它自己本身这个格子之中方向的定义只有<strong>一种类型</strong>（竖直方向的 或者 水平方向的）。所以它的前后两个格子和它自身必须在<strong>同一条直线</strong>上，那么这样就使得进入这个格子的方向，就是这个格子所具有的方向（水平还是竖直）。</li>
<li>因为第二三个条件的限制使得，它连接的两个格子之中会有转弯的方向，如果是它的前一个格子含有转弯的方向，说明是<strong>拐弯进入前一格</strong>的。如果它的后一个格子含有转弯的方向，说明<strong>进入后一格后拐弯</strong>。</li>
</ul>
</li>
</ul>
<ol start="6">
<li>走迷宫的规则和操作：</li>
</ol>
<ul>
<li>8是向上走 2是向下走 4是向左走 1是向右走（判断的顺序是8 2 4 1）</li>
<li>不能再回到上一格的位置</li>
<li>走到终点的位置是 （0，0）</li>
</ul>
<h3 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h3><p>使用#标注第一种类型的特殊点 使用$来标注第二种特殊类型的点 从上一个函数我们可以知道第一个位置固定是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0  1  2  3  4  5 </span><br><span class="line">0 #3 05 05 05 $5 06  </span><br><span class="line">1 0A 0  03 $5 #4 $A</span><br><span class="line">2 #9 $5 0C 0  $A 0A</span><br><span class="line">3 03 $5 $5 06 0A 0A</span><br><span class="line">4 09 $5 06 09 0C $A</span><br><span class="line">5 0  0  09 $5 05 0C</span><br><span class="line"></span><br><span class="line">[3, 5, 5, 5, 5, 6] </span><br><span class="line">[A, 0, 3, 5, 6, A] </span><br><span class="line">[9, 5, C, 0, A, A] </span><br><span class="line">[3, 5, 5, 6, A, A] </span><br><span class="line">[9, 5, 6, 9, C, A] </span><br><span class="line">[0, 0, 9, 5, 5, C]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">idx</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">#↓</td>
<td align="left">←</td>
<td align="left">←</td>
<td align="left">←</td>
<td align="left">*←</td>
<td align="left">←</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">↓</td>
<td align="left">0</td>
<td align="left">→</td>
<td align="left">*→</td>
<td align="left">#↓</td>
<td align="left">*↑</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">#→</td>
<td align="left">*→</td>
<td align="left">↑</td>
<td align="left">0</td>
<td align="left">*↓</td>
<td align="left">↑</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">↓</td>
<td align="left">*←</td>
<td align="left">*←</td>
<td align="left">←</td>
<td align="left">↓</td>
<td align="left">↑</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">→</td>
<td align="left">*→</td>
<td align="left">↓</td>
<td align="left">↑</td>
<td align="left">←</td>
<td align="left">*↑</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">→</td>
<td align="left">*→</td>
<td align="left">→</td>
<td align="left">↑</td>
</tr>
</tbody></table>
<p>上面这个是走迷宫的过程，得到的按着这个方向正着走到最后之后再按着同样的路线反着走一次就能够得到这个目标的6*6的map了</p>
<p>按照第一个函数的赋值的方式就能够得到这个过程是 d3ctf{22441442223133324424441111133333}</p>
<p>所以最后得到的flag是 d3ctf{22441442223133324424441111133333}</p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>迷宫</tag>
        <tag>binToHex</tag>
      </tags>
  </entry>
  <entry>
    <title>SUSCTF_tttree（使用idapython去混淆的学习）</title>
    <url>/2022/03/06/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="SUSCTF-tttree（使用idapython去混淆的学习）"><a href="#SUSCTF-tttree（使用idapython去混淆的学习）" class="headerlink" title="SUSCTF_tttree（使用idapython去混淆的学习）"></a>SUSCTF_tttree（使用idapython去混淆的学习）</h1><p>这道题里面有大量的相同结构的混淆，所以采用了idapython的方式解混淆，这道题需要就是学习用idapython解混淆的过程。后面的平衡树的算法太难了，就没有继续往下解了。</p>
<h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><p>这里面有两个混淆，出题人声称采用了 这里参考了古月浪子大佬的一个混淆思路。</p>
<h3 id="混淆一"><a href="#混淆一" class="headerlink" title="混淆一"></a>混淆一</h3><p>重构序列</p>
<p><strong>花指令形式特征</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push rax </span><br><span class="line">push rax </span><br><span class="line">pushfq </span><br><span class="line">call $+5 </span><br><span class="line">pop rax </span><br><span class="line">add rax,xxxx </span><br><span class="line">push rax </span><br><span class="line">mov [rsp+10h], rax </span><br><span class="line">popfq </span><br><span class="line">pop rax</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：</p>
<p>当该花指令的后面接着的是retn这个指令的时候，就是跳转到这个计算得到的地址</p>
<p>当该花指令的后面接着的是jmp addr2这个指令时，相当于call addr2（addr1就是这个指令之后的返回地址）</p>
<p><strong>解混淆的方法</strong>：</p>
<p>如果是retn指令时:通过“pop rax”和”add rax,xxxx”这两个指令计算得到需要jmp的偏移地址，将jmp+偏移地址的指令写入花指令这个地方的地址，其余空间地址“nop”</p>
<p>如果时jmp addr2指令时，先将这个“pop rax”和”add rax,xxxx”这两个指令计算得到的目标地址（注意这个地方不是相对地址）push，将push+目标地址的指令写入花指令的地址，其余空间地址“nop”。然后先jmp “jmp addr2”的地址，再jmp “push”指令里面的地址</p>
<p>该程序之中的<strong>示例</strong>：</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306092253733.png" alt="image-20220306092253733"></p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306092311317.png" alt="image-20220306092311317"></p>
<h3 id="混淆二"><a href="#混淆二" class="headerlink" title="混淆二"></a>混淆二</h3><p><strong>无效push 和 pop</strong></p>
<p>花指令形式特征</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push [rax|...] </span><br><span class="line">pop [rax|...]</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：push之后马上pop出来，显然这个指令时无效的</p>
<p><strong>解混淆的方法</strong>：直接pop掉这两句就可以了</p>
<p>该程序之中的示例:</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306093739567.png" alt="image-20220306093739567"></p>
<h3 id="idapython脚本"><a href="#idapython脚本" class="headerlink" title="idapython脚本"></a>idapython脚本</h3><p><a href="https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/">idapython的教程</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct</span><br><span class="line">start = 0x140001000  #起始位置</span><br><span class="line">end = 0x14001C694    #结束位置</span><br><span class="line">address_m = [0 for x in range(11)]</span><br><span class="line">address_target = [&#x27;push    rax&#x27;,&#x27;push    rax&#x27;,&#x27;pushfq&#x27;,&#x27;call    $+5&#x27;,&#x27;pop     rax&#x27;,&#x27;add     rax,&#x27;,&#x27;mov &#x27;,&#x27;popfq&#x27;,&#x27;pop     rax&#x27;,&#x27;retn&#x27;]</span><br><span class="line">  # 第一种花指令的特征 注意这个里面的每一条指令中间的空格数都要和ida之中展示的汇编代码相同，所以最好是进行复制粘贴</span><br><span class="line"></span><br><span class="line">def check1():</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i in range(9):</span><br><span class="line">        if i == 5 or i == 6:</span><br><span class="line">            cnt += GetDisasm(address_m[i]).find(address_target[i]) != -1 # GetDisasm：获得对应位置的汇编地址 因为&#x27;add rax,&#x27;,&#x27;mov &#x27;这两个指令中有数据，每个部分的代码就会不一样，所以使用find函数来判断是否存在</span><br><span class="line">        else:</span><br><span class="line">            cnt += GetDisasm(address_m[i]) == address_target[i] # 除了那两个语句以外就需要判断剩下的这些语句是否相等就可以了</span><br><span class="line">    return cnt == 9  # 如果9条语句都和目标类型已知 就认为是第一种花指令</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def check2(x,y):</span><br><span class="line">    cnt = 0</span><br><span class="line">    cnt += print_insn_mnem(x) == &quot;push&quot; # idc.print_insn_mnem()获取操作符 判断操作符是否是push指令</span><br><span class="line">    cnt += print_insn_mnem(y) == &quot;pop&quot;  # idc.print_insn_mnem(y)获取操作符 判断操作符是否是 pop 指令</span><br><span class="line">    cnt += print_operand(x,0) == print_operand(y,0) # idc.print_operand(x, 0) 获取第一个操作数 判断这两个指令的操作数是否相等</span><br><span class="line">    return cnt == 3  # 当以上的三个条件都满足的时候就是第二种花指令</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def check3():</span><br><span class="line">    cnt = 0</span><br><span class="line">    cnt += print_insn_mnem(address_m[0]) == &quot;push&quot; # print_insn_mnem获取操作符 判断操作符是否是push</span><br><span class="line">    cnt += get_operand_type(address_m[0], 0) == o_imm # 如果操作数是一个确定的数值的话，那么返回类型，值为 5</span><br><span class="line">    return cnt == 2</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def nop(u,v): # u是指令的起始地址 v是结束的地址，但是v地址的指令不会被nop</span><br><span class="line">    patch_add = u</span><br><span class="line">    while(patch_add &lt; v):</span><br><span class="line">        patch_byte(patch_add,0x90)</span><br><span class="line">        patch_add += 1</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">p = start</span><br><span class="line">while p &lt;= end:</span><br><span class="line">    address_m[0] = p</span><br><span class="line">    p = next_head(p)   # 利用了 idc.next_head()使当前地址不断增长</span><br><span class="line"></span><br><span class="line">    # 将第二种花指令进行nop</span><br><span class="line">    while print_insn_mnem(p) == &quot;nop&quot;: # 如果是nop语句就跳过</span><br><span class="line">        p = next_head(p)</span><br><span class="line">    if check2(address_m[0], p) == 1: # 判断这两个连续的语句是否是满足第二种花指令的要求</span><br><span class="line">        p = next_head(p) # p定位到第二种花指令结束之后那个地址</span><br><span class="line">        nop(address_m[0], p) # address_m[0]是nop的起始位置  p是nop的结束位置</span><br><span class="line">    else:</span><br><span class="line">        p = address_m[0] # 如果不是花指令起点又回到最初的那个地方</span><br><span class="line"></span><br><span class="line">    # 将第一种花指令nop</span><br><span class="line">    address_m[0] = p # 将起始的地址放入到数组的第一项之中</span><br><span class="line">    for i in range(1, 11): # 判断这个地方连续的10条指令是否满足第一种花指令的要求，取出这10条指令的地址放入到数组之中</span><br><span class="line">        address_m[i] = next_head(address_m[i - 1])</span><br><span class="line"></span><br><span class="line">    if check1() == 1: # 判断是否是第一种花指令</span><br><span class="line">        addri = get_operand_value(address_m[5], 1) # get_operand_value(address_m[5], 1)  获取操作数的数值 即该条 &#x27;add rax,&#x27; 命令的第二个操作数的数值</span><br><span class="line">        addri += address_m[4]  # rax加上操作数，得到目标地址 x+a4-a0-5</span><br><span class="line">        if address_target[9] == GetDisasm(address_m[9]):  # 当最后一条指令是ret时</span><br><span class="line">            addri -= (address_m[0] + 5)</span><br><span class="line">            patch_byte(address_m[0], 0xE9) # 将这个地方的值修改为 0xE9 就是jmp指令 因为 0xE9 JMP 后面的四个字节是偏移 所以这里addri需要计算成偏移地址</span><br><span class="line">            patch_dword(address_m[0] + 1, addri &amp; 0xffffffff) # dw的数值来存放目标的地址</span><br><span class="line">            nop(address_m[0] + 5, address_m[10]) # 将剩下的nop掉</span><br><span class="line">            p = address_m[10]</span><br><span class="line">        else:</span><br><span class="line">            patch_byte(address_m[0], 0x68) # 0x68是push 入栈的操作</span><br><span class="line">            patch_dword(address_m[0] + 1, addri &amp; 0xffffffff) # 将对应的地址push</span><br><span class="line">            nop(address_m[0] + 5, address_m[9])</span><br><span class="line">            p = address_m[9]</span><br><span class="line">    else:</span><br><span class="line">        p = address_m[1] # 指向下一个指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对第一种花指令中结尾是push的操作</span><br><span class="line">p = start # 从程序的开始进行遍历</span><br><span class="line">while p &lt;= end:</span><br><span class="line">    address_m[0] = p</span><br><span class="line">    address_m[1] = next_head(p)</span><br><span class="line">    if check3() == 1: # 当指令满足check3()中指令的要求时进行的操作</span><br><span class="line">        addri = get_operand_value(address_m[0], 0) + 2 ** 32 # get_operand_value 获取push的地址的值   2 ** 32代表2的32次方</span><br><span class="line">        p = address_m[1]   # push指令后的下一条指令</span><br><span class="line">        while print_insn_mnem(p) == &quot;nop&quot;: # 如果遇到nop指令就跳过</span><br><span class="line">            p += 1</span><br><span class="line">        if print_insn_mnem(p) == &quot;jmp&quot;: # 如果是jmp指令</span><br><span class="line">            addrj = struct.unpack(&#x27;&lt;I&#x27;, get_bytes(p + 1, 4))[0] + p - address_m[0] # struct.unpack(&#x27;&lt;I&#x27;, get_bytes(p + 1, 4)) 利用小序端取得地址 这个得到的是一个元组 这条jmp指令的起始位置 减去上一条指令的位置</span><br><span class="line">            addri -= p + 5 # push的地址 减去jmp地址结束的那个地址</span><br><span class="line">            if addri &lt; 0:</span><br><span class="line">                addri += 2 ** 32 # 保持addri这个地址始终大于0</span><br><span class="line">            patch_byte(address_m[0], 0xe8) # 0xE8 CALL 后面的四个字节是地址</span><br><span class="line">            patch_dword(address_m[0] + 1, addrj &amp; 0xffffffff)</span><br><span class="line">            patch_byte(p, 0xe9) # 0xE9 JMP 后面的四个字节是偏移</span><br><span class="line">            p += 1</span><br><span class="line">            patch_dword(p, addri)# 需要跳转到的偏移地址</span><br><span class="line">            p += 4</span><br><span class="line">    else:</span><br><span class="line">        p = address_m[1] # 下一个指令</span><br><span class="line">print(&quot;Finish&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="idapython脚本学习"><a href="#idapython脚本学习" class="headerlink" title="idapython脚本学习"></a>idapython脚本学习</h2><p>idapython的指令<a href="https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/">查询</a></p>
<h3 id="跳转指令和机器码"><a href="#跳转指令和机器码" class="headerlink" title="跳转指令和机器码"></a>跳转指令和机器码</h3><p>注意相同的指令，但是不同的机器码后面所跟着的地址的要求是不一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xE8 CALL 后面的四个字节是地址</span><br><span class="line">0xE9 JMP 后面的四个字节是偏移</span><br><span class="line">0xEB JMP 后面的二个字节是偏移</span><br><span class="line">0xFF15 CALL 后面的四个字节是存放地址的地址</span><br><span class="line">0xFF25 JMP 后面的四个字节是存放地址的地址</span><br><span class="line"></span><br><span class="line">0x68 PUSH 后面的四个字节入栈</span><br><span class="line">0x6A PUSH 后面的一个字节入栈</span><br><span class="line">对于每条指令我们检查他的操作数类型是否为 o_imm(值为 5)，o_imm 类型的操作数就是一个确定的数值或者偏移，一旦这个发现这种类型的操作数</span><br></pre></td></tr></table></figure>

<h3 id="常用到的idapython的函数"><a href="#常用到的idapython的函数" class="headerlink" title="常用到的idapython的函数"></a>常用到的idapython的函数</h3><p>对指令（操作符 操作数等）进行操作的函数：</p>
<ul>
<li>**GetDisasm(ea)**：获得ea这个地址的汇编代码</li>
<li><strong>print_insn_mnem(ea)<strong>：获取ea这个地址的</strong>操作符</strong></li>
<li><strong>print_operand(ea, 0)</strong>:获取当前地址<strong>操作数</strong>。例如获取“MOV AH，06H“指令的AH这个操作数</li>
<li><strong>get_operand_value(ea, n)<strong>：获取</strong>操作数的数值</strong></li>
<li><strong>next_head(ea)<strong>：获取</strong>下一个</strong>指令地址 </li>
<li><strong>prev_head(ea)<strong>：获取</strong>上一个</strong>指令地址</li>
<li><strong>next_addr(ea)<strong>：获取</strong>下一个</strong>地址</li>
<li><strong>prev_addr(ea)<strong>：获取</strong>上一个</strong>地址</li>
<li>**get_operand_type(ea,n)**：获取操作数类型。其返回类型有八种 + 不同的处理器 6 种，这道题之中的o_imm代表是一个确定的数值。还有其它的类型，可以查看上面的那个网址</li>
</ul>
<p>补丁：</p>
<ul>
<li><strong>patch_byte/patch_word/patch_dword/patch_qword(ea, value)</strong>:打补丁，反调试  混淆等等都用得到，修改相应的机器码等，比如这道题之中的指令 patch_byte(address_m[0], 0xe8) 就是修改这个地址的机器码为0xe8 这个jmp指令</li>
</ul>
<p>机器码式搜索：</p>
<ul>
<li>**FindBinary(ea,flag, searchstr, radix=16)**：实行字节或者二进制的搜索。ea代表地址，flag 代表搜索方向或者条件（有具体的参数可以选择，根据需要查表填入）比如说SEARCH_UP和SEARCH_DOWN 用来指明搜索的方向。searchstr代表的是字节字符串，形如’55 48 89 E5’这个样子的</li>
</ul>
<p>对汇编之中函数操作的函数：</p>
<ul>
<li>**idautils.Functions()**：获取函数列表，使用for循环的方式遍历所有的这些地址，然后对每个函数对象进行相应的操作。例如 get_func_name(func) func就是这个函数列表之中的一个对象，这个函数获取这个函数对象的名称。</li>
<li>**get_func_attr(func, FUNCATTR_FLAGS)**：信息收集函数，可以用来检索关于函数的信息，例如它是否是库中代码，或者函数是否有返回值等。对于一个函数来说有九个可能的标志。</li>
</ul>
<h2 id="python函数说明"><a href="#python函数说明" class="headerlink" title="python函数说明"></a>python函数说明</h2><h3 id="struct-pack-和struct-unpack"><a href="#struct-pack-和struct-unpack" class="headerlink" title="struct.pack()和struct.unpack()"></a>struct.pack()和struct.unpack()</h3><p>使用这两个函数需要使用struct包</p>
<p>**struct.pack(fmt,v1,v2,…..)**：将v1,v2等参数的值进行一层包装，包装的方法由fmt指定。被包装的参数必须严格符合fmt。最后返回一个包装后的字符串。 将数据转换成c语言之中相应的存储的形式。</p>
<p><strong>struct.unpack(fmt,string)<strong>：顾名思义，解包。返回一个由解包数据(string)得到的一个</strong>元组(tuple)</strong>, 即使仅有一个数据也会被解包成元组。其中len(string) 必须等于 calcsize(fmt)，这里面涉及到了一个calcsize函数。struct.calcsize(fmt)：这个就是用来计算fmt格式所描述的结构的大小。</p>
<p><strong>fmt的构造</strong>：</p>
<p>格式字符串(format string)由一个或多个格式字符(format characters)组成</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306114015713.png" alt="image-20220306114015713"></p>
<p>在Format string 的首位，有一个可选字符来决定大端和小端：</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306114148873.png" alt="image-20220306114148873"></p>
<p>例子：</p>
<p><img src="/images/SUSCTF-tttree%EF%BC%88%E4%BD%BF%E7%94%A8idapython%E5%8E%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/image-20220306152233838.png" alt="image-20220306152233838"></p>
<h3 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a>find()函数</h3><p><strong>描述</strong>：Python find() 方法检测字符串中<strong>是否包含子字符串 str</strong> 。如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在<strong>指定范围</strong>内，如果包含子字符串返回开始的索引值，否则返回-1</p>
<p><strong>语法</strong>：str.find(str, beg=0, end=len(string))  </p>
<ul>
<li>str – 指定检索的字符串</li>
<li>beg – 开始索引，默认为0。</li>
<li>end – 结束索引，默认为字符串的长度。</li>
</ul>
<p><strong>返回值</strong>：如果包含子字符串返回开始的索引值，否则返回-1。</p>
<p><strong>注意</strong>：寻找目的是搜索的对象（子字符串）是不是在这串字符串里面，不在于它（子字符串）的位置在哪里。子字符串之中的空格是不能忽视的，并且搜索对象（子字符串）在字符串之中必须是连续完整存在的，这样才能说明字符串中包含了子字符串 str。</p>
<p>参考文章：<a href="https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/">https://psyduck0409.github.io/2021/03/01/2021/idapython%E7%AC%94%E8%AE%B0/</a></p>
]]></content>
      <categories>
        <category>混淆</category>
      </categories>
      <tags>
        <tag>idapython</tag>
      </tags>
  </entry>
  <entry>
    <title>TEA系列加密解密</title>
    <url>/2022/02/28/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h1 id="TEA系列加密解密"><a href="#TEA系列加密解密" class="headerlink" title="TEA系列加密解密"></a>TEA系列加密解密</h1><h2 id="TEA加密解密"><a href="#TEA加密解密" class="headerlink" title="TEA加密解密"></a>TEA加密解密</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>在密码学中，微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。</p>
<p>代码的特点： </p>
<ul>
<li>加密使用的数据为2个32位无符号整数，密钥为4个32位无符号整数即密钥长度为128位（当加密解密的对象是一串数组的时候，需要将这个32位无符号整数的数组<strong>每两个32位无符号整数划分为一组</strong>，对每一组数据单独加密解密得到结果）</li>
<li>该算法使用了一个常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 <strong>0×9E3779B9</strong>）作为魔数</li>
</ul>
</blockquote>
<h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>拥有一个叫做<a href="https://en.wikipedia.org/wiki/Feistel_cipher">Feistel 结构</a>的密码学结构。这种密码学结构通俗的来讲就是会将加密的plaintext分成L、R两部分，并且满足 <code>L_&#123;i+1&#125; = R_i, R_&#123;i+1&#125; = F(K_i,R_i) \oplus L_i</code> 这种交换式的加密方式的一种结构。</p>
<p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228191440573.png" alt="image-20220228191440573"></p>
<h3 id="TEA加密算法的实现"><a href="#TEA加密算法的实现" class="headerlink" title="TEA加密算法的实现"></a>TEA加密算法的实现</h3><p>参数要求：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组）</p>
<p>加密特征：存在一个<strong>delta值</strong>，这个值会不停的增加到<strong>sum</strong>之中，形成一种循环的效果；会有一个<strong>位移-&gt;与密钥相加-&gt;异或</strong>的过程；计算delta的sum状态值也会参与</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TEA解密算法的实现"><a href="#TEA解密算法的实现" class="headerlink" title="TEA解密算法的实现"></a>TEA解密算法的实现</h3><p>参数要求：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//解密函数  </span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */  </span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */  </span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */  </span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */  </span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);  </span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">    &#125;                                              /* end cycle */  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>解密数组：{0x3e8947cb,0xcc944639,0x31358388,0x3b0b6893,0xda627361,0x3b2e6427}</p>
<p>key数组：{0x4445,0x4144,0x4245,0x4546}</p>
<p>因为在解密的过程之中会产生移位的运算，这个过程会产生溢出，所以每组解密的对象声明成 <strong>v1[3]={0x3e8947cb,0xcc944639,0x0}</strong> 这样的形式</p>
<p>解密的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */</span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v1[3]=&#123;0x3e8947cb,0xcc944639,0x0&#125;,k[4]=&#123;0x4445,0x4144,0x4245,0x4546&#125;;</span><br><span class="line">    uint32_t v2[3]=&#123;0x31358388,0x3b0b6893,0x0&#125;;</span><br><span class="line">    uint32_t v3[3]=&#123;0xda627361,0x3b2e6427&#125;;</span><br><span class="line">    decrypt(v1, k);</span><br><span class="line">    decrypt(v2, k);</span><br><span class="line">    decrypt(v3, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s %s %s\n&quot;,(char*)v1,(char*)v2,(char*)v3);   // 注意如何将一串数组以字符串的形式输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出的结果：fvBXQdEa rcbvhBPx cOA8Ag6J</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p>printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p>
<p>参数的格式</p>
<p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228193403698.png" alt="image-20220228193403698"></p>
<h2 id="XTEA加密解密"><a href="#XTEA加密解密" class="headerlink" title="XTEA加密解密"></a>XTEA加密解密</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作</p>
</blockquote>
<h3 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228193746682.png" alt="image-20220228193746682"></p>
<h3 id="XTEA加密算法的实现"><a href="#XTEA加密算法的实现" class="headerlink" title="XTEA加密算法的实现"></a>XTEA加密算法的实现</h3><p>相较于TEA的变化：</p>
<ul>
<li>由之前的**<code>((v1&lt;&lt;4) + k0) ^ ((v1&gt;&gt;5) + k1)</code>** 变化成了 **<code>((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1)</code>**，此时v1内部数据的加密变化不再受到密钥的影响。</li>
<li>原先的<code>v1 + sum</code>变成了<code>(sum + key[sum &amp; 3])</code>以及<code>sum + key[(sum&gt;&gt;11) &amp; 3]</code>，密钥变成了<strong>轮转</strong>使用，而不是固定只针对某种数据进行加密（解密）。并且此时密钥的选取<strong>受到sum的影响</strong></li>
<li><code>sum += delta</code>的时机由每次加密开头就发生变化到v0，v1<strong>两个block加密的中间</strong>。</li>
</ul>
<p>输入的参数：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组），注意这里循环的次数不是固定的了，是需要传入的参数<strong>num_rounds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  </span><br><span class="line">    unsigned int i;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;  </span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  </span><br><span class="line">        sum += delta;  </span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="XTEA解密算法的实现"><a href="#XTEA解密算法的实现" class="headerlink" title="XTEA解密算法的实现"></a>XTEA解密算法的实现</h3><p>输入的参数：输入一定要是<strong>一个64bit的数字</strong>，或者可以写作一个拥有<strong>两个元素的32bit的数组</strong>。并且需要一个两倍长度的key（int[4]),即<strong>一个128位</strong>的数字（拥有<strong>四个元素的32bit</strong>的数组），注意这里循环的次数不是固定的了，是需要传入的参数<strong>num_rounds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  </span><br><span class="line">    unsigned int i;  </span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;  </span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[0]=v0; v[1]=v1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */</span><br><span class="line"></span><br><span class="line">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;</span><br><span class="line">    for (i=0; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[3]=&#123;0x73647979,0x726b6f5f,0x0&#125;;</span><br><span class="line">    uint32_t v1[2]=&#123;0x646f675f,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]=&#123;0X95C4C,0X871D,0X1A7B7,0X12C7C7&#125;;</span><br><span class="line">    unsigned int r=32;//num_rounds建议取值为32</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line">    printf(&quot;加密前原始数据：%s%s\n&quot;,(char*)v,(char*)v1);</span><br><span class="line">    encipher(r, v, k);</span><br><span class="line">    encipher(r, v1, k);</span><br><span class="line">    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v1[0]);</span><br><span class="line">    decipher(r, v, k);</span><br><span class="line">    decipher(r, v1, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s%s\n&quot;,(char*)v,(char*)v1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">加密前原始数据：yyds_okr_god</span><br><span class="line">加密后的数据：3461349474 1314311102 3609197830</span><br><span class="line">解密后的数据：yyds_okr_god</span><br></pre></td></tr></table></figure>

<h2 id="XXTEA加密解密"><a href="#XXTEA加密解密" class="headerlink" title="XXTEA加密解密"></a>XXTEA加密解密</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>XTEA再度进化， 变成了支持块加密<code>XXTEA</code></p>
</blockquote>
<h3 id="加密过程-2"><a href="#加密过程-2" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/TEA%E7%B3%BB%E5%88%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/image-20220228200301853.png" alt="image-20220228200301853"></p>
<h3 id="XXTEA加密解密算法的实现"><a href="#XXTEA加密解密算法的实现" class="headerlink" title="XXTEA加密解密算法的实现"></a>XXTEA加密解密算法的实现</h3><p>特点：在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥, 是目前TEA系列中最安全的算法，但性能较上两种有所降低。</p>
<p>参数：输入的是<strong>至少拥有两个元素的32bit的数组</strong>，密钥的长度仍然是<strong>128位</strong>，即拥有<strong>4个元素32位</strong>长度的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdint.h&gt;  </span><br><span class="line">#define DELTA 0x9e3779b9  </span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))  </span><br><span class="line">  </span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])  </span><br><span class="line">&#123;  </span><br><span class="line">    uint32_t y, z, sum;  </span><br><span class="line">    unsigned p, rounds, e;  </span><br><span class="line">    if (n &gt; 1)            /* Coding Part */  </span><br><span class="line">    &#123;  </span><br><span class="line">        rounds = 6 + 52/n;  </span><br><span class="line">        sum = 0;  </span><br><span class="line">        z = v[n-1];  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            sum += DELTA;  </span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;  </span><br><span class="line">            for (p=0; p&lt;n-1; p++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                y = v[p+1];  </span><br><span class="line">                z = v[p] += MX;  </span><br><span class="line">            &#125;  </span><br><span class="line">            y = v[0];  </span><br><span class="line">            z = v[n-1] += MX;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (--rounds);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */  </span><br><span class="line">    &#123;  </span><br><span class="line">        n = -n;  </span><br><span class="line">        rounds = 6 + 52/n;  </span><br><span class="line">        sum = rounds*DELTA;  </span><br><span class="line">        y = v[0];  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;  </span><br><span class="line">            for (p=n-1; p&gt;0; p--)  </span><br><span class="line">            &#123;  </span><br><span class="line">                z = v[p-1];  </span><br><span class="line">                y = v[p] -= MX;  </span><br><span class="line">            &#125;  </span><br><span class="line">            z = v[n-1];  </span><br><span class="line">            y = v[0] -= MX;  </span><br><span class="line">            sum -= DELTA;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (--rounds);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span><br><span class="line"></span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t y, z, sum;</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n-1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=0; p&lt;n-1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+1];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n-1] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=n-1; p&gt;0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p-1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n-1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v[4]= &#123;0x73647979,0x726b6f5f,0x646f675f,0x0&#125;;</span><br><span class="line">    uint32_t const k[4]= &#123;0X95C4C,0X871D,0X1A7B7,0X12C7C7&#125;;</span><br><span class="line">    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line">    printf(&quot;加密前原始数据：%s\n&quot;,(char*)v);</span><br><span class="line">    btea(v, n, k);</span><br><span class="line">    printf(&quot;加密后的数据：%u %u %u\n&quot;,v[0],v[1],v[3]);</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s\n&quot;,(char*)v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">加密前原始数据：yyds_okr_god</span><br><span class="line">加密后的数据：609835868 2980644312 0</span><br><span class="line">解密后的数据：yyds_okr_god</span><br></pre></td></tr></table></figure>

<h2 id="逆向中TEA系列加密的识别"><a href="#逆向中TEA系列加密的识别" class="headerlink" title="逆向中TEA系列加密的识别"></a>逆向中TEA系列加密的识别</h2><p>解决逆向题大部分出现TEA的场合都是【识别算法-&gt;编写对应解密程序】</p>
<p>分析二进制文件中的算法的时候有几个识别的特征</p>
<ul>
<li>可能存在针对<strong>64bit</strong>以及<strong>128bit</strong>数字的操作（输入的<strong>msg和key</strong>） ，一般会用<strong>无符号的32位的数组</strong>表示</li>
<li>存在<strong>先进行位移，然后异或</strong>的类似操作（<code>(z&gt;&gt;5^y&lt;&lt;2) </code>这类混合变换）**<code>(z&gt;&gt;5^y&lt;&lt;2)</code><strong>就是xxtea加密了，存在</strong>(v0 &lt;&lt; 4)** 和 **(v0 &gt;&gt; 5)**移位就是tea和xtea加密了</li>
<li>前面一个复杂的混合变换的结果可能会<strong>叠加</strong>到另一个值上，两者相互叠加（Feistel 结构）</li>
<li><strong>获取密钥</strong>的时候，会使用某一个常量值作为下标（<code>key[(sum&gt;&gt;11) &amp; 3]</code>）存在轮换的方式获得密钥 就是xtea或者xxtea了</li>
<li>会在算法开始定义一个<strong>delta</strong>，并且这个值不断的参与算法，但是<strong>从来不会受到输入的影响</strong>（delta数值如果没有魔改就是0x9e3779b9）如果出现了<strong>0x9e3779b9</strong>这个数字一般就能确定是TEA加密系列</li>
</ul>
<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/4272e0805da3">https://www.jianshu.com/p/4272e0805da3</a></p>
<p><a href="https://www.anquanke.com/post/id/224198#h3-2">https://www.anquanke.com/post/id/224198#h3-2</a></p>
]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>TEA</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF的Dig the way - 栈溢出</title>
    <url>/2022/02/27/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h2 id="BUUCTF的Dig-the-way-栈溢出"><a href="#BUUCTF的Dig-the-way-栈溢出" class="headerlink" title="BUUCTF的Dig the way - 栈溢出"></a>BUUCTF的Dig the way - 栈溢出</h2><p>这是一道栈溢出的题目</p>
<p>进入到主函数里面</p>
<p>首先就是读取data之中数据的代码</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227123156345.png" alt="image-20220227123156345"></p>
<p>通过代码我们可以知道这个地方并没有对数据的写入长度进行限制</p>
<h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><p>fseek()函数可以移动文件的读写指针到指定的位置，即移动当前文件的位置指针，其原型为：<br>  int fseek(FILE * stream, long offset, int fromwhere);</p>
<p>【参数】stream为文件指针，offset为偏移量，fromwhere为指针的起始位置。</p>
<p>参数 offset 为根据参数 fromwhere 来移动读写位置的位移数。参数 fromwhere 为下列其中一种：</p>
<ul>
<li>SEEK_SET：从距文件开头 offset 位移量为新的读写位置；</li>
<li>SEEK_CUR：以目前的读写位置往后增加 offset 个位移量；</li>
<li>SEEK_END：将读写位置指向文件尾后再增加 offset 个位移量。</li>
</ul>
<p>例子：</p>
<ul>
<li>将读写位置移动到文件开头：fseek(fp, 0, SEEK_SET);</li>
<li>将读写位置移动到文件尾时：fseek(fp, 0, SEEK_END);</li>
<li>将读写位置动到离文件开头100字节处：fseek(fp,100L, SEEK_SET);</li>
<li>将读写指针移动到离文件当前位置100字节处：fseek(fp,100L, SEEK_CUR);</li>
<li>将读写指针退回到离文件结尾100字节处：fseek(fp, -100L, SEEK_END);</li>
</ul>
<h4 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h4><p>用 法: <code>long ftell(FILE *fp);</code><br>描 述: 返回当前文件指针位置。这个位置是当前文件指针相对于文件开头的位移量。<br>返回值:返回文件指针的位置，若出错则返回-1L。<br>参数：文件指针。</p>
<h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><p>用 法: size_t fread( void *buffer, size_t size, size_t count, FILE *stream ) ;<br>描 述: fread()用来从文件流中读取数据。参数stream为已打开的文件指针，参数buffer指向欲存放读取进来的数据空间，读取的字节数以参数size * count来决定。<br>返回值: 返回实际读取到的count数目，如果此值比参数count来得小，则代表可能读到了文件尾了或者有错误发生(前者几率大)，这时必须用feof()或ferror()来决定发生什么情况。<br>参数：</p>
<p>buffer ：读取的数据存放的内存的指针（可以是数组，也可以是新开辟的空间，buffer就是一个索引）；<br>size ： 每次读取的字节数 ；<br>count ：读取次数 ；<br>strean：要读取的文件的指针；</p>
<h4 id="三个函数的解析"><a href="#三个函数的解析" class="headerlink" title="三个函数的解析"></a>三个函数的解析</h4><h5 id="func0"><a href="#func0" class="headerlink" title="func0"></a>func0</h5><p>交换栈中的两个数据</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113310818.png" alt="image-20220227113300364"></p>
<h5 id="func1"><a href="#func1" class="headerlink" title="func1"></a>func1</h5><p>这个函数的返回值小于等于2</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113437073.png" alt="image-20220227113437073"></p>
<h5 id="func2"><a href="#func2" class="headerlink" title="func2"></a>func2</h5><p>这个函数的返回值大于等于2</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227113508616.png" alt="image-20220227113508616"></p>
<p>现在我们需要使v11等于0 ，程序之中给v11赋值的是func2函数，但是该函数的返回值一定是大于等于2的，显示不可能实现v11= 0</p>
<p>但是在上面的三个函数之中我们可以看到func1的返回值能够等于0 ，所以需要使用func0这个函数调换栈中func1和func2这两个函数的位置</p>
<h4 id="交换func1函数和func0函数位置"><a href="#交换func1函数和func0函数位置" class="headerlink" title="交换func1函数和func0函数位置"></a>交换func1函数和func0函数位置</h4><p>运行func0函数时，传入的参数v12和v13是初始值，我们只需将表示func1地址的v15 和 表示func2地址的v16交换</p>
<p>v15的地址是 v8+4*7    v16的地址是v8+4*8 所以需要将v12 和 v13的值设为7 和 8 ；</p>
<p>按道理来说7和8的顺序没有关系，但是实际操作发现7和8的赋值顺序不一样，得到的flag是不一样的，只有把v12 = 7和 v13 = 8才可以得到正确的flag</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227122635003.png" alt="image-20220227122635003"></p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227122638492.png" alt="image-20220227122638492"></p>
<h4 id="使得func1的返回值为0"><a href="#使得func1的返回值为0" class="headerlink" title="使得func1的返回值为0"></a>使得func1的返回值为0</h4><p>运行func2时 v12=2  v13=3 ，所以函数之中进行运算的两个数字是v10和v11，v10的值是2 ，若想要这个函数的返回值是0，需要将v10置为-1 即0xffffffff</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227123021830.png" alt="image-20220227123021830"></p>
<h4 id="data文件的构造"><a href="#data文件的构造" class="headerlink" title="data文件的构造"></a>data文件的构造</h4><p>data数据传入的首地址是v7，因为没有设置传入数据的长度，所以可以传入无限制大小的数据，多出来的部分会对后面的数据进行覆盖，v7的长度是20 ，v10的位置是 20+2*4 = 28  v11的位置是 20+3*4=32  v12的位置是 20+4*4=36 v13的位置是 20+5*4=40 总的数据长度是44</p>
<p>用010构造数据，并且保存为data，和exe文件放到同一目录之下，运行程序</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227130028183.png" alt="image-20220227130028183"></p>
<p>运行的结果：</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227130059588.png" alt="image-20220227130059588"></p>
<p>所以得到的flag是</p>
<p>flag{8cda1bdb68a72a392a3968a71bdb8cda}</p>
<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。</p>
<p>实现栈溢出，要满足两个条件。第一，程序要有向栈内写入数据的行为；第二，程序并不限制写入数据的长度。如果想用栈溢出来执行攻击指令，就要在溢出数据内包含攻击指令的内容或地址，并且要将程序控制权交给该指令。攻击指令可以是自定义的指令片段，也可以利用系统内已有的函数及指令。</p>
</blockquote>
<h3 id="函数状态主要涉及三个寄存器-–-esp，ebp，eip"><a href="#函数状态主要涉及三个寄存器-–-esp，ebp，eip" class="headerlink" title="函数状态主要涉及三个寄存器 – esp，ebp，eip"></a>函数状态主要涉及三个寄存器 – esp，ebp，eip</h3><ul>
<li><p><code>esp</code>用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化</p>
</li>
<li><p><code>ebp</code>用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p>
</li>
<li><p><code>eip</code> 用来存储即将执行的程序指令的地址，cpu依照 eip的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p>
<p>使用这三个寄存器实现 将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。</p>
</li>
</ul>
<h3 id="栈溢出攻击"><a href="#栈溢出攻击" class="headerlink" title="栈溢出攻击"></a>栈溢出攻击</h3><blockquote>
<p>当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是<br>eip。所以我们的目标就是让 eip 载入攻击指令的地址。 首先，在退栈过程中，返回地址会被传给<br>eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。</p>
</blockquote>
<p>四种方法归类：</p>
<p>1.修改返回地址，让其指向溢出数据中的一段指令（shellcode） </p>
<p>2.修改返回地址，让其指向内存中已有的某个函数（return2libc）</p>
<p> 3.修改返回地址，让其指向内存中已有的一段指令（ROP） </p>
<p>4.修改某个被调用函数的地址，让其指向另一个函数（hijack GOT）</p>
<p><img src="/images/BUUCTF%E7%9A%84Dig-the-way-%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220227134449755.png" alt="image-20220227134449755"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>32位x86架构下的通用寄存器包括一般寄存器（eax、ebx、ecx、edx），索引寄存器（esi、edi），以及堆栈指针寄存器（esp、ebp）</p>
<ul>
<li><p>eax被称为累加寄存器（Accumulator），用以进行算数运算和返回函数结果等。</p>
</li>
<li><p>ebx被称为基址寄存器（Base），在内存寻址时（比如数组运算）用以存放基地址。</p>
</li>
<li><p>ecx被称为记数寄存器（Counter），用以在循环过程中记数。</p>
</li>
<li><p>edx 被称为数据寄存器（Data），常配合 eax 一起存放运算结果等数据。</p>
</li>
<li><p>esi 指向要处理的数据地址（Source Index）</p>
</li>
<li><p>edi指向存放处理结果的数据地址（Destination Index）</p>
</li>
</ul>
<p>参考文章： <a href="https://blog.csdn.net/weixin_43092232/article/details/96902468">https://blog.csdn.net/weixin_43092232/article/details/96902468</a></p>
]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>VNCTF_2022</title>
    <url>/2022/02/25/VNCTF-2022/</url>
    <content><![CDATA[<h2 id="VN2022"><a href="#VN2022" class="headerlink" title="VN2022"></a>VN2022</h2><h4 id="cm狗"><a href="#cm狗" class="headerlink" title="cm狗"></a>cm狗</h4><p>用jadx软件载入这个apk文件</p>
<p>判断flag的函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141557259.png" alt="image-20220215141557259"></p>
<p>判断的函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141619535.png" alt="image-20220215141619535"></p>
<p>loadDexClass()的这个函数</p>
<p><img src="/images/VNCTF-2022/image-20220215141712322.png" alt="image-20220215141712322"></p>
<p>这里copyfile了一个dex的文件，这里copyFile()函数里面应该还有一系列的操作，一系列操作的结果最后写入了创建的一个文件里面</p>
<p>找到这个文件，并且找到这个函数</p>
<p><img src="/images/VNCTF-2022/image-20220219205934006.png" alt="image-20220219205934006"></p>
<p>该函数的详情</p>
<p><img src="/images/VNCTF-2022/image-20220219210128389.png" alt="image-20220219210128389"></p>
<p>主要的代码</p>
<p><img src="/images/VNCTF-2022/image-20220219210151167.png" alt="image-20220219210151167"></p>
<p><img src="/images/VNCTF-2022/image-20220219210531948.png" alt="image-20220219210531948"></p>
<p>注意这个地方是每次取1024出来，外层有个while(true)的循环的操作</p>
<p>得到的这个文件名称是 classes.dex</p>
<p><img src="/images/VNCTF-2022/image-20220219213108277.png" alt="image-20220219213108277"></p>
<p>对文件进行操作的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v0 = &#x27;vn2022&#x27;</span><br><span class="line">with open(&quot;D:\\re\\buuctf\\VN\\3\\ooo&quot;,&#x27;rb&#x27;) as f1:</span><br><span class="line">    c = f1.read()</span><br><span class="line">with open(&quot;D:\\re\\buuctf\\VN\\3\\out&quot;,&#x27;wb&#x27;) as f2:</span><br><span class="line">    for i in range(len(c)):</span><br><span class="line">        f2.write((c[i]^ord(v0[i %1024 % len(v0)])).to_bytes(1,byteorder=&quot;little&quot;,signed=False))</span><br><span class="line">print(&quot;OK&quot;)</span><br></pre></td></tr></table></figure>

<p>将得到的这个文件命名为class.dex，这是一个dex文件，首先使用dex2jar 将 dex文件转变成jar文件，然后使用jd-gui打开这个得到的jar文件，注意使用dex2jar得到jar文件的时候，需要将dex文件放入到dex2jar的文件夹目录之下</p>
<p>得到的这个文件之中 </p>
<p>加密函数 （xxtea加密）</p>
<p><img src="/images/VNCTF-2022/image-20220219223231506.png" alt="image-20220219223231506"></p>
<p>在hcheck这个函数之中，首先给了一堆数字，然后将输入的flag以及xxtea的密钥输入，对输入进行加密，加密的结果就是上面定义的一系列数值</p>
<p><img src="/images/VNCTF-2022/image-20220219223525059.png" alt="image-20220219223525059"></p>
<p><img src="/images/VNCTF-2022/image-20220219223528938.png" alt="image-20220219223528938"></p>
<p>去网上找一个xxtea解密的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9            //固定的一个常量</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   //固定的运算</span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])   //v是要加密的两个元素的数组</span><br><span class="line">&#123;                                                      //n为数组的长度</span><br><span class="line">    uint32_t y, z, sum;                                //无符号整型</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52/n;               //固定的得出轮数</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n-1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;                //每次进行叠加</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;          //固定运算</span><br><span class="line">            for (p=0; p&lt;n-1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+1];</span><br><span class="line">                v[p] += MX;</span><br><span class="line">                      z = v[p];</span><br><span class="line">                        &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n-1] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p=n-1; p&gt;0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p-1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n-1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int8_t a[]= &#123;68, 39, -92, 108, -82, -18, 72, -55, 74, -56, 38, 11, 60, 84, 97, -40, 87, 71, 99, -82, 120, 104, 47, -71, -58, -57, 0, 33, 42, 38, -44, -39, -60, 113, -2, 92, -75, 118, -77, 50, -121, 43, 32, -106 &#125;;</span><br><span class="line">    uint32_t *v = (uint32_t *)a;</span><br><span class="line">    uint32_t *k= (uint32_t *)&quot;H4pPY_VNCTF!!OvO&quot;;</span><br><span class="line">    int n= 11;</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    printf(&quot;decrypto result:%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n&quot;,v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10]);</span><br><span class="line">    printf(&quot;result:%s&quot;,v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">VNCTF&#123;93ee7688-f216-42cb-a5c2-191ff4e412ba&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220219230318245.png" alt="image-20220219230318245"></p>
<p>所以最后的flag 是 VNCTF{93ee7688-f216-42cb-a5c2-191ff4e412ba}</p>
<h4 id="BabyMaze"><a href="#BabyMaze" class="headerlink" title="BabyMaze"></a>BabyMaze</h4><p>这道题如果直接使用employee6 解pyc得到代码是不行的，因为在这个代码里面有花指令，</p>
<p>方法一：直接使用pycda中的得到bytecode的底层的代码</p>
<p>看见迷宫，拼一下迷宫，按照w代表向上走，s代表向下走，a代表向左走，d代表向右走的方式走迷宫</p>
<p>python的pyc文件的反编译pycdc和pycdas这两个文件，pycdc反编译为python的代码，pycdas这个文件会将pyc文件编译成字节码的形式 <a href="http://www.syjblog.com/?p=470">pyc反编译</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/89935120">pyc的结构体</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Bytecode object */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">   PyObject_HEAD</span><br><span class="line">   int co_argcount;            /* Code Block的位置参数个数，比如说一个函数的位置参数个数*/</span><br><span class="line">   int co_nlocals;             /* Code Block中局部变量的个数，包括其中位置参数的个数 */</span><br><span class="line">   int co_stacksize;           /* 执行该段Code Block需要的栈空间 */</span><br><span class="line">   int co_flags;               /* CO_..., see below */</span><br><span class="line">   PyObject *co_code;          /* Code Block编译所得的字节码指令序列。以PyStingObjet的形式存在 */</span><br><span class="line">   PyObject *co_consts;        /* PyTupleObject对象，保存CodeBlock中的所常量 */</span><br><span class="line">   PyObject *co_names;         /* PyTupleObject对象，保存CodeBlock中的所有符号 */</span><br><span class="line">   PyObject *co_varnames;      /* Code Block中的局部变量名集合 */</span><br><span class="line">   PyObject *co_freevars;      /* Python实现闭包需要用的东西 */</span><br><span class="line">   PyObject *co_cellvars;      /* Code Block中内部嵌套函数所引用的局部变量名集合 */</span><br><span class="line">   /* The rest doesn&#x27;t count for hash/cmp */</span><br><span class="line">   PyObject *co_filename;      /* Code Block所对应的.py文件的完整路径 */</span><br><span class="line">   PyObject *co_name;          /* Code Block的名字，通常是函数名或类名 */</span><br><span class="line">   int co_firstlineno;         /* Code Block在对应的.py文件中起始行 */</span><br><span class="line">   PyObject *co_lnotab;        /* 字节码指令与.py文件中source code行号的对应关系，以PyStringObject的形式存在 */</span><br><span class="line">   void *co_zombieframe;     /* for optimization only (see frameobject.c) */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>

<p>得到：走出的迷宫的结果</p>
<p>ssssddssaassddddwwwwddwwddddddwwddddddssddwwddddddddssssaawwaassaassaassddssaassaawwwwwwaaaaaaaassaassddddwwddssddssssaassddssssaaaaaawwddwwaawwwwaassssssssssssddddssddssddddddddwwaaaaaawwwwddssddwwwwwwwwddssddssssssssddddss</p>
<p>将上面的解md5(32小写)得到最后的结果  VNCTF{801f190737434100e7d2790bd5b0732e}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                   1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">68      BUILD_LIST              31 1 5 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">132     BUILD_LIST              31 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1</span><br><span class="line">196     BUILD_LIST              31 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1</span><br><span class="line">260     BUILD_LIST              31 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1</span><br><span class="line">324     BUILD_LIST              31 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">388     BUILD_LIST              31 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1</span><br><span class="line">452     BUILD_LIST              31 1 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1</span><br><span class="line">516     BUILD_LIST              31 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1</span><br><span class="line">580     BUILD_LIST              31 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">644     BUILD_LIST              31 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1</span><br><span class="line">708     BUILD_LIST              31 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">772     BUILD_LIST              31 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1</span><br><span class="line">836     BUILD_LIST              31 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">900     BUILD_LIST              31 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1</span><br><span class="line">964     BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">1028    BUILD_LIST              31 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1 0 1 1 1 0 1</span><br><span class="line">1092    BUILD_LIST              31 1 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1</span><br><span class="line">1156    BUILD_LIST              31 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 1 1 1</span><br><span class="line">1220    BUILD_LIST              31 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1</span><br><span class="line">1284    BUILD_LIST              31 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 0 1</span><br><span class="line">1348    BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1412    BUILD_LIST              31 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1476    BUILD_LIST              31 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1540    BUILD_LIST              31 1 0 1 1 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">1604    BUILD_LIST              31 1 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1</span><br><span class="line">1668    BUILD_LIST              31 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1</span><br><span class="line">1732    BUILD_LIST              31 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1</span><br><span class="line">1796    BUILD_LIST              31 1 0 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1</span><br><span class="line">1860    BUILD_LIST              31 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 7 1</span><br><span class="line">1924    BUILD_LIST              31 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>VNCTF{801f190737434100e7d2790bd5b0732e}</p>
<h4 id="时空飞行"><a href="#时空飞行" class="headerlink" title="时空飞行"></a>时空飞行</h4><p>运行一下这个程序，因为不能直接运行，所以使用IDA调试运行，所以现在我们需要找到日期和符来歌（根据运行之中的提示语句得到）</p>
<p><img src="/images/VNCTF-2022/image-20220221120512364.png" alt="image-20220221120512364"></p>
<p>变化之后的日期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0FD07C452h, 0EC90A488h, 68D33CD1h, 96F64587h</span><br></pre></td></tr></table></figure>

<p>对输入的日期进行加密的过程</p>
<p><img src="/images/VNCTF-2022/image-20220221122556035.png" alt="image-20220221122556035"></p>
<p>v5[v3] = sub_401A3B(v5[i + 3] ^ v5[i + 2] ^ (unsigned int)v5[i + 1] ^ dword_405040[i]) ^ v4;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v5[4] = sub_401A3B(v5[3] ^ v5[2] ^ (unsigned int)v5[1] ^ dword_405040[0]) ^ v5[0];</span><br><span class="line">v5[5] = sub_401A3B(v5[4] ^ v5[3] ^ (unsigned int)v5[2] ^ dword_405040[1]) ^ v5[1];</span><br><span class="line">... ...</span><br><span class="line">v5[34] = sub_401A3B(v5[33] ^ v5[32] ^ (unsigned int)v5[31] ^ dword_405040[2]) ^ v5[30];</span><br><span class="line">v5[35] = sub_401A3B(v5[34] ^ v5[33] ^ (unsigned int)v5[32] ^ dword_405040[3]) ^ v5[31];</span><br></pre></td></tr></table></figure>

<p>sub_401A3B()这个函数的作用</p>
<p><img src="/images/VNCTF-2022/image-20220221123230352.png" alt="image-20220221123230352"></p>
<p>a1和a1向左移13位的结果和a1向右移9位的结果做异或运算，</p>
<p>逆向分析的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">unsigned int CalcRound(unsigned int key)&#123;</span><br><span class="line">    return key ^((((key&amp;0xffffffff)&lt;&lt;13)|((key&amp;0xffffffff)&gt;&gt;(32-13)))^(((key&amp;0xffffffff)&lt;&lt;(32-9))|((key&amp;0xffffffff)&gt;&gt;9)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long CK[32] = &#123;</span><br><span class="line">0x00070e15,0x1c232a31,0x383f464d,0x545b6269,</span><br><span class="line">0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,</span><br><span class="line">0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,</span><br><span class="line">0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,</span><br><span class="line">0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,</span><br><span class="line">0x30373e45,0x4c535a61,0x686f767d,0x848b9299,</span><br><span class="line">0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,</span><br><span class="line">0x10171e25,0x2c333a41,0x484f565d,0x646b7279</span><br><span class="line">&#125;;</span><br><span class="line">    unsigned int result[] = &#123;0x0FD07C452, 0x0EC90A488, 0x68D33CD1, 0x96F64587&#125;;</span><br><span class="line">    unsigned int re_result[36];</span><br><span class="line">    for(int i=32;i&lt;36;i++)&#123;</span><br><span class="line">        re_result[i] =result[i-32];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=31;i&gt;=0;i--)&#123;</span><br><span class="line">        re_result[i] = CalcRound(re_result[i+1]^re_result[i+2]^re_result[i+3]^CK[i])^re_result[i+4];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned long tem[4] = &#123;0xA3B1BAC6,0x56AA3350,0x677D9197,0xB27022DC&#125;;</span><br><span class="line">    for(int i=0;i&lt;=3;i++)&#123;</span><br><span class="line">        re_result[i]=re_result[i]^tem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char *data = (unsigned char *)re_result;   //因为日期的表示是8个数字，每个数字是用8位来代表</span><br><span class="line">    for(int i=1;i&lt;=2;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=4;j++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;,data[i*4 - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">20211205</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221133215573.png" alt="image-20220221133215573"></p>
<p>将得到的日期放入之后，就要进行符来歌的输入</p>
<p><img src="/images/VNCTF-2022/image-20220221133557404.png" alt="image-20220221133557404"></p>
<p>最后需要对比的元素是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1ebe,0x1e8e,0x1e44,0x1e39,0x1e5b,0x1e8,0x1e36,0x1e8f,0x1edd,0x1e5e,0x1e94,0x1eb5,0x1e1,0x1e70,0x1eab,0x1e63,0x1ebb,0x1e72,0x1e50,0x1e13,0x1e5d,0x1e25,0x1e16,0x1e78</span><br></pre></td></tr></table></figure>

<p>在上面函数 之中对这个数组中的元素做了一定的运算，下面得到的就是运算加密之后的数组</p>
<p><img src="/images/VNCTF-2022/image-20220221170531828.png" alt="image-20220221170531828"></p>
<p>所以需要比较的数组是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221183335046.png" alt="image-20220221183335046"></p>
<p>用爆破的方式得到上面的解，发现这里某些会有多个解所以需要使用递归的方式，深度优先算法解得所有的解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [ 0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3]</span><br><span class="line">i=0</span><br><span class="line">flags=[]</span><br><span class="line">flag = [0]*24</span><br><span class="line">flag[23] = 0xe3</span><br><span class="line">def DFS(deep):</span><br><span class="line">  global flags</span><br><span class="line">  global flag</span><br><span class="line">  if deep ==0:</span><br><span class="line">    flags.append(flag.copy())</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">    for j in range(1,0xff):</span><br><span class="line">      tem = j^((j % 0x12+ flag[deep] + 0x05) ^ 0x41)</span><br><span class="line">      if tem == obj[deep-1]:</span><br><span class="line">        flag[deep-1]=j</span><br><span class="line">        DFS(deep-1)</span><br><span class="line">              </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  DFS(23)</span><br><span class="line">  for i in range(len(flags)):</span><br><span class="line">    print(flags[i])</span><br><span class="line">[20, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[21, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[22, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[23, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[28, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[29, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[30, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[31, 105, 41, 173, 62, 178, 75, 159, 182, 170, 33, 91, 46, 230, 57, 64, 234, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[128, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[129, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[130, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[131, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[136, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[137, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[138, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[139, 221, 127, 219, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[72, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[73, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[74, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[75, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[80, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[81, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[82, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[83, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[88, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[89, 39, 107, 223, 48, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[184, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[185, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[186, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br><span class="line">[187, 211, 117, 221, 52, 160, 93, 169, 240, 236, 97, 35, 54, 232, 45, 78, 236, 134, 33, 151, 82, 198, 52, 227]</span><br></pre></td></tr></table></figure>

<p><img src="/images/VNCTF-2022/image-20220221183354391.png" alt="image-20220221183354391"></p>
<p>通过这个我们可以获得 a1[60] a1[61] a1[62] a1[63] a1[64] a1[65] 5个数</p>
<p>对输入的每32个字节的操作：将32位数 F1F1 F2F2 F3F3 F4F4 排列为 F4F4 F3F3 F2F2 F1F1 </p>
<p><img src="/images/VNCTF-2022/image-20220221184405201.png" alt="image-20220221184405201"></p>
<p>将所有输入的字符进行上面的运算，然后重新赋值给a1 则可以知道数组之中有6个元素</p>
<p><img src="/images/VNCTF-2022/image-20220221184743758.png" alt="image-20220221184743758"></p>
<p>然后就需要进行一系列的运算，</p>
<p><img src="/images/VNCTF-2022/image-20220221185657924.png" alt="image-20220221185657924"></p>
<p>当v5不是6的倍数的时候 </p>
<p>当i不是6的倍数的时候：v5[7] = v5[1]^v5[6]   v5[i] = v5[i-6] ^ v5[i-1] </p>
<p>当i是6的倍数的时候：v5[i] = v5[i-6] ^ T(v5[i-1],v3)  v3代表的是第几个6的倍数</p>
<p><strong>T函数的讲解</strong>：</p>
<p><img src="/images/VNCTF-2022/image-20220221190435689.png" alt="image-20220221190435689"></p>
<p>其中的第一个函数：将a1分解成了4个元素的数组0x  F0F0 F1F1 F2F2 F3F3</p>
<p><img src="/images/VNCTF-2022/image-20220221190819733.png" alt="image-20220221190819733"></p>
<p>其中的第二个函数：将数组中的元素循环右移一位 ；例如 a=[a0,a1,a2,a3] 转化成 a=[a1,a2,a3,a0] </p>
<p>[F3F3,F2F2,F1F1,F0F0] [F2F2,F1F1,F0F0,F3F3]</p>
<p><img src="/images/VNCTF-2022/image-20220221191008054.png" alt="image-20220221191008054"></p>
<p>其中第三个函数：整合上面的数组之中的元素  0x F3F3 F0F0 F1F1 F2F2</p>
<p><img src="/images/VNCTF-2022/image-20220221191329845.png" alt="image-20220221191329845"></p>
<p>所以这个函数的作用是 将 0x  F0F0 F1F1 F2F2 F3F3 转化成 0x F3F3 F0F0 F1F1 F2F2 循环左移动了8位 然后再和对应那个6的倍数作为脚标找到数组对应的元素</p>
<p>作为索引对象的数组是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000,</span><br><span class="line">           0x36000000]</span><br></pre></td></tr></table></figure>

<p>每组得到了6个数字，将这六个元素作为66个元素之中的后六位元素</p>
<p>逆向：</p>
<p>当i不是6的倍数时： v5[i-6] = v5[i]^v5[i-1]</p>
<p>当i是6的倍数时： v5[i-6] = v5[i]^ T(v5[i-1],v3) # v3 = i%6 T是将数循环左移动了8位，再和对应的数字进行异或运算</p>
<p>逆向得到的66个元素的前6个元素，将前6个元素转化为字符输出</p>
<p>所有运算的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = [ 0x25,0x15,0xdf,0xa2,0xc0,0x93,0xad,0x14,0x46,0xc5,0xf,0x2e,0x9a,0xeb,0x30,0xf8,0x20,0xe9,0xcb,0x88,0xc6,0xbe,0x8d,0xe3]</span><br><span class="line">inner_index = [0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000,</span><br><span class="line">           0x36000000]</span><br><span class="line">i=0</span><br><span class="line">flags=[]</span><br><span class="line">flag = [0]*24</span><br><span class="line">flag[23] = 0xe3</span><br><span class="line"># 用递归 ，深度遍历的方法得到所有的解</span><br><span class="line">def DFS(deep):</span><br><span class="line">  global flags</span><br><span class="line">  global flag</span><br><span class="line">  if deep ==0:</span><br><span class="line">    flags.append(flag.copy())</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">    for j in range(1,0xff):</span><br><span class="line">      tem = j^((j % 0x12+ flag[deep] + 0x05) ^ 0x41)</span><br><span class="line">      if tem == obj[deep-1]:</span><br><span class="line">        flag[deep-1]=j</span><br><span class="line">        DFS(deep-1)</span><br><span class="line"></span><br><span class="line"># 位移运算</span><br><span class="line">def rol8(num):</span><br><span class="line">  return ((num&amp;0xffffff)&lt;&lt;8) |((num&amp;0xff000000)&gt;&gt;(32-8))</span><br><span class="line"></span><br><span class="line"># 位移加上 异或运算</span><br><span class="line">def T(num,i):</span><br><span class="line">  num = rol8(num)</span><br><span class="line">  return num^inner_index[i-1]</span><br><span class="line"></span><br><span class="line"># 根据是否是6的倍数进行的不同的异或运算</span><br><span class="line">def multiple(final_flag):</span><br><span class="line">  for i in range(65,5,-1):</span><br><span class="line">    if i%6 !=0:</span><br><span class="line">      final_flag[i-6] = final_flag[i]^final_flag[i-1]</span><br><span class="line">    else:</span><br><span class="line">      final_flag[i - 6] = final_flag[i] ^ T(final_flag[i - 1], i//6)</span><br><span class="line">  return final_flag</span><br><span class="line"></span><br><span class="line"># 将得到的数组进行输出</span><br><span class="line">def print_flag(final_flag):</span><br><span class="line">  for i in range(len(final_flag)):</span><br><span class="line">    for j in range(4):</span><br><span class="line">      print(chr((final_flag[i] &amp; 0xff000000)&gt;&gt;(32-8)),end=&quot;&quot;)</span><br><span class="line">      final_flag[i] = final_flag[i] &lt;&lt; 8</span><br><span class="line">  print()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  DFS(23)</span><br><span class="line">  re_flags = []</span><br><span class="line">  for j in range(len(flags)):</span><br><span class="line">    flag = flags[j]</span><br><span class="line">    tem = []</span><br><span class="line">    # 将每4个8位数组合成 一个16进制的32位数</span><br><span class="line">    for i in range(0, len(flag), 4):</span><br><span class="line">      tem.append(int(</span><br><span class="line">        &quot;0x&quot; + hex(flag[i + 3])[2:].zfill(2) + hex(flag[i + 2])[2:].zfill(2) + hex(flag[i + 1])[2:].zfill(2) + hex(</span><br><span class="line">          flag[i])[2:].zfill(2),16))</span><br><span class="line">    re_flags.append(tem.copy())   # re_flags 里面将24个元素每4个一组转化为一个数</span><br><span class="line"></span><br><span class="line">  # 异或运算的逆向</span><br><span class="line">  final_flag = [0]*66</span><br><span class="line">  re_flags2 = []</span><br><span class="line">  for i in range(len(re_flags)):</span><br><span class="line">    final_flag = [0]*66</span><br><span class="line">    for j in range(6):  #将已知的5个值放入其中</span><br><span class="line">      final_flag[60+j] = re_flags[i][j]</span><br><span class="line">      </span><br><span class="line">    # 利用这5个元素推理出所有的数字</span><br><span class="line">    final_flag = multiple(final_flag)</span><br><span class="line">    tem = []</span><br><span class="line">    for j in range(6):</span><br><span class="line">      tem.append(final_flag[j])</span><br><span class="line">    print(tem)</span><br><span class="line">    re_flags2.append(tem.copy())</span><br><span class="line">  for i in range(len(re_flags2)):</span><br><span class="line">    print_flag(re_flags2[i])</span><br></pre></td></tr></table></figure>

<p>在所有的输出之中找到flag  VNCTF{TimeFlightMachine}</p>
<h4 id="cmgo！"><a href="#cmgo！" class="headerlink" title="cmgo！"></a>cmgo！</h4><p>将这个exe文件拖入ida之中，从函数名称的窗口之中就可以看到这里进行了程序的无符号化，使得函数的名称不能够直观的得到，所以函数的入口难以找到，无符号golang逆向技巧，使用IDAGolangHelper这一脚本，打开脚本文件（文件-脚本文件）找到这个脚本文件夹，选中rename function之后选择go版本,所以将这个exe拖进IDA7.6之中，找到程序入口main.main</p>
<p><img src="/images/VNCTF-2022/image-20220221232254810.png" alt="image-20220221232254810"></p>
<p>找到初始化虚拟机的地方和opcode</p>
<p><img src="/images/VNCTF-2022/image-20220222081345526.png" alt="image-20220222081345526"></p>
<p>第二个函数 mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084558720.png" alt="image-20220222084558720"></p>
<p>第三个函数  mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084616048.png" alt="image-20220222084616048"></p>
<p><img src="/images/VNCTF-2022/image-20220222084743697.png" alt="image-20220222084743697"></p>
<p>第四个函数 mov</p>
<p><img src="/images/VNCTF-2022/image-20220222084926787.png" alt="image-20220222084926787"></p>
<p>第五个函数 push</p>
<p><img src="/images/VNCTF-2022/image-20220222085210002.png" alt="image-20220222085210002"></p>
<p>第六个函数 和push类似的样子</p>
<p><img src="/images/VNCTF-2022/image-20220222085400565.png" alt="image-20220222085400565"></p>
<p>第七个函数 pop</p>
<p><img src="/images/VNCTF-2022/image-20220222085437971.png" alt="image-20220222085437971"></p>
<p>第八个函数 add</p>
<p><img src="/images/VNCTF-2022/image-20220222085652595.png" alt="image-20220222085652595"></p>
<p>第九个函数 sub</p>
<p><img src="/images/VNCTF-2022/image-20220222085733426.png" alt="image-20220222085733426"></p>
<p>第十个函数 div</p>
<p><img src="/images/VNCTF-2022/image-20220222085838161.png" alt="image-20220222085838161"></p>
<p>第十一个函数 mul</p>
<p><img src="/images/VNCTF-2022/image-20220222085928057.png" alt="image-20220222085928057"></p>
<p>第十二个函数 xor</p>
<p><img src="/images/VNCTF-2022/image-20220222090005356.png" alt="image-20220222090005356"></p>
<p>第十三个函数  jmp</p>
<p><img src="/images/VNCTF-2022/image-20220222090054005.png" alt="image-20220222090054005"></p>
<p>第十四个函数 jmp（多了一个判断条件）当等于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090501248.png" alt="image-20220222090501248"></p>
<p>第十五个函数 jnp</p>
<p><img src="/images/VNCTF-2022/image-20220222090557647.png" alt="image-20220222090557647"></p>
<p>第十六个函数 jlp 当小于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090652596.png" alt="image-20220222090652596"></p>
<p>第十七个函数 jhp 当大于的时候跳转</p>
<p><img src="/images/VNCTF-2022/image-20220222090801331.png" alt="image-20220222090801331"></p>
<p>第十八个函数 scanf</p>
<p><img src="/images/VNCTF-2022/image-20220222091046004.png" alt="image-20220222091046004"></p>
<p>第十九个函数 print</p>
<p><img src="/images/VNCTF-2022/image-20220222091135371.png" alt="image-20220222091135371"></p>
<p>第二十个函数 quit</p>
<p><img src="/images/VNCTF-2022/image-20220222091303160.png" alt="image-20220222091303160"></p>
<p>初始化虚拟机并且载入opcode之后，要运行这个虚拟机，所以查看虚拟机的运行的函数，用流程图的方式查看函数的逻辑，找到逻辑之中的循环，找到其中的关键代码</p>
<p><img src="/images/VNCTF-2022/image-20220222120534330.png" alt="image-20220222120534330"></p>
<p>进行动调得到函数的对应关系，动态调试得到的对应关系,</p>
<p><img src="/images/VNCTF-2022/image-20220223001010055.png" alt="image-20220223001010055"></p>
<p>跟踪到[rbx+rdi*8+1008h]这个里面，通过按D将db的数据转化成dq</p>
<p><img src="/images/VNCTF-2022/image-20220223001105287.png" alt="image-20220223001105287"></p>
<p>通过他们的顺序，就能知道code 和 函数的对应关系</p>
<p>opcode的 0-16对应函数1-17</p>
<p>97 98 99对应函数18 19 20</p>
<p>将opcode得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov r0 0X57</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6C</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X63</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6D</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X74</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X56</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X4E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X43</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X54</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X46</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X30</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X32</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X21</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0XA</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X69</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X70</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X75</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X74</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X20</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X66</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6C</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X61</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X67</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X3A</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0XA</span><br><span class="line">pushchar(r0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov r19 0X49</span><br><span class="line">mov r3 0X0</span><br><span class="line">mov r1 0X2B</span><br><span class="line">mov r2 0X1</span><br><span class="line">scanf(r0)</span><br><span class="line">push r0</span><br><span class="line">sub r1 r2</span><br><span class="line">if r1 != r3:quit </span><br><span class="line">mov r0 0X0</span><br><span class="line">push r0</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">mov r0 r6</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">mov r0 r6</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r6 r0</span><br><span class="line">pop r0</span><br><span class="line">add r6 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">mov r0 r7</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">mov r0 r7</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r7 r0</span><br><span class="line">pop r0</span><br><span class="line">add r7 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">mov r0 r8</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">mov r0 r8</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r8 r0</span><br><span class="line">pop r0</span><br><span class="line">add r8 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">mov r0 r9</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">mov r0 r9</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r9 r0</span><br><span class="line">pop r0</span><br><span class="line">add r9 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">mov r0 r10</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">mov r0 r10</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r10 r0</span><br><span class="line">pop r0</span><br><span class="line">add r10 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">mov r0 r11</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">mov r0 r11</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r11 r0</span><br><span class="line">pop r0</span><br><span class="line">add r11 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100   //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">mov r0 r12</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">mov r0 r12</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r12 r0</span><br><span class="line">pop r0</span><br><span class="line">add r12 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100  //进行位移运算 向左移动8位</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">mov r0 r13</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">mov r0 r13</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r13 r0</span><br><span class="line">pop r0</span><br><span class="line">add r13 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r14 r0</span><br><span class="line">pop r0</span><br><span class="line">add r14 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">mov r0 r15</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">mov r0 r15</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r15 r0</span><br><span class="line">pop r0</span><br><span class="line">add r15 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">pop r0</span><br><span class="line">mov r5 0X100</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">mov r0 r16</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">mov r0 r16</span><br><span class="line">mul r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">pop r0</span><br><span class="line">add r16 r0</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">push r6</span><br><span class="line">push r7</span><br><span class="line">push r8</span><br><span class="line">push r9</span><br><span class="line">push r10</span><br><span class="line">push r11</span><br><span class="line">push r12</span><br><span class="line">push r13</span><br><span class="line">push r14</span><br><span class="line">push r15</span><br><span class="line">push r16</span><br><span class="line">//第一次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X11C</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0XE8D1D5DF</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   // 0XE8D1D5DF 数据的比较</span><br><span class="line">mov r0 0XF5E3C114</span><br><span class="line">if r2 != r0:quit   //  0XF5E3C114</span><br><span class="line">// 第二次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X127</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X228EC216</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit  //  0X228EC216 数据的比较</span><br><span class="line">mov r0 0X89D45A61</span><br><span class="line">if r2 != r0:quit   //  0X89D45A61</span><br><span class="line">// 第三次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X132</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X655B8F69</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit    //  0X655B8F69 数据的比较</span><br><span class="line">mov r0 0X2484A07A</span><br><span class="line">if r2 != r0:quit    //  0X2484A07A</span><br><span class="line">// 第四次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X13D</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0XD9E5E7F8</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   //  0XD9E5E7F8 数据的比较</span><br><span class="line">mov r0 0X3A441532</span><br><span class="line">if r2 != r0:quit   //   0X3A441532</span><br><span class="line">// 第五次加密和比较</span><br><span class="line">pop r1</span><br><span class="line">pop r2</span><br><span class="line">mov r20 0X148</span><br><span class="line">mov r0 0X154</span><br><span class="line">jmp r0</span><br><span class="line">mov r0 0X91AB7E88</span><br><span class="line">mov r19 0X183</span><br><span class="line">mov r20 0X153</span><br><span class="line">if r1 != r0:quit   // 0X91AB7E88</span><br><span class="line">mov r0 0X69FC64BC</span><br><span class="line">if r2 != r0:quit   //  0X69FC64BC</span><br><span class="line">pop r1</span><br><span class="line">mov r0 0X7D3765</span><br><span class="line">if r1 != r0:quit   //  0X7D3765</span><br><span class="line">mov r0 0X189</span><br><span class="line">jmp r0</span><br><span class="line">quit!</span><br><span class="line"></span><br><span class="line">mov r3 0X9E3779B9  //tea函数开始的地方 delta</span><br><span class="line">mov r4 0X95C4C     //k0</span><br><span class="line">mov r5 0X871D      //k1</span><br><span class="line">mov r6 0X1A7B7     //k2</span><br><span class="line">mov r7 0X12C7C7    //k3</span><br><span class="line">mov r8 0X0</span><br><span class="line">mov r17 0X10  //用于位移的一堆数字</span><br><span class="line">mov r18 0X20</span><br><span class="line">mov r19 0X160</span><br><span class="line">mov r10 0X0</span><br><span class="line">mov r11 0X20</span><br><span class="line">mov r12 0X1</span><br><span class="line">add r8 r3</span><br><span class="line">mov r0 r2</span><br><span class="line">mul r0 r17</span><br><span class="line">add r0 r4</span><br><span class="line">mov r14 r0</span><br><span class="line">mov r0 r2</span><br><span class="line">add r0 r8</span><br><span class="line">mov r15 r0</span><br><span class="line">mov r0 r2</span><br><span class="line">div r0 r18</span><br><span class="line">add r0 r5</span><br><span class="line">mov r16 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">xor r0 r15</span><br><span class="line">xor r0 r16</span><br><span class="line">add r1 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">mul r0 r17</span><br><span class="line">add r0 r6</span><br><span class="line">mov r14 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">add r0 r8</span><br><span class="line">mov r15 r0</span><br><span class="line">mov r0 r1</span><br><span class="line">div r0 r18</span><br><span class="line">add r0 r7</span><br><span class="line">mov r16 r0</span><br><span class="line">mov r0 r14</span><br><span class="line">xor r0 r15</span><br><span class="line">xor r0 r16</span><br><span class="line">add r2 r0</span><br><span class="line">sub r11 r12</span><br><span class="line">if r11 != r10:quit </span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">mov r0 0X6E</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X6F</span><br><span class="line">pushchar(r0)</span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">mov r0 0X79</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X65</span><br><span class="line">pushchar(r0)</span><br><span class="line">mov r0 0X73</span><br><span class="line">pushchar(r0)</span><br><span class="line">jmp r20</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">v[2]=&#123;0XE8D1D5DF,0XF5E3C114,0X228EC216,0X89D45A61,0X655B8F69,0X2484A07A,0XD9E5E7F8,0X3A441532,0X91AB7E88,0X69FC64BC,0X7D3765&#125;</span><br></pre></td></tr></table></figure>

<p>网上的TEA的加密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上的TEA的解密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void decrypt (uint32_t v[2], const uint32_t k[4]) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up; sum is 32*delta */</span><br><span class="line">    uint32_t delta=0x9E3779B9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目之中的TEA解密的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Decrypt(unsigned long* EntryData,unsigned long* Key) &#123;</span><br><span class="line">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br><span class="line">unsigned long x = EntryData[0];</span><br><span class="line">unsigned long y = EntryData[1];</span><br><span class="line"></span><br><span class="line">unsigned long sum = 0xC6EF3720;</span><br><span class="line">unsigned long delta = 0x9E3779B9;</span><br><span class="line">sum = delta &lt;&lt; 5;   //注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.</span><br><span class="line">//总共加密32轮 那么反序也解密32轮</span><br><span class="line">for (int i = 0; i &lt; 32; i++) &#123;</span><br><span class="line">// 先将y解开 然后参与运算在解x</span><br><span class="line">y -= ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);</span><br><span class="line">x -= ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);</span><br><span class="line">sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">//最后加密的结果重新写入到数组中</span><br><span class="line">EntryData[0] = x;</span><br><span class="line">EntryData[1] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">//通过对比元素的代码处将其分为6组，每两个是一组，只有前10个进行了加密的操作</span><br><span class="line">   unsigned long t1[3] = &#123;0XE8D1D5DF,0XF5E3C114,0x0&#125;;</span><br><span class="line">   unsigned long t2[3] = &#123;0X228EC216,0X89D45A61,0x0&#125;;</span><br><span class="line">   unsigned long t3[3] = &#123;0X655B8F69,0X2484A07A,0x0&#125;;</span><br><span class="line">   unsigned long t4[3] = &#123;0XD9E5E7F8,0X3A441532,0x0&#125;;</span><br><span class="line">   unsigned long t5[3] = &#123;0X91AB7E88,0X69FC64BC,0x0&#125;;</span><br><span class="line">   unsigned long t6[2] = &#123;0X7D3765,0x0&#125;;</span><br><span class="line">//printf(&quot;待加密的数值 = %s\r\n&quot;, (char*)Data);</span><br><span class="line"></span><br><span class="line">unsigned long key[4] = &#123; 0X95C4C,0X871D,0X1A7B7,0X12C7C7 &#125;;</span><br><span class="line"></span><br><span class="line">// 分析代码我们可以得到一共加密了5次，所以数组之中只有10个分组进行了加密的操作</span><br><span class="line">Decrypt(t1, key);</span><br><span class="line">Decrypt(t2, key);</span><br><span class="line">Decrypt(t3, key);</span><br><span class="line">Decrypt(t4, key);</span><br><span class="line">Decrypt(t5, key);</span><br><span class="line"></span><br><span class="line">printf(&quot;解密后的数值 = %s%s%s%s%s%s\r\n&quot;, (char*)t1,(char*)t2,(char*)t3,(char*)t4,(char*)t5,(char *)t6);</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">VNCTF&#123;ecd63ae5-8945-4ac4-b5a5-34fc3ade81e7&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>susctf(DigitalCircuits+hello_word)</title>
    <url>/2022/03/04/susctf-DigitalCircuits-hello-word/</url>
    <content><![CDATA[<h1 id="SUSCTF-DigitalCircuits-hello-word"><a href="#SUSCTF-DigitalCircuits-hello-word" class="headerlink" title="SUSCTF(DigitalCircuits+hello_word)"></a>SUSCTF(DigitalCircuits+hello_word)</h1><p><a href="https://github.com/susers/SUSCTF2022_official_wp/tree/main/reverse">官方的WP</a></p>
<h2 id="DigitalCircuits"><a href="#DigitalCircuits" class="headerlink" title="DigitalCircuits"></a>DigitalCircuits</h2><p>这是一个pyc反编译的题目</p>
<h3 id="pyc文件转换成py文件"><a href="#pyc文件转换成py文件" class="headerlink" title="pyc文件转换成py文件"></a>pyc文件转换成py文件</h3><p>这是一个将pyc打包成地exe文件，首先使用软件解包，这个软件反编译出来地主程序并不是一个pyc文件，需要自己通过instruct这个文件修改这个文件地格式</p>
<p>将pyc文件用unemployed6 编译为py文件，然后得到源代码，分析代码，发现这是一个tea加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># uncompyle6 version 3.8.1.dev0</span><br><span class="line"># Python bytecode 3.7.0 (3394)</span><br><span class="line"># Decompiled from: Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)]</span><br><span class="line"># Embedded file name: DigitalCircuits.py</span><br><span class="line"># Compiled at: 1995-09-28 00:18:56</span><br><span class="line"># Size of source mod 2**32: 257 bytes</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def f1(a, b):   # 只有当两个字符都是1的时候才输出为1 与运算&amp;</span><br><span class="line">    if a == &#x27;1&#x27;:</span><br><span class="line">        if b == &#x27;1&#x27;:</span><br><span class="line">            return &#x27;1&#x27;</span><br><span class="line">    return &#x27;0&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f2(a, b):     # 有1则1    或运算|</span><br><span class="line">    if a == &#x27;0&#x27;:</span><br><span class="line">        if b == &#x27;0&#x27;:</span><br><span class="line">            return &#x27;0&#x27;</span><br><span class="line">    return &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f3(a):    # 取反运算~</span><br><span class="line">    if a == &#x27;1&#x27;:</span><br><span class="line">        return &#x27;0&#x27;</span><br><span class="line">    if a == &#x27;0&#x27;:</span><br><span class="line">        return &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f4(a, b):    # 当一个字符相同的时候返回0 当两个字符不同的时候返回1 异或运算</span><br><span class="line">    # f1(a, f3(b) ： a&amp;(~b)</span><br><span class="line">    # f1(f3(a), b) : (~a)&amp;b</span><br><span class="line">    # f2(f1(a, f3(b)), f1(f3(a), b)) : (a&amp;(~b))|((~a)&amp;b)</span><br><span class="line">    return f2(f1(a, f3(b)), f1(f3(a), b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f5(x, y, z):</span><br><span class="line">    # f4(x, y) ： d = (x&amp;(~y))|((~x)&amp;y) = x^y</span><br><span class="line">    # f4(d, z) :  ((x^y)&amp;(~z))|((~(x^y))&amp;z) 若z是0时 x和y要不同才返回1 若z是1时 x和y要相同 才返回1</span><br><span class="line">    s = f4(f4(x, y), z)</span><br><span class="line">    # f1(x, y) ： x&amp;y</span><br><span class="line">    # f2(x, y) : x|y</span><br><span class="line">    # f1(z, f2(x, y)) : z&amp;(x|y)</span><br><span class="line">    # f2(f1(x, y), f1(z, f2(x, y))) : (x&amp;y)|(z&amp;(x|y)) 当x和y都是1时 或者 z是1 x和y其中一个是1时 返回1</span><br><span class="line">    c = f2(f1(x, y), f1(z, f2(x, y)))</span><br><span class="line">    return (s, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f6(a, b):</span><br><span class="line">    ans = &#x27;&#x27;</span><br><span class="line">    z = &#x27;0&#x27;</span><br><span class="line">    a = a[::-1]   # 将其倒过来</span><br><span class="line">    b = b[::-1]   # 将其倒过来</span><br><span class="line">    for i in range(32):   # 循环32次</span><br><span class="line">        ans += f5(a[i], b[i], z)[0]   # 单个字符</span><br><span class="line">        z = f5(a[i], b[i], z)[1]      # 单个字符</span><br><span class="line"></span><br><span class="line">def f6(a, b):</span><br><span class="line">    ans = &#x27;&#x27;</span><br><span class="line">    z = &#x27;0&#x27;</span><br><span class="line">    a = a[::-1]  # 将其倒过来</span><br><span class="line">    b = b[::-1]  # 将其倒过来</span><br><span class="line">    for i in range(32):  # 循环32次</span><br><span class="line">        ans += ((a[i]^b[i])&amp;(~z))|((~(a[i]^b[i]))&amp;z)  # 单个字符 ((x^y)&amp;(~z))|((~(x^y))&amp;z)</span><br><span class="line">        z = (a[i]&amp;b[i])|(z&amp;(a[i]|b[i]))  # 单个字符</span><br><span class="line">    return ans[::-1]</span><br><span class="line"></span><br><span class="line"># 向左移4位</span><br><span class="line">def f7(a, n):</span><br><span class="line">    return a[n:] + &#x27;0&#x27; * n</span><br><span class="line"></span><br><span class="line"># 向右移5位</span><br><span class="line">def f8(a, n):</span><br><span class="line">    return n * &#x27;0&#x27; + a[:-n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f9(a, b):</span><br><span class="line">    ans = &#x27;&#x27;</span><br><span class="line">    for i in range(32):</span><br><span class="line">        ans += f4(a[i], b[i])   # 逐项比较每一位数，如果相同则加0 如果不同则加1</span><br><span class="line"></span><br><span class="line">    return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f10(v0, v1, k0, k1, k2, k3):</span><br><span class="line">    s = &#x27;00000000000000000000000000000000&#x27;</span><br><span class="line">    d = &#x27;10011110001101110111100110111001&#x27;</span><br><span class="line">    for i in range(32):</span><br><span class="line">        s = f6(s, d)</span><br><span class="line">        # f7(v1, 4) v1&lt;&lt;4    f8(v1, 5) v1&gt;&gt;5</span><br><span class="line">        # f6(v0, f9(f9(f6(v1&lt;&lt;4, k0), f6(v1, s)), f6(v1&gt;&gt;5, k1)))</span><br><span class="line">        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))</span><br><span class="line">        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return v0 + v1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k0 = &#x27;0100010001000101&#x27;.zfill(32)   # 0x4445</span><br><span class="line">k1 = &#x27;0100000101000100&#x27;.zfill(32)   # 0x4144</span><br><span class="line">k2 = &#x27;0100001001000101&#x27;.zfill(32)   # 0x4245</span><br><span class="line">k3 = &#x27;0100010101000110&#x27;.zfill(32)   # 0x4546</span><br><span class="line">flag = input(&#x27;please input flag:&#x27;)</span><br><span class="line">if flag[0:7] != &#x27;SUSCTF&#123;&#x27; or flag[(-1)] != &#x27;&#125;&#x27;:</span><br><span class="line">    print(&#x27;Error!!!The formate of flag is SUSCTF&#123;XXX&#125;&#x27;)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    exit(0)</span><br><span class="line">flagstr = flag[7:-1]</span><br><span class="line">if len(flagstr) != 24:</span><br><span class="line">    print(&#x27;Error!!!The length of flag 24&#x27;)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    exit(0)</span><br><span class="line">else:</span><br><span class="line">    res = &#x27;&#x27;</span><br><span class="line">    # 将这里面的字符串每8个分为一组</span><br><span class="line">    for i in range(0, len(flagstr), 8):</span><br><span class="line">        v0 = flagstr[i:i + 4]</span><br><span class="line">        v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[(i + 1)]))[2:].zfill(8) + bin(ord(flagstr[(i + 2)]))[2:].zfill(8) + bin(ord(flagstr[(i + 3)]))[2:].zfill(8)</span><br><span class="line">        v1 = bin(ord(flagstr[(i + 4)]))[2:].zfill(8) + bin(ord(flagstr[(i + 5)]))[2:].zfill(8) + bin(ord(flagstr[(i + 6)]))[2:].zfill(8) + bin(ord(flagstr[(i + 7)]))[2:].zfill(8)</span><br><span class="line">        res += f10(v0, v1, k0, k1, k2, k3)</span><br><span class="line"></span><br><span class="line">    if res == &#x27;001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111&#x27;:</span><br><span class="line">        print(&#x27;True&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;False&#x27;)</span><br><span class="line">time.sleep(5)</span><br></pre></td></tr></table></figure>

<h3 id="tea算法"><a href="#tea算法" class="headerlink" title="tea算法"></a>tea算法</h3><p>tea 的密钥是：0x4445,0x4144,0x4245,0x4546</p>
<p>最后的加密结果：[0x3e8947cb,0xcc944639,0x31358388,0x3b0b6893,0xda627361,0x3b2e6427]</p>
<p>dalt：0x9e3779b9</p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */</span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v1[3]=&#123;0x3e8947cb,0xcc944639,0x0&#125;,k[4]=&#123;0x4445,0x4144,0x4245,0x4546&#125;;</span><br><span class="line">    uint32_t v2[3]=&#123;0x31358388,0x3b0b6893,0x0&#125;;</span><br><span class="line">    uint32_t v3[3]=&#123;0xda627361,0x3b2e6427&#125;;</span><br><span class="line">    decrypt(v1, k);</span><br><span class="line">    decrypt(v2, k);</span><br><span class="line">    decrypt(v3, k);</span><br><span class="line">    printf(&quot;解密后的数据：%s %s %s\n&quot;,(char*)v1,(char*)v2,(char*)v3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">fvBXQdEa rcbvhBPx cOA8Ag6J</span><br></pre></td></tr></table></figure>

<p>在输入数据的时候：从图中我们可以看到每组字符串中（每4个字符为一组）它将低位的字符放到二进制的高位，所以最后的结果还需要调整字符串的顺序，逆序取出每组数据</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220226130532348.png" alt="image-20220226130532348"></p>
<p>最后的flag是 SUSCTF{XBvfaEdQvbcrxPBh8AOcJ6gA}</p>
<h2 id="hello-word"><a href="#hello-word" class="headerlink" title="hello_word"></a>hello_word</h2><p>这个题目考察vhdl </p>
<h3 id="定位代码"><a href="#定位代码" class="headerlink" title="定位代码"></a>定位代码</h3><p>通过字符串找到一个含有inputflag页面的函数，在里面出现了有vhdl</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220226224203141.png" alt="image-20220226224203141"></p>
<h3 id="VHDL介绍"><a href="#VHDL介绍" class="headerlink" title="VHDL介绍"></a>VHDL介绍</h3><blockquote>
<p>GHDL是一个基于GCC的VHDL语言编译/模拟命令行工具</p>
<p>通过使用代码生成器（<a href="https://llvm.org/">LLVM</a>、<a href="https://gcc.gnu.org/">GCC</a>或仅<a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> / <a href="https://en.wikipedia.org/wiki/Intel_80386">i386</a>，内置的），它比任何解释模拟器都要快得多。它可以处理非常大的设计，例如<a href="https://www.gaisler.com/index.php/downloads/leongrlib">leon3/grlib</a>。</p>
<p>可将波形写入<a href="https://ghdl.github.io/ghdl/using/Simulation.html?highlight=GHW#cmdoption-wave">GHW</a>、<a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD</a>或 FST 文件。结合基于<a href="https://en.wikipedia.org/wiki/Graphical_user_interface">GUI的</a><a href="https://en.wikipedia.org/wiki/Waveform_viewer">波形查看器</a>和良好的文本编辑器，GHDL 是用于<strong>编写、测试和模拟代码</strong>的非常强大的工具。</p>
</blockquote>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220303190451907.png" alt="image-20220303190451907"></p>
<h3 id="状态机介绍"><a href="#状态机介绍" class="headerlink" title="状态机介绍"></a>状态机介绍</h3><p>分析代码这是一个状态机</p>
<blockquote>
<p><strong>有限状态机</strong>（Finite-state machine,FSM）：又称有限状态自动机，简称状态机，是表示有限个状态以及在<strong>这些状态之间的转移和动作等行为的数学模型</strong>。</p>
<p><strong>FSM</strong>：是一种算法思想，简单而言，有限状态机<strong>由一组状态、一个初始状态、输入和根据输入及现有状态转换为下一个状态的转换函数</strong>组成。</p>
<p><strong>六种元素</strong>：起始、终止、现态、次态（目标状态）、动作、条件，我们就可以完成一个状态机图</p>
<p>状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学<a href="https://so.csdn.net/so/search?q=%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">模型</a>。说白了，一般就是指一张状态转换图。</p>
<p>例如：自动门有两个状态，open 和 closed ，closed 状态下，如果读取开门信号，那么状态就会切换为 open 。open 状态下如果读取关门信号，状态就会切换为 closed 。</p>
</blockquote>
<p>能够抽象出来的图：</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304122921881.png" alt="image-20220304122921881">、</p>
<p>状态机的四大概念：</p>
<ul>
<li>第一个是 <strong>State</strong> ，状态。一个状态机至少要<strong>包含两个状态</strong>。例如上面自动门的例子，有 open 和 closed 两个状态。</li>
<li>第二个是 <strong>Event</strong> ，事件。事件就是执行某个操作的触发<strong>条件或者口令</strong>。对于自动门，“按下开门按钮”就是一个事件。</li>
<li>第三个是 <strong>Action</strong> ，动作。事件发生以后要<strong>执行动作</strong>。例如事件是“按开门按钮”，动作是“开门”。编程的时候，一个 Action一般就对应一个函数。</li>
<li>第四个是 <strong>Transition</strong> ，变换。也就是从一个状态<strong>变化</strong>为另一个状态。例如“开门过程”就是一个变换。</li>
</ul>
<h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><p>这道题是被strip了的，下面是对strip概念的解释</p>
<p><strong>strip的作用</strong>：</p>
<p>so文件组成：一个完整的 so 由C代码加一些 debug 信息组成，这些debug信息会记录 so 中所有方法的对照表，就是方法名和其偏移地址的对应表，也叫做符号表。</p>
<p>未strip的so文件：这种既有c代码和debug信息的 so文件就是未 strip 的so文件，通常体积会比较大</p>
<p>strip操作：so 中的debug信息会被剥离，整个 so 的体积也会缩小。</p>
<p>strip操作解说：</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304124408410.png" alt="image-20220304124408410"></p>
<h3 id="逻辑电路"><a href="#逻辑电路" class="headerlink" title="逻辑电路"></a>逻辑电路</h3><p>逻辑电路一般是状态机</p>
<blockquote>
<p>逻辑电路：是指完成逻辑运算的电路。这种电路，一般有<strong>若干个输入端</strong>和<strong>一个 或几个输出端</strong>，当输入信号之间满足某一特定逻辑关系时，电路就开通，有输 出;否则，电路就关闭，无输出。所以，这种电路又叫逻辑门电路，简称门电路。</p>
</blockquote>
<p>这里的case语句展示了这样的逻辑电路的构成</p>
<p>这里考察的是VHDL这个程序</p>
<h3 id="case语句的代码的算法分析"><a href="#case语句的代码的算法分析" class="headerlink" title="case语句的代码的算法分析"></a>case语句的代码的算法分析</h3><h4 id="定位代码-1"><a href="#定位代码-1" class="headerlink" title="定位代码"></a>定位代码</h4><p>首先通过字符串inputflag定位到对应的函数，这是一个switch的循环语句</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304130403296.png" alt="image-20220304130403296"></p>
<p>分析这个switch语句</p>
<h4 id="case1-4"><a href="#case1-4" class="headerlink" title="case1-4"></a>case1-4</h4><p>case1-4不断地跳转，这个地方地代码是对输入地flag的长度赋值</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304130605519.png" alt="image-20220304130605519"></p>
<p>向下跳转到case9的地方</p>
<h4 id="case9模块"><a href="#case9模块" class="headerlink" title="case9模块"></a>case9模块</h4><p>这个地方把输入的值给到vhdl中进行xor模块，然后跳到case10模块</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304132901912.png" alt="image-20220304132901912"></p>
<h4 id="case10模块"><a href="#case10模块" class="headerlink" title="case10模块"></a>case10模块</h4><p>调用vhdl的异或的方法，并且在这里可以知道一个用于异或运算的数组</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133058776.png" alt="image-20220304133058776"></p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133113178.png" alt="image-20220304133113178"></p>
<p>数组是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x56,0xda,0xcd,0x3a,0x7e,0x86,0x13,0xb5,0x1d,0x9d,0xfc,0x97,0x8c,0x31,0x6b,0xc9,0xfb,0x1a,0xe2,0x2d,0xdc,0xd3,0xf1,0xf4,0x36,0x09,0x20,0x42,0x04,0x6a,0x71,0x53,0x78,0xa4,0x97,0x8f,0x7a,0x72,0x39,0xe8,0x3d,0xfa,0x40,0x3d,0x98,0x01]</span><br></pre></td></tr></table></figure>

<h4 id="case11"><a href="#case11" class="headerlink" title="case11"></a>case11</h4><p>将异或的结果和最后的答案对比</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133511919.png" alt="image-20220304133511919"></p>
<p>对比使用的数组：</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304133538057.png" alt="image-20220304133538057"></p>
<p>数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0x05,0x8f,0x9e,0x79,0x2a,0xc0,0x68,0x81,0x2d,0xfc,0xcf,0xa4,0xb5,0x55,0x5f,0xe4,0x9d,0x23,0xd6,0x1d,0xf1,0xe7,0x97,0x91,0x06,0x24,0x42,0x71,0x3c,0x58,0x5c,0x30,0x19,0xc6,0xf5,0xbc,0x4b,0x42,0x5d,0xda,0x58,0x9b,0x24,0x40]</span><br></pre></td></tr></table></figure>

<h4 id="case-5模块"><a href="#case-5模块" class="headerlink" title="case 5模块"></a>case 5模块</h4><p>通过表示正确字符个数的correct判断最后的结果，错误就跳转到wrong的case5这个模块</p>
<p><img src="/images/susctf-DigitalCircuits-hello-word/image-20220304134147758.png" alt="image-20220304134147758"></p>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj1 = [0x05,0x8f,0x9e,0x79,0x2a,0xc0,0x68,0x81,0x2d,0xfc,0xcf,0xa4,0xb5,0x55,0x5f,0xe4,0x9d,0x23,0xd6,0x1d,0xf1,0xe7,0x97,0x91,0x06,0x24,0x42,0x71,0x3c,0x58,0x5c,0x30,0x19,0xc6,0xf5,0xbc,0x4b,0x42,0x5d,0xda,0x58,0x9b,0x24,0x40]</span><br><span class="line">obj2=[0x56,0xda,0xcd,0x3a,0x7e,0x86,0x13,0xb5,0x1d,0x9d,0xfc,0x97,0x8c,0x31,0x6b,0xc9,0xfb,0x1a,0xe2,0x2d,0xdc,0xd3,0xf1,0xf4,0x36,0x09,0x20,0x42,0x04,0x6a,0x71,0x53,0x78,0xa4,0x97,0x8f,0x7a,0x72,0x39,0xe8,0x3d,0xfa,0x40,0x3d,0x98,0x01]</span><br><span class="line">for i in range(len(obj1)):</span><br><span class="line">  print(chr(obj1[i]^obj2[i]),end=&#x27;&#x27;)</span><br><span class="line">  SUSCTF&#123;40a339d4-f940-4fe0-b382-cabb310d2ead&#125;</span><br></pre></td></tr></table></figure>

<p>所以最后的flag是 SUSCTF{40a339d4-f940-4fe0-b382-cabb310d2ead}</p>
]]></content>
      <categories>
        <category>复现</category>
      </categories>
      <tags>
        <tag>susctf</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向之native层的so文件格式</title>
    <url>/2022/03/03/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="安卓逆向之native层的so文件格式"><a href="#安卓逆向之native层的so文件格式" class="headerlink" title="安卓逆向之native层的so文件格式"></a>安卓逆向之native层的so文件格式</h1><h2 id="安卓逆向的相关工具介绍"><a href="#安卓逆向的相关工具介绍" class="headerlink" title="安卓逆向的相关工具介绍"></a>安卓逆向的相关工具介绍</h2><p>反编译代码的工具：</p>
<ul>
<li><a href="https://sourceforge.net/projects/dex2jar/files/">dex2jar</a>:把dex文件转成jar文件</li>
<li><a href="http://java-decompiler.github.io/">jd-gui</a>: 这个工具用于将jar文件转换成java代码</li>
</ul>
<p>反编译资源的工具：</p>
<ul>
<li><a href="https://ibotpeaches.github.io/Apktool/install/">APKTool</a>: 本文重要工具，APK逆向工具。它可以将资源解码，并在修改后可以重新构建它们。它还可以执行一些自动化任务，例如构建apk。解码就是将其恢复成未打包的资源文件（包括resources.arsc，class.dex，9.png和xml）；解码的资源可以重新打包成apk/jar文件；组织和处理依赖于框架资源的APK；Smali调试；执行自动化任务</li>
<li><strong>JEB</strong>:JEB是一个功能强大为安全专业人士设计的安卓应用程序反编译工具，用于逆向工程或者审计apk文件。它是可以直接反编译apk文件的。</li>
<li><a href="https://github.com/skylot/jadx">jadx</a>：jadx是一款反编译利器，同时支持命令行和图形界面，能以最简便的方式完成apk的反编译操作。工具支持<strong>apk、dex、jar、aar</strong>等格式的文件</li>
</ul>
<h2 id="so文件介绍"><a href="#so文件介绍" class="headerlink" title="so文件介绍"></a>so文件介绍</h2><p><strong>概念</strong>：.so 文件是ELF对象文件中可被共享的对象文件(Shared object file)，这些就是所谓的动态库文件。</p>
<p><strong>动态文件的作用</strong>：如果用静态库来生成可执行程序，那每个生成的可执行程序中都会有一份库代码的拷贝。如果在磁盘中存储这些可执行程序，那就会占用额外的磁盘空 间；另外如果拿它们放到Linux系统上一起运行，也会浪费掉宝贵的物理内存。如果将静态库换成动态库，那么这些问题都不会出现。</p>
<p>Android中的so文件就是elf文件，所以需要了解so文件，必须先来了解一下elf文件的格式。</p>
<h3 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h3><p>为了让大家对elf文件格式有一个整体的了解，首先先看一张非虫先生总结好的图片讲解：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/20140918103240781.png" alt="20140918103240781.png"></p>
<p>ELF文件的两种视图，分别是<strong>链接视图</strong>和<strong>执行视图</strong>。</p>
<p><strong>链接视图</strong>：是在<strong>链接时</strong>用到的视图， 以<strong>节</strong>（section）为单位，下图<strong>左侧</strong>的视角是从链接来看的。从图中我们得到，在链接阶段，我们可以忽略<strong>program header table</strong>来处理此文件，因为它是按照<strong>section header table</strong>来处理此文件的。</p>
<p><strong>执行视图</strong>：在<strong>执行时</strong>用到的视图，是以<strong>段</strong>（segment）为单位，下图<strong>右侧</strong>的视角是执行来看的。从图中我们可以得到，在运行阶段可以忽略<strong>section header table</strong>来处理此程序，因为它是按照<strong>program header table</strong>来处理此文件的。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220302143454066.png" alt="image-20220302143454066"></p>
<p><strong>文件的组成</strong>：</p>
<ul>
<li><strong>ELF heade</strong>r： 描述整个文件的组织。</li>
<li><strong>Program Header Table</strong>: 描述文件中的各种segments，用来告诉系统如何创建进程映像的。 </li>
<li><strong>sections</strong> 或者 <strong>segments</strong>：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。</li>
<li><strong>Section Header Table</strong>: 包含了文件各个segction的属性信息</li>
</ul>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220302144111413.png" alt="image-20220302144111413"></p>
<p><strong>区分两种视图的原因</strong>：</p>
<p>在内存之中，多个具有<strong>相同权限</strong>（flg值）section<strong>合并</strong>一个segment。操作系统往往以<strong>页</strong>为基本单位来<strong>管理内存分配</strong>，以及<strong>内存的权限</strong>管理的粒度也是以页为单位。每个section在映射时的长度都是系统<strong>页长度的整数倍</strong>，如果section的长度不是其整数倍，则导致多余部分也将占用一个页，因为一个ELF文件具有很多的section，那么这样将会导致内存浪费严重。为了减少页面内部的碎片，节省了空间，显著提高内存利用率，就将相同权限（flg值）section合并一个segment。</p>
<h4 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h4><p>32位ELF文件中常用的<strong>数据格式</strong>：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303170256836.png" alt="image-20220303170256836"></p>
<p>ELF Header的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define EI_NIDENT 16</span><br><span class="line">typedef struct &#123;</span><br><span class="line">       unsigned char e_ident[EI_NIDENT];  // ELF的一些标识信息，前四位为.ELF,其他的信息比如大小端等</span><br><span class="line">       ELF32_Half e_type;                 // 标识了文件类型</span><br><span class="line">       ELF32_Half e_machine;              // 文件的目标体系架构，比如ARM</span><br><span class="line">       ELF32_Word e_version;              // 0为非法版本，1为当前版本</span><br><span class="line">       ELF32__Addr e_entry;               // 程序入口的虚拟地址</span><br><span class="line">       ELF32_Off e_phoff;                 // 程序头部表偏移地址</span><br><span class="line">       ELF32_Off e_shoff;                 // 节区头部表偏移地址</span><br><span class="line">       ELF32_Word e_flags;                // 保存与文件相关的，特定于处理器的标志</span><br><span class="line">       ELF32_Half e_ehsize;               // ELF头的大小</span><br><span class="line">       ELF32_Half e_phentsize;            // 每个程序头部表的大小</span><br><span class="line">       ELF32_Half e_phnum;                // 程序头部表的数量</span><br><span class="line">       ELF32_Half e_shentsize;            // 每个节区头部表的大小</span><br><span class="line">       ELF32_Half e_shnum;                // 节区头部表的数量</span><br><span class="line">       ELF32_Half e_shstrndx;             // 节区字符串表位置</span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<p>查看ELF Header结构的内容命令： readelf -h android_server</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303171118246.png" alt="image-20220303171118246"></p>
<h5 id="e-entry"><a href="#e-entry" class="headerlink" title="e_entry"></a>e_entry</h5><p>e_entry表示程序入口地址。谓<strong>程序进入点</strong>是指当程序真正执行起来的时候，要运行的指令的运行时地址。其第一条可执行文件test和动态库.so都存在所谓的进入点，且可执行文件的<strong>e_entry</strong>指向C库中的**_start<strong>，而</strong>动态库.so**中的进入点指向 <strong>call_gmon_start</strong>。</p>
<h5 id="重点关注的字段"><a href="#重点关注的字段" class="headerlink" title="重点关注的字段"></a>重点关注的字段</h5><p>在ELF Header中我们需要重点关注以下几个字段：</p>
<ul>
<li><strong>e_entry</strong>：表示程序<strong>入口地址</strong></li>
<li><strong>e_ehsize</strong>：ELF Header<strong>结构大小</strong></li>
<li><strong>e_phoff、e_phentsize、e_phnum</strong>：描述<strong>Program Header Table</strong>的偏移、大小、结构。</li>
<li><strong>e_shoff、e_shentsize、e_shnum</strong>：描述<strong>Section Header Table</strong>的偏移、大小、结构。</li>
<li><strong>e_shstrndx</strong>：这一项描述的是<strong>字符串表</strong>在<strong>Section Header Tabl</strong>e中的索引，值25表示的是Section Header Table中第25项是字符串表（String Table）</li>
</ul>
<h4 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h4><p>section head table(SHT)包含了用来描述每一个<strong>section的条目（entry）</strong>，每一个entry的内容主要包括该 section 的<strong>名称、类型、大小以及在整个ELF文件中的字节偏移位置</strong>等等。</p>
<p>每个条目结构定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    Elf32_Word sh_name;   //节区名，是节区头部字符串表节区（Section Header String Table Section）的索引。名字是一个 NULL 结尾的字符串。</span><br><span class="line">    Elf32_Word sh_type;    //为节区类型</span><br><span class="line">    Elf32_Word sh_flags;    //节区标志</span><br><span class="line">    Elf32_Addr sh_addr;    //如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应处的位置。否则，此字段为 0。</span><br><span class="line">    Elf32_Off sh_offset;    //此成员的取值给出节区的第一个字节与文件头之间的偏移。</span><br><span class="line">    Elf32_Word sh_size;   //此 成 员 给 出 节 区 的 长 度 （ 字 节 数 ）。</span><br><span class="line">    Elf32_Word sh_link;   //此成员给出节区头部表索引链接。其具体的解释依赖于节区类型。</span><br><span class="line">    Elf32_Word sh_info;       //此成员给出附加信息，其解释依赖于节区类型。</span><br><span class="line">    Elf32_Word sh_addralign;    //某些节区带有地址对齐约束.</span><br><span class="line">    Elf32_Word sh_entsize;    //某些节区中包含固定大小的项目，如符号表。对于这类节区，此成员给出每个表项的长度字节数。</span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<h4 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h4><p>有些节区是系统预订的，一般以点开头号,</p>
<h5 id="常用的系统节区"><a href="#常用的系统节区" class="headerlink" title="常用的系统节区"></a>常用的系统节区</h5><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>.bss</td>
<td>SHT_NOBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>包含将出现在程序的内存映像中的为初始化数据。根据定义，当程序开始执行，系统将把这些数据初始化为 0。此节区不占用文件空间。</td>
</tr>
<tr>
<td>.comment</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>包含版本控制信息。</td>
</tr>
<tr>
<td>.data</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td>
</tr>
<tr>
<td>.data1</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td>
</tr>
<tr>
<td>.debug</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>此节区包含用于符号调试的信息。</td>
</tr>
<tr>
<td>.dynamic</td>
<td>SHT_DYNAMIC</td>
<td></td>
<td>此节区包含动态链接信息。节区的属性将包含 SHF_ALLOC 位。是否 SHF_WRITE 位被设置取决于处理器。</td>
</tr>
<tr>
<td>.dynstr</td>
<td>SHT_STRTAB</td>
<td>SHF_ALLOC</td>
<td>此节区包含用于动态链接的字符串，大多数情况下这些字符串代表了与符号表项相关的名称。</td>
</tr>
<tr>
<td>.dynsym</td>
<td>SHT_DYNSYM</td>
<td>SHF_ALLOC</td>
<td>此节区包含了动态链接符号表。</td>
</tr>
<tr>
<td>.fini</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含了可执行的指令，是进程终止代码的一部分。程序正常退出时，系统将安排执行这里的代码。</td>
</tr>
<tr>
<td>.got</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含全局偏移表。</td>
</tr>
<tr>
<td>.hash</td>
<td>SHT_HASH</td>
<td>SHF_ALLOC</td>
<td>此节区包含了一个符号哈希表。</td>
</tr>
<tr>
<td>.init</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含了可执行指令，是进程初始化代码的一部分。当程序开始执行时，系统要在开始调用主程序入口之前（通常指 C 语言的 main 函数）执行这些代码。</td>
</tr>
<tr>
<td>.interp</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含程序解释器的路径名。如果程序包含一个可加载的段，段中包含此节区，那么节区的属性将包含 SHF_ALLOC 位，否则该位为 0。</td>
</tr>
<tr>
<td>.line</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>此节区包含符号调试的行号信息，其中描述了源程序与机器指令之间的对应关系。其内容是未定义的。</td>
</tr>
<tr>
<td>.note</td>
<td>SHT_NOTE</td>
<td>(无)</td>
<td>此节区中包含注释信息，有独立的格式。</td>
</tr>
<tr>
<td>.plt</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含过程链接表（procedure linkage table）。</td>
</tr>
<tr>
<td>.relname .relaname</td>
<td>SHT_REL SHT_RELA</td>
<td></td>
<td>这些节区中包含了重定位信息。如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含 SHF_ALLOC 位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。例如 .text 节区的重定位节区名字将是：.rel.text 或者 .rela.text。</td>
</tr>
<tr>
<td>.rodata .rodata1</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC</td>
<td>这些节区包含只读数据，这些数据通常参与进程映像的不可写段。</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含节区名称。</td>
</tr>
<tr>
<td>.strtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含字符串，通常是代表与符号表项相关的名称。如果文件拥有一个可加载的段，段中包含符号串表，节区的属性将包含SHF_ALLOC 位，否则该位为 0。</td>
</tr>
<tr>
<td>.symtab</td>
<td>SHT_SYMTAB</td>
<td></td>
<td>此节区包含一个符号表。如果文件中包含一个可加载的段，并且该段中包含符号表，那么节区的属性中包含SHF_ALLOC 位，否则该位置为 0。</td>
</tr>
<tr>
<td>.text</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含程序的可执行指令。</td>
</tr>
</tbody></table>
<h5 id="so文件中重要的Section"><a href="#so文件中重要的Section" class="headerlink" title="so文件中重要的Section"></a>so文件中重要的Section</h5><h6 id="符号表-dynsym"><a href="#符号表-dynsym" class="headerlink" title="-符号表(.dynsym)"></a><strong>-符号表(.dynsym)</strong></h6><p>符号表包含用来<strong>定位、重定位程序中符号定义和引用的信息</strong>，简单的理解就是符号表记录了该文件中的所有符号，所谓的符号就是经过<strong>修饰了的函数名或者变量名</strong>，不同的编译器有不同的修饰规则。<strong>例如</strong>符号_ZL15global_static_a，就是由global_static_a变量名经过修饰而来。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">     Elf32_Word st_name;      //符号表项名称。如果该值非0，则表示符号名的字符串表索引(offset)，否则符号表项没有名称。</span><br><span class="line">     Elf32_Addr st_value;       //符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。</span><br><span class="line">     Elf32_Word st_size;         //符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。</span><br><span class="line">     unsigned char st_info;    //符号的类型和绑定属性。</span><br><span class="line">     unsigned char st_other;  //该成员当前包含 0，其含义没有定义。</span><br><span class="line">     Elf32_Half st_shndx;        //每个符号表项都以和其他节区的关系的方式给出定义。此成员给出相关的节区头部表索引。</span><br><span class="line">&#125; Elf32_sym;</span><br></pre></td></tr></table></figure>

<p>符号表的内容</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303175513396.png" alt="image-20220303175513396"></p>
<h6 id="字符串表（-dynstr）"><a href="#字符串表（-dynstr）" class="headerlink" title="-字符串表（.dynstr）"></a><strong>-字符串表（.dynstr）</strong></h6><p>字符串表中存放着<strong>所有符号的名称字符串</strong>。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303175720635.png" alt="image-20220303175720635"></p>
<h6 id="重定位表"><a href="#重定位表" class="headerlink" title="-重定位表"></a><strong>-重定位表</strong></h6><p>重定位就是为程序不同部分<strong>分配加载地址</strong>，<strong>调整</strong>程序中的数据和代码以反映<strong>所分配地址</strong>的过程。简单的言之，则是将程序中的各个部分<strong>映射到合理的地址</strong>上来。例如，当程序调用了一个函数时，相关的调用指令必须把控制传输到适当的目标执行地址。</p>
<p>重定位文件必须包含<strong>如何修改其节区内容的信息</strong>，从而允许可执行文件和共享目标文件保存进程的程序映象的正确信息。</p>
<p>重定位表项的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Addr r_offset;     //重定位动作所适用的位置（受影响的存储单位的第一个字节的偏移或者虚拟地址）</span><br><span class="line">    Elf32_Word r_info;       //要进行重定位的符号表索引，以及将实施的重定位类型（哪些位需要修改，以及如何计算它们的取值）</span><br><span class="line">                                         //其中 .rel.dyn 重定位类型一般为R_386_GLOB_DAT和R_386_COPY；.rel.plt为R_386_JUMP_SLOT</span><br><span class="line">&#125; Elf32_Rel; </span><br></pre></td></tr></table></figure>

<p>r_info 成员使用 <strong>ELF32_R_TYPE 宏运算</strong>可得到<strong>重定位类型</strong>，使用 <strong>ELF32_R_SYM 宏运算</strong>可得到符号在符号表里的<strong>索引值</strong>。</p>
<p>三种宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ELF32_R_SYM(i) ((i)&gt;&gt;8)</span><br><span class="line">#define ELF32_R_TYPE(i) ((unsigned char)(i))</span><br><span class="line">#define ELF32_R_INFO(s, t) (((s)&lt;&lt;8) + (unsigned char)(t))</span><br></pre></td></tr></table></figure>

<p>重定位表中的内容</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303180343936.png" alt="image-20220303180343936"></p>
<h4 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h4><p>程序头部（Program Header）用来在文件中定位各个段的映像,同时包含其他一些用来为程序创建映像所必须的信息。</p>
<p>文件头部的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Word p_type;           //此数组元素描述的段的类型，或者如何解释此数组元素的信息。 </span><br><span class="line">    Elf32_Off  p_offset;           //此成员给出从文件头到该段第一个字节的偏移</span><br><span class="line">    Elf32_Addr p_vaddr;         //此成员给出段的第一个字节将被放到内存中的虚拟地址</span><br><span class="line">    Elf32_Addr p_paddr;        //此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息。</span><br><span class="line">    Elf32_Word p_filesz;         //此成员给出段在文件映像中所占的字节数。可以为0。</span><br><span class="line">    Elf32_Word p_memsz;     //此成员给出段在内存映像中占用的字节数。可以为0。</span><br><span class="line">    Elf32_Word p_flags;         //此成员给出与段相关的标志。</span><br><span class="line">    Elf32_Word p_align;        //此成员给出段在文件中和内存中如何对齐。</span><br><span class="line">&#125; Elf32_phdr;</span><br></pre></td></tr></table></figure>

<p>程序头部表中的内容：</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E4%B9%8Bnative%E5%B1%82%E7%9A%84so%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220303181440086.png" alt="image-20220303181440086"></p>
<p>so文件格式中结构体的某些参数未详细说明，可以去查看下面的这个参考文章。</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/mergerly/article/details/94585901">https://blog.csdn.net/mergerly/article/details/94585901</a></p>
]]></content>
      <categories>
        <category>安卓逆向</category>
      </categories>
      <tags>
        <tag>so文件</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫_逆向</title>
    <url>/2022/03/02/%E8%BF%B7%E5%AE%AB-%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<h1 id="迷宫-逆向"><a href="#迷宫-逆向" class="headerlink" title="迷宫_逆向"></a>迷宫_逆向</h1><h2 id="深度优先算法介绍"><a href="#深度优先算法介绍" class="headerlink" title="深度优先算法介绍"></a>深度优先算法介绍</h2><blockquote>
<p>深度优先搜索算法（Depth-First-Search），是搜索算法的一种。是沿着树的深度遍历树的节点，<strong>尽可能深</strong>的搜索树的分支。当节点v的所有边都己被探寻过，搜索将<strong>回溯</strong>到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于<strong>盲目搜索</strong>。</p>
</blockquote>
<h2 id="深度优先算法在迷宫中的使用"><a href="#深度优先算法在迷宫中的使用" class="headerlink" title="深度优先算法在迷宫中的使用"></a>深度优先算法在迷宫中的使用</h2><p>二维的迷宫：</p>
<ul>
<li>使用递归的方法，用栈的思想放入和取出路径，用数组的方式存放迷宫图</li>
<li>使用for循环遍历四个方向，在每个节点选择走的方向，如果按这个方向向下走一步能够满足条件（不是墙并且没有到达过），就可以将这一步的目标地址进行标记（已经走过），并且将走的方向放入路径之中</li>
<li>当死路的时候就会向上返回。如果四个方向都遍历，没有一个方向能够满足条件，那么就会返回上一轮，并且将这步错误的方向在路径之中去除，并且将这个地址再次标记为未可达</li>
<li>递归的结束条件。已经到达了目标地址的坐标，就可以返回这个路径了</li>
</ul>
<h2 id="二维迷宫题算法实现"><a href="#二维迷宫题算法实现" class="headerlink" title="二维迷宫题算法实现"></a>二维迷宫题算法实现</h2><h3 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h3><p>map：迷宫地图，数组需要在声明的时候进行初始化</p>
<p>stages：上下左右的表示方法</p>
<p>n,m：一共有多少排多少列</p>
<p>stx,sty：迷宫起始的位置，需要对应数组的下标</p>
<p>endx,endy：迷宫终点的位置，需要对应数组相应的下标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> tmap[<span class="number">32</span>][<span class="number">32</span>]=&#123;<span class="string">&quot;00000&quot;</span>,<span class="string">&quot;01100&quot;</span>,<span class="string">&quot;00100&quot;</span>,<span class="string">&quot;00110&quot;</span>,<span class="string">&quot;00000&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> sign[<span class="number">50</span>][<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 右左下上</span></span><br><span class="line"><span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> stages[] = <span class="string">&quot;dasw&quot;</span>;</span><br><span class="line"><span class="comment">//这个迷宫有几排几列，用于判断有没有超出边界</span></span><br><span class="line"><span class="type">int</span> n=<span class="number">5</span>,m=<span class="number">5</span>;</span><br><span class="line"><span class="comment">// 标记起始位置</span></span><br><span class="line"><span class="type">int</span> stx=<span class="number">1</span>,sty=<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 标记终点位置</span></span><br><span class="line"><span class="type">int</span> endx=<span class="number">3</span>,endy=<span class="number">3</span>;</span><br><span class="line"><span class="comment">// road 路径</span></span><br><span class="line"><span class="type">char</span> road[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//已经走了多少步了</span></span><br><span class="line"><span class="type">int</span> steps=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addSteps</span><span class="params">(<span class="type">char</span> stage)</span>&#123;</span><br><span class="line">    road[steps] = stage;</span><br><span class="line">    steps++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">subSteps</span><span class="params">()</span>&#123;</span><br><span class="line">    steps--;</span><br><span class="line">    road[steps] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先算法 提供的参数是走迷宫的起始位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tx,ty;</span><br><span class="line">    <span class="keyword">if</span>(x == endx&amp;&amp;y == endy)&#123;</span><br><span class="line">        <span class="comment">//到达了最后的地方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;走的路径是：%s&quot;</span>,(<span class="type">char</span>*)road);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//tx 和 ty标记到达地址</span></span><br><span class="line">            tx = x+next[i][<span class="number">0</span>];</span><br><span class="line">            ty = y+next[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 当沿着这个方向的下一步不是墙 不是已经走过的地方 并且到达的这个地址在范围之内</span></span><br><span class="line">        <span class="keyword">if</span>(tx&gt;=<span class="number">0</span>&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=<span class="number">0</span>&amp;&amp;ty&lt;m&amp;&amp;tmap[ty][tx]!=<span class="string">&#x27;0&#x27;</span>&amp;&amp;sign[ty][tx]==<span class="number">0</span>)&#123;</span><br><span class="line">            sign[ty][tx]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将之前长度的字符串放入到其中 并且再添加一个字符（表示这一步的方向）</span></span><br><span class="line">            addSteps(stages[i]);</span><br><span class="line">            dfs(tx,ty);</span><br><span class="line">            sign[ty][tx]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//除去最后一步</span></span><br><span class="line">            subSteps();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当四个方向都不满足的时候跳出循环</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    dfs(stx,sty);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：dssd</span><br></pre></td></tr></table></figure>



<h3 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h3><p>使用脚本的时候根据题目的不同需要进行修改的脚本之中的参数有</p>
<p>map：map使用数字类型的数字表示，还是用char类型的数组表示，map的声明以及每一步的是否正确的判断条件都是不一样的</p>
<p>stx和sty：迷宫的起点，数组的起点是从0开始标识的</p>
<p>endx和endy：迷宫的终点，注意数组的下标</p>
<p>signdirect：题目之中这四个方向所代表的字符都是不一样的，需要根据题目的要求具体的表示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># map是迷宫</span></span><br><span class="line"><span class="built_in">map</span> = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line"><span class="comment"># 标记该路径是否走过 5*5的数组的表示方法</span></span><br><span class="line">sign = [[<span class="number">0</span>]*<span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 起始的位置</span></span><br><span class="line">stx = <span class="number">1</span></span><br><span class="line">sty = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记下一步的地址</span></span><br><span class="line">endx = <span class="number">0</span></span><br><span class="line">endy = <span class="number">0</span></span><br><span class="line"><span class="comment"># 每次走的方向 路径</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 标记走的四个方向</span></span><br><span class="line">direct = [[<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 这四个方向的表示方法</span></span><br><span class="line">signdirect=<span class="string">&#x27;dasw&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度遍历方法的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y</span>):</span><br><span class="line">  <span class="keyword">global</span> flag   <span class="comment">#注意在函数里面要当全局变量使用的变量一定要在函数之中进行声明！！！！！！</span></span><br><span class="line">  endx = <span class="number">0</span></span><br><span class="line">  endy = <span class="number">0</span></span><br><span class="line">  <span class="comment"># 到达终点</span></span><br><span class="line">  <span class="keyword">if</span> x==finalx <span class="keyword">and</span> y==finaly:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment"># 未到达终点之前遍历四个方向</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(direct)):</span><br><span class="line">    endx = x+direct[i][<span class="number">0</span>]</span><br><span class="line">    endy = y+direct[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> endy&gt;=<span class="number">0</span> <span class="keyword">and</span> endy&lt;<span class="built_in">len</span>(<span class="built_in">map</span>) <span class="keyword">and</span> endx&gt;=<span class="number">0</span> <span class="keyword">and</span> endx&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>]) <span class="keyword">and</span> <span class="built_in">map</span>[endy][endx] == <span class="number">1</span> <span class="keyword">and</span> sign[endy][endx] !=<span class="number">1</span>:</span><br><span class="line">      sign[endy][endx] = <span class="number">1</span></span><br><span class="line">      flag=flag+signdirect[i]</span><br><span class="line">      dfs(endx,endy)</span><br><span class="line">      sign[endy][endx] = <span class="number">0</span></span><br><span class="line">      flag = flag[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dfs(stx,sty)</span><br><span class="line">运行结果： dssd</span><br></pre></td></tr></table></figure>

<p>如果是用字符串的形式声明迷宫时，map的表示方式，及脚本之中需要改变的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map = [&quot;00000&quot;,&quot;01100&quot;,&quot;00100&quot;,&quot;00110&quot;,&quot;00000&quot;]</span><br><span class="line"># 每一步判断条件的 map[endy][endx] == &#x27;1&#x27; 要修改成满足要求的对应字符而不是数字了</span><br><span class="line">if endy&gt;=0 and endy&lt;len(map) and endx&gt;=0 and endx&lt;len(map[0]) and map[endy][endx] == &#x27;1&#x27; and sign[endy][endx] !=1:    </span><br></pre></td></tr></table></figure>

<h2 id="三维迷宫题的算法实现"><a href="#三维迷宫题的算法实现" class="headerlink" title="三维迷宫题的算法实现"></a>三维迷宫题的算法实现</h2><h3 id="python版本-1"><a href="#python版本-1" class="headerlink" title="python版本"></a>python版本</h3><p>这里需要输入的参数和二维的脚本差不多，只是要多一个z轴上的坐标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">map</span> = [[ <span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaeee&quot;</span>],[<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaae&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>],[<span class="string">&quot;aeeaa&quot;</span>,<span class="string">&quot;aeeaa&quot;</span>,<span class="string">&quot;eeeae&quot;</span>,<span class="string">&quot;eaaae&quot;</span>,<span class="string">&quot;eaaae&quot;</span>],[<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;eaaee&quot;</span>],[ <span class="string">&quot;aaeea&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aeeea&quot;</span>,<span class="string">&quot;eeaea&quot;</span>,<span class="string">&quot;eaaea&quot;</span>]]</span><br><span class="line"></span><br><span class="line">sign = [[[<span class="number">0</span>]*<span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 标记起始位置</span></span><br><span class="line">stx = <span class="number">2</span></span><br><span class="line">sty = <span class="number">4</span></span><br><span class="line">stz = <span class="number">0</span></span><br><span class="line"><span class="comment"># 标识终点位置</span></span><br><span class="line">finalx = <span class="number">2</span></span><br><span class="line">finaly = <span class="number">2</span></span><br><span class="line">finalz = <span class="number">2</span></span><br><span class="line"><span class="comment"># 标记下一步的地址</span></span><br><span class="line">endx = <span class="number">0</span></span><br><span class="line">endy = <span class="number">0</span></span><br><span class="line">endz = <span class="number">0</span></span><br><span class="line"><span class="comment"># 每次走的方向 路径</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 标记走的四个方向</span></span><br><span class="line">direct = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line">signdirect=<span class="string">&#x27;daswxy&#x27;</span></span><br><span class="line"><span class="comment"># 深度遍历方法的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y,z</span>):</span><br><span class="line">  <span class="keyword">global</span> flag   <span class="comment">#注意在函数里面要当全局变量使用的变量一定要在函数之中进行声明！！！！！！</span></span><br><span class="line">  endx = <span class="number">0</span></span><br><span class="line">  endy = <span class="number">0</span></span><br><span class="line">  endz = <span class="number">0</span></span><br><span class="line">  <span class="comment"># 到达终点</span></span><br><span class="line">  <span class="keyword">if</span> x==finalx <span class="keyword">and</span> y==finaly <span class="keyword">and</span> z==finalz:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment"># 未到达终点之前遍历6个</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(direct)):</span><br><span class="line">    endx = x+direct[i][<span class="number">0</span>]</span><br><span class="line">    endy = y+direct[i][<span class="number">1</span>]</span><br><span class="line">    endz = z+direct[i][<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> endy&gt;=<span class="number">0</span> <span class="keyword">and</span> endy&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>]) <span class="keyword">and</span> endx&gt;=<span class="number">0</span> <span class="keyword">and</span> endx&lt;<span class="built_in">len</span>(<span class="built_in">map</span>[<span class="number">0</span>][<span class="number">0</span>]) <span class="keyword">and</span> endz&gt;=<span class="number">0</span> <span class="keyword">and</span> endz&lt;<span class="built_in">len</span>(<span class="built_in">map</span>) <span class="keyword">and</span> <span class="built_in">map</span>[endz][endy][endx] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">and</span> sign[endz][endy][endx] !=<span class="number">1</span>:</span><br><span class="line">      sign[endz][endy][endx] = <span class="number">1</span></span><br><span class="line">      flag=flag+signdirect[i]</span><br><span class="line">      dfs(endx,endy,endz)</span><br><span class="line">      sign[endz][endy][endx] = <span class="number">0</span></span><br><span class="line">      flag = flag[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dfs(stx,sty,stz)</span><br><span class="line"><span class="comment"># 这里返回的结果有多个，选取其中最短的那个即为正确答案   ddwwxxssxaxwwaasasyywwdd</span></span><br><span class="line">ddwwxxssxaxwwaasasyywwdd</span><br><span class="line">ddwwxxssxaxwwaasasyywwdwds</span><br><span class="line">ddwwxxssxaxwwaasasyywwdwwdss</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdd</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdwds</span><br><span class="line">ddwwxxssxaxwwwasasasyywwdwwdss</span><br></pre></td></tr></table></figure>

<p>有时候迷宫的走法不止一个，就取走的路程最小的那个就可以了</p>
]]></content>
      <categories>
        <category>题型</category>
      </categories>
      <tags>
        <tag>迷宫</tag>
      </tags>
  </entry>
</search>
